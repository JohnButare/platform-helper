#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Additional BorgBackup functionality.
	
Common commands:
	backup			backup files
	restore			restore files
	init				initialize the repository
	ls					list backup archives
	repo				repository commands
	rm					remove a backup
	run					run borg
	status			show status

Common options:
	-bh, --backup-host=HOST		host which contains the backup archive
	-r, --repository=NAME			name of the backup repository, defaults to '$backupRepoDefault'"
}

usageVerbose()
{ 
	ScriptUsageEcho "
Other commands:
	environment	return environment variables
	mount				mount a backup
	unmount			unmount a backup
	vorta				run vorta

Other options:
	-bd, --backup-dir=DIR		location of the backup archive on the backup host, defaults to '$backupDirDefault'
	-P,	--passphrase=HOST		repository passphrase
	-u,	--user=USER					backup user, defaults to '$backupUserDefault'"
}

init()
{
	backupDirDefault="$ADATA/borg"
	backupUserDefault="root"
	backupRepoDefault="$HOSTNAME"
	borgVerbose=( ); [[ $verbose ]] && borgVerbose+=( "--verbose" )
	borgPath="/usr/local/bin/borg"
	mountDir="$HOME/Volumes/backup"
	vars=( BORG_PASSPHRASE BORG_REPO )
}

argStart() { unset -v backupDir backupHost backupPassphrase backupRepo backupUser; }

opt()
{
	case "$1" in
		-bd|--backup-dir|-bd=*|--backup-dir=*) ScriptOptGet "backupDir" "dir" "$@";;
		-bh|--backup-host|-bh=*|--backup-host=*) ScriptOptGet "backupHost" "host" "$@";;
		-P|--passphrase|-P=*|--passphrase=*) ScriptOptGet "backupPassphrase" "passphrase" "$@";;
		-r|--repository|-r=*|--repository=*) ScriptOptGet "backupRepo" "repo" "$@";;
		-u|--user|-u=*|--user=*) ScriptOptGet "backupUser" "user" "$@";;
		*) return 1;;
	esac
}

#
# other commands
#

environmentCommand() { setBorgEnvironment && ScriptReturn --export "${vars[@]}"; }
initCommand() { hilight "Creating '$BORG_REPO'..."; runBorg init --encryption=repokey-blake2 "${otherArgs}"; }
lsUsage() { echot "Usage: $(ScriptName) ls -- [OPTION]...\nList backups, for example:\n\nBorgHelper ls -- --prefix 'web-'\nBorgHelper ls -- --glob-archives web"; }
lsCommand() { runBorg list; }
rmUsage() { echot "Usage: $(ScriptName) rm -- [OPTION]...\nRemove backups, for example:\n\nBorgHelper -- ::tmp\nBorgHelper rm -- --prefix 'web-'\nBorgHelper ls -- --glob-archives web"; }
rmCommand() { runBorg delete; }

statusCommand()
{
	setBorgEnvironment || return
	echo "borg will use the ${GREEN}$backupRepo${RESET} repository on ${GREEN}$backupHost${RESET}"
	log1 "user=$backupUser dir=$backupDir\nBORG_REPO=$BORG_REPO"
	return 0
}

#
# backup command
#

backupUsage()
{
		echot "\
Usage: $(ScriptName) backup [PATH [PATH ...]]
Backup files.

	-a,	 --archive=NAME				name of the archive, defaults to archive (see 'borg help placeholders')
	-bh, --backup-hosts=HOSTS	comma separated list of hosts to backup to
	-h,  --host=HOST					host to backup, defaults to localhost
	-nc, --no-check						do not check if the repository is initialized
	-p,	 --prune=N						prune backups leaving the last N backups"
}

backupArgStart() { archive="archive" archiveSuffix="-{now:%Y-%m-%d_%H:%M:%S}"; unset -v backupHostsArg host noCheck noSuffix prune pruneArg; }

backupOpt()
{
	case "$1" in
		-a|--archive|-a=*|--archive=*) ScriptOptGet "archive" "$@";;
		-bh|--backup-hosts|-bh=*|--backup-hosts=*) ScriptOptGet "backupHostsArg" "$@";;
		-H|--host|-H=*|--host=*) ScriptOptGet "host" "$@";;
		-nc|--no-check) noCheck="--no-check";;
		-ns|--no-suffix) noSuffix="--no-suffix" archiveSuffix="";;
		-p|--prune|-p=*|--prune=*) ScriptOptGet --integer "prune" "$@"; pruneArg="--prune=$prune";;
		*) return 1;;
	esac
}

backupArgs() { backupArgs=( "$@" ); shift="$#"; }

backupCommand()
{	
	[[ ! $backupHostsArg ]] && { backupDo; return; }

	[[ "${backupHostsArg,,}" == "all" ]] && backupHostsArg="$(network current servers backup)"
	local backupHost backupHosts=(); StringToArray "$backupHostsArg" "," backupHosts
	for backupHost in "${backupHosts[@]}"; do backupDo || return; done
}

backupDo()
{
	{ SshAgentConf "${globalArgs[@]}" && setBorgEnvironment; } || return

	if IsLocalHost "$host"; then
		backupLocal || return
	else 
		backupRemote || return
	fi
}

backupLocal()
{
	# status
	[[ ! $quiet ]] && hilight "Backing up the $backupRepo $archive archive to $(GetHostname "$backupHost")..."

	# ensure the repository exists
	repoCheck || return

	# delete an existing archive if we are not using a unique suffix
	[[ ! $suffix ]] && { archiveDeleteIfExists "$archive" || return; } 

	# backup
	local args=("${backupArgs[@]}"); [[ ! $quiet ]] && args+=(--stats --progress)
	runBorg create ::$archive"$archiveSuffix" "${args[@]}" || return
	[[ ! $quiet ]] && echo

	# if we are not using a unique suffix there is nothing to prune
	[[ ! $suffix ]] && return

	# prune
	if [[ $prune ]]; then
		echo "Pruning to $prune backups..."
		borg prune --keep-last $prune --prefix "$archive-" || return
	fi

	# status
	[[ $quiet ]] && return
	[[ ! $prune ]] && echo "Backups..."
	borg list --prefix "$archive-" || return
	echo
	
}

backupRemote()
{
	RunLog SshHelper "$(ConfigGet "user")@$host" --borg --interactive --pseudo-terminal "${globalArgs[@]}" -- \
		BorgHelper backup "${backupArgs[@]}" --archive "$archive" --repository="$backupRepo" --backup-hosts="$backupHost" $noCheck $noSuffix $prune "${globalArgs[@]}"
}

#
# mount/unmount command
#

mountUsage()
{
		echot "\
Usage: $(ScriptName) mount [ARCHIVE]
Mount backup repository or archive to $mountDir."
}

mountArgStart() { unset -v archive; }
mountArgs() { [[ $# == 0 ]] && return; ScriptArgGet "archive" -- "$@"; shift; }

mountCommand()
{
	# create the mount directory
	[[ ! -d "$mountDir" ]] && { mkdir --parents "$mountDir" || return; }

	# unmount existing borg backup
	isMounted && [[ $force ]] && { unmountCommand || return; }

	# mount the borg backup
	! isMounted && { borg mount "$archive" "$mountDir" || return; }

	# return the mounted directory
	echo "$mountDir"
}

unmountCommand()
{
	{ [[ ! -d "$mountDir" ]] || ! isMounted; } && return
	borg umount "$mountDir" || return
}

isMounted() { findmnt --list --source=borgfs --target="$mountDir" >& /dev/null; }

#
# repo command

repoUsage() { echot "Usage: $(ScriptName) repo ls\nBorg repository commands."; }

repoCommand() { usage; }
repoLsCommand() { setBorgRepo && sshRun "$backupHost" ls -1 "$backupDir"; }

#
# restore command
#

restoreUsage() { echot "Usage: $(ScriptName) extract -- [OPTION]...
Extract files, for example:

Options:
	-a,	 --archive=NAME		name of the archive, defaults to archive
	-d,	 --dir=DIRECTORY	directory to restore to, defaults to current directory	
	-H,  --host=HOST			host to restore to, defaults to localhost

Examples:
	BorgHelper extract -- ::ProxyManager-2021-11-03_23:14:58"; }


restoreArgStart() { dir="$PWD"; unset -v archive host; }

restoreOpt()
{
	case "$1" in
		-a|--archive|-a=*|--archive=*) ScriptOptGet "archive" "$@";;
		-d|--dir|-d=*|--dir=*) ScriptOptGet "dir" "$@";;
		-H|--host|-H=*|--host=*) ScriptOptGet "host" "$@";;
		*) return 1;;
	esac
}
restoreCommand()
{
	setBorgEnvironment || return
	local args=(); [[ $archive ]] && args+=("::$archive")
	if IsLocalHost "$host"; then restoreLocal; else restoreRemote; fi
}

restoreLocal()
{
	[[ $dir ]] && { cd "$dir" || return; }
	runBorg extract "${args[@]}"
}

restoreRemote()
{
	RunLog SshHelper "$(ConfigGet "user")@$host" --interactive --pseudo-terminal "${globalArgs[@]}" -- \
		BorgHelper restore "${backupArgs[@]}" --dir="$dir" --archive "$archive" --repository="$backupRepo" --backup-host="$backupHost" "${globalArgs[@]}"
}

#
# run command
#

runUsage()
{
		echot "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Run borg as root."
}

runArgs() { runArgs=( "$@" ); shift="$#"; }
runCommand() { runBorg "${runArgs[@]}"; }

#
# vorta command
#

vortaCommand()
{
	log1 "borg $@ ${borgVerbose[@]} ${otherArgs[@]}"
	sudoc BORG_PASSPHRASE="$BORG_PASSPHRASE" BORG_REPO="$BORG_REPO" \
		SSH_AUTH_SOCK="$SSH_AUTH_SOCK" SSH_AGENT_PID="$SSH_AGENT_PID" \
		vorta "${otherArgs[@]}" &
}

#
# helper
#

archiveDelete() { runBorg delete ::"$1"; }
archiveDeleteIfExists() { ! archiveExists "$1" && return; archiveDelete "$1"; }
isBorgBaseHost() { [[ "$backupHost" =~ borgbase\.com$ ]]; }
repoCheck() { [[ $noCheck ]] || repoExists || initCommand; }
sshRun() { SshAgentConf "${globalArgs[@]}" && ssh "$@"; }

archiveExists()
{
	local archive="$1"
	local result; result="$(runBorg list --short --glob-archives "$archive")" || return
	[[ "$result" == "$archive" ]]
}

repoExists()
{
	[[ ! "$backupDir" || $test ]] && return 0
	ssh "$backupHost" "[[ -d \"$backupDir$backupRepo\" ]]"
}

runBorg()
{	
	{ SshAgentConf "${globalArgs[@]}" && setBorgEnvironment; } || return

	IsRoot && { RunLog borg "$@" "${borgVerbose[@]}" "${otherArgs[@]}"; return; }

	RunLog sudoc BORG_PASSPHRASE="$BORG_PASSPHRASE" BORG_REPO="$BORG_REPO" BORG_REMOTE_PATH="$borgPath" BORG_RELOCATED_REPO_ACCESS_IS_OK="$BORG_RELOCATED_REPO_ACCESS_IS_OK" \
		SSH_AUTH_SOCK="$SSH_AUTH_SOCK" SSH_AGENT_PID="$SSH_AGENT_PID" \
		borg "$@" "${borgVerbose[@]}" "${otherArgs[@]}"
}

setBorgEnvironment()
{
	export BORG_RELOCATED_REPO_ACCESS_IS_OK="yes"
	setBorgPassphrase && setBorgRepo
}

setBorgPassphrase()
{
	local passphrase="${backupPassphrase:-$BORG_PASSPHRASE}"
	[[ $force || ! $passphrase ]] && { passphrase="$(credential get borg passphrase --fallback "${globalArgs[@]}")" || return; }
	export BORG_PASSPHRASE="$passphrase"
}

setBorgRepo()
{
	# do not use BORG_REPO for configuration if forcing or if configuration has been supplied from options
	[[ $force ]] && unset BORG_REPO
	[[ $backupDir || $backupHost || $backupUser || $backupRepo ]] && unset BORG_REPO

	# backup host alias
	case "${backupHost,,}" in
		bb|borgbase) backupRepo="${backupRepo:-$backupRepoDefault}"
			case "${backupRepo,,}" in
				oversoul) backupHost="mk099950.repo.borgbase.com";;
				pi1) backupHost="h7gnr153.repo.borgbase.com";;
				pi2) backupHost="q3d82g14.repo.borgbase.com";;
				pi3) backupHost="gw3jk69x.repo.borgbase.com";;
				rosie) backupHost="kx172994.repo.borgbase.com";;
				*) ScriptErr "No backup host specified for repository '$backupRepo'"; return 1;;
			esac;;
		db|dropbox) backupHost="ender.hagerman.butare.net" backupDir="${backupDir:-/Users/jjbutare/Juntos Holdings Dropbox/John Butare/apps/BorgBackup}" backupUser="jjbutare"
	esac

	# get the backup host from BORG_REPO if needed
	[[ ! $backupHost && $BORG_REPO ]] && backupHost="$(GetSshHost "$BORG_REPO")"
	
	# discover the backup host if needed
	[[ ! $backupHost ]] && { backupHost="$(network current server backup)" || return; }

	# ensure we have a backup host
	[[ ! $backupHost ]] && { ScriptErr "unabl to get a backup host"; return 1; }

	# ensure the backupHost is a fully qualified domain name (prevents extra borg prompting)
	! HasDnsSuffix "$backupHost" && { backupHost="$(DnsResolve "$backupHost")" || return; }

	# ensure the backupHost is available
	HostAvailable "$backupHost" || return

	# get the backup dir from BORG_REPO if needed or use the default
	[[ ! $backupDir && $BORG_REPO ]] && backupDir="$(GetSshPort "$BORG_REPO" | RemoveTrailingSlash | GetFilePath)"	
	backupDir="$(EnsureDir "${backupDir:-$backupDirDefault}")"

	# get the backup repo from BORG_REPO if needed or use the default
	[[ ! $backupRepo && $BORG_REPO ]] && backupRepo="$(GetSshPort "$BORG_REPO" | RemoveTrailingSlash | GetFileName)"	
	backupRepo="${backupRepo:-$backupRepoDefault}"

	# get the backup user from BORG_REPO if needed or use the default
	[[ ! $backupUser && $BORG_REPO ]] && backupUser="$(GetSshUser "$BORG_REPO")"	
	backupUser="${backupUser:-$backupUserDefault}"
		
	# BorgBase special handling: u578g3w0@u578g3w0.repo.borgbase.com:repo
	if isBorgBaseHost; then
		backupUser="$(RemoveDnsSuffix "$backupHost")"
		backupDir="" backupRepo="repo"
	fi

	# set the BORG_REPO environment variable
	export BORG_REPO="$backupUser@$backupHost:$backupDir$backupRepo"
}

ScriptRun "$@"

#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Additional BorgBackup functionality.
	
	backup			backup files
	environment	return environment variables
	init				initialize the repository
	list				list backups
	mount				mount a backup
	run					run borg
	status			show status
	unmount			unmount a backup
	vorta				run vorta

	-d, --dir=DIR					backup directory, defaults to '$backupDirDefault'
	-H,	--host=HOST				backup host
	-r, --repository=NAME	backup repository name, defaults to '$backupRepoDefault'
	-u,	--user=USER				backup user, defaults to '$backupUserDefault'"
}

init()
{
	backupDirDefault="$DATA/appdata/borg"
	backupUserDefault="root"
	backupRepoDefault="$HOSTNAME"
	borgArgs=( ); [[ $verbose ]] && borgArgs+=( "--verbose" )
	borgPath="$BIN/borg"
	mountDir="$HOME/Volumes/backup"
	vars=( BORG_PASSPHRASE BORG_REPO )
}

argStart() { unset -v backupDir backupHost backupRepo backupUser; }

opt()
{
	case "$1" in
		-d|--dir|-d=*|--dir=*) ScriptOptGet "backupDir" "dir" "$@";;
		-H|--host|-H=*|--host=*) ScriptOptGet "backupHost" "host" "$@";;
		-r|--repository|-r=*|--repository=*) ScriptOptGet "backupRepo" "repo" "$@";;
		-u|--user|-u=*|--user=*) ScriptOptGet "backupUser" "user" "$@";;
		*) return 1;;
	esac
}

argEnd() { setBorgEnvironment; }

#
# Other Commands
#

environmentCommand() { ScriptReturn --export $verbose "${vars[@]}"; }
initCommand() { hilight "Creating '$BORG_REPO'..."; runBorg init --encryption=repokey-blake2 "${otherArgs}"; }
listCommand() { runBorg list "${otherArgs}"; }

statusCommand()
{
	echo "borg will use the ${GREEN}$backupRepo${RESET} repository on ${GREEN}$backupHost${RESET}"
	[[ $verbose ]] && printf "user=$backupUser dir=$backupDir\nBORG_REPO=$BORG_REPO\n"
	return 0
}

#
# Backup Command
#

backupUsage()
{
		echot "\
Usage: $(ScriptName) backup [PATH [PATH ...]]
Backup files

	-a,	 --archive=NAME			name of the archive, defaults to archive (see 'borg help placeholders')
	     --hosts=HOSTS			comma separated list of hosts to backup to
	-nc, --no-check					do not check if the repository is initialized
	-p,	 --prune=N					prune backups leaving the last N backups"
}

backupArgStart() { archive="archive"; unset -v hosts noCheck prune; }

backupOpt()
{
	case "$1" in
		-a|--archive|-a=*|--archive=*) ScriptOptGet "archive" "$@";;
		-nc|--no-check) noCheck="--no-check";;
		-p|--prune|-p=*|--prune=*) ScriptOptGet "prune" "$@" && IsInteger "$prune";;
		*) return 1;;
	esac
}

backupArgs() { backupArgs=( "$@" ); shift="$#"; }

backupCommand()
{
	# backup
	hilight "Backing up the $archive archive to the $backupRepo repository on $(GetHostname "$backupHost")..."
	repoCheck || return
	runBorg create ::$archive'-{now:%Y-%m-%d_%H:%M:%S}' "${backupArgs[@]}" "${otherArgs[@]}" --stats --progress || return
	echo
	
	# prune
	if [[ $prune ]]; then
		hilight "Pruning $archive to $prune backups..."
		borg prune --keep-last $prune --prefix "$archive-" || return
		echo
	fi

	# status
	hilight "$archive backups..."
	borg list --prefix "$archive-" || return
	echo
}

#
# Mount/Unmount Command
#

mountUsage()
{
		echot "\
Usage: $(ScriptName) mount [ARCHIVE]
Mount backup repository or archive to $mountDir."
}

mountArgStart() { unset -v archive; }
mountArgs() { [[ $# == 0 ]] && return; ScriptArgGet "archive" -- "$@"; shift; }

mountCommand()
{
	# create the mount directory
	[[ ! -d "$mountDir" ]] && { mkdir --parents "$mountDir" || return; }

	# unmount existing borg backup
	isMounted && [[ $force ]] && { unmountCommand || return; }

	# mount the borg backup
	! isMounted && { borg mount "$archive" "$mountDir" || return; }

	# return the mounted directory
	echo "$mountDir"
}

unmountCommand()
{
	{ [[ ! -d "$mountDir" ]] || ! isMounted; } && return
	borg umount "$mountDir" || return
}

isMounted() { findmnt --list --source=borgfs --target="$mountDir" >& /dev/null; }

#
# Run Command
#

runUsage()
{
		echot "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Run borg as root."
}

runArgs() { runArgs=( "$@" ); shift="$#"; }
runCommand() { runBorg "${runArgs[@]}"; }

#
# Vorta Command
#

vortaCommand()
{
	[[ $verbose ]] && EchoErr "borg $@ ${borgArgs[@]} ${otherArgs[@]}"
	sudoc BORG_PASSPHRASE="$BORG_PASSPHRASE" BORG_REPO="$BORG_REPO" \
		SSH_AUTH_SOCK="$SSH_AUTH_SOCK" SSH_AGENT_PID="$SSH_AGENT_PID" \
		vorta "${otherArgs[@]}" &
}

#
# helper
#

isBorgBaseHost() { [[ "$backupHost" =~ borgbase\.com$ ]]; }
repoCheck() { [[ $noCheck ]] || repoExists || initCommand; }

repoExists()
{
	[[ ! "$backupDir" || $test ]] && return 0
	ssh "$backupHost" "[[ -d \"$backupDir$backupRepo\" ]]"
}

runBorg()
{
	[[ $test || $verbose ]] && EchoErr "borg $@ ${borgArgs[@]} ${otherArgs[@]}"
	[[ $test ]] && return

	IsRoot && { borg "$@" "${borgArgs[@]}" "${otherArgs[@]}"; return; }

	sudoc BORG_PASSPHRASE="$BORG_PASSPHRASE" BORG_REPO="$BORG_REPO" BORG_REMOTE_PATH="$borgPath" \
		SSH_AUTH_SOCK="$SSH_AUTH_SOCK" SSH_AGENT_PID="$SSH_AGENT_PID" \
		borg "$@" "${borgArgs[@]}" "${otherArgs[@]}"
}

setBorgEnvironment()
{
	export BORG_RELOCATED_REPO_ACCESS_IS_OK="yes"
	setBorgPassphrase && setBorgRepo 
}

setBorgPassphrase()
{
	local passphrase="$BORG_PASSPHRASE"
	[[ $force || ! $passphrase ]] && { passphrase="$(credential get borg passphrase --fallback)" || return; }
	export BORG_PASSPHRASE="$passphrase"
}

setBorgRepo()
{
	# do not use BORG_REPO for configuration if forcing or if configuration has been supplied from options
	[[ $force ]] && unset BORG_REPO
	[[ $backupDir || $backupHost || $backupUser || $backupRepo ]] && unset BORG_REPO

	# backup host alias
	case "${backupHost,,}" in
		bb|borgbase) backupRepo="${backupRepo:-$backupRepoDefault}"
			case "${backupRepo,,}" in
				oversoul) backupHost="mk099950.repo.borgbase.com";;
				pi1) backupHost="h7gnr153.repo.borgbase.com";;
				pi2) backupHost="q3d82g14.repo.borgbase.com";;
				pi3) backupHost="gw3jk69x.repo.borgbase.com";;
				rosie) backupHost="kx172994.repo.borgbase.com";;
				*) ScriptErr "No backup host specified for repository '$backupRepo'"; return 1;;
			esac;;
		db|dropbox) backupHost="ender.hagerman.butare.net" backupDir="${backupDir:-/Users/jjbutare/Juntos Holdings Dropbox/John Butare/apps/BorgBackup}" backupUser="jjbutare"
	esac

	# get the backup host from BORG_REPO if needed
	[[ ! $backupHost && $BORG_REPO ]] && backupHost="$(GetSshHost "$BORG_REPO")"

	# discover the backup host if needed
	[[ ! $backupHost ]] && { backupHost="$(network current server backup --quiet)" || return; }

	# ensure the backupHost is a fully qualified domain name (prevents extra borg prompting)
	! HasDnsSuffix "$backupHost" && { backupHost="$(DnsResolve "$backupHost")" || return; }

	# get the backup dir from BORG_REPO if needed or use the default
	[[ ! $backupDir && $BORG_REPO ]] && backupDir="$(GetSshPort "$BORG_REPO" | RemoveTrailingSlash | GetFilePath)"	
	backupDir="$(EnsureDir "${backupDir:-$backupDirDefault}")"

	# get the backup repo from BORG_REPO if needed or use the default
	[[ ! $backupRepo && $BORG_REPO ]] && backupRepo="$(GetSshPort "$BORG_REPO" | RemoveTrailingSlash | GetFileName)"	
	backupRepo="${backupRepo:-$backupRepoDefault}"

	# get the backup user from BORG_REPO if needed or use the default
	[[ ! $backupUser && $BORG_REPO ]] && backupUser="$(GetSshUser "$BORG_REPO")"	
	backupUser="${backupUser:-$backupUserDefault}"
		
	# BorgBase special handling: u578g3w0@u578g3w0.repo.borgbase.com:repo
	if isBorgBaseHost; then
		backupUser="$(RemoveDnsSuffix "$backupHost")"
		backupDir="" backupRepo="repo"
	fi

	# set the BORG_REPO environment variable
	export BORG_REPO="$backupUser@$backupHost:$backupDir$backupRepo"
}

ScriptRun "$@"

#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Additional BorgBackup functionality.
	
Common commands:
	backup			backup files
	restore			restore files
	init				initialize the repository
	ls					list backup archives
	remote			run BorgHelper on a remote host
	repo				repository commands
	rm					remove a backup
	run					run borg
	status			show status

Common options:
	-bh, --backup-host=HOST			host to backup to
	-r,  --repository=NAME			name of the backup repository, defaults to '$backupRepoDefault'"
}

usageVerbose()
{ 
	ScriptUsageEcho "
Other commands:
	environment	return environment variables
	mount				mount a backup
	unmount			unmount a backup
	vorta				run vorta

Other options:
	-bd, --backup-dir=DIR			location of the backup archive on the backup host, defaults to '$backupDirDefault'
	-P,	 --passphrase=HOST		repository passphrase
	-u,	 --user=USER					backup user, defaults to '$backupUserDefault'"
}

init()
{
	backupDirDefault="$ADATA/borg"
	backupUserDefault="root"
	backupRepoDefault="$(DnsResolve "$HOSTNAME")" || return
	borgPath="/usr/local/bin/borg"
	mountDir="$HOME/Volumes/backup"
	vars=( BORG_PASSPHRASE BORG_REPO )
}

argStart() { unset -v backupDir backupHost backupPassphrase backupRepo backupUser; }

argEnd()
{
	borgVerboseArg=( ); [[ $verbose ]] && borgVerboseArg+=( "--verbose" )

	# set command specific forces
	unset forceEnvironment
	if [[ $force ]]; then
		if [[ "$command" == @(environment) ]]; then forceEnvironment="true"
		fi
	fi

	return 0
}

opt()
{
	case "$1" in
		-bd|--backup-dir|-bd=*|--backup-dir=*) ScriptOptGet "backupDir" "dir" "$@";;
		-bh|--backup-host|-bh=*|--backup-host=*) ScriptOptGet "backupHost" "host" "$@";;
		-P|--passphrase|-P=*|--passphrase=*) ScriptOptGet "backupPassphrase" "passphrase" "$@";;
		-r|--repository|-r=*|--repository=*) ScriptOptGet "backupRepo" "repo" "$@";;
		-u|--user|-u=*|--user=*) ScriptOptGet "backupUser" "user" "$@";;
		*) return 1;;
	esac
}

#
# other commands
#

environmentCommand() { setBorgEnvironment && ScriptReturn --export "${vars[@]}"; }
initCommand() { hilight "Creating '$BORG_REPO'..."; runBorg init --encryption=repokey-blake2 "${otherArgs}"; }
lsUsage() { echot "Usage: $(ScriptName) ls -- [OPTION]...\nList backups, for example:\n\nBorgHelper ls -- --prefix 'web-'\nBorgHelper ls -- --glob-archives web"; }
lsCommand() { runBorg list; }
rmUsage() { echot "Usage: $(ScriptName) rm -- [OPTION]...\nRemove backups, for example:\n\nBorgHelper -- ::tmp\nBorgHelper rm -- --prefix 'web-'\nBorgHelper ls -- --glob-archives web"; }
rmCommand() { runBorg delete; }

statusCommand()
{
	setBorgEnvironment || return
	echo "borg will use the '${GREEN}$backupRepo${RESET}' repository on '${GREEN}$backupHost${RESET}'"
	log1 "user=$backupUser dir=$backupDir\nBORG_REPO=$BORG_REPO"
	return 0
}

#
# backup command
#

backupUsage()
{
		echot "\
Usage: $(ScriptName) backup [PATH [PATH ...]]
Backup files.

	-a,	 --archive=NAME				name of the archive, defaults to archive (see 'borg help placeholders')
	-bh, --backup-host=HOSTS	comma separated list of hosts to backup to
	-nc, --no-check						do not check if the repository is initialized
	-p,	 --prune=N						prune backups leaving the last N backups"
}

backupArgStart() { archive="archive" archiveSuffix="-{now:%Y-%m-%d_%H:%M:%S}"; unset -v host noCheck noSuffix prune pruneArg; }

backupOpt()
{
	case "$1" in
		-a|--archive|-a=*|--archive=*) ScriptOptGet "archive" "$@";;
		-nc|--no-check) noCheck="--no-check";;
		-ns|--no-suffix) noSuffix="--no-suffix" archiveSuffix="";;
		-p|--prune|-p=*|--prune=*) ScriptOptGet --integer "prune" "$@"; pruneArg="--prune=$prune";;
		*) return 1;;
	esac
}

backupArgs() { backupArgs=( "$@" ); shift="$#"; }

backupCommand()
{	
	log1 "backup $(description)"

	# backupHost not set
	[[ ! $backupHost ]] && { setBorgEnvironment && backupDo; return; }
	
	# get hosts to backup to
	local backupHostArg="$backupHost"
	[[ "${backupHostArg,,}" == "all" ]] && { backupHost="$(network current servers backup)" || return; }
	log2 "backup $(description): backup hosts: $backupHostArg"

	# backup to each host
	local backupHost backupHost=(); StringToArray "$backupHostArg" "," backupHosts
	for backupHost in "${backupHosts[@]}"; do
		setBorgEnvironment || return
		backupDo || return
	done
	
}

backupDo()
{
	# status
	local message="backing up the '$archive' archive to the '$backupRepo' repository on '$backupHost' (${backupArgs[@]})"
	log1 "backup $(description): $message"
	[[ ! $quiet ]] && EchoWrap "${message^}..."

	# ensure the repository exists
	repoCheck || return

	# delete an existing archive if we are not using a unique suffix
	[[ ! $suffix ]] && { archiveDeleteIfExists "$archive" || return; } 

	# backup
	local args=("${backupArgs[@]}"); [[ ! $quiet ]] && args+=(--stats --progress)
	runBorg create ::$archive"$archiveSuffix" "${args[@]}" || return
	[[ ! $quiet ]] && echo

	# if we are not using a unique suffix there is nothing to prune
	[[ ! $suffix ]] && return

	# prune
	if [[ $prune ]]; then
		echo "Pruning to $prune backups..."
		borg prune --keep-last $prune --prefix "$archive-" || return
	fi

	# status
	[[ $quiet ]] && return
	[[ ! $prune ]] && echo "Backups..."
	borg list --prefix "$archive-" || return
	echo
	
}

#
# mount/unmount command
#

mountUsage()
{
		echot "\
Usage: $(ScriptName) mount [ARCHIVE]
Mount backup repository or archive to $mountDir."
}

mountArgStart() { unset -v archive; }
mountArgs() { [[ $# == 0 ]] && return; ScriptArgGet "archive" -- "$@"; shift; }

mountCommand()
{
	# create the mount directory
	[[ ! -d "$mountDir" ]] && { mkdir --parents "$mountDir" || return; }

	# unmount existing borg backup
	isMounted && [[ $force ]] && { unmountCommand || return; }

	# mount the borg backup
	! isMounted && { borg mount "$archive" "$mountDir" || return; }

	# return the mounted directory
	echo "$mountDir"
}

unmountCommand()
{
	{ [[ ! -d "$mountDir" ]] || ! isMounted; } && return
	borg umount "$mountDir" || return
}

isMounted() { findmnt --list --source=borgfs --target="$mountDir" >& /dev/null; }

#
# remote command
#

remoteUsage() { EchoWrap "Usage: $(ScriptName) remote HOST -- ARGUMENTS...\nrun BorgHelper on a remote host."; }
remoteArgs() { ScriptArgGet "host" -- "$@"; }

remoteCommand()
{
	log1 "remote $(description)"; setBorgEnvironment || return
	
	# validate the host
	! SshIsAvailable "$host" && { ScriptErr "'$host' is not available"; return 1; }

	# set passphrase
	BorgConf "${globalArgs[@]}" || return

	# run the remote command
	RunLog SshHelper "$host" --borg --credential "${globalArgs[@]}" -- BorgHelper "${otherArgs[@]}" "${globalArgs[@]}"
}

#
# repo command
#

repoUsage() { echot "Usage: $(ScriptName) repo ls\nBorg repository commands."; }
repoCommand() { usage; }
repoLsCommand() { setBorgRepo && sshRun "$backupHost" ls -1 "$backupDir"; }

#
# restore command
#

restoreUsage() { echot "Usage: $(ScriptName) extract -- [OPTION]...
Extract files, for example:

Options:
	-a,	 --archive=NAME		name of the archive, defaults to archive
	-d,	 --dir=DIRECTORY	directory to restore to, defaults to current directory	

Examples:
	BorgHelper extract -- ::ProxyManager-2021-11-03_23:14:58"; }


restoreArgStart() { dir="$PWD"; unset -v archive host; }

restoreOpt()
{
	case "$1" in
		-a|--archive|-a=*|--archive=*) ScriptOptGet "archive" "$@";;
		-d|--dir|-d=*|--dir=*) ScriptOptGet "dir" "$@";;
		*) return 1;;
	esac
}
restoreCommand()
{
	log1 "restore $(description)"; setBorgEnvironment || return

	local args=(); [[ $archive ]] && args+=("::$archive")
	[[ $dir ]] && { cd "$dir" || return; }
	runBorg extract "${args[@]}"
}

#
# run command
#

runUsage()
{
		echot "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Run borg as root."
}

runArgs() { runArgs=( "$@" ); shift="$#"; }
runCommand() { runBorg "${runArgs[@]}"; }

#
# vorta command
#

vortaCommand()
{	
	log1 "vorta: ${borgVerboseArg[@]} ${otherArgs[@]}"
	SshAgentConf "${globalArgs[@]}" && setBorgEnvironment && runRoot vorta "${otherArgs[@]}"
}

#
# helper
#

archiveDelete() { runBorg delete ::"$1"; }
archiveDeleteIfExists() { ! archiveExists "$1" && return; archiveDelete "$1"; }
description() { echo "on '$HOSTNAME' as '$USER'"; }
isBorgBaseHost() { [[ "$backupHost" =~ borgbase\.com$ ]]; }
repoCheck() { [[ $noCheck ]] || repoExists || initCommand; }

archiveExists()
{
	local archive="$1"
	local result; result="$(runBorg list --short --glob-archives "$archive")" || return
	[[ "$result" == "$archive" ]]
}

repoExists()
{
	[[ ! "$backupDir" || $test ]] && return 0
	runSsh "$backupHost" "[[ -d \"$backupDir$backupRepo\" ]]"
}

runBorg()
{	
	SshAgentConf "${globalArgs[@]}" && setBorgEnvironment && runRoot borg "$@" "${borgVerboseArg[@]}" "${otherArgs[@]}"
}

runRoot()
{
	# run directly if already root
	IsRoot && { "$@"; return; }

	# run using:
	# - sudoc: to elevate using credential manager
	# - BORG variables: borg configuration
	# - SSH variables: allows borg to use the current users ssh-agent SSH keys
	sudoc \
		BORG_PASSPHRASE="$BORG_PASSPHRASE" BORG_REPO="$BORG_REPO" BORG_REMOTE_PATH="$borgPath" BORG_RELOCATED_REPO_ACCESS_IS_OK="$BORG_RELOCATED_REPO_ACCESS_IS_OK" \
		SSH_AUTH_SOCK="$SSH_AUTH_SOCK" SSH_AGENT_PID="$SSH_AGENT_PID" \
		"$@"
}

runSsh()
{
	SshAgentConf "${globalArgs[@]}" && ssh "$@"
}

setBorgEnvironment()
{
	log2 "setting the environment"
	export BORG_RELOCATED_REPO_ACCESS_IS_OK="yes"
	setBorgPassphrase && setBorgRepo && log2 "setBorgEnvironment: BORG_REPO='$BORG_REPO'"
}

setBorgPassphrase()
{
	local passphrase="${backupPassphrase:-$BORG_PASSPHRASE}"
	[[ $forceEnvironment || ! $passphrase ]] && { passphrase="$(credential get borg passphrase --fallback "${globalArgs[@]}")" || return; }
	export BORG_PASSPHRASE="$passphrase"
}

setBorgRepo()
{
	# do not use BORG_REPO for configuration if forcing or if configuration has been supplied from options
	[[ $forceEnvironment ]] && unset BORG_REPO
	[[ $backupDir || $backupHost || $backupUser || $backupRepo ]] && unset BORG_REPO

	# backup host alias
	case "${backupHost,,}" in
		bb|borgbase) backupRepo="${backupRepo:-$backupRepoDefault}"
			case "${backupRepo,,}" in
				oversoul) backupHost="mk099950.repo.borgbase.com";;
				pi1) backupHost="h7gnr153.repo.borgbase.com";;
				pi2) backupHost="q3d82g14.repo.borgbase.com";;
				pi3) backupHost="gw3jk69x.repo.borgbase.com";;
				rosie) backupHost="kx172994.repo.borgbase.com";;
				*) ScriptErr "No backup host specified for repository '$backupRepo'"; return 1;;
			esac;;
		db|dropbox) backupHost="ender.hagerman.butare.net" backupDir="${backupDir:-/Users/jjbutare/Juntos Holdings Dropbox/John Butare/apps/BorgBackup}" backupUser="jjbutare"
	esac

	# get the backup host from BORG_REPO if needed
	[[ ! $backupHost && $BORG_REPO ]] && backupHost="$(GetSshHost "$BORG_REPO")"
	
	# discover the backup host if needed
	[[ ! $backupHost ]] && { backupHost="$(network current server backup)" || return; }

	# ensure we have a backup host
	[[ ! $backupHost ]] && { ScriptErr "unabl to get a backup host"; return 1; }

	# ensure the backupHost is a fully qualified domain name (prevents extra borg prompting)
	! HasDnsSuffix "$backupHost" && { backupHost="$(DnsResolve "$backupHost")" || return; }

	# ensure the backupHost is available
	HostAvailable "$backupHost" || return

	# get the backup dir from BORG_REPO if needed or use the default
	[[ ! $backupDir && $BORG_REPO ]] && backupDir="$(GetSshPort "$BORG_REPO" | RemoveTrailingSlash | GetFilePath)"	
	backupDir="$(EnsureDir "${backupDir:-$backupDirDefault}")"

	# get the backup repo from BORG_REPO if needed or use the default
	[[ ! $backupRepo && $BORG_REPO ]] && backupRepo="$(GetSshPort "$BORG_REPO" | RemoveTrailingSlash | GetFileName)"	
	backupRepo="${backupRepo:-$backupRepoDefault}"

	# get the backup user from BORG_REPO if needed or use the default
	[[ ! $backupUser && $BORG_REPO ]] && backupUser="$(GetSshUser "$BORG_REPO")"	
	backupUser="${backupUser:-$backupUserDefault}"
		
	# BorgBase special handling: u578g3w0@u578g3w0.repo.borgbase.com:repo
	if isBorgBaseHost; then
		backupUser="$(RemoveDnsSuffix "$backupHost")"
		backupDir="" backupRepo="repo"
	fi

	# set the BORG_REPO environment variable
	export BORG_REPO="$backupUser@$backupHost:$backupDir$backupRepo"
}

ScriptRun "$@"

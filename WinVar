#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script || exit # empty argument prevents passing scripts arguments

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... get|set|delete VAR [VALUE]
Set user or system variable in the Windows registry.

	-s, --system			set a system variable system wide (default is user)
	-p, --path				the variable refers to a semi-colon separated path, the value is a directory to add to the path"
}

init() { defaultCommand="run"; }

argStart() { unset path system; }
args() { ScriptArgGet "varArg" "var" -- "$@" && shift; }

opt()
{
	case "$1" in
		-s|--system) CanElevate && system="-m";;
		-p|--path) path="--path";;
		*) return 1;;
	esac
}

argEnd()
{
	if [[ $system ]]; then
		key="HKLM/SYSTEM/CurrentControlSet/Control/Session Manager/Environment/$varArg"
	else
		key="HKCU/Environment/$varArg"
	fi
}

#
# delete command
#

deleteCommand() { RunLog registry delete "$key" "${globalArgs[@]}"; }

#
# get command
#

getUsage()
{
	ScriptUsageEcho "\
Usage: $(ScriptName) get VAR
Get variable.

  -nv, --no-validate		do not validate the value in the registry with the actual value"
}

getAargStart() { unset noValidate; }

getOpt()
{
	case "$1" in
		-nv|--no-validate) noValidate="--no-validate";;
		*) return 1;;
	esac
}

getCommand()
{
	# get registry value
	! RunLog registry exist "$key" "${globalArgs[@]}" && { ScriptErr "the variable '$varArg' does not exist in the registry"; return; }
	local registryValue; registryValue="$(RunLog registry get "$key" "${globalArgs[@]}" | RemoveCarriageReturn)" || return
	[[ $noValidate ]] && { echo -E "$registryValue"; return; }

	# get actual value
	local actualValue; actualValue="$(cmd.exe /c echo %${varArg}%  2> /dev/null | RemoveCarriageReturn)" || return
	[[ "$registryValue" == "$actualValue" ]] && return
	echo -E "the '$varArg' variables value in the registry ('$registryValue') does not match the actual value ('$actualValue')"; return 1
}

#
# set command
#

setArgs() { ScriptArgGet --required "value" -- "$@" && ScriptCheckDir "$value" && shift; }

setCommand()
{
	local newValue="$value" changed="true"

	# add value to a path
	if [[ $path ]]; then

		# validate and convert to Windows path format
		! drive IsWin "$newValue" && { ScriptErr "'$newValue' is not a Windows directory"; return; }
		newValue="$(utw "$newValue")"

		# get the current value of the path
		local currentValue="$(registry get "$key" "${globalArgs[@]}" | sed 's/\r//g')" # remove trailing carriage return

		# if the new value is not in the current path, append it
		local parts; StringToArray "${currentValue//\\/\\\\}" ";" parts
		if IsInArray "$newValue" parts; then
			unset changed
		elif [[ $currentValue ]]; then
			newValue="$currentValue;$newValue"
		fi

	fi

	# set the variable if forcing or if it is changed
	if [[ $force || $changed ]]; then

		# elevate if nee to set system variable		
		if [[ $system ]] && ! IsElevated; then
			local file="$(mktemp)" || return
			echo "setx.exe \"$varArg\" \"$newValue\" $system" > "$file"
			RunScript --elevate --pause-error source "$file"  >& /dev/null || { rm "$file"; return 1; }
			rm "$file" || return

		# set variable
		elif ! start setx.exe "$varArg" "$newValue" $system >& /dev/null; then
			ScriptErr "unable to set the '$varArg' variable: "
			start setx.exe "$varArg" "$newValue" $system
			return 1

		fi
	fi

	# set the variable and return it
	[[ $path ]] && local $varArg="${!varArg}:$(wtu "$value")" || local $varArg="$value"
	ScriptReturn --export "$varArg"
}

ScriptRun "$@"

#!/usr/bin/env bash
. function.sh

HeaderBig "BASH Test"

hilight "printf prints multiple arguments (each argument in brackets)..."
var="a b c"; printf '[%s] ' "a b" c; echo;
echo

hilight "use ShowsArgs to validate passed arguments..."
set -- "1" "2 3"; ShowArgs "$@"
echo

hilight "variables are local to a subshell..."
a="1"; printf "(initial) a=$a"; (a="2"; printf " (subshell) a=$a"); echo " (final) a=$a"
echo

hilight "variables before a command are set only for the command, not it's arguments..."
test() { printf " (command) a=$a"; }
a="1"; printf "(initial) a=$a"; a="2" test; echo " (final) a=$a"

hilight "strings are expanded (shell splits strings into separate words)..."
var="a b c"
printf "      one argument: "; printf '[%s] ' "$var"; echo;
printf "multiple arguments: "; printf '[%s] ' $var; echo;
echo

hilight "double quotes prevent expansion (word splitting)..."
var="a b c"
printf "      one argument: "; printf '[%s] ' "$var"; echo;
printf "multiple arguments: "; printf '[%s] ' $var; echo;
echo

hilight "words are split using the IFS variable (defaults to space and horizontal tab)..."
ShowIfs
echo

hilight "words splitting occurs when the command is parsed (command name, arguments, create array)..."
IFS=":" # cannot set IFS temporarily, 
a=( $(echo "a:b:c") ); ArrayShow a
command="ls:/tmp"; $command
args="1:2:3"; echo $args
ResetIfs # reset IFS to the default value
echo

hilight "use SplitArgs to test the effect of word splitting..."
IFS=":" SplitArgs "1:2:3"
echo

hilight "use ArrayMake to populate an array from a string using a temporary IFS..."
# note: here string not needed since ArrayMake supports arguments, i.e. IFS=$'\n' ArrayMake a <<< $'1:2\n3 4'; ArrayShow a
a=(); IFS=$'\n' ArrayMake a $'1:2\n3 4'; ArrayShow a
echo

hilight "use ArrayMake to iteratate over a commands output using a for loops, IFS is preserved, syntax is clear..."
dirs=(); IFS=$'\n' ArrayMake dirs "$(command ls -1 "/tmp")"; ArrayShow dirs
for dir in "${dirs[@]}"; do echo -$dir-; done
echo

hilight "use ArrayMakeC to iteratate over a commands which may fail output using a for loops, IFS is preserved, syntax is clear..."
dirs=(); IFS=$'\n' ArrayMakeC dirs command ls -1 "/bogus" || echo "command threw an error"
dirs=(); IFS=$'\n' ArrayMakeC dirs command ls -1 "/tmp" || return
for dir in "${dirs[@]}"; do echo -$dir-; done
echo

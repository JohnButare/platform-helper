#!/usr/bin/env bash
#-x (debug) -v (verbose)
. function.sh || exit

usage()
{
	# collect
	# local [NUM](100)		copy NUM random picutres to the local computer
	# frame 			 				copy media to a picture frame 
	echot "\
usage: media COMMAND
	AddDate FILES		add DateTimeOriginal to the specified files
	get					get pictures from a device
	info FILES 			display metadata
	rename FILES		rename using the date taken  
  SyncBooks				synchronize books with nas1
  -t, --test 			test the operation without making any changes
	-v, --verbose		verbose output"
	exit $1
}

getUsage() { echot "\
usage: media get
	Get media from a device
	-c, --copy				copy media 
	-d, --dest DEST 	destination directory
	-m, --move				move media
	-nm,--no-metadata do not add import metadata
	-nr,--no-review   do not review imported images
	-p, --person NAME person's name used in the destination folder
	-s, --source DIR	media source directory
	-t, --test 				test the operation without making any changes
	-v, --verbose			verbose output"; exit $1; }

args()
{
	unset -v command files help test verbose
	while (( $# != 0 )); do
		case "$1" in
			--help) help="--help";;
			--test|-t) test="--test";;
			--verbose|-v) verbose="--verbose";;
			AddDate) command="AddDate";; SyncBooks) command="SyncBooks";;
			*)
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(AddDate|info|rename) ]] && { files+=( "$1" ); shift; continue; }
				[[ "$command" == @(get) ]] && break
				UnknownOption "$1"
		esac
		shift
	done
	[[ $help ]] && { IsFunction "${command}Usage" && ${command}Usage 0 || usage 0; }
	[[ ! $command ]] && { MissingOperand "command"; }
	if [[ "$command" == @(AddDate|info|rename) ]]; then 
		[[ ! $files ]] && MissingOperand "file"
		for file in "${files[@]}"; do [[ ! -f "$file" ]] && { EchoErr "media $command: cannot access \`$file\`: No such file"; return 1; }; done
	fi;
	args=("$@")
}

GetArgs()
{
	unset dest noMetadata person
	operation="default" review="true"
	while (( $# != 0 )); do
		case "$1" in
			--copy|-c) operation="copy";;
			--dest) dest="$2"; shift;;
			--move|-m) operation="move";;
			--no-metadata|-nm) noMetadata="true";;
			--no-review|-nr) unset review;;
			--person|-p) person="$2"; shift;;
			--source|-s) source="$2"; shift;;
			--test|-t) test="--test";;
			--verbose|-v) verbose="--verbose";;
			*) getUsage 1;;
		esac
		shift
	done
	[[ $dest && ! -d "$dest" ]] && { EchoErr "media get: directory  \`$dest\` does not exit"; return 1; }
	[[ ! $person ]] && person="$(FullName)"
	[[ $source && ! -d "$source" ]] && { EchoErr "media get: cannot access \`$source\`: No such directory"; return 1; }
	return 0
}

init() 
{
	mediaRoo=oversoul
	mediaUnc="//$mediaRoo/Public"
	nas="nas1"

	dateTakenMetadata=( -Make -Model -HandlerVendorId -Keywords 
		-CompressorName -Software -CreatorTool -DateTimeOriginal -CreationTime
		-ImportedFileSizeBytes 	-CreateDate -MediaCreateDate -ModifyDate)

	pictureExtensions=( jpg png )
	videoExtensions=( 3gp avi mpg mp4 mts m2ts moff modd mov 3gp )
}

run() {	args "$@" || return; init || return; ${command}Command "${args[@]}"; }

#
# Helper Functions
# 

GetMediaType()
{
	local ext="$1" result

	if IsInArray "$ext" pictureExtensions; then
		result="picture"
	elif IsInArray "$ext" videoExtensions; then
	 result="video"
	else
		return 1
	fi 

	r "$result" $2
}

GetNewName() { r "$(${G}date "+%Y_%m_%d %H_%M_%S" -d "$1")" $2; }
NormalizeDate() {	r "$(${G}date "+%Y-%m-%d %H:%M:%S" -d "$1")" $2; }
ExifDate() {	r "$(${G}date "+%Y:%m:%d %H:%M:%S" -d "$1")" $2; }

GetDateTaken() # returns the files date taken in the format YYYY-MM-DD HH:MM:SS
{
	local file="$1" metadataVar="$2" returnVar="$3"
	local -A md; CopyArray $metadataVar md
	local mm="${md[Make]}-${md[Model]}" dto="${md[DateTimeOriginal]}" isUtc
	local ext; GetFileExtension "$file" ext || return
	local mediaType; GetMediaType "$ext" mediaType || return

	# Apple
	if [[ "$mm" ==  @(Apple-iPad|Apple-iPhone*) || "${md[HandlerVendorID]}" == "Apple" ]]; then
		s="$dto"
		[[ "$mediaType" == "video" ]] && { s="${md[MediaCreateDate]}"; isUtc=true; }

	# Sony HDR-SR12 (video), DSC-HX5V (still)
	elif [[ "$mm" == @(sony-HDR-SR12|sony-DSC-HX5V|CASIO COMPUTER CO.,LTD.-EX-Z150) || ( "$mediaType" == "video" && "$mm" == @(sony-) )]]; then # no model for HDR-SR12 videos
		s="$dto"

	elif [[ "$mm" == "-" && "${md[CompressorName]}" == "Ambarella AVC encoder" ]]; then # GoPro
		s="${md[MediaCreateDate]}"

	# Motorola DROID RAZR
	elif [[ "$mm" ==  @(motorola-DROID RAZR) || ( "$mediaType" == "video" && "${md[CompressorName]}" == "MOTO" ) ]]; then
		s="$dto"
		if [[ ! $s ]]; then
			if [[ "$mediaType" == "video" ]]; then
				isUtc=true
			else # pictures="$dto"
				if [[ ${md[CreatorTool]} ]]; then # photo editors change the ModifyDate
					unset s
				else	
					s="${md[ModifyDate]}"
				fi
			fi
			additionalMetadata+=( "-DateTimeOriginal=$(ExifDate "$s")" )
		fi

	# File modification date: Photo Booth, no metadata (( ${#v[@]} == 0 ))
	elif [[ "${md[Keywords]}" =~ .*Photo\ Booth.* ]]; then
		s="$dto"
		if [[ ! $s ]]; then
			s="$(${G}stat -c%y "$file")" || return;
			additionalMetadata+=( "-DateTimeOriginal=$(ExifDate "$s")" )
		fi

	# PNG - Windows shows CreationTime as the Date taken
	elif [[ "$ext" == @(PNG) ]]; then
		s="$dto"
		[[ ! $s ]] && s="${md[CreationTime]}"
		[[ ! $s ]] && s="$(${G}stat -c%y "$file")" || return;
		[[ $s && ! $dto ]] && additionalMetadata+=( "-DateTimeOriginal=$(ExifDate "$s")" )
		[[ $s && ! ${md[CreationTime]} ]] && additionalMetadata+=( "-CreationTime=$(ExifDate "$s")" )

	# Use DateTimeOriginal if present - Windows shows this as Date taken
	elif [[ $dto ]]; then
		s="$dto"

	# no metadata - file modification date
	elif (( ${#md[@]} == 0 )); then
		printf "no metadata..."
		s="$(${G}stat -c%y "$file")" || return;
		additionalMetadata+=( "-DateTimeOriginal=$(ExifDate "$s")" )

	else
		return 1

	fi

	[[ ! $s ]] && return 1
	[[ $isUtc ]] && s="$(${G}date -d "${md[CreateDate]} UTC")";
	NormalizeDate "$s" $returnVar
}

PrintMetadata()
{
	local file="$1" metadataVar="$2"
	local -A md; CopyArray $metadataVar md

	printf "%s:\n" "$(GetFileName "$file")"
	for var in "${!md[@]}"; do printf "	$var=${md[$var]}\n"; done
	echo ""
}

AddMetadata()
{
	local file="$1" metadata=( "${@:2}" )
	printf "metadata..."
	[[ $verbose ]] && { echo "(exiftool \"$file\" ${metadata[@]})"; }
	[[ $test ]] && return
	if ! exiftool -preserve "$(utw "$file")" "${metadata[@]}" >& /dev/null; then
		EchoErr -e "\nmedia get: unable to add metadata to \`$file\`"; return 1
	fi
}

GetMetadata() # GetMetadata FILE ARRAY [METADATA...](dateTakenMetadata)
{
	local file="$1" array="$2" metadata=( "${@:3}" )
	[[ ! $metadata ]] && metadata=( "${dateTakenMetadata[@]}" )
	#exiftool -fast2 -s2 "$(utw "$file")" "${metadata[@]}" 2> /dev/null | sed -e 's/: /]="/' -e 's/^/[/' -e 's/$/"/'  -e 's/:/-/' -e 's/:/-/'
	#pause
	eval "$array=( $(exiftool -fast2 -s2 "$(utw "$file")" "${metadata[@]}" 2> /dev/null | sed -e 's/: /]="/' -e 's/^/[/' -e 's/$/"/'  -e 's/:/-/' -e 's/:/-/' ) )"
}

#
# Get Command
#

GetInit()
{
	processAfterDateSeconds="" # "$(GetSeconds "11/26/2012")" # process media after this date
	bigFileSizeBytes=10000000 # 100 MiB, for progress file copy

	dropbox="$HOME/Dropbox/Camera Uploads"
	iCloud="$HOME/Pictures/iCloud Photos/My Photo Stream"
	localDirs=( "$DOC/data/download/pictures" "$iCloud" "$dropbox" )

	# options: GMT, copy, move
	unset externalDirs
	externalDirs=( /dcim/100OLYMP /mssony/moml0001 /dcim/100photo )
	externalDirs+=( "/100APPLE:copy" "/101APPLE:copy" "/102APPLE:copy") # iOS, permanantly mount Media\DCIM using iExplorer
	externalDirs+=( "/dcim/100GOPRO" )
	externalDirs+=( "/dcim/100msdcf" "/dcim/101msdcf" "/avchd/bdmv/stream:move" ) # Sony-DSC-HX5V
	externalDirs+=( "/dcim/100NIKON"  ) # Nikon (Alice)
	externalDirs+=( "/dcim/100CASIO" ) # Casio Exilim 8.1 MP ( CASIO COMPUTER CO.,LTD.-EX-Z150 )
	externalDirs+=( "/dcim/100msdcf" "/mp_root/101pnv01:move" "/avchd/bdmv/stream:move" )

	fileFormat="^[0-9][0-9][0-9][0-9]_[0-9][0-9]_[0-9][0-9] [0-9][0-9]_[0-9][0-9]_[0-9][0-9]" # YYYY_MM_DD HH_MM_SS

	local dir suffix="Camera/$person"
	if [[ $dest ]]; then
		destPicturePrefix="$(unc mount "//$dest/photo/$suffix")" || return
		destVideoPrefix="$(unc mount "//$dest/video/$suffix")" || return
	elif HostUtil available "$nas"; then
		destPicturePrefix="$(unc mount "//$nas/usbshare1/photo/$suffix")" || return
		destVideoPrefix="$(unc mount "//$nas/usbshare1/video/$suffix")" || return
	else
		destPicturePrefix="$(PublicPictures)/$suffix"
		destVideoPrefix="$(PublicVideos)/$suffix"
	fi

	echo "Picture destination: $destPicturePrefix"
	echo "Video destination: $destVideoPrefix"
	ask 'Confirm destination locations then press any key to continue' --delay 3 || return 1
	return 0
}

getCommand()
{
	local driveLabel importLocation imageProcessedDirs videoProcessedDirs tmpDir="/tmp/media"

	GetArgs "${args[@]}" || return
	GetInit || return
	
	if [[ $source ]]; then
		ProcessDir "$(GetFullPath "$source")" "$operation" || return
	else
		for dir in "${localDirs[@]}"; do ProcessDir "$dir" "$operation" || return; done
		for drive in "$VOLUMES/"*; do ProcessDrive "$drive" "$operation" || return; done
	fi

	[[ $review && $imageProcessedDirs ]] &&
		for dir in "${imageProcessedDirs[@]}"; do { ImageEdit "$dir"; sleep 1; } done

	[[ $review && $videoProcessedDirs ]] &&
		for dir in "${videoProcessedDirs[@]}"; do { VideoEdit "$dir"; sleep 1; } done

	if [[ -d "$tmpDir" ]]; then
		printf "cleanup..."
		[[ $verbose ]] && echo "(removing \`$tmpDir\`)"
		[[ ! $test ]] && { rm -fr "$tmpDir" || return; }
		[[ ! $verbose ]] && echo "done"
	fi

}

ProcessDrive()
{
	local drivePath="$1" operation="$2" dirs=( "${externalDirs[@]}" )
	local drive; GetFileName "$drivePath" drive || return; [[ "$drive" == @(c|d|Macintosh HD|MobileBackups) ]] && return 0
	local driveLabel; GetDriveLabel "$drive" driveLabel
	local importLocation; [[ "$driveLabel" =~ .*(iPad|iPhone).* ]] && importLocation="${driveLabel%% - DCIM}"
	local dir options

	for dir in "${dirs[@]}"; do
		IFS=":" read -a options <<<"$dir"; 
		dir="${options[0]}"

		[[ ! -d "$drivePath$dir" ]] && continue

		local op="$operation"
		if [[ "$op" == "default" ]]; then
			if IsInArray copy options; then op="copy"
			elif IsInArray move options; then op="move"; fi
		fi

		ProcessDir "$drivePath$dir" "$op" "$importLocation" || return
	done
}

ProcessDir()
{ 
	local dir="$1" operation="$2" importLocation="$3"
	[[ ! -d "$dir" ]] && return

	[[ ! $importLocation ]] && case "$dir" in
		"$dropbox") importLocation="Dropbox";;
		"$iCloud") importLocation="iCloud";;
		*) importLocation="${dir///cygdrive/}"
	esac

	printf "**************************************************\n* $importLocation\n**************************************************\n"	

	local processAfter
	[[ -f "$dir/.processAfter" ]] && processAfter="$(cat "$dir/.processAfter")"

	shopt -s nullglob
	for file in "$dir/"*; do ProcessFile "$file" "$operation" "$processAfter" || return; done

	[[ "$operation" == "copy" ]] && 
		echo "$(ls -1 "$dir" | tail -1 | sed 's/"//g')" > "$dir/.processAfter" || return
}

ProcessFile()
{
	local file="$1" operation="$2" processAfterFileName="$3" additionalMetadata
	local fileName; GetFileName "$file" fileName || return

	[[ $processAfterFileName && ! "$fileName" > "$processAfterFileName" ]] && return 0

	printf "$fileName..."

	local fileSize="$(GetFileSize "$file" B)"
	local ext; GetFileExtension "$file" ext || return
	local fileDesc; GetFileNameWithoutExtension "$file" fileDesc || return
	local mediaType; GetMediaType "$ext" mediaType || return 0

	[[ "$operation" == "default" ]] && operation="move"

	local destPrefix="$destPicturePrefix"; [[ "$mediaType" == "video" ]] && destPrefix="$destVideoPrefix"
	if [[ ! -d "$destPrefix" ]]; then
		ask "Create the destination directory $destPrefix" || return 1
		${G}mkdir --parents "$destPrefix" || return
	fi

	local -A fileMetadata; GetMetadata "$file" fileMetadata || return
	local dateTaken; GetDateTaken "$file" fileMetadata dateTaken || { echo "no DateTaken"; return 0; }
	local dateTakenSeconds=$(GetSeconds "$dateTaken")
	local prefix; GetNewName "$dateTaken" prefix || return
	local destDir="$destPrefix/$(${G}date +%Y -d "$dateTaken")/$(${G}date +%Y%m -d "$dateTaken")" 
	local suffix dest="$destDir/$prefix.$ext"

	[[ $processAfterDateSeconds ]] && CompareSeconds "$dateTakenSeconds" "<" "$processAfterDateSeconds" && 
		{ echo "skipping"; return 0; }

	#pause "$dateTaken-$dateTakenSeconds-$prefix-$destDir-$dest"
	[[ $verbose ]] && PrintMetadata "(metadata)" fileMetadata

	[[ ! -d "$destDir" ]] && { ${G}mkdir --parents "$destDir" || return; }

	while [[ -f "$dest" ]]; do
		IsDuplicateFile && { RemoveProcessedFile "$file" "$prefix${suffix:+-$suffix}"; return; } 
		(( ++suffix )); dest="$destDir/$prefix-$suffix.$ext" # use a suffix for rapid picture taking (same name, different size)
	done

	if [[ "$mediaType" == "picture" ]]; then
		IsInArray "$destDir" imageProcessedDirs || imageProcessedDirs+=( "$destDir" );
	else
		IsInArray "$destDir" videoProcessedDirs || videoProcessedDirs+=( "$destDir" );
	fi

	local operationDesc="moving"; [[ "$operation" == "copy" ]] && operationDesc="copying"
	printf "$prefix${suffix:+-$suffix}..."

	local bigFile; (( fileSize >= bigFileSizeBytes )) && bigFile="true"

	if [[ ! $noMetadata && "$ext" != @(avi|mts|m2ts) ]]; then
		local tmpFile="$tmpDir/$fileName"
		[[ ! -d "$tmpDir" ]] && { ${G}mkdir "$tmpDir" || return; }
		GetCopyFile "$file" "$tmpFile" "" "caching" || return
		AddImportedMetadata "$tmpFile" || return
		GetCopyFile "$tmpFile" "$dest" "$bigFile" "$operationDesc" || return
	else
		GetCopyFile "$file" "$dest" "$bigFile" "$operationDesc" || return
	fi

	if [[ "$operation" == "move" ]]; then
		[[ $verbose ]] && echo "(rm \`$file\`)"
		[[ ! $test ]] && { rm "$file" || return; }
	fi

	[[ ! $bigFile || $test ]] && echo "done"
	[[ $verbose ]] && pause
	return 0
}

IsDuplicateFile()
{
	# videos are duplicate if names match
	[[ "$mediaType" == "video" ]] && return 0 

	# current size is the same
	[[ "$fileSize" == "$(GetFileSize "$dest" B)" ]] && return 0

	# original size is the same
	[[ "$fileSize" == "$(exiftool -fast2 -s3 -ImportedFileSizeBytes "$dest" 2> /dev/null | sed -e '/^Ma/d')" ]] && return 0

	return 1
}

AddImportedMetadata()
{
	local toFile="$1"
	AddMetadata "$toFile" "${additionalMetadata[@]}" \
		-ImportedDate="$(${G}date '+%Y:%m:%d %H:%M:%S')" \
		-ImportedFileModificationTime="$(ExifDate "$(${G}stat -c%y "$file")")" \
		-ImportedFileSizeBytes="$fileSize" \
		-ImportedOnHost="$HOSTNAME" \
		-ImportedByUser="$USER" \
		-ImportedFromFolder="$importLocation" \
		-ImportedFileName="$fileName" \
		-ImportedToFolder="${destDir///cygdrive/}"
		
}

RemoveProcessedFile()
{
	local file="$1" desc="$2"
	[[ "$operation" == "copy" ]] && { echo "$desc already processed...skipping"; return 0; }
	printf "$desc already processed...removing..."
	[[ $verbose ]] && echo "(removing \`$file\`)"
	[[ ! $test ]] && { rm "$file" || return; }
	echo "done"
	return 0
}

GetCopyFile() # SRC DEST
{
	local src="$1" dest="$2" bigFile="$3" desc="$4"

	printf "$desc..."
	[[ $verbose ]] && { echo "(cp \"$src\" \"$dest\")"; }
	[[ $test ]] && return 0
	[[ ! $bigFile ]] && { cp "$src" "$dest"; return; }
	[[ "$PLATFORM" != "win" ]] && { CopyDir "$src" "$dest"; return; }

	local srcDir destDir srcFileName destFileName
	
	GetFilePath "$src" srcDir || return
	GetFilePath "$dest" destDir || return
	GetFileName "$src" srcFileName || return
	GetFileName "$dest" destFileName || return

	[[ "$srcFileName" != "$destFileName" ]] && { mv "$src" "$srcDir/$destFileName" || return; }
	CopyDir "$srcDir/$destFileName" "$destDir" || return

	[[ "$srcFileName" != "$destFileName" ]] && { mv "$srcDir/$destFileName" "$src" || return; }
	return 0
}

#
# Other Commands
#

AddDateCommand() { for file in "${files[@]}"; do AddDate "$file" || return; done; }
AddDate()
{
	local file="$1"
	local fileName; GetFileName "$file" fileName || return; printf "$fileName..."
	local ext; GetFileExtension "$file" ext || return
	local mediaType; GetMediaType "$ext" mediaType || { echo "unknown media type"; return 0; }
	local -A fileMetadata; GetMetadata "$file" fileMetadata || return
	local dateTaken; GetDateTaken "$file" fileMetadata dateTaken && { echo "date already present"; return 0; }
	local modificationDate="$(${G}stat -c%y "$file")" || return;
	local additionalMetadata=( "-DateTimeOriginal=$(ExifDate "$modificationDate")" )
	printf "adding date..."; AddMetadata "$file" "${additionalMetadata[@]}"; echo "done"
}

renameCommand() { for file in "${files[@]}"; do Rename "$file" || return; done; }
Rename()
{
	local file="$1"
	local path; GetFilePath "$file" path || return
	local fileName; GetFileName "$file" fileName || return; printf "$fileName..."
	local name; GetFileNameWithoutExtension "$file" name || return
	local ext; GetFileExtension "$file" ext || return
	local suffix; [[ "$name" =~ .*-[0-9]+ ]] && suffix="-${name##*-}"
	local -A fileMetadata; GetMetadata "$file" fileMetadata || return
	local dateTaken; GetDateTaken "$file" fileMetadata dateTaken || { echo "no DateTaken"; return 0; }
	local newName; GetNewName "$dateTaken" newName || return
	local expected="$newName$suffix" 
	local newFile="${path:+$path/}$expected.$ext"

	[[ "$name" == "$expected" && ! $additionalMetadata ]] && { echo "name is correct"; return 0; }

	if [[ "$name" != "$expected" ]]; then
		printf "$expected..."
		[[ $verbose ]] && { echo "(mv \"$file\" \"$newFile\")" || return; }
		[[ ! $test ]] && { mv "$file" "$newFile" || return; }
	fi

	[[ $additionalMetadata ]] && AddMetadata "$newFile" "${additionalMetadata[@]}"

	[[ ! $verbose ]] && echo "done"
}

infoCommand() { for file in "${files[@]}"; do Info "$file" || return; done; }
Info()
{
	local file="$1"
	declare -A fileMetadata; GetMetadata "$file" fileMetadata || return
	PrintMetadata "$file" fileMetadata
}

SyncBooksCommand()
{
	#calibre opds || return
	merge "$UDATA/books" "//nas1/home/documents/data/books" || return
	merge "$UDATA/books" "//nas1/web/books" || return
}

run "$@"

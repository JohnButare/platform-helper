#!/usr/bin/env bash
#-x (debug) -v (verbose)
. function.sh || exit

usage()
{
	# collect
	# local [NUM](100)		copy NUM random picutres to the local computer
	# frame 			 				copy media to a picture frame 
	echot "\
usage: media COMMAND
	backup					backup media
	date FILES			add DateTimeOriginal to the specified files
	get							get pictures from a device
	info FILES 			display metadata
	rename FILES		rename using the date taken  

  -t, --test 			test the operation without making any changes
	-v, --verbose		verbose output"
	exit $1
}

getUsage() { echot "\
usage: media get
	Get media from a device
	-c, --copy				copy media 
	-d, --dest DEST 	destination directory
	-m, --move				move media
	-p, --person NAME person's name used in the destination folder
	-s, --source DIR	media source directory
	-t, --test 				test the operation without making any changes
	-v, --verbose			verbose output"; exit $1; }

args()
{
	unset -v command files help test verbose

	while (( $# != 0 )); do
		case "$1" in
			--help) help="--help";;
			--test|-t) test="--test";;
			--verbose|-v) verbose="--verbose";;
			AddDate) command="AddDate";; SyncBooks) command="SyncBooks";;
			*)
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(AddDate|info|rename) ]] && { files+=( "$1" ); shift; continue; }
				[[ "$command" == @(get) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	[[ $help ]] && { IsFunction "${command}Usage" && ${command}Usage 0 || usage 0; }
	[[ ! $command ]] && { MissingOperand "command"; }
	if [[ "$command" == @(AddDate|info|rename) ]]; then 
		[[ ! $files ]] && MissingOperand "file"
		for file in "${files[@]}"; do [[ ! -f "$file" ]] && { EchoErr "media $command: cannot access \`$file\`: No such file"; return 1; }; done
	fi;
	args=("$@")
}

getArgs()
{
	unset dest person
	operation="move"

	while (( $# != 0 )); do
		case "$1" in
			--copy|-c) operation="copy";;
			--dest|-d) dest="$2"; shift;;
			--move|-m) operation="move";;
			--person|-p) person="$2"; shift;;
			--source|-s) source="$2"; shift;;
			--test|-t) test="--test";;
			--verbose|-v) verbose="--verbose";;
			*) getUsage 1;;
		esac
		shift
	done

	return 0
}

init() 
{
	nas="$(ConfigGet "fs")" nasDir="data/media"

	dateTakenMetadata=( -Make -Model -HandlerVendorId -Keywords 
		-CompressorName -Software -CreatorTool -DateTimeOriginal -CreationTime
		-ImportedFileSizeBytes 	-CreateDate -MediaCreateDate -ModifyDate)

	pictureExtensions=( jpg png )
	videoExtensions=( 3gp avi mpg mp4 mts m2ts moff modd mov 3gp )
}

run() {	args "$@" || return; init || return; ${command}Command "${args[@]}"; }

#
# Helper Functions
# 

GetNewName() { r "$(${G}date "+%Y_%m_%d %H_%M_%S" -d "$1")" $2; }
NormalizeDate() {	r "$(${G}date "+%Y-%m-%d %H:%M:%S" -d "$1")" $2; }
ExifDate() {	r "$(${G}date "+%Y:%m:%d %H:%M:%S" -d "$1")" $2; }

GetMediaType()
{
	local ext="$1" result

	if IsInArray "$ext" pictureExtensions; then
		result="picture"
	elif IsInArray "$ext" videoExtensions; then
	 result="video"
	else
		return 1
	fi 

	r "$result" $2
}

GetDateTaken() # returns the files date taken in the format YYYY-MM-DD HH:MM:SS
{
	local file="$1" metadataVar="$2" returnVar="$3" s
	local -A md; ArrayCopy $metadataVar md
	local mm="${md[Make]}-${md[Model]}" dto="${md[DateTimeOriginal]}" isUtc
	local ext; GetFileExtension "$file" ext || return
	local mediaType; GetMediaType "$ext" mediaType || return

	# Apple
	if [[ "$mm" ==  @(Apple-iPad|Apple-iPhone*) || "${md[HandlerVendorID]}" == "Apple" ]]; then
		s="$dto"
		[[ "$mediaType" == "video" ]] && { s="${md[MediaCreateDate]}"; isUtc=true; }

	# Use DateTimeOriginal if present - Windows shows this as Date taken
	elif [[ $dto ]]; then
		s="$dto"

	# no metadata - file modification date
	elif (( ${#md[@]} == 0 )); then
		printf "no metadata (using file modification date)..."
		s="$(${G}stat -c%y "$file")" || return;
		additionalMetadata+=( "-DateTimeOriginal=$(ExifDate "$s")" )

	# metadata is preset, but could not determine the original datetime
	else
		return 1

	fi

	[[ ! $s ]] && return 1
	[[ $isUtc ]] && s="$(${G}date -d "${md[CreateDate]} UTC")";
	NormalizeDate "$s" $returnVar
}

PrintMetadata()
{
	local file="$1" metadataVar="$2"
	local -A md; ArrayCopy $metadataVar md

	printf "%s:\n" "$(GetFileName "$file")"
	for var in "${!md[@]}"; do printf "	$var=${md[$var]}\n"; done
	echo ""
}

AddMetadata()
{
	local file="$1" metadata=( "${@:2}" )
	printf "metadata..."
	[[ $verbose ]] && { echo "(exiftool \"$file\" ${metadata[@]})"; }
	[[ $test ]] && return
	if ! exiftool -preserve "$(utw "$file")" "${metadata[@]}" >& /dev/null; then
		EchoErr -e "\nmedia get: unable to add metadata to \`$file\`"; return 1
	fi
}

GetMetadata() # GetMetadata FILE ARRAY [METADATA...](dateTakenMetadata) - put file metadata into an associate array
{
	local file="$1" array="$2" metadata=( "${@:3}" ) result

	[[ ! $metadata ]] && metadata=( "${dateTakenMetadata[@]}" )

	result="$(exiftool -fast2 -s2 "$file" "${metadata[@]}" 2> /dev/null | sed -e 's/: /]="/' -e 's/^/[/' -e 's/$/"/' -e 's/:/-/' -e 's/:/-/' )"
	eval "$array=( $result )"
}

#
# Get Command
#

getCommand()
{
	local disks drives importLocation

	getArgs "${args[@]}" || return
	getInit || return
	
	if [[ $source ]]; then
		processDir "$(GetFullPath "$source")" || return
	else
		for dir in "${localDirs[@]}"; do processDir "$dir" || return; done

		drive mount all || return

		IFS=$'\n' drives=( $(drive mounts) )
		for drive in "${drives[@]}"; do
			processDrive "$drive"
		done

		#drive unmount all || return

	fi
}

getInit()
{
	localDirs=( "$DOC/data/download/pictures" )

	! InPath exiftool && { package exiftool || return; }

	# set directioes to check.  options: GMT, copy, move
	unset mediaDirs
	mediaDirs=(  )
	mediaDirs+=( "/dcim/100GOPRO" ) 
	mediaDirs+=( "/dcim/100msdcf" "/dcim/101msdcf" "/avchd/bdmv/stream" ) # Sony-DSC-HX5V
	mediaDirs+=( "/DCIM/100EOS_R"  ) # Canon EOS
	
	fileFormat="^[0-9][0-9][0-9][0-9]_[0-9][0-9]_[0-9][0-9] [0-9][0-9]_[0-9][0-9]_[0-9][0-9]" # YYYY_MM_DD HH_MM_SS

	if [[ $source && ! -d "$source" ]]; then
		IsUncPath "$source" && { source="$(unc mount "$dest")"; } || return
		[[ ! -d "$source" ]] && { EchoErr "source directory \"$source\" does not exist"; return 1; }
	fi

	unset useSuffix pictureDir videoDir

	if [[ $dest ]]; then
		IsUncPath "$dest" && { dest="$(unc mount "$dest")" || return; }
	else
		! IsAvailable "$nas" && { EchoErr "$nas is not available"; return 1; }
		dest="$(unc mount "//$nas/$nasDir")" || return
		useSuffix="true"
	fi

	[[ ! -d "$dest" ]] && { EchoErr "destination directory  \"$dest\" does not exit"; return 1; }

	if [[ $useSuffix ]]; then
		[[ ! $person ]] && person="$(FullName)"

		pictureDir="$dest/photo/Camera/$person" || return
		${G}mkdir --parents "$pictureDir" || return

		videoDir="$dest/video/Camera/$person" || return
		${G}mkdir --parents "$videoDir" || return
	fi

	return 0
}

processDrive()
{
	local drive="$1" dir

	for dir in "${mediaDirs[@]}"; do
		processDir "$drive$dir" || return
	done
}

processDir()
{ 
	local dir="$1"
	
	[[ ! -d "$dir" ]] && return

	printf "Processing $dir..."	

	shopt -s nullglob
	for file in "$dir/"*; do
		ProcessFile "$file" || return
	done

	echo "done"
}

ProcessFile()
{
	local src="$1" additionalMetadata
	local srcName; GetFileName "$src" srcName || return
	local ext; GetFileExtension "$src" ext || return
	local srcDesc; GetFileNameWithoutExtension "$src" srcDesc || return
	local mediaType; GetMediaType "$ext" mediaType || return 0
	local -A srcMetadata; GetMetadata "$src" srcMetadata || return
	local dateTaken; GetDateTaken "$src" srcMetadata dateTaken || { echo "no DateTaken"; return 0; }
	local srcNamePrefix; GetNewName "$dateTaken" srcNamePrefix || return
	local destDir="$dest"
	
	if [[ $useSuffix ]]; then
		destDir="$pictureDir"; [[ "$mediaType" == "video" ]] && destDir="$videoDir"
		destDir="$destDir/$(${G}date +%Y -d "$dateTaken")/$(${G}date +%Y%m -d "$dateTaken")" # add YYYY/YYYYMM
		${G}mkdir --parents "$destDir" || return
	fi
	
	local dest="$destDir/$srcNamePrefix.$ext"

	[[ $verbose ]] && PrintMetadata "(metadata)" srcMetadata

	local suffix alreadyProcessed # add a suffix for media taken in the same second
	while [[ -f "$dest" ]]; do
		IsFileSame "$src" "$dest" && { alreadyProcessed="true"; break; }
		(( ++suffix )); dest="$destDir/$srcNamePrefix-$suffix.$ext"
	done

	printf "$srcNamePrefix${suffix:+-$suffix}..."

	if [[ $alreadyProcessed ]]; then
		printf "skipping (already processed)..."
	else
		[[ $verbose ]] && { echo "(cp \"$src\" \"$dest\")"; }
		[[ ! $test ]] && { cp "$src" "$dest" || return; }
	fi

	if [[ "$operation" == "move" ]]; then
		[[ $verbose ]] && echo "(rm \"$src\")"
		[[ ! $test ]] && { rm "$src" || return; }
	fi

	[[ $verbose ]] && pause

	return 0
}

#
# Other Commands
#

dateCommand() { for file in "${files[@]}"; do addDate "$file" || return; done; }
infoCommand() { for file in "${files[@]}"; do info "$file" || return; done; }
renameCommand() { for file in "${files[@]}"; do rename "$file" || return; done; }

backupCommand()
{
	local dir="//$(ConfigGet "fsUnc")/public/media"

	printf "backup..."

	printf "data..."
	BeyondCompare "$dir"	"//$(ConfigGet "fs")/data/media" &

	local drives; IFS=$'\n' drives=( $(drive mounts) )

	for drive in "${drives[@]}"; do
		[[ ! "$(drive label "$drive")" =~ backup ]] && continue
		local dir="$(drive mount "$drive")" || continue
		[[ ! -d "$dir/media" ]] && continue

		printf "$(drive label "$drive")..."
		BeyondCompare "$dir" "/mnt/$drive/media" &
	done

	echo "done"
}

addDate()
{
	local file="$1"
	local fileName; GetFileName "$file" fileName || return; printf "$fileName..."
	local ext; GetFileExtension "$file" ext || return
	local mediaType; GetMediaType "$ext" mediaType || { echo "unknown media type"; return 0; }
	local -A fileMetadata; GetMetadata "$file" fileMetadata || return
	local dateTaken; GetDateTaken "$file" fileMetadata dateTaken && { echo "date already present"; return 0; }
	local modificationDate="$(${G}stat -c%y "$file")" || return;
	local additionalMetadata=( "-DateTimeOriginal=$(ExifDate "$modificationDate")" )
	printf "adding date..."; AddMetadata "$file" "${additionalMetadata[@]}"; echo "done"
}

info()
{
	local file="$1"
	declare -A fileMetadata; GetMetadata "$file" fileMetadata || return
	PrintMetadata "$file" fileMetadata
}

rename()
{
	local file="$1"
	local path; GetFilePath "$file" path || return
	local fileName; GetFileName "$file" fileName || return; printf "$fileName..."
	local name; GetFileNameWithoutExtension "$file" name || return
	local ext; GetFileExtension "$file" ext || return
	local suffix; [[ "$name" =~ .*-[0-9]+ ]] && suffix="-${name##*-}"
	local -A fileMetadata; GetMetadata "$file" fileMetadata || return
	local dateTaken; GetDateTaken "$file" fileMetadata dateTaken || { echo "no DateTaken"; return 0; }
	local newName; GetNewName "$dateTaken" newName || return
	local expected="$newName$suffix" 
	local newFile="${path:+$path/}$expected.$ext"

	[[ "$name" == "$expected" && ! $additionalMetadata ]] && { echo "name is correct"; return 0; }

	if [[ "$name" != "$expected" ]]; then
		printf "$expected..."
		[[ $verbose ]] && { echo "(mv \"$file\" \"$newFile\")" || return; }
		[[ ! $test ]] && { mv "$file" "$newFile" || return; }
	fi

	[[ $additionalMetadata ]] && AddMetadata "$newFile" "${additionalMetadata[@]}"

	[[ ! $verbose ]] && echo "done"
}

run "$@"

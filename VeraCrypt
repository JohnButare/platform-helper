#!/usr/bin/env bash
. app.sh || exit

usage() 
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [cd|close|IsInstalled|IsRunning|mount|profile|program|restart|start|startup|unmount|version](start)
$(ScriptName) commands."
}

init()
{
	defaultCommand="start"
	cd="$UDATA/VeraCrypt" 
	profileName="VeraCrypt"
	profileMask="*"

	# find program
	case "$PLATFORM" in
		win) program="$P/VeraCrypt/VeraCrypt.exe" profileDir="$UADATA/../Roaming/VeraCrypt";;
		*) unset program;;
	esac
	[[ "${1,,}" == "isinstalled" ]] && { isInstalledCommand; return; }
	[[ ! -e "$program" ]] && { ScriptErr "$(ScriptName) is not installed"; return 1; }
	[[ ! -d "$profileDir" ]] && { ${G}mkdir --parents "$profileDir" || return; }

	return 0
}

cdCommand() { echo "$cd"; }
closeCommand() { ! isRunningCommand && return 0; ProcessClose "$program"; } 
isInstalledCommand() { [[ -f "$program" ]]; }
isRunningCommand() { IsProcessRunning "$program"; }
profileUsage() { echot "Usage: $(ScriptName) profile dir|SaveDir|save|restore [<profile name>|default](latest)\n$(ScriptName) configuration."; }
profileArgs() { profileArgs=( "$@" ); (( shift+=$# )); }
profileCommand() { profile $noPrompt --app "$profileName" --method "$profileDir" --files "$profileMask" "${profileArgs[@]}"; }
programCommand() { echo "$program"; }
restartCommand() { closeCommand && startCommand; }
startArgs() { startArgs=( "$@" ); shift="$#"; }
startCommand() { isInstalledCommand && start $wait "$program" "${startArgs[@]}"; }
startupCommand() { startCommand; }
versionCommand() { FileVersion "$program"; }
									 
#
# Mount Command
#

mountUsage() { echo "\
Usage: $(ScriptName) mount FILE [LETTER]

	-d, --dir DIRECTORY					return the directory in the mounted volume, or return it
															if present in existing mounted drives.
	-p, --password PASSWORD			password for the file
	"; }

mountArgStart() { unset file letter password; }

mountOpt() 
{
	case "$1" in
		-p|--password|-p=*|--password=*) ScriptOptGet password "$@" || return;;
		-d|--dir|-d=*|--dir=*) ScriptOptGet dir "$@" || return;;
		*) return 1
	esac
}

mountArgs()
{
	ScriptArgGet "file" -- "$@" && ScriptCheckFile "$file"; shift;
	[[ $1 ]] && { ScriptArgDriveLetter "$1" || return; shift; }
	return 0
}

mountCommand()
{
	# check if the directory is already mounted
	if [[ $dir ]]; then
		local drive drives; IFS=$'\n' drives=( $(drive mounts) )
		for drive in "${drives[@]}"; do 
			[[ -d "$drive/$dir" ]] && { echo "$drive/$dir"; return; }
		done
	fi

	local args=( /cache yes /quit /nowaitdlg yes /volume "$(utw "$file")" )
	
	[[ $letter ]] && args+=( /letter "$letter" ) || args+=( /auto )

	credential exists secure strong --fallback && { password="$(credential get secure strong --fallback)" || return; }
	[[ $password ]] && args+=( /silent /password "$password" )

	# get the currently mounted drives
	local drives; [[ ! $letter ]] && { drives="$(drive list)" || return; }

	# mount the volume
	[[ ! $quiet ]] && EchoErr "Mounting encrypted volume \`$(FileToDesc "$file")\`..."
	"$program" "${args[@]}" || return

	# get the new first new drive letter if needed
	if [[ ! $letter ]]; then
		IFS=$'\n' drives=( $(printf "$drives") ) || return # IFS use interferes with running VeraCrypt
		local newDrives; IFS=$'\n' newDrives=( $(drive list) ) || return
		letter="$(ArrayIntersection newDrives drives | head -1)" || return
	fi

	# mount the new drive
	[[ $dir ]] && dir="/$dir"
	[[ $letter ]] && echo "$(drive mount "$letter")$dir" || return

	return 0
}

#
# Unmount Command
#

unmountUsage() { echo "Usage: $(ScriptName) unmount LETTER"; }
unmountArgStart() { unset letter; }
unmountArgs() { ScriptArgDriveLetter "$1" || return; shift; }

unmountCommand()
{
	[[ ! $quiet ]] && echo "Unmounting encrypted volume..."
	[[ -d "/mnt/$letter" ]] && { drive unmount "$letter" || return; }
	"$program" /quit /silent /dismount "$letter"
}

ScriptRun "$@"

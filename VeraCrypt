#!/usr/bin/env bash
. app.sh || exit

run() {	init && args "$@" && "${command}Command" "${args[@]}"; }

init()
{ 
	unset program profileDir
	case "$PLATFORM" in
		win) program="$P/VeraCrypt/VeraCrypt.exe" profileDir="$ADATA/../Roaming/VeraCrypt";;
	esac
	cd="$UDATA/VeraCrypt" profileName="VeraCrypt"
}

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
$(ScriptName) commands.

	start|startup|close|restart|cd
	mount|unmount
  profile save|restore|dir|SaveDir [<profile name>|default](latest) [--global]

  -b, --brief					brief status messages
  -np, --no-prompt   suppress interactive prompts"
}

args()
{
	unset -v brief noPrompt

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-b|--brief) brief="--brief";;	
			-h|--help) usage 0;;
			-np|--no-prompt) noPrompt="--no-prompt";;
			--) shift; otherArgs+=("$@"); set --; break;;
			*) ScriptOpt "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"
	
	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	[[ $# != "0" && "$command" != @(start|startup|profile|service) ]] && usage
	args=("$@")
}

#
# Commands
#

cdCommand() { echo "$cd"; }
closeCommand() { ! isRunningCommand && return 0; ProcessClose "$program"; }
isInstalledCommand() { [[ -f "$program" ]]; }
isRunningCommand() { IsTaskRunning "$program"; }
restartCommand() { closeCommand && startCommand; }
startCommand() { ! isInstalledCommand && return 1; isRunningCommand && return 0; start "$program" "$@"; }

profileCommand()
{
	[[ ! -d "$profileDir" ]] && { mkdir --parents "$profileDir" || return; }
	profile $noPrompt --app "$profileName" --method "$profileDir" --files "*" "$@"
}

#
# Mount Command
#

mountUsage() { echo "\
Usage: $(ScriptName) mount FILE [LETTER]
	-p, --password PASSWORD			password for the file"; }

mountArgStart() { unset file letter password; }

mountOpt() 
{
	case "$1" in
		-p|--password|-p=*|--password=*) ScriptOptGet password "$@" || return;;
		*) return 1
	esac
}

mountArgs()
{
	ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift;
	[[ $1 ]] && { ScriptArgDriveLetter "$1" || return; shift; }
	return 0
}

mountCommand()
{
	local letterArg="/auto"; [[ $letter ]] && letterArg="/letter $letter"
	local passwordArg

	if [[ $password ]]; then 
		passwordArg="/password $password"
	elif credential exists secure strong --fallback; then
		passwordArg="/password $(credential get secure strong --fallback)" || return
	fi

	# get the currently mounted drives
	#local drives; [[ ! $letter ]] && { IFS=$'\n' drives=( $(drive list) ) || return; }
	local drives; [[ ! $letter ]] && { drives="$(drive list)" || return; }

	# mount the volume
	"$program" /cache yes /quit /silent /nowaitdlg yes $letterArg $passwordArg /volume "$(utw "$file")" || return

	# get the new first new drive letter if needed
	if [[ ! $letter ]]; then
		IFS=$'\n' drives=( $(printf "$drives") ) || return # IFS use interferes with running VeraCrypt
		local newDrives; IFS=$'\n' newDrives=( $(drive list) ) || return
		letter="$(ArrayDiff newDrives drives | head -1)" || return
	fi

	# mount the new drive
	[[ $letter ]] && drive mount "$letter" || return

	return 0
}

#
# Unmount Command
#

unmountUsage() { echo "Usage: $(ScriptName) unmount LETTER"; }
unmountArgStart() { unset letter; }
unmountArgs() { ScriptArgDriveLetter "$1" || return; shift; }
unmountCommand() { drive unmount "$letter" && "$program" /quit /silent /dismount "$letter"; }

#
# helper
#

run "$@"

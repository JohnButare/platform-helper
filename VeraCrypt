#!/usr/bin/env bash
. app.sh || exit

init()
{ 
	unset program profileDir
	case "$PLATFORM" in
		win) program="$P/VeraCrypt/VeraCrypt.exe" profileDir="$ADATA/../Roaming/VeraCrypt";;
	esac
	cd="$UDATA/VeraCrypt" profileName="VeraCrypt"
}

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
$(ScriptName) commands.

	start|close|restart|cd
	mount|unmount
  profile save|restore|dir|SaveDir [<profile name>|default](latest) [--global]

  -b, --brief					brief status messages
  -np, --no-prompt   suppress interactive prompts"
}

argStart() { unset -v brief noPrompt; }

opt()
{
	case "$1" in "") : ;;
		-b|--brief) brief="--brief";;	
		-h|--help) usage 0;;
		-np|--no-prompt) noPrompt="--no-prompt";;
		*) return 1;;
	esac
}

#
# Commands
#

cdCommand() { echo "$cd"; }
closeCommand() { ! isRunningCommand && return 0; ProcessClose "$program"; }
isInstalledCommand() { [[ -f "$program" ]]; }
isRunningCommand() { IsTaskRunning "$program"; }
restartCommand() { closeCommand && startCommand; }
startCommand() { ! isInstalledCommand && return 1; isRunningCommand && return 0; start "$program" "${otherArgs[@]}"; }

profileArgStart() { profileArgs=(); }
profileArgs() { profileArgs="$@"; (( shift+=$# )); true; }
profileCommand()
{
	[[ ! -d "$profileDir" ]] && { mkdir --parents "$profileDir" || return; }
	profile $noPrompt --app "$profileName" --method "$profileDir" --files "*" "$@"
}

#
# Mount Command
#

mountUsage() { echo "\
Usage: $(ScriptName) mount FILE [LETTER]

	-d, --dir DIRECTORY					return the directory in the mounted volume, or return it
															if present in existing mounted drives.
	-p, --password PASSWORD			password for the file
	"; }

mountArgStart() { unset file letter password; }

mountOpt() 
{
	case "$1" in
		-p|--password|-p=*|--password=*) ScriptOptGet password "$@" || return;;
		-d|--dir|-d=*|--dir=*) ScriptOptGet dir "$@" || return;;
		*) return 1
	esac
}

mountArgs()
{
	ScriptArgGet "file" -- "$@" && ScriptCheckFile "$file"; shift;
	[[ $1 ]] && { ScriptArgDriveLetter "$1" || return; shift; }
	return 0
}

mountCommand()
{
	# check if the directory is already mounted
	if [[ $dir ]]; then
		local drive drives; IFS=$'\n' drives=( $(drive mounts) )
		for drive in "${drives[@]}"; do 
			[[ -d "$drive/$dir" ]] && { echo "$drive/$dir"; return; }
		done
	fi

	local args=( /cache yes /quit /nowaitdlg yes /volume "$(utw "$file")" )
	
	[[ $letter ]] && args+=( /letter "$letter" ) || args+=( /auto )

	credential exists secure strong --fallback && { password="$(credential get secure strong --fallback)" || return; }
	[[ $password ]] && args+=( /silent /password "$password" )

	# get the currently mounted drives
	local drives; [[ ! $letter ]] && { drives="$(drive list)" || return; }

	# mount the volume
	[[ ! $quiet ]] && EchoErr "Mounting encrypted volume \`$(FileToDesc "$file")\`..."
	"$program" "${args[@]}" || return

	# get the new first new drive letter if needed
	if [[ ! $letter ]]; then
		IFS=$'\n' drives=( $(printf "$drives") ) || return # IFS use interferes with running VeraCrypt
		local newDrives; IFS=$'\n' newDrives=( $(drive list) ) || return
		letter="$(ArrayDiff newDrives drives | head -1)" || return
	fi

	# mount the new drive
	[[ $dir ]] && dir="/$dir"
	[[ $letter ]] && echo "$(drive mount "$letter")$dir" || return

	return 0
}

#
# Unmount Command
#

unmountUsage() { echo "Usage: $(ScriptName) unmount LETTER"; }
unmountArgStart() { unset letter; }
unmountArgs() { ScriptArgDriveLetter "$1" || return; shift; }

unmountCommand()
{
	[[ ! $quiet ]] && echo "Unmounting encrypted volume..."
	[[ -d "/mnt/$letter" ]] && { drive unmount "$letter" || return; }
	"$program" /quit /silent /dismount "$letter"
}

#
# helper
#

ScriptRun "$@"

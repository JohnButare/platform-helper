#!/usr/bin/env bash
. script.sh || exit

run() {	init && args "$@" && "${command}Command" "${args[@]}"; }

init()
{
	switch="" waitDefault=120 poeSwitchDefault="StudyDeskSwitch"

	hostArg="HOST format is HOST[:PORT] where PORT is an optional switch port number.
		If the PORT is allthe command applies to all switch ports on the host."
}

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
Manage host or PoE switch port power state.

	on|off|reboot|sleep|firmware|hibernate
	fix				fix power issues
	status		host power status

	-t, --timeout=[500]		milliseconds to wait for a response from the host
	-v, --verbose 				show verbose information where possible"
	exit $1
}

args()
{
	unset -v verbose timeout

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do		
		case "$1" in "") : ;;
			-h|--help) usage 0;;
			-t|--timeout|-t=*|--timeout=*) ScriptOptGet "timeout" "$@"; ! IsInteger "$timeout" && usage;;
			-v|--verbose) verbose="--verbose";;
			*) ScriptOpt "$@";;
		esac
		shift
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	! needsHost && [[ $@ ]] && usage
	args=("$@")
}

needsHost() { [[ "${commands[0]}" != @(fix) ]]; }

#
# Fix Command
#

fixUsage()
{
	echot "\
Usage: power fix info|sleep|wake
Examine issues preventing computer sleep or wake"
}

fixCommand() { usage; }

fixSleepCommand()
{
	! IsElevated && { elevate RunScript --pause power fix sleep; return; }
	
	local numRequests="$(powercfg.exe /requests | grep -i "None" | wc -l)"
	if (( numRequests == 6 )); then
		echo "No devices are preventing the computer from sleeping"
		return 0
	fi

	echo "Requests preventing sleep..."
	PowerCfg.exe -REQUESTS
}

fixWakeCommand()
{
	echo "Devices which can wake the system:"
	PowerCfg.exe -DEVICEQUERY wake_armed

	echo "Device which last woke the system:"
	PowerCfg.exe -LastWake
}

fixInfoCommand()
{
echot "\
"'Wake:
- Disable wake: PowerCfg -DeviceDisableWake <devicename>
- Examples: 
PowerCfg.exe -DeviceDisableWake "HID Keyboard Device"
PowerCfg.exe -DeviceDisableWake "HID-compliant mouse (009)"

Sleep:
- View overrides:  powercfg -RequestsOverride
- Add override:    powercfg -RequestsOverride SERVICE "<device>" SYSTEM
- Remove override: powercfg -RequestsOverride SERVICE "<device>"
- Examples:
powercfg.exe -RequestsOverride DRIVER "Realtek High Definition Audio" SYSTEM
powercfg.exe -RequestsOverride DRIVER "Sound Blaster X-Fi Xtreme Audio" SYSTEM
powercfg.exe -RequestsOverride SERVICE "\Device\HarddiskVolume1\Windows\System32\svchost.exe (CryptSvc)" SYSTEM
- override in Device Manager, device Power tab'
}

#
# Power Opertation Commands
#

opUsage()
{
	echot "\
Usage: power $command HOST
Perform a power operation

	$hostArg

	-e, --exit 					return the specified exit code after the power command
	-f, --force 				force the power operation even if we believe the host is in the correct state
	-s, --ssh 					make an ssh connection after power operation
	-w, --wait=[120]		seconds for the host to change state
	-ws,--wait-ssh			wait for an ssh connection

	-ie, --ignore-errors	ignore errors non-fatal errors
	-q, --quiet 					minimize informational messages
	-t, --test 						test the operation without making any changes"
}

opArgStart()
{
	unset -v exit force ssh quiet test wait powerSshWait
	unset -v desc sshCommand
	expectedState="off" ignoreErrors=1 timeout=500
}

opOpt() 
{
	case "$1" in
		-e|--exit|-e=*|--exit=*) ScriptOptGet "exit" "$@";;
		-f|--force) force="true";;
		-ie|--ignore-errors) ignoreErrors="0";;
		-q|--quiet) quiet="--quiet";;
		-s|--ssh) ssh="true"; powerSshWait="true"; [[ ! $wait ]] && wait="$waitDefault";;
		   --test) test="--test";;
		-w|--wait|-w=*|--wait=*) IsInteger "$2" && ScriptOptGet "wait" "$@" || wait="$waitDefault";; 
		-ws|--wait-ssh) waitSsh="true"; [[ ! $wait ]] && wait="$waitDefault";;

		*) return 1
	esac
}

offUsage() { opUsage; }
offArgStart() { opArgStart; desc="Powering off"; sshCommand="shutdown now"; }
offOpt() { opOpt "$@"; }
offCommand() { power "off" "$@"; }

onUsage() { opUsage; }
onArgStart() { opArgStart; desc="Powering on"; expectedState="on"; }
onOpt() { opOpt "$@"; }
onCommand() { power "on" "$@"; }

firmwareUsage() { opUsage; }
firmwareArgStart() { opArgStart; desc="Entering firmware on"; }
firmwareOpt() { opOpt "$@"; }
firmwareCommand() { power "firmware" "$@"; }

hibernateUsage() { opUsage; }
hibernateArgStart() { opArgStart; desc="Hibernating"; }
hibernateOpt() { opOpt "$@"; }
hibernateCommand() { power "hibernate" "$@"; }

rebootUsage() { opUsage; }
rebootArgStart() { opArgStart; desc="Rebooting"; expectedState=""; sshCommand="shutdown -r now"; }
rebootOpt() { opOpt "$@"; }
rebootCommand() { power "reboot" "$@"; }

sleepUsage() { opUsage; }
sleepArgStart() { opArgStart; desc="Sleeping"; }
sleepOpt() { opOpt "$@"; }
sleepCommand() { power "sleep" "$@"; }

powerOffCleanup() { [[ $switch && $force ]] && switchPortOff "$switch" "$switchPort"; return 0; }
powerSshAvailable() { [[ $sshCommand ]] && SshHelper connect "$host" -- "ls /" >& /dev/null; }
powerSshWait() { printf "$hostDesc..."; powerWaitOn "${wait}" || return; }

power()
{
	local op="$1"; shift

	# local
	if [[ ! $@ ]]; then
		[[ $exit ]] && { powerExit "$op"; return; }
		powerLocal "$op"; return
	fi

	# remote
	local host
	for host in "$@"; do
		powerRemote "$host" "$op" || return
	done
}

# run the power command and ensure the exit code is returned to the callers
powerExit()
{
	local op="$1"

	# ensure sudo credentials are active
	sudoc -v 

	# perform the power operation in a delayed sub-shell so this shell can process the exit code
	# the sub-shell is disconnected so the power command still runs if this shell terminates
	{ nohup bash -c 'sleep 2; power $op' & } 

	exit $exit
}

powerLocal()
{
	local op="$1"

	case "$op" in
		on) return 0;;
		off|reboot) vmware IsInstalled && { vmware SuspendAll || return; }
	esac

	printf "$op..."
	[[ $test ]] && return

	# assumes policy is set so no password is required (for remote power operation)
	case "$op" in
		firmware)
			if IsPlatform win; then elevate shutdown.exe /r /fw /t 0; exit
			fi;;

		hibernate)
			if IsPlatform win; then start psshutdown -h -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif InPath systemctl; then systemctl hibernate; exit
			fi;;

		off)
			if IsPlatform win; then start psshutdown -s -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif IsPlatform qnap; then sudo poweroff; exit
			elif IsPlatform rock; then systemctl halt -i; exit
			elif IsPlatform synology; then /sbin/shutdown -P now; exit
			elif InPath systemctl; then systemctl poweroff; exit
			elif InPath shutdown; then shutdown -p now; exit
			fi;;

		reboot)
			if IsPlatform win; then start psshutdown -r -f -t 0; exit
			elif IsPlatform mac; then sudo /sbin/shutdown -r now; exit
			elif IsPlatform qnap; then sudo reboot; exit
			elif IsPlatform synology; then sudo /sbin/shutdown -r now; exit
			elif InPath systemctl; then systemctl reboot -i; exit
			elif InPath shutdown; then shutdown -r now; 
			fi;;

		sleep)
			if IsPlatform win; then start psshutdown -d -t 0; exit
			elif IsPlatform mac; then osascript -e 'tell application "System Events" to sleep'; exit
			elif IsPlatform qnap; then sudo qcli_admin --entersleep; exit
			elif InPath systemctl; then systemctl suspend; exit
			fi;;

	esac
}

powerRemote()
{
	local host="$1"; initHost "$host" || return
	local op="$2"

	# if a switch port was specified control it
	if [[ $switchPort ]]; then
		[[ "$op" != @(on|off) ]] && { EchoErr "Switch ports can only be turned on or off"; return 1; }
		RunFunction "switchPort" "$op" "$host" "$switchPort" || return; 
		echo "done"; return
	fi

	# determine host switch port to control it's power
	local switch switchPort; switchLookup "$host" || return
	local power; [[ $host && $switch && $switchPort ]] && power="true"

	# determine host power command
	if SshIsAvailable "$host"; then
		SshInPath "$host" "power" && { sshCommand="$BIN/power $op"; }
	else
		sshCommand=""
	fi

	# force a wait if needed (can turn the hosts switch port off after sending it a power off command)
	[[ $sshCommand && $switch && $op == @(off|hibernate) ]] && wait="$waitDefault"

	# determine the current status off the host
	local initialState="off"; IsAvailable "$host" "$timeout" && initialState="on"

	# description	
	if [[ ! $force && "$initialState" == "$expectedState" ]]; then
		[[ "$op" == "on" && $waitSsh ]] && ! powerSshAvailable && { powerSshWait; return; }
		[[ ! $quiet ]] && echo "$hostDesc is already $expectedState"
		return 0
	fi

	printf "$desc $hostDesc..."
	RunFunction "power" "$op" || return
	echo "done"

	[[ $ssh ]] && { SshHelper connect -x "$host" || return; }

	return 0
}

powersleep() { powerOp "sleep" && powerWaitOff "$wait"; }
powerFirmware() { powerOp "firmware" && powerWaitOff "$wait"; }
powerHibernate() { doOff; }

powerOp()
{
	local op="$1"

	# generic power operations require an sshCommand
	if [[ ! $sshCommand ]]; then
		[[ ! $quiet ]] && ScriptErr "$op operation is not available on $host"
		return "$ignoreErrors"
	fi

	doSsh "$host" -- "$sshCommand"
}

powerOff()
{
	if [[ $sshCommand && "$initialState" == "on" ]]; then
		doSsh "$host" -- "$sshCommand" > /dev/null || { powerOffCleanup; return 1; }
		powerWaitOff "$wait" || return
	fi

	if [[ $switch ]]; then
		[[ $sshCommand && "$initialState" == "on" ]] && { sleep 1 || return; }
		switchPortOff "$switch" "$switchPort" || return
	fi

	return 0
}

powerOn() 
{ 
	if [[ ! $force && "$initialState" == "on" ]]; then
		[[ ! $quiet ]] && echo "$hostDesc is already on"
		return 0
	fi
	
	# power on associated switch port if specified
	if [[ $power ]]; then
		switchPortOn $switch $switchPort || return
		[[ ! $sshCommand ]] && return

	# turn on host using Wake-on-LAN.  A MAC address must be specified in /etc/ethers
	elif grep "${host}$" "/etc/ethers" >& /dev/null; then
		local broadcastAddress="$(GetBroadcastAddress)"; [[ $broadcastAddress ]] && broadcastAddress="-i $broadcastAddress"
		printf "wol..."
		[[ ! $test ]] && wakeonlan $broadcastAddress "${host,,}" > /dev/null # host must be lower case to be found
	fi

	# wait for the host to power up
	powerWaitOn "$wait" || return
} 

powerReboot()
{
	if [[ "$initialState" == "off" ]]; then
		[[ $switch ]] && { switchPortOff "$switch" "$switchPort" || return; } # make sure the switch port if off
		powerOn; return
	fi
	
	doSsh "$host" -- "$sshCommand" >& /dev/null || return
	powerWaitOff "${wait:-$waitDefault}" || return
	powerWaitOn "${wait}" || return
}

# powerWaitOff SECONDS - wait for host to disconnect from the network
powerWaitOff()
{
	local seconds="$1"

	( [[ ! $seconds ]] || ! IsAvailable "$host" "$timeout") && return 0

	printf "waiting..."

	for (( i=1; i<=$seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if ! IsAvailable "$host" "$timeout"; then
			printf "disconnected..."
			return 0			
		fi

		[[ $test && "$i" == "4" ]] && return 0
		printf "."
	done

	printf "still connected..."
	return 1
}

# powerWaitOn SECONDS - wait for host to become available
powerWaitOn()
{
	local found seconds="$1"

	( [[ ! $seconds ]] || IsAvailable "$host" "$timeout") && return 0

	printf "waiting..."

	for (( i=1; i<=$seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if [[ $found ]]; then
			powerSshAvailable && { printf "ssh..."; return 0; }

		elif IsAvailable "$host" "$timeout"; then
			found="true"; printf "found..."
			[[ ! $waitSsh ]] && return 0
		fi

		[[ $test && "$i" == "4" ]] && return 0
		printf "."
	done

	echo "not found"
	return 1
}

#
# Status Command
#

statusUsage()
{
	echot "\
Usage: power status [watts] HOST
Report the status of the host or PoE switch (on or off).  
If port is all then the status of all switch ports is displayed.

	$hostArg

	-t, --timeout=[500]		milliseconds to wait for a response from the host
	-v, --verbose 				show verbose status information"
}

statusArgEnd() { [[ ! $1 ]] && MissingOperand "host"; return 0; }

statusCommand()
{
	local host command="doStatus"; [[ $verbose ]] && command="doStatusVerbose"
	for host in "$@"; do "$command" "$host" || return; done; 
}

statusWattsCommand()
{
	local host="$1"; initHost "$host" || return

	if [[ $switchPort ]]; then
		switchWatts "$host" "$switchPort"
	else
		local switch switchPort; switchLookup "$host" || return
		[[ $switch && $switchPort ]] && switchWatts "$switch" "$switchPort"
	fi
}

doStatus()
{
	local host="$1"; initHost "$host" || return
	local result

	if [[ $switchPort ]]; then
		if [[ "$switchPort" == "all" ]]; then
			SshHelper connect "admin@$host" -- swctrl poe show; return
		else
			switchPortStatus "$host" "$switchPort"; result=$?
		fi
	else
		IsAvailable "$host" "$timeout"; result=$?
	fi	
	
	[[ "$result" == "0" ]] && echo "on" || echo "off"
}

doStatusVerbose()
{
	local host="$1"; initHost "$host" || return
	local status="$(doStatus "$host")"

	if [[ $switchPort ]]; then
		echo "$hostDesc port $switchPort is $status ($(switchWatts "$host" "$switchPort")w)"
	else
		local switch switchPort; switchLookup "$host" || return

		local power
		[[ $switch && $switchPort ]] && power="$(switchWatts "$switch" "$switchPort")w"
		[[ $power ]] && power=" ($power)"

		echo "$hostDesc is $status$power"
	fi
}

#
# Switch Helper - assume UniFi Ubiquiti PoE switch
#

# switchLookup HOST - set the switch and port that the specified host is connected to
switchLookup()
{
	local hostShort="$(RemoveDnsSuffix "$1")"
	local line=( $(grep -i "^$hostShort[ 	]" "$DATA/setup/ports") )
	switch="${line[1]}" switchPort="${line[2]}"
}

# switchPortOn switch port - turn the power of a PoE port on
switchPortOn()
{
	local switch="$1" switchPort="$2"
	printf "port $switchPort..."
	switchPortStatus $switch $switchPort && { [[ ! $quiet ]] && printf "already on..."; return; }
	doSsh "admin@$switch" -- swctrl poe set auto id $switchPort || return
	printf "on..."
}

# switchPortOff switch port - turn the power of a PoE port off
switchPortOff()
{
	local switch="$1" switchPort="$2"
	printf "port..."
	! switchPortStatus $switch $switchPort && { [[ ! $quiet ]] && printf "already off..."; return; }
	doSsh "admin@$switch" -- swctrl poe set off id $switchPort || return
	printf "off..."
}

# switchPortStatus switch port - get the power status of a PoE port
switchPortStatus()
{ 
	local switch="$1" switchPort="$2"
	SshHelper connect "admin@$switch" -- swctrl poe show id "$switchPort" |& cut -c7-13 | grep "Auto" >& /dev/null
}

# switchWatts SWITCH PORT - get the watts used by the specified switch and port
switchWatts() { SshHelper connect "admin@$1" -- swctrl poe show id $2 |& tail -1 | cut -c65-73 | tr -d "[:space:]"; }

#
# Helper
#

initHost()
{
	# parse host - HOST:PORT
	switchPort="$(GetWord "$host" 2 :)"
	host="$(GetWord "$host" 1 :)"
	hostOrig="${host,,}"
	
	# host aliases
	case "$hostOrig" in
		oversoul) host="oversoulw2";; # WOL only works on wired adapter
		b) host="BackShedSwitch";;
		c) host="StudyClosetSwitch";;
		d) host="StudyDeskSwitch";;
		g) host="GarageSwitch";;
	esac

	# validate host
	! GetIpAddress "$host" >& /dev/null && { HostUnknown "$host"; return 1; }
	hostDesc="$(os name "$host" | RemoveDnsSuffix)"
}

doSsh()
{ 
	[[ $verbose ]] && echo -n $'\n'"SshHelper $@"$'\n'
	[[ $test ]] && return
	SshHelper connect "$@"
}

run "$@"

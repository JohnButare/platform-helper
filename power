#!/usr/bin/env bash
. /usr/local/data/bin/function.sh

run() {	args "$@" || return; init || return; ${command}Command "${args[@]}"; }

init()
{
	# switch variables
	local b="BackShedSwitch" c="StudyClosetSwitch" d="StudyDeskSwitch" g="GarageSwitch"
	
	# host aliases
	case "$host" in
		oversoul) host="oversoulw2";; # WOL only works on WiFi adapter
		b) host="$b";; # Back shed switch
		c) host="$c";; # study Closet switch, i.e. on c 4 to turn on study closet switch port 4
		d) host="$d";; # study Desk switch
		g) host="$g";; # Garage switch
	esac

	hostName="$host"
}
 
usage()
{
	echot "\
usage: power on|off|reboot|sleep|firmware|hibernate [host]:[port|all]
	Control host or PoE switch port power state.

	firmware									reboot to the UEFI firmware settings
	status host:[port|all]		report the status of the host or PoE switch (on or off)
															If port is all then the status of all switch ports is displayed
															Return 0 if the host (or host PoE port) is on, and 1 if off
	fix info|sleep|wake				examine issues preventing computer sleep or wake

  -e, --exit 								return the specified exit code after the power command
  -f, --force 							force the power operation even if we believe the host is in the correct state
  -s, --ssh 								make an ssh connection
	-t, --timeout [500]				milliseconds to wait for a response from the host.
  -v, --verbose 						show verbose information where possible
	-w, --wait [120]					seconds for the host to change state
			--wait-ssh						wait for an ssh connection"
	exit $1
}

args()
{
	unset exit force host op port ssh switch user verbose waitSeconds waitSsh
	timeoutMilliseconds=500 waitDefault=120 poeSwitchDefault="StudyDeskSwitch"

	while [ "$1" != "" ]; do
		case "$1" in
			--exit|-e) exit="$2"; shift;;
			--force|-f) force="true";;
			--help|-h) IsFunction "${command}Usage" && ${command}Usage || usage 0;;
			--ssh|-s) ssh="true"; waitSsh="true"; [[ ! $waitSeconds ]] && waitSeconds="$waitDefault";;
			--timeout|-t) ! IsInteger $2 && usage; timeoutMilliseconds="$2"; shift;;
			--verbose|-v) verbose="true";;
			--wait|-w) IsInteger $2 && { waitSeconds="$2"; shift; } || waitSeconds="$waitDefault";;
			--wait-ssh) waitSsh="true"; [[ ! $waitSeconds ]] && waitSeconds="$waitDefault";;
			*) 				
				[[ ! $command && "$1" == @(on|off|reboot|sleep|firmware|hibernate) ]] && { command="power"; op="$1"; shift; continue; }
				[[ ! $command ]] && IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				[[ ! $host && "$command" == @(power|status) ]] && ! IsOption "$1" && { host="${1,,}"; shift; continue; }
				[[ "$command" == @(fix) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	port="$(GetWord "$host" 2 :)"
	host="$(GetWord "$host" 1 :)"
	sshHost="$host"
	host="$(GetSshHost "$host")"

	[[ ! $command ]] && MissingOperand "command"

	args=("$@")
}

#
# commands 
#

statusCommand()
{
	local result status="on"

	[[ ! $host ]] && MissingOperand "host"

	if [[ $port ]]; then
		if [[ "$port" == "all" ]]; then
			SshHelper admin@$host swctrl poe show; return
		else
			switchPortStatus $host $port
		fi
	else
		IsAvailable $host $timeoutMilliseconds
	fi	
	result=$?

	[[ "$result" != 0 ]] && status="off"

	[[ ! $verbose ]] && { echo "$status"; return $result; }

	if [[ $port ]]; then
		echo "$hostName port $port is $status ($(switchWatts "$host" "$port")w)"
	else
		local switch port watts; getSwitchPort "$host" || return
		[[ $switch && $port ]] && watts=" ($(switchWatts "$switch" "$port")w)"
		echo "$hostName is $status$watts"
	fi
	
	return $result
}

#
# Fix Commands
#

fixCommand()
{
	! IsPlatform win && return

	local command; CheckSubCommand fix "$1"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	Fix${command}Command "$@"
}

FixSleepCommand()
{
	! IsElevated && { elevate RunScript --pause power fix sleep; return; }
	
	local numRequests="$(powercfg.exe /requests | grep -i "None" | wc -l)"
	if (( numRequests == 6 )); then
		echo "No devices are preventing the computer from sleeping"
		return 0
	fi

	echo "Requests preventing sleep..."
	PowerCfg.exe -REQUESTS
}

FixWakeCommand()
{
	echo "Devices which can wake the system:"
	PowerCfg.exe -DEVICEQUERY wake_armed

	echo "Device which last woke the system:"
	PowerCfg.exe -LastWake
}

FixInfoCommand()
{
echot "\
"'Wake:
- Disable wake: PowerCfg -DeviceDisableWake <devicename>
- Examples: 
PowerCfg.exe -DeviceDisableWake "HID Keyboard Device"
PowerCfg.exe -DeviceDisableWake "HID-compliant mouse (009)"

Sleep:
- View overrides:  powercfg -RequestsOverride
- Add override:    powercfg -RequestsOverride SERVICE "<device>" SYSTEM
- Remove override: powercfg -RequestsOverride SERVICE "<device>"
- Examples:
powercfg.exe -RequestsOverride DRIVER "Realtek High Definition Audio" SYSTEM
powercfg.exe -RequestsOverride DRIVER "Sound Blaster X-Fi Xtreme Audio" SYSTEM
powercfg.exe -RequestsOverride SERVICE "\Device\HarddiskVolume1\Windows\System32\svchost.exe (CryptSvc)" SYSTEM
- override in Device Manager, device Power tab'
}

#
# Power Command
#

powerCommand()
{
	if ! IsLocalHost "$host"; then doRemotePower
	elif [[ $exit ]]; then doExitPower
	else doLocalPower "$op"
	fi
}

# run the power command and ensure the exit code is returned to the callers
doExitPower()
{
	# ensure sudo credentials are active
	sudoc -v 

	# perform the power operation in a delayed sub-shell so this shell can process the exit code
	# the sub-shell is disconnected so the power command still runs if this shell terminates
	{ nohup bash -c 'sleep 2; power $op' & } 

	exit $exit
}


doRemotePower()
{
	local opf="$(ProperCase "$op")" # op for function

	# control switch port only
	if [[ $port ]]; then
		[[ "$op" != @(on|off) ]] && { EchoErr "Switch ports can only be turned on or off"; return 1; }
		switchPort$opf "$host" "$port" || return; 
		echo "done"; return
	fi

	# get switch port information
	local switch port; getSwitchPort "$host" || return
	local power; [[ $host && $switch && $port ]] && power="true"

	# ssh command to use to control host power
	local basicSshCommand sshCommand="$BIN/power $op"
	case "$op" in
		off) basicSshCommand="shutdown now";;
		reboot) basicSshCommand="shutdown -r now";;
	esac
	
	# host specific power commands
	case "$(RemoveDnsSuffix "$host")" in
		AirthingsBridge|*Camera|GarageWaterHeater|HueBridge|TvTuner) sshCommand="";;
		*Ap|*Switch|UnifiController|VeraBridge) sshCommand="$basicSshCommand";;
	esac

	# force a wait if we need to change the power state of the switch port after the host turns off
	[[ $switch && $op == @(off|hibernate) ]] && waitSeconds="$waitDefault"

	# determine the current status off the host
	local initialState="off"; IsAvailable $host $timeoutMilliseconds && initialState="on"

	# description
	local desc expectedState="off"
	case "$op" in
		firmware) desc="Entering firmware on";;
		hibernate) desc="Hibernating";;
		off) desc="Powering off";;
		on) desc="Powering on"; expectedState="on";;
		reboot) desc="Rebooting"; expectedState="";;
		sleep) desc="Sleeping";;
	esac

	if [[ ! $force && "$initialState" == "$expectedState" ]]; then
		[[ "$op" == "on" && $waitSsh ]] && ! checkSsh && { doWaitSsh; return; }
		echo "$host is already $expectedState"
		return 0
	fi

	[[ ! $sshCommand && ! ( "$op" == "off" && $port ) ]] && { EchoErr "\n$host does not support the $op power operation"; return 1; }

	printf "$desc $hostName..."

	# perform operation
	if [[ "$op" == @(firmware|sleep) ]]; then
		SshHelper $sshHost "$sshCommand" || return
		waitOff "$waitSeconds" || return
	else
		do$opf || return
	fi
	
	echo "done"

	[[ $ssh ]] && { SshHelper -x "$sshHost" || return; }
	return 0
}

doWaitSsh() { printf "$hostName..."; waitOn "${waitSeconds}" || return; echo "done"; }

doOn() 
{ 
	[[ ! $force && "$initialState" == "on" ]] && { echo "$hostName is already on"; return 0; }
	
	# power on associated switch port if specified
	if [[ $power ]]; then
		switchPortOn $switch $port || return
		[[ ! $sshCommand ]] && { echo "done"; return; }
	fi

	# Turn on host using Wake-on-LAN.  A MAC address must be specified in /etc/ethers
	if grep "${host}$" "/etc/ethers" >& /dev/null; then
		local broadcastAddress="$(GetBroadcastAddress)"; [[ $broadcastAddress ]] && broadcastAddress="-i $broadcastAddress"
		printf "wol..."
		wakeonlan $broadcastAddress "${host,,}" > /dev/null # host must be lower case to be found
	fi

	# wait for the host to power up
	waitOn "$waitSeconds" || return

	return 0
} 

doHibernate() { doOff; }

doOff()
{
	if [[ $sshCommand && "$initialState" == "on" ]]; then
		SshHelper $sshHost "$sshCommand" > /dev/null || { offCleanup; return 1; }
		waitOff "$waitSeconds" || return
	fi

	if [[ $switch ]]; then
		[[ $sshCommand && "$initialState" == "on" ]] && { sleep 1 || return; }
		switchPortOff "$switch" "$port" || return
	fi

	return 0
}

offCleanup() { [[ $switch && $force ]] && switchPortOff "$switch" "$port"; return 0; }

doReboot()
{
	if [[ "$initialState" == "off" ]]; then
		[[ $switch ]] && { switchPortOff "$switch" "$port" || return; } # make sure the switch port if off
		doOn; return
	fi
	
	SshHelper $sshHost "$sshCommand" >& /dev/null || return
	waitOff "${waitSeconds:-$waitDefault}" || return
	waitOn "${waitSeconds}" || return
}

doLocalPower() # op
{
	local op="$1"

	case "$op" in
		on) return 0;;
		off|reboot) vmware IsInstalled && { vmware SuspendAll || return; }
	esac

	printf "$op..."

	# assumes policy is set so no password is required (for remote power operation)
	case "$op" in
		firmware)
			if IsPlatform win; then elevate shutdown.exe /r /fw /t 0; exit
			fi;;

		hibernate)
			if IsPlatform win; then start psshutdown -h -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif InPath systemctl; then systemctl hibernate; exit
			fi;;

		off)
			if IsPlatform win; then start psshutdown -s -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif IsPlatform qnap; then sudo poweroff; exit
			elif IsPlatform rock; then systemctl halt -i; exit
			elif IsPlatform synology; then /sbin/shutdown -P now; exit
			elif InPath systemctl; then systemctl poweroff; exit
			elif InPath shutdown; then shutdown -p now; exit
			fi;;

		reboot)
			if IsPlatform win; then start psshutdown -r -f -t 0; exit
			elif IsPlatform mac; then sudo /sbin/shutdown -r now; exit
			elif IsPlatform qnap; then sudo reboot; exit
			elif IsPlatform synology; then sudo /sbin/shutdown -r now; exit
			elif InPath systemctl; then systemctl reboot -i; exit
			elif InPath shutdown; then shutdown -r now; 
			fi;;

		sleep)
			if IsPlatform win; then start psshutdown -d -t 0; exit
			elif IsPlatform mac; then osascript -e 'tell application "System Events" to sleep'; exit
			elif IsPlatform qnap; then sudo qcli_admin --entersleep; exit
			elif InPath systemctl; then systemctl suspend; exit
			fi;;

	esac

	EchoErr "$op is not supported"
	return 1
}

# waitOn SECONDS - wait for host to become available
waitOn()
{
	local found s="$1"

	( [[ ! $s ]] || IsAvailable $host $timeoutMilliseconds) && return 0

	printf "waiting..."

	for (( i=1; i<=$s; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if [[ $found ]]; then
			checkSsh && { printf "ssh..."; return 0; }

		elif IsAvailable "$host" "$timeoutMilliseconds"; then
			found="true"; printf "found..."
			[[ ! $waitSsh ]] && return 0
		fi

		printf "."
	done

	printf "not found"
	return 1
}

checkSsh() { SshHelper "$sshHost" "ls /" >& /dev/null; }

# waitOff SECONDS - wait for host to disconnect from the network
waitOff()
{
	local s="$1"

	( [[ ! $s ]] || ! IsAvailable "$host" "$timeoutMilliseconds") && return 0

	printf "waiting..."

	for (( i=1; i<=$s; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if ! IsAvailable "$host" "$timeoutMilliseconds"; then
			printf "disconnected..."
			return 0			
		fi

		printf "."
	done

	printf "still connected..."
	return 1
}

#
# Helper Functions
#

# getSwitchPort HOST - set the switch and port that the specified host is connected to
getSwitchPort()
{
	local hostShort="$(RemoveDnsSuffix "$1")"
	local line=( $(grep -i "^$hostShort[ 	]" "$DATA/setup/ports") )
	switch="${line[1]}" port="${line[2]}"
}

#
# Switch Helper Functions - assumes UniFi Ubiquiti PoE switch
#

# switchWatts SWITCH PORT - get the watts used by the specified switch and port
switchWatts() { SshHelper admin@$1 swctrl poe show id $2 |& tail -1 | cut -c65-73 | tr -d "[:space:]"; }

# switchPortStatus switch port - get the power status of a PoE port
switchPortStatus()
{ 
	local switch="$1" port="$2"
	SshHelper admin@$1 swctrl poe show id $2 |& cut -c7-13 | grep "Auto" >& /dev/null
}

# switchPortOn switch port - turn the power of a PoE port on
switchPortOn()
{
	local switch="$1" port="$2"
	printf "port..."
	switchPortStatus $switch $port && { printf "already on..."; return; }
	SshHelper admin@$switch swctrl poe set auto id $port || return
	printf "on..."
}

# switchPortOff switch port - turn the power of a PoE port off
switchPortOff()
{
	local switch="$1" port="$2"
	printf "port..."
	! switchPortStatus $switch $port && { printf "already off..."; return; }
	SshHelper admin@$switch swctrl poe set off id $port || return
	printf "off..."
}

run "$@"

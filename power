#!/usr/bin/env bash
. /usr/local/data/bin/function.sh

run() {	args "$@" || return; init || return; ${command}Command "${args[@]}"; }
 
usage()
{
	echot "\
usage: power on|off|reboot|sleep|firmware|hibernate|status [host] [port]
	Control host or PoE switch port power state.  
	Use fully qualified domain name for host name to avoid local name resolution delay.
	Turn turn a host on it must have an entry in /etc/ethers to get the MAC address.

	firmware							reboot to the UEFI firmware settings
	status [port]					report the status of the host or PoE switch (on or off)
												if port is all then the status of all switch ports is displayed
	fix info|sleep|wake		examine issues preventing computer sleep or wake

  -f, --force 					force the wakeup command to be sent
  -s, --ssh 						make an ssh connection
	-t, --timeout [500]		milliseconds to wait for a response from the host
												shorter times are more responsive but may result in
											 	false off state detection
	-w, --wait [120]			seconds for the host to change state
			--wait-ssh				wait for an ssh connection"
	exit $1
}

args()
{
	unset force host poeSwitchDefault port ssh switch timeoutMilliseconds waitDefault waitSeconds waitSsh

	timeoutMilliseconds=500
	waitDefault=120
	poeSwitchDefault="StudyDeskSwitch"

	while [ "$1" != "" ]; do
		case "$1" in
			--force|-f) force="true";;
			--help|-h) IsFunction "${command}Usage" && ${command}Usage || usage 0;;
			--ssh|-s) ssh="true"; waitSsh="true"; [[ ! $waitSeconds ]] && waitSeconds="$waitDefault"; shift;;
			--timeout|-t) ! IsInteger $2 && usage; timeoutMilliseconds="$2"; shift;;
			--wait|-w) IsInteger $2 && { waitSeconds="$2"; shift; } || waitSeconds="$waitDefault";;
			--wait-ssh) waitSsh="true"; [[ ! $waitSeconds ]] && waitSeconds="$waitDefault";;
			*)
				[[ ! $command ]] && IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				[[ ! $port ]] && { IsInteger "$1" || [[ "$1" == "all" ]]; } && { port="$1"; shift; continue; }
				! IsOption "$1" && [[ ! $host && "$command" == @(on|off|sleep|reboot|status|firmware) ]] && { host="${1,,}"; shift; continue; }	

				[[ "$command" == @(fix) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	# ensure command was specified
	[[ ! $command ]] && MissingOperand "command"

	# set default host for a PoE switch port
	[[ $port && ! $host ]] && host="$poeSwitchDefault"

	args=("$@")
}

init()
{
	local b="BackShedSwitch" c="StudyClosetSwitch" d="StudyDeskSwitch" g="GarageSwitch"
	
	# map host aliases
	case "$host" in
		oversoul) host="oversoulw2";; # WOL only works on WiFi adapter
		b) host="$b";; # back shed switch
		c) host="$c";; # study closet switch, i.e. on c 4 to turn on study closet switch port 4
		d) host="$d";; # study desk switch
		g) host="$g";; # garage switch
	esac

	[[ $command == @(fix|status) ]] && return 0

	# set our power (the local hsot) 
	IsLocalHost "$host" && { setLocalPower; return; }

	# determine power command to use remotely
	sshCommand="$BIN/power $command"
	case "$command" in
		off) basicSshCommand="shutdown now";;
		reboot) basicSshCommand="shutdown -r now";;
	esac
	
	# map hosts to a switch PoE port so we can power it up or down
	if ! IsLocalHost "$host"; then
		case "$host" in
			pi5) switch="$c" port=23;;
			rp1) switch="$c" port=28;;
			pi6|pi6.local) switch="$c" port=29;;
			pi7) switch="$d" port=5;;
			PoeSplitter) switch="$d" port=6 sshCommand="";;
			TvTuner) switch="$g" port=5 sshCommand="";;
			UnifiController) switch="$c" port=27 sshCommand="$basicSshCommand";;
		esac
	fi

	hostName="$host"

	# control PoE switch port only
	if [[ $port && ! $switch ]]; then
		case "$command" in
			on) switchPortOn "$host" "$port"; exit;;
			off) switchPortOff "$host" "$port"; exit;;
			*) EchoErr "Switch ports can only be turned on or off"; return 1;;
		esac
	fi

	# force a wait if we need to change the power state of the switch port after the host turns off
	[[ $switch && $command == @(off|hibernate) ]] && waitSeconds="$waitDefault"

	# determine the current status off the host
	if [[ $sshCommand ]]; then
		IsLocalAddress "$host" && host="$(MdnsResolve "$host" 2> /dev/null)" # multiple calls to MdnsResolve in Windows fail so cache the IP address
		initialHostStatus="off"
		IsAvailable $host $timeoutMilliseconds && initialHostStatus="on"
	fi

	return 0
}

#
# power for local host
# 

setLocalPower()
{
	[[ "$command" == "on" ]] && return 0

	[[ "$command" == @(off|reboot) ]] && { cleanupHost || return; }

	echo "Issuing $command..."
	logger "issuing power $command..."

	# assumes policy is set so no password is required for remote power command 
	case "$command" in
		firmware)
			if IsPlatform win; then elevate shutdown.exe /r /fw /t 0; exit
			fi;;

		hibernate)
			if IsPlatform win; then start psshutdown -h -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif InPath systemctl; then systemctl hibernate; exit
			fi;;

		off)
			if IsPlatform win; then start psshutdown -s -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif IsPlatform qnap; then sudo poweroff; exit
			elif IsPlatform rock; then systemctl halt -i; exit
			elif IsPlatform synology; then /sbin/shutdown -P now; exit
			elif InPath systemctl; then systemctl poweroff; exit
			elif InPath shutdown; then shutdown -p now; exit
			fi;;

		reboot)
			if IsPlatform win; then start psshutdown -r -f -t 0; exit
			elif IsPlatform mac; then sudo /sbin/shutdown -r now; exit
			elif IsPlatform qnap; then sudo reboot; exit
			elif IsPlatform synology; then sudo /sbin/shutdown -r now; exit
			elif InPath systemctl; then systemctl reboot -i; exit
			elif InPath shutdown; then shutdown -r now; 
			fi;;

		sleep)
			if IsPlatform win; then start psshutdown -d -t 0; exit
			elif IsPlatform mac; then osascript -e 'tell application "System Events" to sleep'; exit
			elif IsPlatform qnap; then sudo qcli_admin --entersleep; exit
			elif InPath systemctl; then systemctl suspend; exit
			fi;;

	esac

	EchoErr "$command is not supported"
	return 1
}

# run required cleanup before host goes down
cleanupHost()
{
	! vmware IsInstalled && return;

	echo "Running shutdown scripts..."
	vmware SuspendAll || return
}

#
# switch port - assumes UniFi Ubiquiti PoE switch
#

# switchPortStatus switch port - get the power status of a PoE port
switchPortStatus()
{ 
	local switch="$1" port="$2"
	SshHelper admin@$switch swctrl poe show id $port |& grep Auto >& /dev/null
}

# switchPortOn switch port - turn the power of a PoE port on
switchPortOn()
{
	local switch="$1" port="$2"

	switchPortStatus $switch $port && { echo "$switch port $port is already on"; return; }

	echo "Turning $switch port $port on..."
	SshHelper admin@$switch swctrl poe set auto id $port
}

# switchPortOff switch port - turn the power of a PoE port off
switchPortOff()
{
	local switch="$1" port="$2"

	! switchPortStatus $switch $port && { echo "$switch port $port is already off"; return; }

	echo "Turning $switch port $port off..."
	SshHelper admin@$switch swctrl poe set off id $port
}

#
# power for remote host
#

# waitOn host - wait waitSeconds for host to become available
waitOn()
{
	local found

	( [[ ! $waitSeconds ]] || IsAvailable $host $timeoutMilliseconds) && return 0

	printf "Waiting $waitSeconds seconds for $hostName to be available..."

	for (( i=1; i<=$waitSeconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }

		if [[ $found ]]; then
			if SshHelper "$host" "ls /" >& /dev/null; then
				echo "ssh connected in $i seconds"				
				return 0
			fi

		elif IsAvailable "$host" "$timeoutMilliseconds"; then
			printf "found in $i seconds"
			[[ ! $waitSsh ]] && { echo; return 0; }
			found="true"
		fi

		printf "."
	done

	echo "not found"
	return 1
}

# waitOff host - wait waitSeconds for host to disconnect from the network
waitOff()
{
	( [[ ! $waitSeconds ]] || ! IsAvailable "$host" "$timeoutMilliseconds") && return 0

	printf "Waiting $waitSeconds seconds for $hostName to disconnect..."

	for (( i=1; i<=$waitSeconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }

		if ! IsAvailable "$host" "$timeoutMilliseconds"; then
			echo "disconnected in $i seconds"
			return 0			
		fi

		printf "."
	done

	echo "still connected"
	return 1
}

#
# commands
#

# statusCommand - return 0 if the host (or host PoE port) is on, and 1 if off
statusCommand()
{
	local result status="on"

	if [[ $port ]]; then
		if [[ "$port" == "all" ]]; then
			SshHelper admin@$host swctrl poe show | egrep -v Bad; return
		else
			switchPortStatus $host $port
		fi
	else
		IsAvailable $host $timeoutMilliseconds
	fi	
	result=$?

	[[ "$result" != 0 ]] && status="off"

	if [[ $port ]]; then
		echo "$hostName port $port is $status"
	else
		echo "$hostName is $status" 
	fi
	
	return $result
}

onCommand() 
{ 
	[[ ! $force && "$initialHostStatus" == "on" ]] && { echo "$hostName is already on"; return 0; }

	# power on associated switch port if specified
	if [[ $host && $switch && $port ]]; then
		switchPortOn $switch $port || return
		[[ ! $sshCommand ]] && return
	fi

	# Turn on host using Wake-on-LAN.  A MAC address must be specified in /etc/ethers
	local broadcastAddress="$(GetBroadcastAddress)"; [[ $broadcastAddress ]] && broadcastAddress="-i $broadcastAddress"
	echo "Turning $hostName on..."
	wakeonlan $broadcastAddress "${host,,}" # host must be lower case to be found

	# wait for the host to power up
	waitOn || return

	[[ $ssh ]] && { SshHelper -x "$host"; return; }

	return 0
} 

offCommand()
{
	local desc="Powering off"; [[ "$command" == "hibernate" ]] && desc="Hibernating"

	if [[ $sshCommand && "$initialHostStatus" == "on" ]]; then
		echo "$desc $hostName..."
		SshHelper $host "$sshCommand" || return
		waitOff || return
	fi

	if [[ $switch ]]; then
		[[ $sshCommand && "$initialHostStatus" == "on" ]] && { SleepStatus 1 || return; }
		switchPortOff "$switch" "$port" || return
	fi

	return 0
}

hibernateCommand() { offCommand; }

rebootCommand()
{
	if [[ "$initialHostStatus" == "off" ]]; then
		[[ $switch ]] && { switchPortOff "$switch" "$port" || return; }
		onCommand; return
	fi
	
	echo "Rebooting $hostName..."
	SshHelper $host "$BIN/power $command" || return
	waitOff || return
	waitOn || return
}

sleepCommand()
{
	[[ "$initialHostStatus" == "off" ]] && return 0;

	echo "Sleeping $hostName..."
	SshHelper $host "$BIN/power $command" || return
	waitOff || return
}

firmwareCommand()
{
	[[ "$initialHostStatus" == "off" ]] && return 0;

	echo "Entering firmware on $hostName..."
	SshHelper $host "$BIN/power $command" || return
	waitOff || return
}

#
# Fix Commands
#

fixCommand()
{
	! IsPlatform win && return

	local command; CheckSubCommand fix "$1"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	Fix${command}Command "$@"
}

FixSleepCommand()
{
	! IsElevated && { elevate RunScript --pause power fix sleep; return; }
	
	local numRequests="$(powercfg.exe /requests | egrep -i None | wc -l)"
	if (( numRequests == 6 )); then
		echo "No devices are preventing the computer from sleeping"
		return 0
	fi

	echo "Requests preventing sleep..."
	PowerCfg.exe -REQUESTS
}

FixWakeCommand()
{
	echo "Devices which can wake the system:"
	PowerCfg.exe -DEVICEQUERY wake_armed

	echo "Device which last woke the system:"
	PowerCfg.exe -LastWake
}

FixInfoCommand()
{
echot "\
"'Wake:
- Disable wake: PowerCfg -DeviceDisableWake <devicename>
- Examples: 
PowerCfg.exe -DeviceDisableWake "HID Keyboard Device"
PowerCfg.exe -DeviceDisableWake "HID-compliant mouse (009)"

Sleep:
- View overrides:  powercfg -RequestsOverride
- Add override:    powercfg -RequestsOverride SERVICE "<device>" SYSTEM
- Remove override: powercfg -RequestsOverride SERVICE "<device>"
- Examples:
powercfg.exe -RequestsOverride DRIVER "Realtek High Definition Audio" SYSTEM
powercfg.exe -RequestsOverride DRIVER "Sound Blaster X-Fi Xtreme Audio" SYSTEM
powercfg.exe -RequestsOverride SERVICE "\Device\HarddiskVolume1\Windows\System32\svchost.exe (CryptSvc)" SYSTEM
- override in Device Manager, device Power tab'
}

run "$@"

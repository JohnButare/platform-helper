#!/usr/bin/env bash
. /usr/local/data/bin/function.sh

run() {	args "$@" || return; init || return; ${command}Command "${args[@]}"; }

init()
{
	# switch variables
	local b="BackShedSwitch" c="StudyClosetSwitch" d="StudyDeskSwitch" g="GarageSwitch"
	
	# host aliases
	case "$host" in
		oversoul) host="oversoulw2";; # WOL only works on WiFi adapter
		b) host="$b";; # Back shed switch
		c) host="$c";; # study Closet switch, i.e. on c 4 to turn on study closet switch port 4
		d) host="$d";; # study Desk switch
		g) host="$g";; # Garage switch
	esac

	hostName="$host"
}
 
usage()
{
	echot "\
usage: power on|off|reboot|sleep|firmware|hibernate [host] [port]
	Control host or PoE switch port power state.

	firmware									reboot to the UEFI firmware settings
	status host [port|all]		report the status of the host or PoE switch (on or off)
															If port is all then the status of all switch ports is displayed
															Return 0 if the host (or host PoE port) is on, and 1 if off
	fix info|sleep|wake				examine issues preventing computer sleep or wake

  -f, --force 							force the wakeup command to be sent
  -s, --ssh 								make an ssh connection
	-t, --timeout [500]				milliseconds to wait for a response from the host.
	-w, --wait [120]					seconds for the host to change state
			--wait-ssh						wait for an ssh connection"
	exit $1
}

args()
{
	unset force host op port ssh switch waitSeconds waitSsh
	timeoutMilliseconds=500 waitDefault=120 poeSwitchDefault="StudyDeskSwitch"

	while [ "$1" != "" ]; do
		case "$1" in
			--force|-f) force="true";;
			--help|-h) IsFunction "${command}Usage" && ${command}Usage || usage 0;;
			--ssh|-s) ssh="true"; waitSsh="true"; [[ ! $waitSeconds ]] && waitSeconds="$waitDefault";;
			--timeout|-t) ! IsInteger $2 && usage; timeoutMilliseconds="$2"; shift;;
			--wait|-w) IsInteger $2 && { waitSeconds="$2"; shift; } || waitSeconds="$waitDefault";;
			--wait-ssh) waitSsh="true"; [[ ! $waitSeconds ]] && waitSeconds="$waitDefault";;
			*) 				
				[[ ! $command && "$1" == @(on|off|reboot|sleep|firmware|hibernate) ]] && { command="power"; op="$1"; shift; continue; }
				[[ ! $command ]] && IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				[[ ! $host && "$command" == @(power|status) ]] && ! IsOption "$1" && { host="${1,,}"; shift; continue; }
				[[ ! $port ]] && { IsInteger "$1" || [[ "$1" == "all" ]]; } && { port="$1"; shift; continue; }
				[[ "$command" != @(fix) ]] && UnknownOption "$1"
		esac
		shift
	done

	[[ ! $command ]] && MissingOperand "command"
	args=("$@")
}

#
# commands 
#

statusCommand()
{
	local result status="on"

	[[ ! $host ]] && MissingOperand "host"

	if [[ $port ]]; then
		if [[ "$port" == "all" ]]; then
			SshHelper admin@$host swctrl poe show | grep "On[ ]*Good"; return
		else
			switchPortStatus $host $port
		fi
	else
		IsAvailable $host $timeoutMilliseconds
	fi	
	result=$?

	[[ "$result" != 0 ]] && status="off"

	if [[ $port ]]; then
		echo "$hostName port $port is $status ($(switchWatts "$host" "$port")w)"
	else
		local switch port watts; getSwitchPort "$host" || return
		[[ $switch && $port ]] && watts=" ($(switchWatts "$switch" "$port")w)"
		echo "$hostName is $status$watts"
	fi
	
	return $result
}

#
# Fix Commands
#

fixCommand()
{
	! IsPlatform win && return

	local command; CheckSubCommand fix "$1"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	Fix${command}Command "$@"
}

FixSleepCommand()
{
	! IsElevated && { elevate RunScript --pause power fix sleep; return; }
	
	local numRequests="$(powercfg.exe /requests | egrep -i None | wc -l)"
	if (( numRequests == 6 )); then
		echo "No devices are preventing the computer from sleeping"
		return 0
	fi

	echo "Requests preventing sleep..."
	PowerCfg.exe -REQUESTS
}

FixWakeCommand()
{
	echo "Devices which can wake the system:"
	PowerCfg.exe -DEVICEQUERY wake_armed

	echo "Device which last woke the system:"
	PowerCfg.exe -LastWake
}

FixInfoCommand()
{
echot "\
"'Wake:
- Disable wake: PowerCfg -DeviceDisableWake <devicename>
- Examples: 
PowerCfg.exe -DeviceDisableWake "HID Keyboard Device"
PowerCfg.exe -DeviceDisableWake "HID-compliant mouse (009)"

Sleep:
- View overrides:  powercfg -RequestsOverride
- Add override:    powercfg -RequestsOverride SERVICE "<device>" SYSTEM
- Remove override: powercfg -RequestsOverride SERVICE "<device>"
- Examples:
powercfg.exe -RequestsOverride DRIVER "Realtek High Definition Audio" SYSTEM
powercfg.exe -RequestsOverride DRIVER "Sound Blaster X-Fi Xtreme Audio" SYSTEM
powercfg.exe -RequestsOverride SERVICE "\Device\HarddiskVolume1\Windows\System32\svchost.exe (CryptSvc)" SYSTEM
- override in Device Manager, device Power tab'
}

#
# Power Command
#

powerCommand()
{
	IsLocalHost "$host" && { setLocalPower "$op"; return; }

	# control switch port only
	if [[ $port ]]; then
		case "$op" in
			on) switchPortOn "$host" "$port"; exit;;
			off) switchPortOff "$host" "$port"; exit;;
			*) EchoErr "Switch ports can only be turned on or off"; return 1;;
		esac
	fi

	local switch port; getSwitchPort "$host" || return
	local basicSshCommand sshCommand="$BIN/power $op"

	# basic ssh commands when the power script is not present
	case "$op" in
		off) basicSshCommand="shutdown now";;
		reboot) basicSshCommand="shutdown -r now";;
	esac
	
	# host specific power commands
	case "$(RemoveDnsSuffix "$host")" in
		PoeSplitter|TvTuner) sshCommand="";;
		*Ap|*Switch|UnifiController) sshCommand="$basicSshCommand";;
	esac

# here here

	# force a wait if we need to change the power state of the switch port after the host turns off
	[[ $switch && $op == @(off|hibernate) ]] && waitSeconds="$waitDefault"

	# determine the current status off the host
	if [[ $sshCommand ]]; then
		IsLocalAddress "$host" && { host="$(MdnsResolve "$host")" || return; }
		initialHostStatus="off"
		IsAvailable $host $timeoutMilliseconds && initialHostStatus="on"
	fi

	printf "Issuing $op to $host..."

		# set power for a local Hyper-V host (assume Hyper-V hosts start with $HOSTNAME-)
	[[ $host =~ $HOSTNAME- ]] && { setVmPower; exit; }


	local desc="Powering off"; [[ "$command" == "hibernate" ]] && desc="Hibernating"
	echo "$desc $hostName..."
		echo "Rebooting $hostName..."
	echo "Sleeping $hostName..."
	printf "Entering firmware on $hostName..."

	return 0
}

doFirmware()
{
	[[ "$initialHostStatus" == "off" ]] && return 0;

	SshHelper $host "$BIN/power $command" || return
	waitOff || return
}

doHibernate() { doOff; }

doOn() 
{ 
	[[ ! $force && "$initialHostStatus" == "on" ]] && { echo "$hostName is already on"; return 0; }

	local power; [[ $host && $switch && $port ]] && power="true"
	# power on associated switch port if specified
	if [[ $power ]]; then
		printf "power..."
		switchPortOn $switch $port || return
		[[ ! $sshCommand ]] && { echo "done"; return; }
	fi

	# Turn on host using Wake-on-LAN.  A MAC address must be specified in /etc/ethers
	if grep "${host}$" "/etc/ethers" >& /dev/null; then
		local broadcastAddress="$(GetBroadcastAddress)"; [[ $broadcastAddress ]] && broadcastAddress="-i $broadcastAddress"
		echo "wol..."
		wakeonlan $broadcastAddress "${host,,}" # host must be lower case to be found
	fi

	# wait for the host to power up
	waitOn || return

	[[ $ssh ]] && { SshHelper -x "$host"; return; }

	return 0
} 

doOff()
{
	if [[ $sshCommand && "$initialHostStatus" == "on" ]]; then
		SshHelper $host "$sshCommand" || return
		waitOff || return
	fi

	if [[ $switch ]]; then
		printf "port..."
		[[ $sshCommand && "$initialHostStatus" == "on" ]] && { sleep 1 || return; }
		switchPortOff "$switch" "$port" || return
	fi

	return 0
}

doSleep()
{
	[[ "$initialHostStatus" == "off" ]] && return 0;
	SshHelper $host "$BIN/power $command" || return
	waitOff || return
}

setVmPower()
{
	[[ "$command" = @(on|off|reboot|sleep) ]] && { hyperv "$command" "$host"; return; }
	EchoErr "Hyper-V $command command is not supported"
	return 1
}

doReboot()
{
	if [[ "$initialHostStatus" == "off" ]]; then
		[[ $switch ]] && { printf "port..."; switchPortOff "$switch" "$port" || return; }
		onCommand; return
	fi
	
	SshHelper $host "$BIN/power $command" || return
	waitOff || return
	waitOn || return
}

# waitOn - wait waitSeconds for host to become available
waitOn()
{
	local found

	( [[ ! $waitSeconds ]] || IsAvailable $host $timeoutMilliseconds) && return 0

	printf "Waiting ${waitSeconds}s for $hostName to become available..."

	for (( i=1; i<=$waitSeconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if [[ $found ]]; then
			SshHelper "$host" "ls /" >& /dev/null && { echo "ssh"; return 0; }

		elif IsAvailable "$host" "$timeoutMilliseconds"; then
			[[ ! $waitSsh ]] && { echo "found"; return 0; }
			printf "found..."; found="true"
		fi

		printf "."
	done

	echo "not found"
	return 1
}

# waitOff - wait waitSeconds for host to disconnect from the network
waitOff()
{
	( [[ ! $waitSeconds ]] || ! IsAvailable "$host" "$timeoutMilliseconds") && return 0

	printf "Waiting ${waitSeconds}s for $hostName to disconnect..."

	for (( i=1; i<=$waitSeconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if ! IsAvailable "$host" "$timeoutMilliseconds"; then
			echo "disconnected"
			return 0			
		fi

		printf "."
	done

	echo "still connected"
	return 1
}

setLocalPower() # op
{
	local op="$1"

	case "$op" in
		on) return 0;;
		off|reboot) vmware IsInstalled && { vmware SuspendAll || return; }
	esac

	printf "Issuing $op..."

	# assumes policy is set so no password is required (for remote power operation)
	case "$op" in
		firmware)
			if IsPlatform win; then elevate shutdown.exe /r /fw /t 0; exit
			fi;;

		hibernate)
			if IsPlatform win; then start psshutdown -h -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif InPath systemctl; then systemctl hibernate; exit
			fi;;

		off)
			if IsPlatform win; then start psshutdown -s -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif IsPlatform qnap; then sudo poweroff; exit
			elif IsPlatform rock; then systemctl halt -i; exit
			elif IsPlatform synology; then /sbin/shutdown -P now; exit
			elif InPath systemctl; then systemctl poweroff; exit
			elif InPath shutdown; then shutdown -p now; exit
			fi;;

		reboot)
			if IsPlatform win; then start psshutdown -r -f -t 0; exit
			elif IsPlatform mac; then sudo /sbin/shutdown -r now; exit
			elif IsPlatform qnap; then sudo reboot; exit
			elif IsPlatform synology; then sudo /sbin/shutdown -r now; exit
			elif InPath systemctl; then systemctl reboot -i; exit
			elif InPath shutdown; then shutdown -r now; 
			fi;;

		sleep)
			if IsPlatform win; then start psshutdown -d -t 0; exit
			elif IsPlatform mac; then osascript -e 'tell application "System Events" to sleep'; exit
			elif IsPlatform qnap; then sudo qcli_admin --entersleep; exit
			elif InPath systemctl; then systemctl suspend; exit
			fi;;

	esac

	EchoErr "$op is not supported"
	return 1
}

#
# Helper Functions
#

# getSwitchPort HOST - set the switch and port that the specified host is connected to
getSwitchPort()
{
	local hostShort="$(RemoveDnsSuffix "$1")"
	local line=( $(grep "^$hostShort[ 	]" "$DATA/setup/ports") )
	switch="${line[1]}" port="${line[2]}"
}

#
# Switch Helper Functions - assumes UniFi Ubiquiti PoE switch
#

# switchWatts SWITCH PORT - get the watts used by the specified switch and port
switchWatts() { SshHelper admin@$1 swctrl poe show id $2 |& tail -1 | cut -c65-73 | tr -d "[:space:]"; }

# switchPortStatus switch port - get the power status of a PoE port
switchPortStatus()
{ 
	local switch="$1" port="$2"
	SshHelper admin@$1 swctrl poe show id $2 |& grep "On[ ]*Good" >& /dev/null
}

# switchPortOn switch port - turn the power of a PoE port on
switchPortOn()
{
	local switch="$1" port="$2"

	switchPortStatus $switch $port && { echo "$switch port $port is already on"; return; }

	echo "Turning $switch port $port on..."
	SshHelper admin@$switch swctrl poe set auto id $port
}

# switchPortOff switch port - turn the power of a PoE port off
switchPortOff()
{
	local switch="$1" port="$2"

	! switchPortStatus $switch $port && { echo "$switch port $port is already off"; return; }

	echo "Turning $switch port $port off..."
	SshHelper admin@$switch swctrl poe set off id $port
}

run "$@"

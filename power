#!/usr/bin/env bash
. script.sh || exit

run() {	init && args "$@" && "${command}Command" "${args[@]}"; }

init() { switch="" waitDefault=120 poeSwitchDefault="StudyDeskSwitch"; }

initHost()
{
	host="${host,,}"

	# switch variables
	local b="BackShedSwitch" c="StudyClosetSwitch" d="StudyDeskSwitch" g="GarageSwitch"
	
	# host aliases
	case "$host" in
		oversoul) host="oversoulw2";; # WOL only works on WiFi adapter
		b) host="$b";; # Back shed switch
		c) host="$c";; # study Closet switch, i.e. on c 4 to turn on study closet switch port 4
		d) host="$d";; # study Desk switch
		g) host="$g";; # Garage switch
	esac

	hostName="$host"

	# parse host
	port="$(GetWord "$host" 2 :)"
	host="$(GetWord "$host" 1 :)"
	sshHost="$host"
	host="$(GetSshHost "$host")"
}

usage()
{
	ScriptUsage "$1" "\
Usage: power on|off|reboot|sleep|firmware|hibernate [host]:[port|all]
	Control host or PoE switch port power state.

  -e, --exit 					return the specified exit code after the power command
  -f, --force 				force the power operation even if we believe the host 
  											is in the correct state
  -s, --ssh 					make an ssh connection
	-t, --timeout [500]	milliseconds to wait for a response from the host.
  -v, --verbose 			show verbose information where possible
	-w, --wait [120]		seconds for the host to change state
			--wait-ssh			wait for an ssh connection"
	exit $1
}

args()
{
	unset -v exit force ssh vebose wait waitSsh
	timeout=500

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do		
		case "$1" in "") : ;;
			-e*|--exit=*|--exit) ScriptArg "exit" "$@";;
			-f|--force) force="true";;
			-h|--help) usage 0;;
			-s|--ssh) ssh="true"; waitSsh="true"; [[ ! $wait ]] && wait="$waitDefault";;
			-t|--timeout) ScriptArg "timeout" "$@"; ! IsInteger "$timeout" && usage;;
			-v|--verbose) verbose="true";;
			-w|--wait) IsInteger "$2" && ScriptArg "wait" "$@" || wait="$waitDefault";; 
			   --wait-ssh) waitSsh="true"; [[ ! $wait ]] && wait="$waitDefault";;
			*) ScriptOption "$@";;
		esac
		shift
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	! needsHost && [[ $@ ]] && usage
	args=("$@")
}

needsHost() { [[ "${commands[0]}" != @(fix) ]]; }

#
# Status Command
#

statusUsage()
{
	echot "\
Usage: power status host:[port|all]		
Report the status of the host or PoE switch (on or off).  If port is all then
the status of all switch ports is displayed.  Return 0 if the host (or host
PoE port) is on, and 1 if off."
}

statusCommand()
{
	[[ ! $@ ]] && MissingOperand "host"
	
	local host
	for host in "$@"; do
		initHost || return
		status || return
	done
}

status()
{
	local result status="on"

	if [[ $port ]]; then
		if [[ "$port" == "all" ]]; then
			SshHelper "admin@$host" swctrl poe show; return
		else
			switchPortStatus "$host" "$port"
		fi
	else
		IsAvailable "$host" "$timeout"
	fi	
	result=$?

	[[ "$result" != 0 ]] && status="off"

	[[ ! $verbose ]] && { echo "$status"; return $result; }

	if [[ $port ]]; then
		echo "$hostName port $port is $status ($(switchWatts "$host" "$port")w)"
	else
		local switch port watts; switchGetPort "$host" || return
		[[ $switch && $port ]] && watts=" ($(switchWatts "$switch" "$port")w)"
		echo "$hostName is $status$watts"
	fi
	
	return $result
}

#
# Fix Commands
#

fixUsage()
{
	echot "\
Usage: power fix info|sleep|wake
Examine issues preventing computer sleep or wake"
}

fixCommand() { usage; }

fixSleepCommand()
{
	! IsElevated && { elevate RunScript --pause power fix sleep; return; }
	
	local numRequests="$(powercfg.exe /requests | grep -i "None" | wc -l)"
	if (( numRequests == 6 )); then
		echo "No devices are preventing the computer from sleeping"
		return 0
	fi

	echo "Requests preventing sleep..."
	PowerCfg.exe -REQUESTS
}

fixWakeCommand()
{
	echo "Devices which can wake the system:"
	PowerCfg.exe -DEVICEQUERY wake_armed

	echo "Device which last woke the system:"
	PowerCfg.exe -LastWake
}

fixInfoCommand()
{
echot "\
"'Wake:
- Disable wake: PowerCfg -DeviceDisableWake <devicename>
- Examples: 
PowerCfg.exe -DeviceDisableWake "HID Keyboard Device"
PowerCfg.exe -DeviceDisableWake "HID-compliant mouse (009)"

Sleep:
- View overrides:  powercfg -RequestsOverride
- Add override:    powercfg -RequestsOverride SERVICE "<device>" SYSTEM
- Remove override: powercfg -RequestsOverride SERVICE "<device>"
- Examples:
powercfg.exe -RequestsOverride DRIVER "Realtek High Definition Audio" SYSTEM
powercfg.exe -RequestsOverride DRIVER "Sound Blaster X-Fi Xtreme Audio" SYSTEM
powercfg.exe -RequestsOverride SERVICE "\Device\HarddiskVolume1\Windows\System32\svchost.exe (CryptSvc)" SYSTEM
- override in Device Manager, device Power tab'
}

#
# Power Commands
#

firmwareCommand() { power "firmware" "$@"; }
hibernateCommand() { power "hibernate" "$@"; }
offCommand() { power "off" "$@"; }
onCommand() { power "on" "$@"; }
rebootCommand() { power "reboot" "$@"; }
sleepCommand() { power "sleep" "$@"; }

power()
{
	local host op="$1"; shift

	# local
	if [[ ! $@ ]]; then
		[[ $exit ]] && { powerExit "$op"; return; }
		powerLocal "$op"; return
	fi

	# remote
	for host in "$@"; do
		initHost || return
		powerRemote "$op" || return
	done
}

# run the power command and ensure the exit code is returned to the callers
powerExit()
{
	local op="$1"

	# ensure sudo credentials are active
	sudoc -v 

	# perform the power operation in a delayed sub-shell so this shell can process the exit code
	# the sub-shell is disconnected so the power command still runs if this shell terminates
	{ nohup bash -c 'sleep 2; power $op' & } 

	exit $exit
}

powerLocal() # op
{
	local op="$1"

	case "$op" in
		on) return 0;;
		off|reboot) vmware IsInstalled && { vmware SuspendAll || return; }
	esac

	printf "$op..."

	# assumes policy is set so no password is required (for remote power operation)
	case "$op" in
		firmware)
			if IsPlatform win; then elevate shutdown.exe /r /fw /t 0; exit
			fi;;

		hibernate)
			if IsPlatform win; then start psshutdown -h -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif InPath systemctl; then systemctl hibernate; exit
			fi;;

		off)
			if IsPlatform win; then start psshutdown -s -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif IsPlatform qnap; then sudo poweroff; exit
			elif IsPlatform rock; then systemctl halt -i; exit
			elif IsPlatform synology; then /sbin/shutdown -P now; exit
			elif InPath systemctl; then systemctl poweroff; exit
			elif InPath shutdown; then shutdown -p now; exit
			fi;;

		reboot)
			if IsPlatform win; then start psshutdown -r -f -t 0; exit
			elif IsPlatform mac; then sudo /sbin/shutdown -r now; exit
			elif IsPlatform qnap; then sudo reboot; exit
			elif IsPlatform synology; then sudo /sbin/shutdown -r now; exit
			elif InPath systemctl; then systemctl reboot -i; exit
			elif InPath shutdown; then shutdown -r now; 
			fi;;

		sleep)
			if IsPlatform win; then start psshutdown -d -t 0; exit
			elif IsPlatform mac; then osascript -e 'tell application "System Events" to sleep'; exit
			elif IsPlatform qnap; then sudo qcli_admin --entersleep; exit
			elif InPath systemctl; then systemctl suspend; exit
			fi;;

	esac

	EchoErr "$op is not supported"
	return 1
}

powerRemote()
{
	local op="$1"
	local opf="$(ProperCase "$op")" # op for function

	# control switch port only
	if [[ $port ]]; then
		[[ "$op" != @(on|off) ]] && { EchoErr "Switch ports can only be turned on or off"; return 1; }
		switchPort$opf "$host" "$port" || return; 
		echo "done"; return
	fi

	# get switch port information
	local switch port; switchGetPort "$host" || return
	local power; [[ $host && $switch && $port ]] && power="true"

	# ssh command to use to control host power
	local basicSshCommand sshCommand="$BIN/power $op"
	case "$op" in
		off) basicSshCommand="shutdown now";;
		reboot) basicSshCommand="shutdown -r now";;
	esac
	
	# host specific power commands
	case "$(RemoveDnsSuffix "$host")" in
		AirthingsBridge|*Camera|GarageWaterHeater|HueBridge|TvTuner) sshCommand="";;
		*Ap|*Switch|UnifiController|VeraBridge) sshCommand="$basicSshCommand";;
	esac

	# force a wait if we need to change the power state of the switch port after the host turns off
	[[ $switch && $op == @(off|hibernate) ]] && wait="$waitDefault"

	# determine the current status off the host
	local initialState="off"; IsAvailable "$host" "$timeout" && initialState="on"

	# description
	local desc expectedState="off"
	case "$op" in
		firmware) desc="Entering firmware on";;
		hibernate) desc="Hibernating";;
		off) desc="Powering off";;
		on) desc="Powering on"; expectedState="on";;
		reboot) desc="Rebooting"; expectedState="";;
		sleep) desc="Sleeping";;
	esac

	if [[ ! $force && "$initialState" == "$expectedState" ]]; then
		[[ "$op" == "on" && $waitSsh ]] && ! checkSsh && { waitSsh; return; }
		echo "$host is already $expectedState"
		return 0
	fi

	[[ ! $sshCommand && ! ( "$op" == "off" && $port ) ]] && { EchoErr "\n$host does not support the $op power operation"; return 1; }

	printf "$desc $hostName..."

	# perform operation
	if [[ "$op" == @(firmware|sleep) ]]; then
		SshHelper $sshHost "$sshCommand" || return
		waitOff "$wait" || return
	else
		power$opf || return
	fi
	
	echo "done"

	[[ $ssh ]] && { SshHelper -x "$sshHost" || return; }
	return 0
}

powerHibernate() { doOff; }

powerOff()
{
	if [[ $sshCommand && "$initialState" == "on" ]]; then
		SshHelper $sshHost "$sshCommand" > /dev/null || { powerOffCleanup; return 1; }
		waitOff "$wait" || return
	fi

	if [[ $switch ]]; then
		[[ $sshCommand && "$initialState" == "on" ]] && { sleep 1 || return; }
		switchPortOff "$switch" "$port" || return
	fi

	return 0
}

powerOffCleanup() { [[ $switch && $force ]] && switchPortOff "$switch" "$port"; return 0; }

powerOn() 
{ 
	[[ ! $force && "$initialState" == "on" ]] && { echo "$hostName is already on"; return 0; }
	
	# power on associated switch port if specified
	if [[ $power ]]; then
		switchPortOn $switch $port || return
		[[ ! $sshCommand ]] && { echo "done"; return; }
	fi

	# Turn on host using Wake-on-LAN.  A MAC address must be specified in /etc/ethers
	if grep "${host}$" "/etc/ethers" >& /dev/null; then
		local broadcastAddress="$(GetBroadcastAddress)"; [[ $broadcastAddress ]] && broadcastAddress="-i $broadcastAddress"
		printf "wol..."
		wakeonlan $broadcastAddress "${host,,}" > /dev/null # host must be lower case to be found
	fi

	# wait for the host to power up
	waitOn "$wait" || return
} 

powerReboot()
{
	if [[ "$initialState" == "off" ]]; then
		[[ $switch ]] && { switchPortOff "$switch" "$port" || return; } # make sure the switch port if off
		doOn; return
	fi
	
	SshHelper $sshHost "$sshCommand" >& /dev/null || return
	waitOff "${wait:-$waitDefault}" || return
	waitOn "${wait}" || return
}

# waitOff SECONDS - wait for host to disconnect from the network
waitOff()
{
	local s="$1"

	( [[ ! $s ]] || ! IsAvailable "$host" "$timeout") && return 0

	printf "waiting..."

	for (( i=1; i<=$s; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if ! IsAvailable "$host" "$timeout"; then
			printf "disconnected..."
			return 0			
		fi

		printf "."
	done

	printf "still connected..."
	return 1
}

# waitOn SECONDS - wait for host to become available
waitOn()
{
	local found s="$1"

	( [[ ! $s ]] || IsAvailable "$host" "$timeout") && return 0

	printf "waiting..."

	for (( i=1; i<=$s; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if [[ $found ]]; then
			checkSsh && { printf "ssh..."; return 0; }

		elif IsAvailable "$host" "$timeout"; then
			found="true"; printf "found..."
			[[ ! $waitSsh ]] && return 0
		fi

		printf "."
	done

	echo "not found"
	return 1
}

waitSsh() { printf "$hostName..."; waitOn "${wait}" || return; echo "done"; }

#
# Switch Helper - assume UniFi Ubiquiti PoE switch
#

# switchGetPort HOST - set the switch and port that the specified host is connected to
switchGetPort()
{
	local hostShort="$(RemoveDnsSuffix "$1")"
	local line=( $(grep -i "^$hostShort[ 	]" "$DATA/setup/ports") )
	switch="${line[1]}" port="${line[2]}"
}

# switchPortOn switch port - turn the power of a PoE port on
switchPortOn()
{
	local switch="$1" port="$2"
	printf "port $port..."
	switchPortStatus $switch $port && { printf "already on..."; return; }
	SshHelper admin@$switch swctrl poe set auto id $port || return
	printf "on..."
}

# switchPortOff switch port - turn the power of a PoE port off
switchPortOff()
{
	local switch="$1" port="$2"
	printf "port..."
	! switchPortStatus $switch $port && { printf "already off..."; return; }
	SshHelper admin@$switch swctrl poe set off id $port || return
	printf "off..."
}

# switchPortStatus switch port - get the power status of a PoE port
switchPortStatus()
{ 
	local switch="$1" port="$2"
	SshHelper admin@$1 swctrl poe show id $2 |& cut -c7-13 | grep "Auto" >& /dev/null
}

# switchWatts SWITCH PORT - get the watts used by the specified switch and port
switchWatts() { SshHelper admin@$1 swctrl poe show id $2 |& tail -1 | cut -c65-73 | tr -d "[:space:]"; }

#
# Helper
#

checkSsh() { SshHelper "$sshHost" "ls /" >& /dev/null; }

run "$@"

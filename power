#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
Manage host or PoE switch port power state.

	on|off|reboot|sleep|firmware|hibernate
	fix				fix power issues
	status		host power status

	-t, --timeout=[$timeout]		milliseconds to wait for a response from the host
	-u, --user USER							SSH user"
}

init()
{
	switch="" waitDefault=120 poeSwitchDefault="StudyDeskSwitch"

	hostArg="HOST format is HOST[:PORT] where PORT is an optional switch port number.
		If the PORT is all the command applies to all switch ports on the host."

	unset user; [[ "$USER" == "homebridge" ]] && user="$(ConfigGet "user")@"

	return 0
}

argStart() { unset -v hosts; timeout="$(ConfigGet "hostTimeout")"; }

opt()
{
	case "$1" in
		-t|--timeout|-t=*|--timeout=*) ScriptOptGet "timeout" "$@"; ! IsInteger "$timeout" && usage;;
		-u|--user|-u=*|--user=*) ScriptOptGet "user" "$@"; user=$user@;;
		*) return 1;;
	esac
}

args()
{
	[[ "${commands[0]}" == @(fix) ]] && return
	hosts=( "$@" ); (( shift+=$# )); true
}

#
# Fix Command
#

fixUsage()
{
	echot "\
Usage: power fix info|sleep|wake
Examine issues preventing computer sleep or wake"
}

fixCommand() { usage; }

fixSleepCommand()
{
	! IsElevated && { elevate RunScript --pause power fix sleep; return; }
	
	local numRequests="$(powercfg.exe /requests | grep -i "None" | wc -l)"
	if (( numRequests == 6 )); then
		echo "No devices are preventing the computer from sleeping"
		return 0
	fi

	echo "Requests preventing sleep..."
	PowerCfg.exe -REQUESTS
}

fixWakeCommand()
{
	echo "Devices which can wake the system:"
	PowerCfg.exe /DeviceQuery wake_armed

	echo "Device which last woke the system:"
	PowerCfg.exe /LastWake
}

fixInfoCommand()
{
echot "\
"'Wake:
- Disable wake: PowerCfg -DeviceDisableWake <devicename>
- Examples: 
PowerCfg.exe -DeviceDisableWake "HID Keyboard Device"
PowerCfg.exe -DeviceDisableWake "HID-compliant mouse (009)"

Sleep:
- View overrides:  powercfg -RequestsOverride
- Add override:    powercfg -RequestsOverride SERVICE "<device>" SYSTEM
- Remove override: powercfg -RequestsOverride SERVICE "<device>"
- Examples:
powercfg.exe /DeviceDisableWake "HID-compliant mouse (001)"
powercfg.exe /DeviceQuery wake_from_any
powercfg.exe -RequestsOverride DRIVER "Realtek High Definition Audio" SYSTEM
powercfg.exe -RequestsOverride DRIVER "Sound Blaster X-Fi Xtreme Audio" SYSTEM
powercfg.exe -RequestsOverride SERVICE "\Device\HarddiskVolume1\Windows\System32\svchost.exe (CryptSvc)" SYSTEM
powercfg -devicequery wake_from_any # device which can wake the system
- override in Device Manager, device Power tab'
}

#
# Power Opertation Commands
#

opUsage()
{
	echot "\
Usage: power $command [HOST]...
Perform a power operation

	$hostArg

	-e, --exit 					return the specified exit code after the power command
	-f, --force 				force the power operation even if we believe the host is in the correct state
	-g, --gui 					make a GUI desktop connection after power operation
	-s, --ssh 					make an ssh connection after power operation
	-w, --wait=[120]		seconds for the host to change state
	-ws,--wait-ssh			wait for an ssh connection

	-ie, --ignore-errors	ignore errors non-fatal errors
	-q, --quiet 					minimize informational messages
	-t, --test 						test the operation without making any changes"
}

opArgStart()
{
	unset -v exit force gui quiet test wait powerSshWait
	unset -v desc sshCommand
	expectedState="off" ignoreErrors=1
}

opOpt() 
{
	case "$1" in
		-e|--exit|-e=*|--exit=*) ScriptOptGet "exit" "$@";;
		-ie|--ignore-errors) ignoreErrors="0";;
		-g|--gui) gui="true";;
		-s|--ssh) ssh="true"; powerSshWait="true"; [[ ! $wait ]] && wait="$waitDefault"; true;;
		-w|--wait|-w=*|--wait=*) IsInteger "$2" && ScriptOptGet "wait" "$@" || wait="$waitDefault";; 
		-ws|--wait-ssh) waitSsh="--wait-ssh"; [[ ! $wait ]] && wait="$waitDefault";;
		*) return 1
	esac
}

offUsage() { opUsage; }
offArgStart() { opArgStart; desc="Powering off"; sshCommand="shutdown now"; }
offOpt() { opOpt "$@"; }
offCommand() { doPower "off"; }

onUsage() { opUsage; }
onArgStart() { opArgStart; desc="Powering on"; expectedState="on"; }
onOpt() { opOpt "$@"; }
onCommand() { doPower "on"; }

firmwareUsage() { opUsage; }
firmwareArgStart() { opArgStart; desc="Entering firmware on"; }
firmwareOpt() { opOpt "$@"; }
firmwareCommand() { doPower "firmware"; }

hibernateUsage() { opUsage; }
hibernateArgStart() { opArgStart; desc="Hibernating"; }
hibernateOpt() { opOpt "$@"; }
hibernateCommand() { doPower "hibernate"; }

rebootUsage() { opUsage; }
rebootArgStart() { opArgStart; desc="Rebooting"; expectedState=""; sshCommand="shutdown -r now"; }
rebootOpt() { opOpt "$@"; }
rebootCommand() { doPower "reboot"; }

sleepUsage() { opUsage; }
sleepArgStart() { opArgStart; desc="Sleeping"; }
sleepOpt() { opOpt "$@"; }
sleepCommand() { doPower "sleep"; }

powerOffCleanup() { [[ $switch && $force ]] && switchPortOff "$switch" "$switchPort"; return 0; }
powerSshAvailable() { [[ $sshCommand ]] && SshHelper connect "$host" -- "ls /" >& /dev/null; }
powerSshWait() { printf "$hostDesc..."; powerWaitOn "${wait}" || return; }

doPower()
{
	local op="$1"; shift

	# local
	if [[ ! ${hosts[@]} ]]; then
		[[ $exit ]] && { powerExit "$op"; return; }
		powerLocal "$op"; return
	fi

	# remote
	local host
	for host in "${hosts[@]}"; do
		powerRemote "$host" "$op" || return
	done

	return 0
}

# run the power command and ensure the exit code is returned to the callers
powerExit()
{
	local op="$1"

	# ensure sudo credentials are active
	sudoc -v 

	# perform the power operation in a delayed sub-shell so this shell can process the exit code
	# the sub-shell is disconnected so the power command still runs if this shell terminates
	{ nohup bash -c 'sleep 2; power $op' & } 

	exit $exit
}

powerLocal()
{
	local op="$1"

	case "$op" in
		on) return 0;;
		off|reboot) vmware IsInstalled && { vmware SuspendAll || return; }
	esac

	printf "$op..."
	[[ $test ]] && return

	# assumes policy is set so no password is required (for remote power operation)
	case "$op" in
		firmware)
			if IsPlatform win; then elevate shutdown.exe /r /fw /t 0; exit
			fi;;

		hibernate)
			if IsPlatform win; then start psshutdown -h -f -t 0; exit
			elif IsPlatform mac; then /sbin/shutdown -h now; exit
			elif InPath systemctl; then systemctl hibernate; exit
			fi;;

		off)
			if IsPlatform win; then start psshutdown -s -f -t 0; exit
			elif IsPlatform mac; then sudoc /sbin/shutdown -h now; exit
			elif IsPlatform qnap; then sudoc poweroff; exit
			elif IsPlatform rock; then systemctl halt -i; exit
			elif IsPlatform synology; then /sbin/shutdown -P now; exit
			elif InPath systemctl; then systemctl poweroff; exit
			elif InPath shutdown; then shutdown -p now; exit
			fi;;

		reboot)
			if IsPlatform win; then start psshutdown -r -f -t 0; exit
			elif IsPlatform mac; then sudoc /sbin/shutdown -r now; exit
			elif IsPlatform qnap; then sudo reboot; exit
			elif IsPlatform synology; then sudo /sbin/shutdown -r now; exit
			elif InPath systemctl; then systemctl reboot -i; exit
			elif InPath shutdown; then shutdown -r now; 
			fi;;

		sleep)
			if IsPlatform win; then start psshutdown -d -t 0; exit
			elif IsPlatform mac; then osascript -e 'tell application "System Events" to sleep'; exit
			elif InPath systemctl; then systemctl suspend; exit
			fi;;

	esac
}

powerRemote()
{
	local host="$1"; initHost "$host" || return
	local op="$2"

	# wait for the host to become available if we are connecting to the GUI desktop (except for virtual machines,
	# whose GUI is available while starting up)
	[[ $gui && ! $wait ]] && ! IsHostnameVm "$host" && wait="$waitDefault"

	# if a switch port was specified control it
	if [[ $switchPort ]]; then
		[[ "$op" != @(on|off) ]] && { EchoErr "Switch ports can only be turned on or off"; return 1; }
		RunFunction "switchPort" "$op" "$host" "$switchPort" || return; 
		echo "done"; return
	fi

	# determine host switch port to control it's power
	local switch switchPort; switchLookup "$host" || return
	local power; [[ $host && $switch && $switchPort ]] && power="true"

	# determine the current status off the host
	local initialState="off"; IsAvailable "$host" "$timeout" && initialState="on"

	# determine the current status off the switch port
	local initialSwitchState="$expectedState"
	if [[ $power ]]; then
		initialSwitchState="off"
		switchPortStatus $switch $switchPort && initialSwitchState="on"
	fi

	# determine host information if needed and it is on
	_platform="linux"
	if [[ "$host" != @(VeraBridge) && "$initialState" == "on" && "$op" != "on" ]] && SshIsAvailable "$host"; then
		SshInPath "$user$host" "power" && { sshCommand="$BIN/power $op"; }
		ScriptEval HostGetInfo vars "$host" >& /dev/null
	fi

	# force a wait if we can turn the hosts switch port off after sending it a power off command
	[[ $sshCommand && $switch && $op == @(off|hibernate) ]] && wait="$waitDefault"

	# description	
	if [[ ! $force && "$initialState" == "$expectedState" && "$initialState" == "$initialSwitchState" ]]; then
		[[ ! $quiet ]] && echo "$hostDesc is already $expectedState"
		[[ "$op" == "on" && $waitSsh ]] && ! powerSshAvailable && { powerSshWait; return; }
		[[ "$op" == "on" && $gui ]] && { doGuiConnect || return; }
		[[ "$op" == "on" && $ssh ]] && { doSshConnect || return; }
		return 0
	fi

	printf "$desc $hostDesc..."
	RunFunction "power" "$op" || return
	echo "done"

	doGuiConnect || return
	doSshConnect || return
}

powerSleep() { powerOp "sleep" && powerWaitOff "$wait"; }
powerFirmware() { powerOp "firmware" && powerWaitOff "$wait"; }
powerHibernate() { doOff; }

powerOp() # sleep, firmware
{
	local op="$1"

	# power on Hyper-V virtual machine	
	if IsHostnameVm "$host"; then
		printf "command..."; 
		hyperv power "$op" "$host" "${globalArgs[@]}"; return

	# use SSH
	elif [[ ! $sshCommand ]]; then
		[[ ! $quiet ]] && ScriptErr "$op operation is not available on $host"
		return "$ignoreErrors"
	fi

	printf "command..."; doSsh "$user$host" "$sshCommand"
}

powerOff()
{
	# power off Hyper-V virtual machine	
	if IsHostnameVm "$host"; then
		printf "command..."; 
		hyperv power off "$host" "${globalArgs[@]}" || return
		return
	fi

	# power off using SSH
	if [[ $sshCommand && "$initialState" == "on" ]]; then
		printf "command..."; doSsh "$user$host" "$sshCommand" || { powerOffCleanup; return 1; }
		powerWaitOff "$wait" || return
	fi

	# power off switch port
	if [[ $switch ]]; then
		[[ $sshCommand && "$initialState" == "on" ]] && { sleep 1 || return; }
		switchPortOff "$switch" "$switchPort" || return
	fi

	return 0
}

powerOn() 
{ 
	if [[ ! $force && "$initialState" == "on" ]]; then
		[[ ! $quiet ]] && echo "$hostDesc is already on"
		return 0
	fi

	# power on Hyper-V virtual machine	
	if IsHostnameVm "$host"; then
		printf "command..."; 
		hyperv power on "$host" "${globalArgs[@]}" || return

	# power on associated switch port if specified
	elif [[ $power ]]; then
		switchPortOn $switch $switchPort || return

	# turn on host using Wake-on-LAN.  A MAC address must be specified in /etc/ethers
	elif grep " ${host}$" "/etc/ethers" >& /dev/null; then

		local mac="$(GetMacAddress "$host")"
		local broadcastAddress="$(GetBroadcastAddress)"; [[ $broadcastAddress ]] && broadcastAddress="-i $broadcastAddress"

		[[ $verbose ]] && printf "wol ($mac)..." || printf "wol..."

		if [[ ! $test ]]; then
			if IsPlatform wsl; then
				 wakeonlan.exe -w -mac "$mac" >& /dev/null || return
			else 
				# host must be lower case to be found
				wakeonlan $broadcastAddress "${host,,}" > /dev/null 
			fi
		fi

	fi

	# wait for the host to power up
	powerWaitOn "$wait" || return
} 

powerReboot()
{
	# try rebooting using the SSH
	if [[ $sshCommand && "$initialState" == "on" ]] && SshIsAvailable "$host"; then
		printf "command..."
		doSsh "$user$host" "$sshCommand" && \
			powerWaitOff "${wait:-$waitDefault}" && \
			powerWaitOn "${wait}" && \
			return
	fi

	# try power cycling the switch port
	[[ $switch ]] && { switchPortReboot "$switch" "$switchPort"; return; }

	# reboot a Hyper-V virtual machine	
	IsHostnameVm "$host" && { hyperv power reboot "$host" "${globalArgs[@]}"; return; }

	# try powering on
	[[ "$initialState" == "off" ]] && { powerOn; return; }

	# unable to reboot
	ScriptErr "unable to reboot '$host'"
}

# powerWaitOff SECONDS - wait for host to disconnect from the network
powerWaitOff()
{
	local seconds="$1"

	( [[ ! $seconds ]] || ! IsAvailable "$host" "$timeout") && return 0

	printf "waiting..."

	for (( i=1; i<=$seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if ! IsAvailable "$host" "$timeout"; then
			printf "disconnected..."
			return 0			
		fi

		[[ $test && "$i" == "4" ]] && return
		printf "."
	done

	printf "still connected..."
	return 1
}

# powerWaitOn SECONDS - wait for host to become available
powerWaitOn()
{
	local found seconds="$1"

	( [[ ! $seconds ]] || IsAvailable "$host" "$timeout") && return 0

	printf "waiting..."

	for (( i=1; i<=$seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; return 1; }

		if [[ $found ]]; then
			powerSshAvailable && { printf "ssh..."; return 0; }

		elif IsAvailable "$host" "$timeout"; then
			found="true"; printf "found..."
			[[ ! $waitSsh ]] && return 0
		fi

		[[ $test && "$i" == "4" ]] && return 0
		printf "."
	done

	echo "not found"
	return 1
}

#
# Status Command
#

statusUsage()
{
	echot "\
Usage: power status [watts] HOST[:PORT]
Report the status of the host or PoE switch (on or off).  
If port is all then the status of all switch ports is displayed.

	$hostArg

	-t, --timeout=[$timeout]		milliseconds to wait for a response from the host"
}

statusArgEnd() { [[ ! $hosts ]] && MissingOperand "host"; return 0; }

statusCommand()
{
	local host command="doStatus"; [[ $verbose ]] && command="doStatusVerbose"
	for host in "${hosts[@]}"; do "$command" "$host" || return; done; 
}

statusWattsCommand() { for host in "${hosts[@]}"; do doStatusWatts "$host" || return; done; }

doStatus()
{
	local host="$1"; initHost "$host" || return
	local result

	if [[ $switchPort ]]; then
		if [[ "$switchPort" == "all" ]]; then
			SshHelper connect "admin@$host" -- swctrl poe show; return
		else
			switchPortStatus "$host" "$switchPort"; result=$?
		fi
	else
		IsAvailable "$host" "$timeout"; result=$?
	fi	
	
	[[ "$result" == "0" ]] && echo "on" || echo "off"
}

doStatusVerbose()
{
	local host="$1"; initHost "$host" || return
	local status="$(doStatus "$host")"

	if [[ $switchPort ]]; then
		echo "$hostDesc port $switchPort is $status ($(switchWatts "$host" "$switchPort")w)"
	else
		local switch switchPort; switchLookup "$host" || return

		local power
		[[ $switch && $switchPort ]] && power="$(switchWatts "$switch" "$switchPort")w"
		[[ $power ]] && power=" ($power)"

		echo "$hostDesc is $status$power"
	fi
}

doStatusWatts()
{
	local host="$1"; initHost "$host" || return

	if [[ $switchPort ]]; then
		switchWatts "$host" "$switchPort"
	else
		local switch switchPort; switchLookup "$host" || return
		[[ $switch && $switchPort ]] && switchWatts "$switch" "$switchPort"
	fi
}

#
# Switch Helper - assume UniFi Ubiquiti PoE switch
#

# switchLookup HOST - set the switch and port that the specified host is connected to
switchLookup()
{
	local hostShort="$(RemoveDnsSuffix "$1")"
	local line=( $(grep -i "^$hostShort[ 	]" "$DATA/setup/ports") )
	switch="${line[1]}" switchPort="${line[2]}"
}

# switchPortOn switch port - turn the power of a PoE port on
switchPortOn()
{
	local switch="$1" switchPort="$2"
	printf "port $switchPort..."
	switchPortStatus $switch $switchPort && { [[ ! $quiet ]] && printf "already on..."; return; }
	doSsh "admin@$switch" swctrl poe set auto id $switchPort || return
	printf "on..."
}

# switchPortOff switch port - turn the power of a PoE port off
switchPortOff()
{
	local switch="$1" switchPort="$2"
	[[ $verbose ]] && printf "$switch $switchPort..."
	printf "port..."
	! switchPortStatus $switch $switchPort && { [[ ! $quiet ]] && printf "already off..."; return; }
	doSsh "admin@$switch" swctrl poe set off id $switchPort || return
	printf "off..."
}

switchPortReboot()
{
	local switch="$1" switchPort="$2"
	switchPortOff "$switch" "$switchPort" || return
	sleep 1
	switchPortOn "$switch" "$switchPort" || return
	powerWaitOn "${wait}" || return
}

# switchPortStatus switch port - get the power status of a PoE port
switchPortStatus()
{ 
	local switch="$1" switchPort="$2"
	(( verboseLevel > 1 )) && SshHelper connect "admin@$switch" -- swctrl poe show id "$switchPort" >& /dev/stderr
	SshHelper connect "admin@$switch" -- swctrl poe show id "$switchPort" |& cut -c7-13 | grep "Auto" >& /dev/null
}

# switchWatts SWITCH PORT - get the watts used by the specified switch and port
switchWatts()
{
	(( verboseLevel > 1 )) && SshHelper connect "admin@$1" -- swctrl poe show id $2 >& /dev/stderr
	SshHelper connect "admin@$1" -- swctrl poe show id $2 |& tail -1 | cut -c65-73 | tr -d "[:space:]"; 
}

#
# Helper
#

initHost()
{
	# parse host - HOST:PORT
	switchPort="$(GetWord "$host" 2 :)"
	host="$(GetWord "$host" 1 :)"
	hostOrig="${host,,}"
	
	# host aliases
	case "$hostOrig" in
		b) host="BackShedSwitch";;
		c) host="StudyClosetSwitch";;
		d) host="StudyDeskSwitch";;
		g) host="GarageSwitch";;
		ender) host="enderw1";;
		nas3) host="nas3w2";;
	esac

	# validate host
	if ! GetIpAddress "$host" >& /dev/null; then

		# check for virtual host
		if GetIpAddress "$HOSTNAME-$host" >& /dev/null; then
			host="$HOSTNAME-$host"
		else
			HostUnresolved "$host"; return 1
		fi

	fi

	hostDesc="$(os name "$host" | RemoveDnsSuffix)"
}

doSsh()
{ 
	[[ $verbose ]] && echo -n $'\n'"SshHelper "$1" -- -o ServerAliveInterval=1 -o ServerAliveCountMax=1 ${@:2}"$'\n'
	[[ $test ]] && return

	local result redirect=">"; [[ "$_platform" == "win" ]] && redirect=">&" # suppress Windows psshutdown header
	redirect+=" /dev/null"
	[[ $verbose ]] && unset redirect

	# perform ssh
	# - ServerAliveInterval and ServerAliveCountMax prevents ssh hang (seen in Windows)
	# - StudyDeskSwitch requires ServerAliveInterval >= 2
	SshHelper connect "$1" --pseudo-terminal "${globalArgs[@]}" -- -o ServerAliveInterval=2 -o ServerAliveCountMax=1 "${@:2}" $redirect
	result="$?"

	# Windows psshutdown hangs and always returns an error
	[[ "$_platform" == "win" ]] && return 0 || return "$result"
}

doGuiConnect()
{
	[[ ! $gui ]] && return 0

	# Hyper-V GUI connection
	if IsHostnameVm "$host"; then
		hyperv connect gui "$host" "${globalArgs[@]}"; return

	# Remote Desktop GUI connection
 	elif [[ "$_platform" == "win" ]] && InPath "mstsc.exe"; then
 		mstsc.exe "/v:$host"; return

 	# no GUI connection available
 	else
		[[ ! $quiet ]] && ScriptErr "GUI operation is not available on $host"
		return "$ignoreErrors"

 	fi

}

doSshConnect() { [[ ! $ssh ]] && return 0; SshHelper connect -x "$host" $waitSsh; }

ScriptRun "$@"

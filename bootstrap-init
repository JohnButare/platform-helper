#!/usr/bin/env bash
# bootstrap-init [CONFIG_FILE]- bootstrap a local system with no dependencies

run()
{
	header "bootstrap-init ($USER)"
	init "$@" || return	
	configureProxyServer || return
	setupPackageManager || return
	setTimezone || return
	installPackages || return
	configureOs || return
	createUser || return
	createUserHome || return
	runAsUser || return
	mountPublic || return
	runBootstrap || return
}

configureProxyServer()
{
	local proxy="$(configGet "proxy")"; [[ ! $proxy ]] && return
	local proxyServer="$(configGet "proxyServer")"

	# return if the proxy server is not available
	if ! isAvailable "$proxyServer"; then
		hilight "Skipping proxy server configuration ($proxyServer is not available)..."
		return
	fi

	# set proxy variables
	[[ ! $HTTP_PROXY ]] && export {HTTP_PROXY,HTTPS_PROXY}="$proxy"

	# set package proxy configuration
	if [[ -d /etc/apt/apt.conf.d && ! -f "/etc/apt/apt.conf.d/proxy" ]]; then
		hilight "Setting proxy server to $proxy..."
		printf 'Acquire::http::Proxy "%s";\nAcquire::https::Proxy "%s";\n' "$proxy" "$proxy" | $sudo tee "/etc/apt/apt.conf.d/proxy"
	fi

	return 0
}

setTimezone()
{
	! isDebian && return

	local timezone="$(configGet "timezone")"
	( [[ ! $timezone ]] || cat "/etc/timezone" |& grep "$timezone" > /dev/null ) && return

	DEBIAN_FRONTEND=noninteractive $sudo apt install -y tzdata || return
	[[ ! -f "/usr/share/zoneinfo/$timezone" ]] && return
	$sudo ln -snf "/usr/share/zoneinfo/$timezone" "/etc/localtime" || return
	echo "$timezone" | sudo tee "/etc/timezone" || return
	$sudo dpkg-reconfigure -f noninteractive tzdata || return
}

createUser()
{
	isMac || [[ ! $user ]] || grep "$user" /etc/passwd >& /dev/null && return

	hilight "Creating user $user..."
	sudo adduser "$user" --gecos "" || return
	sudo usermod -aG sudo $user || return
}

createUserHome()
{
	isMac || [[ ! $user ]] && return

	local dir="$(grep "$user" /etc/passwd | cut -d: -f 6)"
	[[ -d "$dir" ]] && return

	hilight "Creating user $user home directory..."
	sudo mkhomedir_helper $user || return
}

runAsUser()
{
	[[ $user && "$USER" == "$user" ]] && return

	[[ $restart ]] && { hilight "Restarting to run as $user..."; return 100; }
	
	local script="${BASH_SOURCE[0]}"

	# allow user to update bootstrap files
	sudo chown "$user" "/tmp/bootstrap/"* || return
	sudo chmod ugo+rwx "/tmp/bootstrap/"* || return

	hilight "Running $script as $user..."
	cd /tmp || return

	# preserve entire environment so wslpath works properly and WSL_ environment variables are passed
	sudo --preserve-env --user=$user --set-home "$script" "${globalArgs[@]}" 
	
	exit
}

runBootstrap()
{
	hilight "Bootstrapping from $bootstrapHost..."
	export PATH=$bin:$PATH
	bootstrap "$bootstrapHost" "$install" "$verbose"
}

doReboot()
{
	hilight "Rebooting..."

	isWin && { sync; wsl.exe --shutdown; exit 100; }

	# do not prompt for sudo password
	fixReboot "+"

	# reboot with a delay to allow exit
	nohup bash -c "sleep 2; reboot now" &

	# status 100 indicates a retry to bootstrap-init
	sleep 1
	exit 100 
}

fixReboot()
{
	local file; file="$(which reboot)" || return
	[[ $sudo && -f "$file" ]] && { $sudo chmod ${1}s "$file" || return; }
}

#
# Configure OS
#

configureOs() 
{
	! updateNeeded "os" && return

	hilight "Configuring the operating system..."
	configure-$platform || return
	updateDone "os" || return
}

configure-debian() { :; }
configure-mac() { :; }

configure-entware()
{
	if isQnap; then
		[[ ! -d "/usr/etc/sudoers.d" ]] && { mkdir /usr/etc/sudoers.d || return; }
		[[ ! -f "/usr/etc/sudoers.d/$user" ]] && { echo "$user ALL=(ALL) ALL" > /usr/etc/sudoers.d/$user || return; }
	fi

	return 0	
}

configure-win()
{
	inPath apt && { $sudo apt update || return; } # fix "Could not find command-not-found database" in WSL
	return
}

#
# Initialize
#

init()
{	
	# variables
	export functionConfigFileCache="${BASH_SOURCE[0]%/*}/bootstrap-config.sh"

	# arguments
	unset -v force noPrompt quiet restart verbose
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-f|--force) force="--force";;
			-q|--force) quiet="--quiet";;
			-np|--no-prompt) noPrompt="--no-prompt";;
			-r|--restart) restart="--restart";;
			-v|--verbose) verbose="--verbose";;
			*) 
				[[ -f "$1" ]] && { export functionConfigFileCache="$1"; shift; continue; }
				echo "bootstrap-init: invalid argument '$1'"; return 1;
		esac
		shift
	done
	globalArgs=($force $noPrompt $quiet $verbose)

	# variables
	user="$(configGet "user")"
	bootstrapHost="$(configGet "bootstrapHost")"
	bootstrapShare="$(configGet "bootstrapShare")"

	# mount location for public files
	mount="$HOME/Volumes/public"
	local target="$bootstrapHost"
	{ [[ -d "$target/public" ]] || [[ "$target" =~ ^/mnt ]]; } && mount="$target/public" # mounted directory
	[[ -d "/share/Public/documents/data/install" ]] && mount="/share/Public" # local directory

	# platform variables
	initPlatform || return

	# sudo
	sudo="sudo"; ! inPath sudo && sudo=""
	[[ ! $sudo && "$USER" != "root" ]] && { echo "bootstrap-init: sudo is not present and user is not root"; return 1; }

	# debian only includes sbin directories in the root users path
	PATH="/usr/local/sbin:/usr/sbin:/sbin:$PATH" 

	# update directory
	updateInit "/tmp/bootstrap" || return

	return 0
}

initPlatform()
{
	chroot=""; [[ -f /etc/debian_chroot ]] && chroot="$(cat "/etc/debian_chroot")"
	container=""; inPath systemd-detect-virt && [[ "$(systemd-detect-virt --container)" != "none" ]] && container="true"

	platform_kernel="linux"
	if [[ "$(uname -r)" =~ .*-Microsoft$ ]]; then platform_kernel="wsl1"
	elif [[ "$(uname -r)" =~ .*-microsoft-standard$ ]]; then platform_kernel="wsl2"
	fi

	# platform=debian|entware|mac|win
	platform=debian
	[[ "$(uname)" == "Darwin" ]] && platform=mac
	! isChroot && [[ "$platform_kernel" == @(wsl1|wsl2) ]] && platform=win

	# platform_like=qnap|synology
	! isContainer && [[ $(uname -r) =~ .*-qnap ]] && { platform="entware" platform_like="qnap"; }
	! isContainer && [[ -f /proc/syno_platform ]] && { platform="entware" platform_like="synology"; }

	# ID=ubuntu|raspbian|qts
	[[ -f /etc/os-release ]] && eval $(cat /etc/os-release)

	# GNU utilities	
	export G=""; isMac && G="g"

	return 0
}

#
# Mount Public
#

mountPublic() 
{ 
	bin="$mount/documents/data/bin"
	install="$mount/Documents/data/install"

	[[ -d "$bin" ]] && return

	hilight "Mounting public share..."

	${G}mkdir --parents "$mount" || return

	if isWin && [[ "$mount" =~ ^/mnt ]]; then mountPublic-win-drive
	elif ! isAvailable "$bootstrapHost"; then mountPublic-sshfs
	elif [[ "$platform_kernel" == "wsl1" ]]; then mountPublic-win
	elif [[ "$platform_kernel" == "wsl2" || "$platform" == "entware" ]]; then mountPublic-debian
	else mountPublic-$platform
	fi
}

mountPublic-debian()
{
	# install
	package cifs-utils || return	

	# configure
	local unc="//$bootstrapHost/$bootstrapShare"
	local line="$unc $mount cifs username=$user,noauto,rw,users 0 0"	
	! grep -q "$line" "/etc/fstab" && { echo "$line" | sudo tee -a "/etc/fstab" || return; }

	# mount
	[[ $verbose ]] && echo "mounting SMB drive: mount.cifs $unc $mount -o user=$user sec=ntlmsspi"
	mount.cifs "$unc" "$mount" -o user=$user sec=ntlmsspi || return
}

mountPublic-win-drive() # mount a Windows drive letter, must start with /mnt, i.e. /mnt/d
{ 
	local dir="$mount" drive="${dir/\/mnt\//}"
	[[ ! -d "$dir" ]] && { sudo mkdir "$dir" || return 1; }
	mount 2>&1 | grep "$drive: on $dir type drvfs" &> /dev/null && return 0;
	[[ $verbose ]] && echo "mounting windows drive: sudo mount -t drvfs $drive: $dir"
	sudo mount -t drvfs "$drive:" "$dir" &> /dev/null
}

mountPublic-mac()
{
	[[ $verbose ]] && echo "mounting SMB drive: mount_smbfs -s smb://$user@$bootstrapHost/$bootstapShare $mount"
	mount_smbfs -s "smb://$user@$bootstrapHost/$bootstapShare" "$mount" || return
}

mountPublic-sshfs()
{
	# install
	package sshfs || return

	# configure
	local file="/etc/fuse.conf"
	grep -q "^#user_allow_other" "$file" && { sudo sed -i 's/^#user_allow_other$/user_allow_other/' "$file" || return; }

	# mount
	local share="$bootstrapHost:$(configGet "bootstrapDir")" port="$(configGet "bootstrapPort")" 
	[[ $verbose ]] && echo "mounting SSH drive: sshfs -o allow_other -o follow_symlinks $share $mount -p $port"
	sshfs -o allow_other -o follow_symlinks "$share" "$mount" -p "$port" || return
}

mountPublic-win()
{
	[[ $verbose ]] && echo "mounting SMB drive: sudo mount -t drvfs //$bootstrapHost/$bootstrapShare $mount"
	sudo mount -t drvfs "//$bootstrapHost/$bootstrapShare" "$mount"
}

#
# Packages
#

installPackages()
{
	! updateNeeded "packages" && return

	hilight "Installing packages..."
	installPackages-pre || return
	installPackages-$platform || return
	installPackages-post || return
	updateDone "packages" || return
}

installPackages-pre()
{
	isUbuntu && isWin && { package ubuntu-standard || return; }
	return 0
}

debWin="cgroup-tools inotify-tools iputils-ping ncat"

installPackages-debian() { package $debWin net-tools openssh-server; }
installPackages-entware() { package bash coreutils coreutils-ln coreutils-readlink coreutils-tac mount-utils nano; }
installPackages-mac() { package bash coreutils gnu-sed ncat; }
installPackages-win() {	package $debWin || return; }

installPackages-post()
{
	isWsl2 && { package cifs-utils || return; }
	isUbuntu && isWin && { package ubuntu-wsl || return; }
	package findutils rsync || return
}

package()
{
	packageInstalled "$@" && return

	case $platform in
		debian|win) sudo apt install -y --allow-unauthenticated "$@";;
		mac) brew install "$@";;
		entware) sudo opkg install "$@";;
	esac
}

packageInstalled()
{ 
	if inPath dpkg; then
		# if any one of the packages passed returns "no packages found" then return 1
		dpkg --get-selections "$@" |& grep -q "no packages found" && return 1
	else
		# assumes each package name is in the path
		inPath "$@" 
	fi

	return 0
}

#
# Package Manager
#

setupPackageManager()
{
	! updateNeeded "PackageManager" && return

	hilight "Setting up the package manager..."
	setupPackageManager-$platform || return
	updateDone "PackageManager" || return
}

setupPackageManager-win() { setupPackageManager-debian; }
setupPackageManager-mac() { :; }

setupPackageManager-debian()
{
	debianUnminimizeDoc || return
	debianFixMan || return
	debianPackageUpdate || return
	debianPackageCore || return
	return 0
}

setupPackageManager-entware()
{
	[[ ! -d "/opt/bin" ]] && { wget -O - "http://bin.entware.net/x64-k3.2/installer/generic.sh" | sudo /bin/sh || return; }
	[[ ! -f "/opt/bin/stat" ]] && { sudo opkg install coreutils-stat || return; } # we need stat now
	export PATH=/opt/bin:$PATH
}

debianPackageCore()
{
	inPath "sudo" && return
	apt install sudo -y || return
}

debianPackageUpdate()
{
	hilight "Updating packages..."
	$sudo apt update -y || return
	$sudo apt dist-upgrade -y || return
	$sudo apt autoremove -y || return

	[[ -f /var/run/reboot-required ]] && doReboot || fixReboot "-"

	return 0
}

debianUnminimizeDoc() # from /usr/local/sbin/unminimize
{
	local config="/etc/dpkg/dpkg.cfg.d/excludes" configTmp="/etc/dpkg/dpkg.cfg.d/excludes.dpkg-tmp" motd="/etc/update-motd.d/60-unminimize"

	[[ ! -f "$config" && ! -f "$configTmp" && ! -f "$motd" ]] && return
	[[ -f "$config" ]] && { $sudo mv "$config" "$configTmp" || return; }

	hilight "Restoring documentation..."
  $sudo apt-get update || return
  $sudo apt-get upgrade -y || return
  dpkg -S /usr/share/man/ |sed 's|, |\n|g;s|: [^:]*$||' | DEBIAN_FRONTEND=noninteractive xargs $sudo apt-get install --reinstall -y || return
  dpkg --verif y--verify-format rpm | awk '/..5......   \/usr\/share\/doc/ {print $2}' | sed 's|/[^/]*$||' | sort |uniq | xargs dpkg -S | sed 's|, |\n|g;s|: [^:]*$||' | uniq | DEBIAN_FRONTEND=noninteractive xargs $sudo apt-get install --reinstall -y || return
  dpkg --verify --verify-format rpm | awk '/..5......   \/usr\/share\/locale/ {print $2}' | sed 's|/[^/]*$||' | sort |uniq | xargs dpkg -S | sed 's|, |\n|g;s|: [^:]*$||' | uniq | DEBIAN_FRONTEND=noninteractive xargs $sudo apt-get install --reinstall -y || return

  if $sudo dpkg --verify --verify-format rpm | awk '/..5......   \/usr\/share\/doc/ {exit 1}'; then
  	$sudo rm -f "$configTmp" "$motd" || return
  fi

  return 0
}

debianFixMan()
{
	[[ "$(dpkg-divert --truename /usr/bin/man)" != "/usr/bin/man.REAL" ]] && return

	$sudo rm -f "/usr/bin/man" || return
	$sudo dpkg-divert --quiet --remove --rename "/usr/bin/man" || return
}

#
# helper
#

configGet() { (. "$functionConfigFileCache"; eval echo "\$$1"); }
getDateStamp() { ${G}date '+%Y%m%d'; }
getFileDateStamp() { stat |& grep "BusyBox" >& /dev/null && return; ${G}date '+%Y%m%d' -d "$(${G}stat --format="%y" "$1")"; }
header() { initColor; printf "${RB_BLUE}*************** ${RB_INDIGO}$1${RB_BLUE} ***************${RESET}\n"; }
hilight() { initColor; printf "${GREEN}$1${RESET}\n"; }
initColor() { GREEN=$(printf '\033[32m'); RB_BLUE=$(printf '\033[38;5;021m') RB_INDIGO=$(printf '\033[38;5;093m') RESET=$(printf '\033[m'); }
inPath() { local f; for f in "$@"; do ! which "$f" >& /dev/null && return 1; done; return 0; }
isAvailable() { ping -c 2 -W 2 "$1" &> /dev/null; }
isChroot() { [[ $chroot ]]; }
isContainer() { [[ $container ]]; }
isDebian() { [[ "$platform" == "debian" ]]; }
isMac() { [[ "$platform" == "mac" ]]; }
isPi() { [[ "$ID" == "raspbian" ]]; }
isUbuntu() { [[ "$ID" == "ubuntu" ]]; }
isWin() { [[ "$platform" == "win" ]]; }
isWsl2() { [[ "$(uname -r)" =~ .*-microsoft-standard$ ]]; }
isQnap() { [[ "$platform_like" == "qnap" ]]; }
pause() { local response; read -n 1 -s -p "${*-Press any key when ready...}"; echo; }
updateInit() { export updateDir="$1"; [[ -d "$updateDir" ]] && return; ${G}mkdir --parents "$updateDir"; }
updateNeeded() { [[ $force || ! -f "$updateDir/$1" || "$(getDateStamp)" != "$(getFileDateStamp "$updateDir/$1")" ]]; }
updateDone() { sudo touch "$updateDir/$1"; }

run "$@"

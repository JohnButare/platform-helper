#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "Usage: $(ScriptName) [OPTION]... [HOST]...

	-p, --prompt		prompt for what to update
	-P,	--protocol	$(ScriptOptNetworkProtocolUsage)
	-f, --force			update the host even if it might be up to date
	-s, --skip LIST	comma seperated list of items to skip
	-w, --what LIST	comma seperated list of items to update

items (default): $(echo "${defaultItems[@]}")
			(other): $(echo "${otherItems[@]}")

File syncronization:
	-do,	--dest-older	assume destination files are than the local source files
	-so,	--src-older		assume local files are older than the destination files
	-nb,	--no-bak			do not backup files to the bak directory"
	exit $1
}

init()
{	
	defaultCommand="update"	
	defaultItems=( file adobe brew choco fzf motd npm node os python ruby store zsh )
	defaultItems+=( hass )
	defaultItems+=( pool-controller pool-dash-panel pool-temperature )
	otherItems=( debian intel mac micro opkg windows wsl )
	allItems=( "${defaultItems[@]}" "${otherItems[@]}" )
	ohMyZsh="$HOME/.oh-my-zsh"
}

argStart() { unset -v method noBak prompt protocol skipArg whatArg; skip=() what=() ; }

opt()
{
	case "$1" in
		-do|--dest-older|--destination-older) method="--dest-older";;
		-nb|--no-bak) noBak="--no-bak";;
		-p|--prompt) prompt="--prompt";;		
		-P|--protocol|-P=*|--protocol=*) ScriptOptNetworkProtocol "$@";;
		-s|--skip|-s=*|--skip=*) ScriptArgItems "skip" "allItems" "$@" || return;;
		-so|--src-older|--source-older) method="--src-older";;
		-w|--what|-w=*|--what=*) ScriptArgItems "what" "allItems" "$@" || return;;
		*) return 1;;
	esac
}

args() { hosts=( "$@" ); (( shift+=$# )); return 0; }

argEnd() 
{
	[[ $hosts ]] && { updateHosts; exit; }	
	[[ ! $prompt ]] && function ask { hilight "Updating $1..."; }
	return 0
}

#
# commands
#

updateCommand()
{
	local item

	[[ ! $what ]] && what=( "${defaultItems[@]}" )

	for item in "${what[@]}"; do
		IsInArray "$item" skip && continue
		${item}Installed && ask "$item" && { "${item}Update" || return; }
	done

	return 0
}

#
# OS Update
#

osInstalled() { true; }

osUpdate()
{
	! UpdateNeeded "os" && return
	RunPlatform "os" || return
	UpdateDone "os" || return
}

osDebian()
{
	ask "Debian update" && { debianUpdate || return; }
	ask "Brew update" && { brewUpdate || return; }
	return 0
}

osEntware() { opkgUpdate; }

osMac()
{
	ask "Mac update" && { macUpdate || return; }
	ask "Brew update" && { brewUpdate || return; }
	return 0
}

osWin()
{
	IsSsh && return 0 # these update requires a GUI
	ask "Windows update" && { windowsUpdate || return; }
	CanElevate && ask "WSL update" && { wslUpdate || return; }
	intelInstalled && ask "Intel update" && { intelUpdate || return; }
	return 0
}

#
# Adobe Update
#

adobeInstalled() { [[ -f "$P32\Common Files\Adobe\OOBE\PDApp\UWA\UpdaterStartupUtility.exe" ]]; }
adobeUpdate() { start "$P32\Adobe\Adobe Creative Cloud\ACC\Creative Cloud.exe"; }

#
# Homebrew Update
#

brewInstalled() { InPath brew; }

brewUpdate()
{
	{ ! brewInstalled || ! UpdateNeeded "brew"; } && return
	
	brew doctor; # brew doctor on arm always returns failure on Big Sur and ARM
	brew update || return
	brew upgrade || return
	brew upgrade --cask || return

	UpdateDone "brew" || return
}

#
# Chocolatey Update
#

chocoInstalled() { InPath "choco.exe"; }

chocoUpdate()
{ 
	! UpdateNeeded "choco" && return
	elevate choco.exe upgrade chocolatey
	UpdateDone "choco" || return
}

#
# Debian Update
#

debianInstalled() { IsPlatform "debian"; }

debianUpdate()
{ 
	{ ! debianInstalled || ! UpdateNeeded "debian"; } && return

	# update using apt or nala
	local update="apt"; InPath nala && update="nala"; debianUpdate${update^} || return

	[[ -f /var/run/reboot-required ]] && ask 'Reboot to finish the update' && { sudo reboot || return; }

	UpdateDone "debian" || return
}

debianUpdateApt()
{
	# update the package list
	sudoc apt update || return
	InPath apt-file && { sudo apt-file update || return; }

	# upgrade packages if needed
	! [[ "$(apt-check --human-readable 2>&1)" =~ "0 packages".* ]] && { sudo apt dist-upgrade -y || return; update="true"; }

	sudo apt autoremove -y || return

	# some packages are not listed in apt-check, update them if needed
	local done=""; sudo apt autoremove -y |& grep "0 not upgraded" >& /dev/null && done="true"
	[[ ! $done ]] && { sudo apt dist-upgrade -y || return; }

	return 0
}

debianUpdateNala() { sudoc nala upgrade --assume-yes; }

#
# File Update
#

fileInstalled() { return 0; }

fileUpdate()
{
	{ ! fileInstalled || ! UpdateNeeded "file"; } && return
	local server; server="$(GetServer "file")" || return
	IsLocalHostIp "$server" && return # do not sync files to ourself
	! unc IsAvailable "$server" "${protocolArg[@]}" "${globalArgs[@]}" && return
	SyncLocalFiles $method $noBak "${protocolArg[@]}" "$server" || return
	UpdateDone "file" || return
}

#
# fzf Update
#

fzfInstalled() { [[ -d "$HOME/.fzf" ]]; }

fzfUpdate()
{
	{ ! fzfInstalled || ! UpdateNeeded "fzf"; } && return
	cd "$HOME/.fzf" || return
	git pull || return
	sudoc ~/.fzf/install --bin || return
	UpdateDone "fzf" || return
}

#
# Home Assistant Update
#

hassInstalled() { HomeAssistant IsInstalled; }

hassUpdate()
{
	{ ! hassInstalled || ! UpdateNeeded "hass"; } && return
	HomeAssistant update && UpdateDone "hass"
}

#
# Intel Update
#

intelInstalled() { [[ -d "$P32/Intel/Driver and Support Assistant" ]]; }

intelUpdate()
{
	{ ! intelInstalled || ! UpdateNeeded "intel"; } && return
	start "https://www.intel.com/content/www/us/en/support/intel-driver-support-assistant.html" || return
	UpdateDone "intel" || return
}

#
# MacOS Update
#

macInstalled() { IsPlatform mac; }

macUpdate()
{
	{ ! macInstalled || ! UpdateNeeded "mac"; } && return
	sudoc softwareupdate --list # --install --all
	UpdateDone "mac" || return
}

#
# Micro Update
#

microInstalled() { InPath "micro"; }

microUpdate()
{
	{ ! microInstalled || ! UpdateNeeded "micro"; } && return
	MicroHelper update || return
	UpdateDone "micro" || return
}

#
# motd Update
#

motdInstalled() { return 0; }

motdUpdate()
{
	local file="/var/run/motd.dynamic"
	{ [[ ! -f "$file" ]] || cmp -s "$HOME/.hushlogin" "$file"; } && return
	tee "$HOME/.hushlogin" < "$file" || return
}

#
# npm (Nginx Proxy Manager)
#

# do not use docker-compose, Nginx Proxy Manager now hosted by Nomad
npmInstalled() { [[ -f "$SRV/nginx-proxy-manager/docker-compose.yml.HOLD" ]]; } 

npmUpdate()
{
	{ ! InPath docker-compose || ! npmInstalled || ! UpdateNeeded "npm"; } && return
	pushd "$SRV/nginx-proxy-manager" >& /dev/null || return
	{ docker-compose pull && docker-compose up -d --remove-orphans && docker image prune --force; } || return
	UpdateDone "npm" || return
}

#
# Node.js Update
#

nodeInstalled() { which node >& /dev/null; }

nodeUpdate()
{
	{ ! nodeInstalled || ! UpdateNeeded "node"; } && return
	sudoc rm -fr "/usr/local/lib/node_modules/.bin" || return # cleanup
	sudoc npm install --location=global npm@latest && sudo npm update --location=global && UpdateDone "node"
}

#
# opkg Update
#

opkgInstalled() { InPath opkg; }

opkgUpdate()
{
	{ ! opkgInstalled || ! UpdateNeeded "opkg"; } && return

	sudoc opkg update || return
	sudoc opkg upgrade || return
	
	UpdateDone "opkg" || return
}

#
# Pool Update
#

poolControllerDir="/opt/pool-controller"
poolDashPanelDir="/opt/pool-dash-panel"
poolTemperatureDir="/opt/pool-temperature"

pool-controllerInstalled() { gitRepoInstalled "$poolControllerDir"; }
pool-dash-panelInstalled() { gitRepoInstalled "$poolDashPanelDir"; }
pool-temperatureInstalled() { gitRepoInstalled "$poolTemperatureDir"; }

pool-controllerUpdate() { gitRepoUpdate "pool-controller" "$poolControllerDir" "pool-controller"; }
pool-dash-panelUpdate() { gitRepoUpdate "pool-dash-panel" "$poolDashPanelDir" "pool-dash-panel"; }
pool-temperatureUpdate() { gitRepoUpdate "pool-temperature" "$poolTemperatureDir" "pool-temperature"; }

#
# Python Update
#

pythonInstalled() { PythonConf && which pip3 >& /dev/null; }

pythonUpdate()
{
	{ ! pythonInstalled || ! UpdateNeeded "python"; } && return

	# to avoid incompatibilities, only pip and pipx should be installed in the user directory
	local outdated; outdated="$(python3 -m pip list --user --outdated --format=columns)"
	
	# pip
	if echo "$outdated" | grep --quiet '^pip '; then
		python3 -m pip install --user --upgrade pip || return
	fi

	# pipx
	if echo "$outdated" | grep --quiet '^pipx '; then
    python3 -m pip install --user --upgrade pipx || return
	fi

	# pipx packages
	if InPath pipx; then
		pipx upgrade-all || return
		pipxg upgrade-all || return
	fi

	UpdateDone "python" || return
}

#
# Ruby Update
#

rubyInstalled() { which gem >& /dev/null; }

rubyUpdate()
{	
	{ ! rubyInstalled || IsPlatformAll mac,arm; } && return # gem is not functional on mac ARM

	local args=( --no-document ) # documents take a while to install
	local sudo="sudoc"
	InPath asdf && asdf plugin list |& grep --quiet '^ruby$' && unset sudo
	InPath rvm && unset sudo
	
	# do not update mac bundled ruby
	IsPlatform mac && [[ "$(which ruby)" == "/usr/bin/ruby" ]] && { return 0; }

	# update
	UpdateNeeded "RubySystem" && { $sudo gem update --system "${args[@]}" || return; UpdateDone "RubySystem" || return; }
	UpdateNeeded "ruby" && { $sudo gem update "${args[@]}" || return; UpdateDone "ruby" || return; }

	return 0
}

#
# Store Update
#

storeInstalled() { IsPlatform win || { IsPlatform mac && InPath mas; } || { IsPlatform qnap && InPath qpkg_cli; }; }

storeUpdate()
{
	{ ! storeInstalled || ! UpdateNeeded "store"; } && return
	RunPlatform "store" || return
	UpdateDone "store" || return
}

storeQnap() { sudoc qpkg_cli --update_all; }
storeMac() { mas upgrade; }
storeWin() { return 0; store; } # store update often fails in Windows

#
# Windows Update
#

windowsInstalled() { IsPlatform win; }

windowsUpdate()
{
	{ ! windowsInstalled || ! UpdateNeeded "windows"; } && return
	FindInPath "wuapp.exe" > /dev/null && start "wuapp.exe" || cmd.exe /c start ms-settings:windowsupdate >& /dev/null; 
	UpdateDone "windows" || return
}

wslInstalled() { IsPlatform win; }

wslUpdate()
{
	{ ! wslInstalled && ! UpdateNeeded "wsl"; } && return
	wsl update && UpdateDone "wsl"
}

#
# Zsh Update
#

zshInstalled() { InPath zsh && [[ -d "$ohMyZsh/.git" ]]; }

zshUpdate() 
{ 
	{ ! zshInstalled || ! UpdateNeeded "zsh"; } && return
	ZshHelper update && UpdateDone "zsh"
}

#
# helper
#

gitRepoInstalled() { [[ -d "$1/.git" ]]; }

gitRepoUpdate()
{
	local app="$1" dir="$2" service="$3"

	{ ! ${app}Installed || ! UpdateNeeded "$app"; } && return
	
	cd "$dir" || return
	sudor git fetch || return
	
	if [[ "$(sudor GitHelper upstream)" != "up-to-date" ]]; then
		sudor git pull || return
		serviceRestart "$service" || return
	fi
	
	UpdateDone "$app"
}

serviceRestart() { [[ ! $1 ]] && return; service restart "$1"; }

updateHosts()
{
	local h
	for h in "${hosts[@]}"; do
		header "Update $h"
		SshHelper connect -x -t "$h" -- HostUpdate $whatArg $skipArg $force $prompt $method $noBak --protocol=smb || return
	done
}

ScriptRun "$@"

#!/usr/bin/env bash
. script.sh || exit
. color.sh || return

run() {	init && args "$@" && "${command}Command" "${args[@]}"; }

init() { unset -v protocol; ohMyZsh="$HOME/.oh-my-zsh"; }

usage()
{
	echot "\
Usage: $(ScriptName) [OPTION]... [COMMAND](all)

	motd|file|os
	adobe|intel|micro|node|python|ruby|windows|zsh

			--host HOST	host to update
	-p, --prompt		prompt for what to update
			--protocol	$(ScriptNetworkProtocolUsage)
	-f, --force			update the host even if it might be up to date
	-s, --skip LIST	comma seperated list of items to skip"
	exit $1
}

args()
{
	unset -v command force host prompt 
	skip=()

	# commands
	ScriptCommand "allCommand" "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-f|--force) force="force";;
			   --host|--host=*) ScriptArg "host" "$@";;
			-h|--help) usage 0;;
			-p|--prompt) prompt="--prompt";;		
			   --protocol|--protocol=*) ScriptGetNetworkProtocol "$@";;
			-s|--skip|-s*|--skip=*) ScriptArg "skip" "$@"; StringToArray "${skip,,}" "," skip;;
			--) shift; otherArgs+=("$@"); set --; break;;
			*) ScriptOption "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	[[ $@ ]] && usage
	args=("$@")

	# remote update
	[[ $host ]] && { SshHelper -t "$host" -- HostUpdate --protocol=smb; exit; }

	# initialize
	[[ ! $prompt ]] && function ask { printf "${BLUE}%s${RESET}\n" "Updating $1..."; }

	return 0
}

#
# commands
#

allCommand()
{
	local c components=( motd file os micro zsh adobe node python ruby )

	for c in "${components[@]}"; do
		IsInArray "$c" skip && continue
		${c}Installed && ask "$c" && { ${c}Command || return; }
	done
}

windowsCommand() {  FindInPath "wuapp.exe" > /dev/null && start "wuapp.exe" || cmd.exe /c start ms-settings:windowsupdate >& /dev/null; }

#
# OS Command
#

osInstalled() { return 0; }
osCommand() { RunPlatform "os"; }

# debian

osDebian()
{ 
	! UpdateNeeded "debian" && return

	# update the package list
	sudoc apt update || return

	# upgrade packages if needed
	! [[ "$(apt-check --human-readable 2>&1)" =~ "0 packages".* ]] && { sudo apt dist-upgrade -y || return; update="true"; }

	sudo apt autoremove -y || return

	# some packages are not listed in apt-check, update them if needed
	local done=""; sudo apt autoremove -y |& grep "0 not upgraded" >& /dev/null && done="true"
	[[ ! $done ]] && { sudo apt dist-upgrade -y || return; }

	[[ -f /var/run/reboot-required ]] && ask 'Reboot to finish the update' && { sudo reboot || return; }

	UpdateDone "debian" || return
}

# mac

osMac()
{
	ask "Brew update" && { osMacBrew || return; }
	ask "App Store update" && { osMacStore || return; }
	ask "Software update" && { osMacSoftware || return; }
	return 0;
}

osMacBrew()
{
	! UpdateNeeded "brew" && return
	brew doctor; # brew doctor on arm always returns failure on Big Sur and ARM
	brew update || return
	brew upgrade || return
	brew upgrade --cask || return
	UpdateDone "brew" || return
}

osMacSoftware()
{
	! UpdateNeeded "SoftwareUpdate" && return
	sudoc softwareupdate --install --all
	UpdateDone "SoftwareUpdate" || return
}

osMacStore()
{
	! UpdateNeeded "AppStore" && return
	InPath mas && { mas upgrade || return; }
	UpdateDone "AppStore" || return;
}

# QNAP

osQnap()
{
	! UpdateNeeded "qnap" && return
	sudo opkg update || return
	sudo opkg upgrade || return
	UpdateDone "qnap" || return
}

# Windows

osWin()
{
	! UpdateNeeded "win" && return
	IsSsh && return 0 # these update requires a GUI
	ask "Windows update" && { windowsCommand || return; }
	ask "WSL update" && { osWinWsl || return; }
	ask "Store update" && { store || return; }
	osIntelInstalled && ask "Intel update" && { osIntel || return; }
	UpdateDone "win"
}

osWinWsl()
{
	! UpdateNeeded "WSL" && return
	wsl update
	UpdateDone "WSL"
}

osIntelInstalled() { [[ -d "$P32/Intel/Driver and Support Assistant" ]]; }
osIntel() {  start "https://www.intel.com/content/www/us/en/support/intel-driver-support-assistant.html"; }

#
# Adobe Command
#

adobeInstalled() { [[ -f "$P32\Common Files\Adobe\OOBE\PDApp\UWA\UpdaterStartupUtility.exe" ]]; }
adobeCommand() { adobeInstalled || return 0; start "$P32\Adobe\Adobe Creative Cloud\ACC\Creative Cloud.exe"; }

#
# File Command
#

fileInstalled() { return 0; }
fileCommand() { SyncLocalFiles IsAvailable "$protocolArg" && SyncLocalFiles "$protocolArg" || return; }

#
# Micro Command
#

microInstalled() { return 0; }

microCommand()
{
	! UpdateNeeded "micro" && return
	MicroHelper update || return
	UpdateDone "micro" || return
}

#
# motd Command
#

motdInstalled() { return 0; }

motdCommand()
{
	local file="/var/run/motd.dynamic"
	{ [[ ! -f "$file" ]] || cmp -s "$HOME/.hushlogin" "$file"; } && return
	tee "$HOME/.hushlogin" < "$file" || return
}

#
# Node.js Command
#

nodeInstalled() { which node >& /dev/null; }

nodeCommand()
{
	{ ! nodeInstalled || ! UpdateNeeded "node"; } && return
	nodeInstalled || return 0
	ask 'npm update' -dr n && { sudo npm install -g npm@latest || return; }
	sudo npm update -g || return
	UpdateDone "node" || return
}

#
# Zsh Command
#

zshInstalled() { InPath zsh && [[ -d "$ohMyZsh/.git" ]]; }

zshCommand() 
{ 
	{ ! zshInstalled || ! UpdateNeeded "zsh"; } && return
	ZshHelper update || return
	UpdateDone "zsh" || return
}

#
# Python Command
#

pythonInstalled() { which pip3 >& /dev/null; }

pythonCommand()
{
	{ ! pythonInstalled || ! UpdateNeeded "python"; } && return
	
	for pkg in $( pip3 list --outdated --format=columns | cut -d' ' -f 1 | ${G}tail --lines=+3 ); do
		echo "Updating $pkg..."
    sudo -H pip3 install -U $pkg || return
	done

	UpdateDone "python" || return
}

#
# Ruby Command
#

rubyInstalled() { which gem >& /dev/null; }

rubyCommand()
{	
	{ ! rubyInstalled || IsPlatformAll mac,arm; } && return # gem is not functional on mac ARM

	local sudo="sudoc"; InPath rvm && unset sudo
	local args=( --no-document ) # documents take a while to install
	[[ "$PLATFORM" == "mac" ]] && { args+=( "-n /usr/local/bin" ); sudo="sudoc"; }

	UpdateNeeded "RubySystem" && { $sudo gem update --system "${args[@]}" || return; UpdateDone "RubySystem" || return; }
	UpdateNeeded "ruby" && { $sudo gem update "${args[@]}" || return; UpdateDone "ruby" || return; }

	return 0
}

run "$@"

#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	echot "\
Usage: $(ScriptName) [OPTION]... [HOST]...

	-p, --prompt		prompt for what to update
	-P,	--protocol	$(ScriptOptNetworkProtocolUsage)
	-f, --force			update the host even if it might be up to date
	-s, --skip LIST	comma seperated list of items to skip
	-w, --what LIST	comma seperated list of items to update

File syncronization:
	-do,	--dest-older	assume destination files are than the local source files
	-so,	--src-older		assume local files are older than the destination files
	-nb,	--no-bak			do not backup files to the bak directory

Items: adobe|file|intel|micro|motd|node|os|python|ruby|windows|zsh"
	exit $1
}

init()
{	
	defaultCommand="update"	
	what=( file fzf os store adobe motd node python ruby zsh )
	all=( "${what[@]}" brew debian intel mac micro windows wsl )
	ohMyZsh="$HOME/.oh-my-zsh"
}

argStart() { unset -v method noBak prompt protocol skipArg whatArg; skip=(); }

opt()
{
	case "$1" in
		-do|--dest-older|--destination-older) method="--dest-older";;
		-nb|--no-bak) noBak="--no-bak";;
		-p|--prompt) prompt="--prompt";;		
		-P|--protocol|-P=*|--protocol=*) ScriptOptNetworkProtocol "$@";;
		-s|--skip|-s=*|--skip=*) getItem "skip" "$@" || return;;
		-so|--src-older|--source-older) method="--src-older";;
		-w|--what|-w=*|--what=*) getItem "what" "$@" || return;;
		*) return 1;;
	esac
}

args() { hosts=( "$@" ); (( shift+=$# )); true; }

argEnd() 
{
	[[ $hosts ]] && { updateHosts; exit; }	
	[[ ! $prompt ]] && function ask { printf "${BLUE}%s${RESET}\n" "Updating $1..."; }
	return 0
}

getItem()
{
	local var="$1" value; shift
	local -n varArg="${var}Arg"

	# get the item argument
	ScriptOptGet "value" "$var" "$@" || return
	varArg="--$var=$value"
	StringToArray "${value,,}" "," "$var"

	# check for valid items
	local i items; StringToArray "${value,,}" "," items
	for i in "${items[@]}"; do
		! IsInArray "$i" all && { ScriptErr "'$i' is not a valid item"; exit 1; }
	done

	return 0
}

#
# commands
#

updateCommand()
{
	local i

	for i in "${what[@]}"; do
		IsInArray "$i" skip && continue
		${i}Installed && ask "$i" && { "${i}Update" || return; }
	done
}

#
# OS Update
#

osInstalled() { true; }

osUpdate()
{
	! UpdateNeeded "os" && return
	RunPlatform "os" || return
	UpdateDone "os" || return
}

# Debian Update

osDebian() { debianUpdate; }

osMac()
{
	ask "Brew update" && { brewUpdate || return; }
	ask "Mac update" && { macUpdate || return; }	
	return 0;
}

osQnap()
{
	! UpdateNeeded "qnap" && return
	sudo opkg update || return
	sudo opkg upgrade || return
	UpdateDone "qnap" || return
}

osWin()
{
	! UpdateNeeded "win" && return
	IsSsh && return 0 # these update requires a GUI
	ask "Windows update" && { windowsUpdate || return; }
	ask "WSL update" && { wslUpdate || return; }
	intelInstalled && ask "Intel update" && { intelUpdate || return; }
	UpdateDone "win"
}

#
# Adobe Update
#

adobeInstalled() { [[ -f "$P32\Common Files\Adobe\OOBE\PDApp\UWA\UpdaterStartupUtility.exe" ]]; }
adobeUpdate() { start "$P32\Adobe\Adobe Creative Cloud\ACC\Creative Cloud.exe"; }

#
# Debian Update
#

debianInstalled() { IsPlatform "debian"; }

debianUpdate()
{ 
	{ ! debianInstalled || ! UpdateNeeded "debian"; } && return

	# update the package list
	sudoc apt update || return

	# upgrade packages if needed
	! [[ "$(apt-check --human-readable 2>&1)" =~ "0 packages".* ]] && { sudo apt dist-upgrade -y || return; update="true"; }

	sudo apt autoremove -y || return

	# some packages are not listed in apt-check, update them if needed
	local done=""; sudo apt autoremove -y |& grep "0 not upgraded" >& /dev/null && done="true"
	[[ ! $done ]] && { sudo apt dist-upgrade -y || return; }

	[[ -f /var/run/reboot-required ]] && ask 'Reboot to finish the update' && { sudo reboot || return; }

	UpdateDone "debian" || return
}

#
# File Update
#

fileInstalled() { return 0; }

fileUpdate()
{
	IsLocalHostIp "$(ConfigGet fs)" && return # do not sync files to ourself
	! SyncLocalFiles IsAvailable "${protocolArg[@]}" && return
	SyncLocalFiles $method $noBak "${protocolArg[@]}" || return
}

#
# fzf Update
#

fzfInstalled() { [[ -d ~/.fzf ]]; }

fzfUpdate()
{
	{ ! fzfInstalled || ! UpdateNeeded "fzf"; } && return
	cd ~/.fzf || return
	git pull || return
	sudoc ~/.fzf/install --bin || return
	UpdateDone "fzf" || return
}

#
# Intel Update
#

intelInstalled() { [[ -d "$P32/Intel/Driver and Support Assistant" ]]; }
intelUpdate() {  start "https://www.intel.com/content/www/us/en/support/intel-driver-support-assistant.html"; }

#
# MacOS Update
#

brewInstalled() { InPath brew; }
brewUpdate()
{
	! UpdateNeeded "brew" && return
	brew doctor; # brew doctor on arm always returns failure on Big Sur and ARM
	brew update || return
	brew upgrade || return
	brew upgrade --cask || return
	UpdateDone "brew" || return
}

macInstalled() { IsPlatform mac; }

macUpdate()
{
	{ ! macInstalled || ! UpdateNeeded "mac"; } && return
	sudoc softwareupdate --list # --install --all
	UpdateDone "mac" || return
}

#
# Micro Update
#

microInstalled() { InPath "micro"; }

microUpdate()
{
	{ ! microInstalled || ! UpdateNeeded "micro"; } && return
	MicroHelper update || return
	UpdateDone "micro" || return
}

#
# motd Update
#

motdInstalled() { return 0; }

motdUpdate()
{
	local file="/var/run/motd.dynamic"
	{ [[ ! -f "$file" ]] || cmp -s "$HOME/.hushlogin" "$file"; } && return
	tee "$HOME/.hushlogin" < "$file" || return
}

#
# Node.js Update
#

nodeInstalled() { which node >& /dev/null; }

nodeUpdate()
{
	{ ! nodeInstalled || ! UpdateNeeded "node"; } && return
	ask 'npm update' -dr n && { sudo npm install -g npm@latest || return; }
	sudo npm update -g || return
	UpdateDone "node" || return
}

#
# Zsh Update
#

zshInstalled() { InPath zsh && [[ -d "$ohMyZsh/.git" ]]; }

zshUpdate() 
{ 
	{ ! zshInstalled || ! UpdateNeeded "zsh"; } && return
	ZshHelper update || return
	UpdateDone "zsh" || return
}

#
# Python Update
#

pythonInstalled() { which pip3 >& /dev/null; }

pythonUpdate()
{
	{ ! pythonInstalled || ! UpdateNeeded "python"; } && return
	
	for pkg in $( python3 -m pip list --outdated --format=columns | cut -d' ' -f 1 | ${G}tail --lines=+3 ); do
		echo "Updating $pkg..."
    python3 -m pip install -U $pkg || return
	done

	UpdateDone "python" || return
}

#
# Ruby Update
#

rubyInstalled() { which gem >& /dev/null; }

rubyUpdate()
{	
	{ ! rubyInstalled || IsPlatformAll mac,arm; } && return # gem is not functional on mac ARM

	local sudo="sudoc"; InPath asdf || InPathAny asdf rvm && unset sudo
	local args=( --no-document ) # documents take a while to install
	
	# do not update macOS bundled ruby
	[[ "$PLATFORM" == "mac" && "$(which ruby)" == "/usr/bin/ruby" ]] && { return 0; }

	# update
	UpdateNeeded "RubySystem" && { $sudo gem update --system "${args[@]}" || return; UpdateDone "RubySystem" || return; }
	UpdateNeeded "ruby" && { $sudo gem update "${args[@]}" || return; UpdateDone "ruby" || return; }

	return 0
}

#
# Store Update
#

storeInstalled() { IsPlatform win || { IsPlatform mac && InPath mas; }; }

storeUpdate()
{
	! UpdateNeeded "store" && return
	RunPlatform "store" || return
	UpdateDone "store" || return
}

storeWin() { return 0; store; } # store update often fails in Windows
storeMac() { mas upgrade; }

#
# Windows Update
#

windowsInstalled() { IsPlatform win; }
windowsUpdate() { FindInPath "wuapp.exe" > /dev/null && start "wuapp.exe" || cmd.exe /c start ms-settings:windowsupdate >& /dev/null; }

wslInstall() { IsPlatform win; }

wslUpdate()
{
	! UpdateNeeded "WSL" && return
	wsl update
	UpdateDone "WSL"
}

#
# helper
#

updateHosts()
{
	local h
	for h in "${hosts[@]}"; do
		header "Update $h"
		SshHelper connect -x -t "$h" -- HostUpdate $whatArg $skipArg $force $prompt $method $noBak --protocol=smb || return
	done
}

ScriptRun "$@"

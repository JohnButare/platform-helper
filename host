#!/bin/bash
. function.sh

usage()
{
	echot "\
usage: host available|boot|connect|info|start
	-t, --timeout								milliseconds to wait for the host
	-w, --wait [seconds](120)		wait for the host to become available 
	-q, --quiet									minimize messages
	available	<host>						check if host is available
	boot <host>|(<ip> <mac>)		boot the host
	connect <host>|(<ip> <mac>)	boot and remote control the host
	start <host> <program>			start a program on host using ssh or psexe
	info <host> [<var>]		 			get host information, variables are
		${fields[*]}"
	exit $1
}

init() 
{
	unset command host quiet wait
	fields=(host network sleep backup mobile install virtual platform port wake ips macs)
	fieldDefaults=(- - no no no no no - yes no -)
	timeout=(--timeout 200)
}

args()
{
	while [ "$1" != "" ]; do
		case "$1" in
			-h|--help) usage 0;;
			-t|--timeout) timeout=(--timeout $2); shift;;
			-q|--quiet) quiet=(--quiet);;
			-w|--wait) IsInteger $2 && { wait=(--wait $2); shift; } || wait=(--wait 120);;
			*) 
				[[ ! $command ]] && IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				! IsOption "$1" && [[ ! $host && "$command" == *(available|boot|connect|info|name|start) ]] && { GetHostArg "$@"; shift; continue; }			
				[[ "$command" == @(info|start) ]] && break
				UnknownOption "$1"
		esac
		shift
	done
	[[ ! $command ]] && MissingOperand "command"
	[[ ! $host && "$command" == *(available|boot|connect|info|name|start) ]] && MissingOperand "host"
	args=("$@")
}

GetHostArg()
{
	[[ $# == 0 ]] && MissingOperand "host"
	host="$1"
}

GetMacAddressArg()
{
	[[ $# == 0 ]] && MissingOperand "mac address"
	mac="$1"
}

run() {	init; args "$@"; ${command}Command "${args[@]}"; }

availableCommand()
{
	case "$host" in
		butare.net) return 0
	esac

	checkHost $host ${timeout[1]} && return 0
	[[ ! $wait ]] && return 1

	printf "Waiting ${wait[1]} seconds for $host..."

	for (( i=1; i<=${wait[1]}; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
		checkHost $host ${timeout[1]} && { echo "found in $i seconds"; return 0; }
		printf "."
	done

	echo "not found"
	return 1
}

# checkHost <host> <timeout> - minimize the time taken if the hostname is not found, or if the hostname is found and the host is not available
checkHost()
{
	local host="$1" timeout="$2" timeoutIncrease=0 ip port platform 

	if IsIpAddress "$host"; then
		ip="$host"
	elif ScriptEval host info $host; then
		ip="${ips[0]}"
	fi

	case "$host" in
		ExampleHostNeedingExtraPingTime) timeoutIncrease=200;;
		oversoul|jjbutare-mobl) timeoutIncrease=800;;
	esac
	(( timeout += $timeoutIncrease ))


	# Mac's respond to ping when asleep if any sharing services are enabled
	{ ! IsInteger "$port" && [[ "$platform" == "mac" ]] ; } && port=88

	if IsInteger "$port"; then
		[[ ! $ip ]] && { ip=$(IpAddress $host) || return; }
		ConnectToPort $ip $port $timeout
	else
		local pingHost="$host"
		[[ $ip ]] && pingHost="$ip"
		ping -n 1 -w $timeout $pingHost >& /dev/null
	fi

}

nameCommand()
{
	case "$host" in
		$COMPUTERNAME) echo "${host,,}"; return 0;;
		butare.net|nas) echo "nas"; return 0;; 
	esac

	infoCommand > /dev/null && { echo "${host,,}"; return 0; }

	quiet=(--quiet)
	name="$(startCommand hostname)"
	[[ ! $name ]] && name="$host"
	echo "${name,,}"
}

startCommand()
{
	availableCommand || { [[ ! $quiet ]] && echo "$host is not available"; return 1; }

	if ConnectToPort $host 22 $(( ${timeout[1]}*3 )) ; then
		ssh $host "$@"
	else
		platform="$(infoCommand platform)"
		[[ "$platform" == "win" ]] && psexec '\\'$host "$@" 2> /dev/null
	fi
}

infoCommand()
{
	local field

	(( $# > 0 )) && { field="$1"; shift; GetInfoFieldIndex "$field"; fieldIndex="$?"; }

	[[ $# != 0 ]] && usage 1

	line=( $(grep -i "^$host[	 ]" "$(ScriptDir)/HostInfo.txt") )
	[[ ! $line ]] && return 1

	# Specific field
	[[ $field ]] && { GetInfoValue $fieldIndex; echo "${!field}"; return; }

	# All fields
 	for (( i=0; i<${#fields[@]}; ++i )); do GetInfoValue $i; done
 	ScriptReturn "${fields[@]}"
}

GetInfoValue() # GetInfoValue index - uses fields, fieldDefaults, line[], sets the field name
{
	local index="$1" 
	local field="${fields[$index]}"
	eval ${field}="${line[$index]}"

	case "$field" in
		ips|macs) IFS='-' read -r -a $field <<< "${!field}";;
		*) [[ "$value" == "-" ]] && $field="${fieldDefaults[$index]}";;
	esac
}

GetInfoFieldIndex()
{
	IsInArray "$1" fields && return $isInIndex
	EchoErr "$field is not a valid variable.  Valid variables are ${fields[@]}"; exit 1;
}

connectCommand()
{
	! host available "$host" && { host boot "$host" --wait 30 || return; }
	[[ "$(host info "$host" platform)" == "win" ]] && ConnectWindows || ConnectOther
}

ConnectOther() { VisionApp "$host"; }

ConnectWindows()
{
	local suffix="Remote Desktop/$host.rdp" rdp

	ScriptEval os FindDirs || return

	if [[ -f "$_UserData/$suffix" ]]; then
		rdp="$_UserData/$suffix"
	elif [[ -f "$_CloudData/$suffix" ]]; then
		rdp="$_CloudData/$suffix"
	fi

	if [[ $rdp ]]; then
		start "$rdp"
	else
		start mstsc /f /v:$host
	fi
}

bootCommand()
{
	local ip="$host" macAddress subNet=255.255.255.0

	IsIpAddress "$host" && { GetMacAddressArg "$1"; shift; }
	[[ $# != 0 ]] && UnknownOption "$1"

 	host available "$host" && { echo "Host $host is already awake"; return; }

	if [[ ! $macAddress ]]; then
		ScriptEval host info "$host" || return
		ip="${ips[0]}"
		mac="${macs[0]}"
	fi

	[[ ! $mac ]] && { MissingOperand "mac address"; }

 	echo "Sending wakeup packet to $host..."
	PowerOff wol -ip "$ip" -subnet "$subNet" -mac "$mac" || return
	availableCommand
}

run "$@"

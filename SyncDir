#!/usr/bin/env bash
. script.sh || exit

run() {	init && args "$@" && "${command}Command" "${args[@]}"; }

init() { :; }

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... SRC DEST
Synchronize the source and destination directories.

	-di, --dest-id  			destination unique identifier
	-do, --dest-older			assume the destination files are older
	-d, --dir 						directory suffix, added to src and dest
	-e, --exist						source and destination directories must exist, otherwise exit silently
	-nb, --no-bak					do not back up replaced files
	-p, --protocol=[NFS|SMB|SSH|INTEGER](SMB) use the specified protocol for file sharing
	-r, --recursive				synchronize subdirectories
	-si, --src-id  				source unique identifier
	-so, --src-older			assume the source files are older
	-v, --verbose					show additional status
	-x, --exclude	FILES 	one or more files or directories to skip"
	exit $1
}

init() { lastSyncSuffix="sync.txt"; }

args()
{
	unset -v dest destId dir exist method noBak protocol recursive src srcId uncArgs verbose x

	# commands
	ScriptCommand syncCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-d|--dir|-d*|--dir=*) ScriptArg "dir" "$@";;
			-di|--destid|-di*|--destid=*) ScriptArg "destId" "$@";;
			-do|--dest-older) method="--dest-older";;
			-e|--exist) exist="--exist";;
			-h|--help) usage 0;;
			-nb|--no-bak) noBak="--no-bak";;
			-p|--protocol|-p*|--protocol=*) ScriptGetNetworkProtocol "$@"; [[ $protocol ]] && uncArgs+=(--protocol "$protocol");;
			-r|--recursive) recursive="--recursive";;
			-si|--srcid|-si*|--srcid=*)  ScriptArg "srcId" "$@";;
			-so|--src-older|-so*|--src-older=*) method="--src-older";;
			-v|--verbose) verbose="--verbose"; uncArgs+=("$verbose");;
			-x|--exclude) while [[ $2 ]] && ! IsOption "$2"; do x+=("$2"); shift; done;;
			--) shift; otherArgs+=("$@"); set --; break;;
			*) ScriptOption "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"
	
	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	ScriptGetArg "src" "$1"; shift
	ScriptGetArg "dest" "$1"; shift
	[[ $@ ]] && usage

	x+=( ".*$lastSyncSuffix" )
	src="$src/$dir"; RemoveTrailingSlash "$src" src
	dest="$dest/$dir"; RemoveTrailingSlash "$dest" dest
	args=("$src" "$dest")
}

syncCommand()
{
	local src="$1" dest="$2"

	# src or dest directory is excluded
	{ IsInArray --array-wild "${src##*/}" x || IsInArray --array-wild "${dest##*/}" x; } && return

	[[ $verbose ]] && printf "SyncDir: src=$(getSrcDesc) dest=$(getDestDesc) srcId=$srcId destId=$destId..."
	IsUncPath "$src" && { src="$(unc mount "$src" "${uncArgs[@]}")" || { printf "\nUnable to mount $(getSrcDesc)\n"; return 1; }; }
	IsUncPath "$dest" && { dest="$(unc mount "$dest" "${uncArgs[@]}")" || { printf "\nUnable to mount $(getDestDesc)\n"; return 1; }; }
	[[ $exist && (! -d "$src" && ! -d "$dest") ]] && return 0

	if [[ ! -d "$src" && ! -d "$dest" ]]; then
		echo
		EchoErr "Source ($(getSrcDesc)) and destination ($(getDestDesc)) directories do not exist"
		return 1
	fi

	local lastSyncSrcFile="$src/.${destId}_${lastSyncSuffix}"
	local lastSyncDestFile="$dest/.${srcId}_${lastSyncSuffix}"

	getLastSync || return

	if [[ ! -d "$src" ]]; then
			case "${method##--}" in
				dest-older) deleteMissingDir --quiet "$dest";;
				src-older) copyMissingDir "$dest" "$src";;
				*) syncMissingDir "$dest" "$src";;
			esac || return		
	elif [[ ! -d "$dest" ]]; then
			case "${method##--}" in
				dest-older) copyMissingDir "$src" "$dest";;
				src-older) deleteMissingDir --quiet "$src";;
				*) syncMissingDir "$src" "$dest";;
			esac || return		
	else
		sync "$src" "$dest" || return
	fi

	setLastSync || return
}

#
# helper
#

desc() { FileToDesc "$1"; }
getSrcDesc() { desc "$src"; }
getDestDesc() { desc "$dest"; }

sync()
{
	local src="$1" dest="$2"
	local srcFiles destFiles srcIndex=0 destIndex=0 lastSrcIndex lastDestIndex
	local ignoreMs convertTime srcLine destLine srcFile destFile srcOnlyFiles destOnlyFiles

	#printf "\nSyncing %s\n" "$(GetFileName "$src")"
	getFileList srcFiles "$src"; [[ $verbose ]] && printf "src..." || printf "."
	getFileList destFiles "$dest";  [[ $verbose ]] && echo "dest" || printf "."
	lastSrcIndex="${#srcFiles[@]}"; lastDestIndex="${#destFiles[@]}"

	while (( srcIndex<lastSrcIndex || destIndex<lastDestIndex )); do

		srcLine="${srcFiles[$srcIndex]}"
		destLine="${destFiles[destIndex]}"
	
		# quick check
		if [[ "$srcLine" == "$destLine" ]]; then
			(( ++srcIndex, ++destIndex ))
			continue;
		fi
		
		srcFile="${srcLine%	*	*}"; destFile="${destLine%	*	*}"
		#printf 'sync: difference in file "%s"' "$srcFile"; IsInArray --array-wild "$srcFile" x && echo " (excluded)" || echo; pause

		if [[ "$srcFile" == "$destFile" ]]; then
			! IsInArray --array-wild "$srcFile" x && { syncFile "$src" "$dest" || return; }
			(( ++srcIndex, ++destIndex ))

		elif [[ $srcFile && ( "$destFile" == "" || "$srcFile" < "$destFile" ) ]]; then
			! IsInArray --array-wild "$srcFile" x && srcOnlyFiles+=("$srcFile")
			(( ++srcIndex ))

		elif [[ "$srcFile" == "" || "$destFile" < "$srcFile" ]]; then
			! IsInArray --array-wild "$destFile" x && destOnlyFiles+=("$destFile")
			(( ++destIndex ))
		
		fi
	done

	case "${method##--}" in
		dest-older)
			deleteFiles "$dest" "${destOnlyFiles[@]}" || return
			copyFiles "$src" "$dest" "${srcOnlyFiles[@]}" || return;;
		src-older)
			deleteFiles "$src" "${srcOnlyFiles[@]}" || return
			copyFiles "$dest" "$src" "${destOnlyFiles[@]}" || return;;
		*) 
			syncMissingFiles "$src" "$dest" "${srcOnlyFiles[@]}" || return
			syncMissingFiles "$dest" "$src" "${destOnlyFiles[@]}" || return
	esac

	[[ ! $recursive ]] && return

	local srcDirs destDirs dir

	getDirList srcDirs "$src"
	for dir in "${srcDirs[@]}"; do
		syncCommand "$src/$dir" "$dest/$dir" || return
	done

	getDirList destDirs "$dest"
	for dir in "${destDirs[@]}"; do
		IsInArray "$dir" srcDirs && continue
		syncCommand "$src/$dir" "$dest/$dir" || return
	done

}

syncFile()
{
	local src="$1" dest="$2"
	local srcPath="$src/$srcFile" destPath="$dest/$destFile" 
	local srcPathDesc="$(desc "$src/$srcFile")" destPathDesc="$(desc "$dest/$destFile")"
	local srcInfo srcFileSize srcFileAge destInfo destFileSize destFileAge ext
	local desc="$srcFile" srcDesc destDesc

	IFS="	" read srcFileSize srcFileAge <<< "${srcLine#$srcFile	}"
	IFS="	" read destFileSize destFileAge <<< "${destLine#$destFile	}"
	
	[[ $convertTime ]] && { srcFileAge="$(GetSeconds "$srcFileAge")"; destFileAge="$(GetSeconds "$destFileAge")"; }
	GetFileExtension "$srcFile" ext

	# printf "syncFile $srcPath to $destPath\n"
	# printf 'src="%s" srcFileSize=%s srcFileAge=%s\n' "$src" "$srcFileSize" "$srcFileAge"
	# printf 'dest="%s" destFileSize=%s destFileAge=%s\n' "$dest" "$destFileSize" "$destFileAge"
	# pause

	if (( srcFileSize==destFileSize )) && diff "$srcPath" "$destPath" > /dev/null; then
		local srcFileDate="$(${G}date -d @$srcFileAge)" destFileDate="$(${G}date -d @$destFileAge)"
		# printf "$srcFile (src=$srcFileDate dest=$destFileDate)..."
		# printf "\nsrcFileAge=%s-%s\ndestFileAge=%s-%s\n" "$srcFileDate" "$srcFileAge" "$destFileDate" "$destFileAge"
		# pause
		#stat "$srcPath"; stat "$destPath"
		syncFileTimes "$srcPath" "$srcFileAge" "$destPath" "$destFileAge" || return
		return
	fi

	case "$method" in
	--dest-older) replaceFile "$srcPath" "$destPath" "$desc"; return;;
	--src-older) replaceFile "$destPath" "$srcPath" "$desc"; return;;
	esac

	if CompareSeconds $destFileAge '<' $srcFileAge; then
		local older="$dest" olderAge="$destFileAge" destDesc="older" newer="$src" srcDesc="newer"
		local olderDesc="$destPathDesc" newerDesc="$srcPathDesc"
		desc=">$desc"
	else
		local older="$src" olderAge="$srcFileAge" srcDesc="older" newer="$dest" destDesc="newer"
		local olderDesc="$srcPathDesc" newerDesc="$destPathDesc"
		desc="<$desc"
	fi
	local olderPath="$older/$srcFile" newerPath="$newer/$srcFile"

	if [[ $lastSync ]] && CompareSeconds $olderAge '<=' $lastSync; then
		replaceFile "$newerPath" "$olderPath" "$desc"; return
	fi

	printf "\n\nDifferences:\n"
	local diff="diff"; InPath colordiff && diff="colordiff"
	$diff "$srcPath" "$destPath"
	echo

	printf "%s: %s %s (%s bytes)\n" "$srcDesc" "$srcPathDesc" "$(ShowSimpleTime @$srcFileAge)" "$srcFileSize"
	printf "%s: %s %s (%s bytes)\n" "$destDesc" "$destPathDesc" "$(ShowSimpleTime @$destFileAge)" "$destFileSize"

	local defaultChoice=3
	case $ext in
		dll|exe|com) defaultChoice=3;; # ReplaceOlder
		*) defaultChoice=1;; # EditBoth
	esac

	while true; do
		ask ' (1) Edit (2) Delete (3) Replace older (4) Replace newer' -vr 1234 -dr $defaultChoice

		case $(( $?+1 )) in
		  1)  # edit
				merge --wait "$olderPath" "$newerPath"
		    if (( $? != 1 )); then
		    	echo "$srcFile is still diferent"
	    		continue
	  		fi
	  		setFileTimes "$srcPath" "$destPath" || return
	  		;;
		  2) # delete

				if [[ $noBak ]]; then
					rm -f "$srcPath" "$destPath" || return
				else
					bak --local --quiet "$srcPath" "$destPath" || return
				fi;;
			3) replaceFile "$newerPath" "$olderPath" "$olderDesc"; return;;
	  	4) replaceFile "$olderPath" "$newerPath" "$newerDesc"; return;;
		esac
		return
	done
}

copyMissingDir()
{
	local src="$1" dest="$2"
	local finalSrcDir="$(GetFileName "$(RemoveTrailingSlash "$src")")"

	echo "$finalSrcDir..."
	CopyDir "$src" "$dest" $recursive || return
}

deleteMissingDir() 
{ 
	local ask="--ask"; [[ "$1" == "--quiet" ]] && { unset ask; shift; } 
	local dir="$1"
	
	DelDir $ask --verbose "$dir"
}

copyFile()
{
	local src="$1" dest="$2" desc="$3"

	printf "$(GetFileName "$desc")..."
	# ${G}cp --force --preserve=timestamps "$src" "$dest" || return
	${G}cp --force "$src" "$dest" || return # --preserve=timestamps does not work reliably
	${G}touch "$dest" --reference "$src" || return
}

copyFiles()
{
	local src="$1" dest="$2"; shift 2
	local files=("$@")

	for file in "${files[@]}"; do
		copyFile "$src/$file" "$dest/$file" "$src/$file" || return
	done
}

deleteFiles()
{
	local dir="$1"; shift
	local desc files=("$@")
	
	for file in "${files[@]}"; do
		if [[ $noBak ]]; then
			printf "\nRemoving \`$(desc "$dir/$file")\`..."
			rm -f "$dir/$file" || return
			printf "done\n"
		else
			bak --move --local --quiet "$dir/$file" || return
		fi
	done
}

getDirList() 
{ 
	IFS=$'\n' read -d '' -r -a $1 < <(\
		${G}find "$2" -maxdepth 1 -type d -printf "%f\n" | tail -n +2 | RemoveEmptyLines | sort); 
}

# getFileList() - get files, each file attributes requested individually, very slow over WebDAV, timestamp in milliseconds
getFileList() 
{
	local result="$1" dir="$2" lines

 	IFS=$'\n' read -d '' -r -a lines < <(\
 		${G}find "$dir" -maxdepth 1 -type f -not -iname ".*$lastSyncSuffix" -printf "%f\t%s\t%T@\n" | sort); 

 	# always ignore ms - ignore thrash
	ignoreMs="true"

	# check if we should ignore millisconds (not present for nas)
	if [[ ! $ignoreMs ]]; then
		local ms="${lines[0]##*.}${lines[1]##*.}${lines[2]##*.}${lines[3]##*.}"
		[[ "$ms" == *(0) ]] && ignoreMs="true"
	fi

	for (( i = 0; i < ${#lines[@]}; i++ )); do
		[[ $ignoreMs ]] && line="${lines[$i]%.*}" || line="${lines[$i]}"
		printf -v $result[$i] -- "$line"
	done
}

getLastSync()
{
	lastSync=0

	if [[ -f "$lastSyncSrcFile" ]]; then
		# Call GetSeconds to ensure we have a valid timestamp
		lastSync="$(GetSeconds "$(<"$lastSyncSrcFile")" 2> /dev/null)"
		[[ ! $lastSync ]] && lastSync=0
	fi

	# printf 'lastSync="%s" (%s)\n' "$(ShowTime "@$lastSync")" "$lastSync"
	return 0
}

promptForFiles()
{
	local operation="$1" desc="$2"; shift 2
	local result items status="on"

	[[ "$operation" == "delete" ]] && status="off"

	for file in "${files[@]}"; do
		items+=( "$file" "" "$status" )
	done

	result=$(dialog --stdout --title "Synchronizing Files" \
		--backtitle "$desc" \
  	--checklist "Choose files to $operation:" $(($LINES-5)) 50 $(($LINES)) -- "${items[@]}")
	clear

	eval results=( $result )
	(( ${#results[@]} == 0 )) && return

	# operate on selected files
	"$@" "${results[@]}" || return

	# remove selected results from the files to process
	ArrayRemove files "${results[@]}"
}

replaceFile()
{
	local src="$1" dest="$2" desc="$3"

	if [[ ! "$noBak" ]]; then
		bak --local --quiet "$dest" || return
	fi

	printf "$(GetFileName "$desc")..."; [[ $verbose ]] && echo
	# ${G}cp --force --preserve=timestamps "$src" "$dest" || return
	${G}cp --force "$src" "$dest" || return # --preserve=timestamps does not work reliably
	${G}touch "$dest" --reference "$src" || return
}

setLastSync() 
{
	[[ ! -d "$src" || ! -d "$dest" ]] && return 0
	
	local hide newSync=$(GetSeconds) hideFile

	[[ "$PLATFORM" == "win" && ! -f "$lastSyncSrcFile" ]] && hide="true"

	{ echo "@$newSync" >& "$lastSyncSrcFile"; } >& /dev/null || { rm -f "$lastSyncSrcFile"; echo "@$newSync" > "$lastSyncSrcFile" || return; }
	{ echo "@$newSync" >& "$lastSyncDestFile"; } >& /dev/null || { rm -f "$lastSyncDestFile"; echo "@$newSync" > "$lastSyncDestFile" || return; }

	if IsPlatform win && [[ $hide ]]; then
		FileHide "$lastSyncSrcFile" || return;
		FileHide "$lastSyncDestFile" || return;
	fi

	# cleanup sync files older than 30 days
	find "$src" -name ".*$lastSyncSuffix" -mtime +30 -type f -delete
	find "$dest" -name ".*$lastSyncSuffix" -mtime +30 -type f -delete

	return 0
}

# syncFileTimes() - touch not functional over WebDAV
syncFileTimes()
{
	local f1="$1" f1Age="$2" f2="$3" f2Age="$4"

	#stat $f1; stat $f2
	if CompareSeconds "$f1Age" '>' "$f2Age"; then
		${G}touch "$f2" --reference "$f1"  
		#stat "$f2"; pause
	else
		${G}touch "$f1" --reference "$f2"
		#stat "$f1"; pause
	fi
}

setFileTimes()
{
	local now="$(GetSeconds)"
	for file in "$@"; do
		${G}touch "$file" -d "@$now"
		#stat "$file"
	done
}

syncMissingDir()
{
	local src="$1" dest="$2"

	echo "Directory $(desc "$dest") does not exist"
	ask "Do you want to (d)elete or (c)opy directory \`$(desc "$src")?\`" -vr dc -dr c
	if [[ $? == 0 ]]; then
		deleteMissingDir "$src"
	else
		copyMissingDir "$src" "$dest"
	fi

}

syncMissingFiles()
{
	local src="$1" dest="$2"; shift 2
	local files=("$@")

	[[ ! $files ]] && return 0

	while (( ${#files[@]} != 0 )); do
		printf "\n\nSync files only in \`$(desc "$src")\` directory: "
		ArrayShow files

		ask '  (1) Copy All (2) Delete All (3) Copy Some (4) Delete Some' -vr 1234 -dr 1

		case $(( $? + 1 )) in
			1) copyFiles "$src" "$dest" "${files[@]}" || return; unset files;;
		 	2) deleteFiles "$src" "${files[@]}" || return; unset files;;
			3) promptForFiles "copy" "Synchronizing files from $src to $dest" || return;;
			4) promptForFiles "delete" "Deleting files from $src" || return;;
		esac

	done
}

run "$@"

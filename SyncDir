#!/usr/bin/env bash
. function.sh

# test: 
# SyncDir --SrcId jjbutare-mobl --DestId jjbutare-mobl7 /cygdrive/c/Users/Public/documents/data/archive //jjbutare-mobl7/c\$/Users/Public/documents/data/archive
# SyncDir --SrcId jjbutare-mobl --DestId nas1 /cygdrive/c/Users/Public/documents //butare.net@ssl@5006/public/documents -d data/bin/mac

usage()
{
	echot "\
usage: SyncDir <src> <dest>
	Synchronize the source and destination directories.  The last synchronization time is used
	to perform conflict resolution

	-di, --dest-id  			destination unique identifier
	-do, --dest-older			assume the destination files are older
	-d, --dir 						directory suffix, added to src and dest
	-e, --exist						source and destination directories must exist, otherwise exit silently
	-nb, --no-bak					do not back up replaced files
	-r, --recursive				synchronize subdirectories
	-si, --src-id  				source unique identifier
	-so, --src-older			assume the source files are older
	-x, --exclude	FILES 	one or more files or directories to skip"
	exit $1
}

init() 
{
	lastSyncSuffix="sync.txt";
}

args()
{
	unset dest destId dir exist method noBak recursive src srcId x
	while [ "$1" != "" ]; do
		case "$1" in
			-d|--dir) dir="$2"; shift;;
			-di|--destid) destId="$2_"; shift;;
			-do|--dest-older) method="--dest-older";;
			-e|--exist) exist="--exist";;
			-nb|--no-bak) noBak="--no-bak";;
			-r|--recursive) recursive="--recursive";;
			-si|--srcid) srcId="$2_"; shift;;
			-so|--src-older) method="--src-older";;
			-x|--exclude) while [[ $2 ]] && ! IsOption "$2"; do x+=("$2"); shift; done;;
			-h|--help) IsFunction "${command}Usage" && ${command}Usage || usage 0;;
			*)
				! IsOption "$1" && [[ ! $src ]] && { src="$1"; shift; continue; }
				! IsOption "$1" && [[ ! $dest ]] && { dest="$1"; shift; continue; }
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $src ]] && MissingOperand "src"
	[[ ! $dest ]] && MissingOperand "dest"

	args=("$@")
	src="$src/$dir"; RemoveTrailingSlash "$src" src
	dest="$dest/$dir"; RemoveTrailingSlash "$dest" dest
	x+=( ".*$lastSyncSuffix" )
}

SyncDirCommand()
{
	local src="$1" dest="$2" srcDesc="$3" descDesc="$4"

	[[ "$srcDesc" ]] || srcDesc="$src"
	[[ "$destDesc" ]] || destDesc="$dest"

	# src or dest directory is excluded
	{ IsInArray -aw "${src##*/}" x || IsInArray -aw "${dest##*/}" x; } && return

	local srcOrig="$src" destOrig="$dest"
	IsUncPath "$src" && { src="$(unc mount "$src")" || { printf "\nUnable to mount $srcOrig\n"; return 1; }; }
	IsUncPath "$dest" && { dest="$(unc mount "$dest")" || { printf "\nUnable to mount $destOrig\n"; return 1; }; }

	[[ $exist && (! -d "$src" && ! -d "$dest") ]] && return 0

	if [[ ! -d "$src" && ! -d "$dest" ]]; then
		echo
		EchoErr "Source ($srcDesc) and destination ($destDesc) directories do not exist"
		return 1
	fi

	local lastSyncSrcFile="$src/.$destId$lastSyncSuffix"
	local lastSyncDestFile="$dest/.$srcId$lastSyncSuffix"

	GetLastSync

	if [[ ! -d "$src" ]]; then
			case "${method##--}" in
				dest-older) DeleteMissingDir --quiet "$dest" "$destDesc";;
				src-older) CopyMissingDir "$dest" "$src" "$destDesc" "$srcDesc";;
				*) SyncMissingDir "$dest" "$src" "$destDesc" "$srcDesc";;
			esac || return		
	elif [[ ! -d "$dest" ]]; then
			case "${method##--}" in
				dest-older) CopyMissingDir "$src" "$dest"  "$srcDesc" "$destDesc";;
				src-older) DeleteMissingDir --quiet "$src" "$srcDesc";;
				*) SyncMissingDir "$src" "$dest"  "$srcDesc" "$destDesc";;
			esac || return		
	else
		sync "$src" "$dest"  "$srcDesc" "$destDesc" || return
	fi

	SetLastSync
}

sync()
{
	local src="$1" dest="$2" srcDesc="$3" destDesc="$4" 
	local srcFiles destFiles srcIndex=0 destIndex=0 lastSrcIndex lastDestIndex
	local ignoreMs convertTime srcLine destLine srcFile destFile srcOnlyFiles destOnlyFiles

	#printf "\nSyncing %s\n" "$(GetFileName "$srcDesc")"
	GetFileList srcFiles "$src" "$srcDesc"; printf "."; GetFileList destFiles "$dest" "$destDesc"; printf "."; 
	lastSrcIndex="${#srcFiles[@]}"; lastDestIndex="${#destFiles[@]}"; printf "."

	while (( srcIndex<lastSrcIndex || destIndex<lastDestIndex )); do

		srcLine="${srcFiles[$srcIndex]}"
		destLine="${destFiles[destIndex]}"
	
		# quick check
		if [[ "$srcLine" == "$destLine" ]]; then
			(( ++srcIndex, ++destIndex ))
			continue;
		fi
		
		srcFile="${srcLine%	*	*}"; destFile="${destLine%	*	*}"
		#printf 'SyncFile: difference in file "%s"' "$srcFile"; IsInArray --array-wild "$srcFile" x && echo " (excluded)" || echo; pause

		if [[ "$srcFile" == "$destFile" ]]; then
			! IsInArray --array-wild "$srcFile" x && { SyncFile "$src" "$dest" "$srcDesc" "$destDesc" || return; }
			(( ++srcIndex, ++destIndex ))

		elif [[ $srcFile && ( "$destFile" == "" || "$srcFile" < "$destFile" ) ]]; then
			! IsInArray --array-wild "$srcFile" x && srcOnlyFiles+=("$srcFile")
			(( ++srcIndex ))

		elif [[ "$srcFile" == "" || "$destFile" < "$srcFile" ]]; then
			! IsInArray --array-wild "$destFile" x && destOnlyFiles+=("$destFile")
			(( ++destIndex ))
		
		fi
	done

	case "${method##--}" in
		dest-older)
			DeleteFiles "$dest" "$destDesc" "${destOnlyFiles[@]}" || return
			CopyFiles "$src" "$dest" "$srcDesc" "$destDesc" "${srcOnlyFiles[@]}" || return;;
		src-older)
			DeleteFiles "$src" "$srcDesc" "${srcOnlyFiles[@]}" || return
			CopyFiles "$dest" "$src" "$destDesc" "$srcDesc" "${destOnlyFiles[@]}" || return;;
		*) 
			SyncMissingFiles "$src" "$dest" "$srcDesc" "$destDesc" "${srcOnlyFiles[@]}" || return
			SyncMissingFiles "$dest" "$src" "$destDesc" "$srcDesc" "${destOnlyFiles[@]}" || return
	esac

	[[ ! $recursive ]] && return

	local srcDirs destDirs dir

	GetDirList srcDirs "$src"
	for dir in "${srcDirs[@]}"; do
		[[ "$dir" == @(bak) ]] && continue
		SyncDirCommand "$src/$dir" "$dest/$dir" "$srcDesc/$dir" "$destDesc/$dir" || return
	done

	GetDirList destDirs "$dest"
	for dir in "${destDirs[@]}"; do
		[[ "$dir" == @(bak) ]] && continue
		IsInArray "$dir" srcDirs && continue
		SyncDirCommand "$src/$dir" "$dest/$dir" "$srcDesc/$dir" "$destDesc/$dir" || return
	done

}

SyncFile()
{
	local src="$1" dest="$2" srcDesc="$3" destDesc="$4"
	local srcPath="$src/$srcFile" destPath="$dest/$destFile" srcPathDesc="$srcDesc/$srcFile" destPathDesc="$destDesc/$destFile"
	local srcInfo srcFileSize srcFileAge destInfo destFileSize destFileAge ext
	local desc="$srcFile"

	IFS="	" read srcFileSize srcFileAge <<< "${srcLine#$srcFile	}"
	IFS="	" read destFileSize destFileAge <<< "${destLine#$destFile	}"
	
	[[ $convertTime ]] && { srcFileAge="$(GetSeconds "$srcFileAge")"; destFileAge="$(GetSeconds "$destFileAge")"; }
	GetFileExtension "$srcFile" ext

	# printf "SyncFile $srcPath to $destPath\n"
	# printf 'src="%s" srcFileSize=%s srcFileAge=%s\n' "$src" "$srcFileSize" "$srcFileAge"
	# printf 'dest="%s" destFileSize=%s destFileAge=%s\n' "$dest" "$destFileSize" "$destFileAge"
	# pause

	if (( srcFileSize==destFileSize )) && diff "$srcPath" "$destPath" > /dev/null; then
		local srcFileDate="$(${G}date -d @$srcFileAge)" destFileDate="$(${G}date -d @$destFileAge)"
		# printf "$srcFile (src=$srcFileDate dest=$destFileDate)..."
		# printf "\nsrcFileAge=%s-%s\ndestFileAge=%s-%s\n" "$srcFileDate" "$srcFileAge" "$destFileDate" "$destFileAge"
		# pause
		#stat "$srcPath"; stat "$destPath"
		SyncFileTimes "$srcPath" "$srcFileAge" "$destPath" "$destFileAge" || return
		return
	fi

	case "$method" in
	--dest-older) ReplaceFile "$srcPath" "$destPath" "$desc"; return;;
	--src-older) ReplaceFile "$destPath" "$srcPath" "$desc"; return;;
	esac

	if CompareSeconds $destFileAge '<' $srcFileAge; then
		local older="$dest" olderAge="$destFileAge" destDesc="older" newer="$src" srcDesc="newer"
		local olderDesc="$destPathDesc" newerDesc="$srcPathDesc"
		desc=">$desc"
	else
		local older="$src" olderAge="$srcFileAge" srcDesc="older" newer="$dest" destDesc="newer"
		local olderDesc="$srcPathDesc" newerDesc="$destPathDesc"
		desc="<$desc"
	fi
	local olderPath="$older/$srcFile" newerPath="$newer/$srcFile"

	if [[ $lastSync ]] && CompareSeconds $olderAge '<=' $lastSync; then
		ReplaceFile "$newerPath" "$olderPath" "$desc"; return
	fi

	printf "\n\nDifferences:\n"
	diff "$srcPath" "$destPath"
	echo

	printf "%s: %s %s (%s bytes)\n" "$srcDesc" "$srcPathDesc" "$(ShowSimpleTime @$srcFileAge)" "$srcFileSize"
	printf "%s: %s %s (%s bytes)\n" "$destDesc" "$destPathDesc" "$(ShowSimpleTime @$destFileAge)" "$destFileSize"

	local defaultChoice=3
	case $ext in
		dll|exe|com) defaultChoice=3;; # ReplaceOlder
		*) defaultChoice=1;; # EditBoth
	esac

	while true; do
		ask ' (1) Edit (2) Delete (3) Replace older (4) Replace newer' -vr 1234 -dr $defaultChoice

		case $(( $?+1 )) in
		  1)  # edit
				merge --wait "$olderPath" "$newerPath"
		    if (( $? != 1 )); then
		    	echo "$srcFile is still diferent"
	    		continue
	  		fi
	  		SetFileTimes "$srcPath" "$destPath" || return
	  		;;
		  2) # delete

				if [[ $noBak ]]; then
					rm -f "$srcPath" "$destPath" || return
				else
					bak --local --quiet "$srcPath" "$destPath" || return
				fi;;
			3) ReplaceFile "$newerPath" "$olderPath" "$olderDesc"; return;;
	  	4) ReplaceFile "$olderPath" "$newerPath" "$newerDesc"; return;;
		esac
		return
	done
}

SyncMissingFiles()
{
	local src="$1" dest="$2" srcDesc="$3" destDesc="$4"; shift 4
	local files=("$@")

	[[ ! $files ]] && return 0

	while (( ${#files[@]} != 0 )); do
		printf "\n\nSync files only in $srcDesc directory: "
		ShowArray files

		ask '  (1) Copy All (2) Delete All (3) Copy Some (4) Delete Some' -vr 1234 -dr 1

		case $(( $? + 1 )) in
			1) CopyFiles "$src" "$dest" "$srcDesc" "$destDesc" "${files[@]}" || return; unset files;;
		 	2) DeleteFiles "$src" "$srcDesc" "${files[@]}" || return; unset files;;
			3) PromptForFiles "copy" "Synchronizing files from $srcDesc to $destDesc" "CopyFiles" "$src" "$dest" "$srcDesc" "$destDesc" || return;;
			4) PromptForFiles "delete" "Deleting files from $srcDesc" "DeleteFiles" "$src" "$srcDesc" || return;;
		esac

	done
}

SyncMissingDir()
{
	local src="$1" dest="$2" srcDesc="$3" destDesc="$4"

	echo "Directory $destDesc does not exist"
	ask "Do you want to (D)elete or (C)opy directory \"$srcDesc?\"" -vr DC -dr C
	if [[ $? == 0 ]]; then
		DeleteMissingDir "$src" "$srcDesc"
	else
		CopyMissingDir "$src" "$dest" "$srcDesc" "$destDesc"
	fi	
}

CopyMissingDir()
{
	local src="$1" dest="$2" srcDesc="$3" destDesc="$4"
	CopyDir "$src" "$dest" $recursive
}

DeleteMissingDir() 
{ 
	local ask="--ask"; [[ "$1" == "--quiet" ]] && { unset ask; shift; } 
	local dir="$1" dirDesc="$2"
	
	DelDir $ask --verbose "$dir"
}

GetLastSync()
{
	lastSync=0

	if [[ -f "$lastSyncSrcFile" ]]; then
		# Call GetSeconds to ensure we have a valid timestamp
		lastSync="$(GetSeconds "$(<"$lastSyncSrcFile")" 2> /dev/null)"
		[[ ! $lastSync ]] && lastSync=0
	fi

	# printf 'lastSync="%s" (%s)\n' "$(ShowTime "@$lastSync")" "$lastSync"
}

SetLastSync() 
{
	[[ ! -d "$src" || ! -d "$dest" ]] && return 0
	
	local hide newSync=$(GetSeconds) hideFile

	[[ "$PLATFORM" == "win" && ! -f "$lastSyncSrcFile" ]] && hide="true"

	echo "@$newSync" > "$lastSyncSrcFile" || return
	echo "@$newSync" > "$lastSyncDestFile" || return

	if IsPlatform win && [[ $hide ]]; then
		attrib.exe +h "$(utw "$lastSyncSrcFile")" || return;
		attrib.exe +h "$(utw "$lastSyncDestFile")" || return;
	fi;

	return 0
}

GetFileList() 
{
	if IsPlatform cygwin; then
		GetFileListWin "$@"
	else
		GetFileListPosix "$@"
	fi
}

# GetFileListPosix() - get files using POSIX commands, each file attributes requested individually, very slow over WebDAV, timestamp in milliseconds
GetFileListPosix() 
{
	local result="$1" dir="$2" dirDesc="$3" lines

 	IFS=$'\n' read -d '' -r -a lines < <(\
 		${G}find "$dir" -maxdepth 1 -type f -not -iname ".*$lastSyncSuffix" -printf "%f\t%s\t%T@\n" | sort); 

 	# always ignore ms - ignore thrash
	ignoreMs="true"

	# check if we should ignore millisconds (not present for nas)
	if [[ ! $ignoreMs ]]; then
		local ms="${lines[0]##*.}${lines[1]##*.}${lines[2]##*.}${lines[3]##*.}"
		[[ "$ms" == *(0) ]] && ignoreMs="true"
	fi

	for (( i = 0; i < ${#lines[@]}; i++ )); do
		[[ $ignoreMs ]] && line="${lines[$i]%.*}" || line="${lines[$i]}"
		printf -v $result[$i] -- "$line"
	done
}

# GetFileListWin() - use Windows cmd dir, files retrieved in a single batch, much faster over slow networks, timestamp in seconds
GetFileListWin()
{
	local result="$1" dir="$2" dirDesc="$3" lines line name size time resultIndex=0
	convertTime="true"

	# 1) get the file list
	# 2) remove embedded carriage returns, see them with echo "*${lines[i]}*" | od -c
	IFS=$'\n' read -d '' -r -a lines < <(\
 		cmd /c dir /TW /A:-D /-C /ON "$(utw "$dir")" 2> /dev/null | sed 's/\r//' | egrep -v "<SYMLINK>|.*$lastSyncSuffix" | ${G}head --lines=-2)

	for (( i = 0; i < ${#lines[@]}; i++ )); do
		(( i < 10 )) && [[ "${lines[$i]:0:10}" == @(* *|) ]] && continue # first 10 characters must contain a date (dir has variable number of headers)

		line="${lines[i]}"

		name="${line:39}"
		time="${line:0:20}"
		size="${line:21:17}"
		printf -v $result[$resultIndex] "%s\t%d\t%s" "$name" "$size" "$time"
		(( ++resultIndex ))
	done
}

GetDirList() 
{ 
	IFS=$'\n' read -d '' -r -a $1 < <(\
		${G}find "$2" -maxdepth 1 -type d -printf "%f\n" | tail -n +2 | sort); 
}

PromptForFiles()
{
	local operation="$1" desc="$2"; shift 2
	local result items status="on"

	[[ "$operation" == "delete" ]] && status="off"

	for file in "${files[@]}"; do
		items+=( "$file" "" "$status" )
	done

	result=$(dialog --stdout --title "Synchronizing Files" \
		--backtitle "$desc" \
  	--checklist "Choose files to $operation:" $(($LINES-5)) 50 $(($LINES)) -- "${items[@]}")
	clear

	eval results=( $result )
	(( ${#results[@]} == 0 )) && return

	"$@" "${results[@]}" || return

	for file in "${results[@]}"; do
		IsInArray "$file" files && unset files[$isInIndex]
	done
}

DeleteFiles()
{
	local dir="$1" dirDesc="$2"; shift 2
	local files=("$@")
	
	for file in "${files[@]}"; do
		if [[ $noBak ]]; then
			printf "\nRemoving $dirDesc/$file..."
			rm -f "$dir/$file" || return
			printf "done\n"
		else
			bak --move --local --quiet "$dir/$file" || return
		fi
	done
}

CopyFiles()
{
	local src="$1" dest="$2" srcDesc="$3" destDesc="$4"; shift 4
	local files=("$@")

	for file in "${files[@]}"; do
		CopyFile "$src/$file" "$dest/$file" "$srcDesc/$file" || return
	done
}

CopyFile()
{
	local src="$1" dest="$2" desc="$3"

	printf "$(GetFileName "$desc")..."
	${G}cp "$src" "$dest" || return # --preserve=timestamps does not work reliably
	sudoc ${G}touch "$dest" --reference "$src" || return
}

ReplaceFile()
{
	local src="$1" dest="$2" desc="$3"

	if [[ ! "$noBak" ]]; then
		bak --local --quiet "$dest" || return
	fi

	printf "$(GetFileName "$desc")..."
	${G}cp "$src" "$dest" || return # --preserve=timestamps does not work reliably
	sudoc ${G}touch "$dest" --reference "$src" || return
}

# SyncFileTimes() - touch not functional over WebDAV
SyncFileTimes()
{
	local f1="$1" f1Age="$2" f2="$3" f2Age="$4"

	#stat $f1; stat $f2
	if CompareSeconds "$f1Age" '>' "$f2Age"; then
		sudoc ${G}touch "$f2" --reference "$f1"  
		#stat "$f2"; pause
	else
		sudoc ${G}touch "$f1" --reference "$f2"
		#stat "$f1"; pause
	fi
}

SetFileTimes()
{
	local now="$(GetSeconds)"
	for file in "$@"; do
		sudoc ${G}touch "$file" -d "@$now"
		#stat "$file"
	done
}

run() {	init; args "$@"; SyncDirCommand "$src" "$dest"; }

run "$@"

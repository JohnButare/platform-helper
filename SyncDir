#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... SRC DEST
Synchronize the source and destination directories.

	-di, --dest-id  	destination unique identifier
	-do, --dest-older	assume the destination files are older
	-e, --exist				source and destination directories must exist, otherwise exit silently
	-nb, --no-bak			do not back up replaced files
	-p, --protocol	 	$(ScriptOptNetworkProtocolUsage)
	-r, --recursive		synchronize subdirectories
	-si, --src-id  		source unique identifier
	-so, --src-older	assume the source files are older
	-v, --verbose			show additional status
	-x, --exclude			one or more files or directories to skip"
	exit $1
}

init()
{
	defaultCommand="sync"
	lastSyncSuffix="sync.txt"
}

argStart() { unset -v dest destId dir exist method noBak protocol recursive src srcId uncArgs x; }

opt()
{
	case "$1" in
		-di|--destid|-di=*|--destid=*) ScriptOptGet "destId" "$@";;
		-do|--dest-older) method="--dest-older";;
		-e|--exist) exist="--exist";;
		-nb|--no-bak) noBak="--no-bak";;
		-p|--protocol|-p*|--protocol=*) ScriptOptNetworkProtocol "$@"; [[ $protocol ]] && uncArgs+=(--protocol "$protocol");;
		-r|--recursive) recursive="--recursive";;
		-si|--srcid|-si=*|--srcid=*)  ScriptOptGet "srcId" "$@";;
		-so|--src-older|-so=*|--src-older=*) method="--src-older";;
		-x|--exclude) while [[ $2 ]] && ! IsOption "$2"; do x+=("$2"); shift; (( shift++ )); done;;
		*) return 1;;
	esac
}

syncArgStart() { unset -v src dest; }

syncArgs()
{
	ScriptArgGet "src" -- "$@"; shift
	ScriptArgGet "dest" -- "$@"; shift
}

syncCommand()
{
	x+=( ".*$lastSyncSuffix" )
	sync "$(RemoveTrailingSlash "$src")" "$(RemoveTrailingSlash "$dest")"
}

#
# helper
#

desc() { FileToDesc "$1"; }
getSrcDesc() { desc "$src"; }
getDestDesc() { desc "$dest"; }

sync()
{
	local src="$1" dest="$2"

	# src or dest directory is excluded
	{ IsInArray --array-wild "${src##*/}" x || IsInArray --array-wild "${dest##*/}" x; } && return

	# logging
	[[ $verbose ]] && LogMessage "sync: src=$(getSrcDesc) dest=$(getDestDesc) srcId=$srcId destId=$destId"

	# mount and validate src and dest directories
	IsUncPath "$src" && { src="$(unc mount "$src" "${uncArgs[@]}")" || { EchoErr "Unable to mount $(getSrcDesc)"; return 1; }; }
	IsUncPath "$dest" && { dest="$(unc mount "$dest" "${uncArgs[@]}")" || { EchoErr "Unable to mount $(getDestDesc)"; return 1; }; }

	[[ $exist && (! -d "$src" && ! -d "$dest") ]] && return 0

	if [[ ! -d "$src" && ! -d "$dest" ]]; then
		echo
		EchoErr "Source ($(getSrcDesc)) and destination ($(getDestDesc)) directories do not exist"
		return 1
	fi

	# determine last sync times
	local lastSyncSrcFile="$src/.${destId}_${lastSyncSuffix}"
	local lastSyncDestFile="$dest/.${srcId}_${lastSyncSuffix}"

	getLastSync || return

	# sync
	if [[ ! -d "$src" ]]; then
			case "${method##--}" in
				dest-older) deleteMissingDir --quiet "$dest";;
				src-older) copyMissingDir "$dest" "$src";;
				*) syncMissingDir "$dest" "$src";;
			esac || return		
	elif [[ ! -d "$dest" ]]; then
			case "${method##--}" in
				dest-older) copyMissingDir "$src" "$dest";;
				src-older) deleteMissingDir --quiet "$src";;
				*) syncMissingDir "$src" "$dest";;
			esac || return		
	else
		syncDo "$src" "$dest" || return
	fi

	setLastSync || return
}

syncDo()
{
	local src="$1" dest="$2"
	local srcFiles destFiles srcIndex=0 destIndex=0 lastSrcIndex lastDestIndex
	local ignoreMs convertTime srcLine destLine srcFile destFile srcOnlyFiles destOnlyFiles

	(( verboseLevel > 1 )) && LogPrint "syndDo: "
	getFileList srcFiles "$src"; (( verboseLevel > 1 )) && PrintErr "src times..."; [[ ! $verbose ]] && printf "."
	getFileList destFiles "$dest";  (( verboseLevel > 1 )) && EchoErr "dest times"; [[ ! $verbose ]] && printf "."
	lastSrcIndex="${#srcFiles[@]}"; lastDestIndex="${#destFiles[@]}"

	while (( srcIndex<lastSrcIndex || destIndex<lastDestIndex )); do
		log3 "src=$srcIndex..$lastSrcIndex dest=$destIndex..$lastDestIndex"

		srcLine="${srcFiles[$srcIndex]}"
		destLine="${destFiles[destIndex]}"
	
		# quick check
		if [[ "$srcLine" == "$destLine" ]]; then
			(( ++srcIndex, ++destIndex ))
			continue;
		fi

		srcFile="${srcLine%	*	*}"; destFile="${destLine%	*	*}"

		if (( verboseLevel > 1 )); then
			printf 'sync: difference in file "%s"' "$srcFile"
			IsInArray --array-wild "$srcFile" x && echo " (excluded)" || echo
			log3 " srcLine=$srcLine"; log3 "destLine=$destLine"
		fi

		if [[ "$srcFile" == "$destFile" ]]; then
			! IsInArray --array-wild "$srcFile" x && { syncFile "$src" "$dest" || return; }
			(( ++srcIndex, ++destIndex ))

		elif [[ $srcFile && ( "$destFile" == "" || "$srcFile" < "$destFile" ) ]]; then
			! IsInArray --array-wild "$srcFile" x && srcOnlyFiles+=("$srcFile")
			(( ++srcIndex ))

		elif [[ "$srcFile" == "" || "$destFile" < "$srcFile" ]]; then
			! IsInArray --array-wild "$destFile" x && destOnlyFiles+=("$destFile")
			(( ++destIndex ))
		
		fi
	done

	case "${method##--}" in
		dest-older)
			deleteFiles "$dest" "${destOnlyFiles[@]}" || return
			copyFiles "$src" "$dest" "${srcOnlyFiles[@]}" || return;;
		src-older)
			deleteFiles "$src" "${srcOnlyFiles[@]}" || return
			copyFiles "$dest" "$src" "${destOnlyFiles[@]}" || return;;
		*) 
			syncMissingFiles "$src" "$dest" "${srcOnlyFiles[@]}" || return
			syncMissingFiles "$dest" "$src" "${destOnlyFiles[@]}" || return
	esac

	[[ ! $recursive ]] && return

	local srcDirs destDirs dir

	getDirList srcDirs "$src"
	for dir in "${srcDirs[@]}"; do
		sync "$src/$dir" "$dest/$dir" || return
	done

	getDirList destDirs "$dest"
	for dir in "${destDirs[@]}"; do
		IsInArray "$dir" srcDirs && continue
		sync "$src/$dir" "$dest/$dir" || return
	done
}

syncFile()
{
	local src="$1" dest="$2"
	local srcPath="$src/$srcFile" destPath="$dest/$destFile" 
	local srcPathDesc="$(desc "$src/$srcFile")" destPathDesc="$(desc "$dest/$destFile")"
	local srcInfo srcFileSize srcFileAge destInfo destFileSize destFileAge ext
	local desc="$srcFile" srcDesc destDesc

	IFS="	" read srcFileSize srcFileAge <<< "${srcLine#$srcFile	}"
	IFS="	" read destFileSize destFileAge <<< "${destLine#$destFile	}"
	
	[[ $convertTime ]] && { srcFileAge="$(GetSeconds "$srcFileAge")"; destFileAge="$(GetSeconds "$destFileAge")"; }
	GetFileExtension "$srcFile" ext

	# printf "syncFile $srcPath to $destPath\n"
	# printf 'src="%s" srcFileSize=%s srcFileAge=%s\n' "$src" "$srcFileSize" "$srcFileAge"
	# printf 'dest="%s" destFileSize=%s destFileAge=%s\n' "$dest" "$destFileSize" "$destFileAge"
	# pause

	if (( srcFileSize==destFileSize )) && diff "$srcPath" "$destPath" > /dev/null; then
		local srcFileDate="$(${G}date -d @$srcFileAge)" destFileDate="$(${G}date -d @$destFileAge)"
		# printf "$srcFile (src=$srcFileDate dest=$destFileDate)..."
		# printf "\nsrcFileAge=%s-%s\ndestFileAge=%s-%s\n" "$srcFileDate" "$srcFileAge" "$destFileDate" "$destFileAge"
		# pause
		#stat "$srcPath"; stat "$destPath"
		RunLog syncFileTimes "$srcPath" "$srcFileAge" "$destPath" "$destFileAge" || return
		return
	fi

	case "$method" in
	--dest-older) replaceFile "$srcPath" "$destPath" "$desc"; return;;
	--src-older) replaceFile "$destPath" "$srcPath" "$desc"; return;;
	esac

	if CompareSeconds $destFileAge '<' $srcFileAge; then
		local older="$dest" olderAge="$destFileAge" destDesc="older" newer="$src" srcDesc="newer"
		local olderDesc="$destPathDesc" newerDesc="$srcPathDesc"
		desc=">$desc"
	else
		local older="$src" olderAge="$srcFileAge" srcDesc="older" newer="$dest" destDesc="newer"
		local olderDesc="$srcPathDesc" newerDesc="$destPathDesc"
		desc="<$desc"
	fi
	local olderPath="$older/$srcFile" newerPath="$newer/$srcFile"

	if [[ $lastSync ]] && CompareSeconds $olderAge '<=' $lastSync; then
		replaceFile "$newerPath" "$olderPath" "$desc"; return
	fi

	printf "\n\nDifferences:\n"
	local diff="diff"; InPath delta && diff="delta --paging never"
	$diff "$srcPath" "$destPath"
	echo

	printf "%s: %s %s (%s bytes)\n" "$srcDesc" "$srcPathDesc" "$(ShowSimpleTime @$srcFileAge)" "$srcFileSize"
	printf "%s: %s %s (%s bytes)\n" "$destDesc" "$destPathDesc" "$(ShowSimpleTime @$destFileAge)" "$destFileSize"

	local defaultChoice=3
	case $ext in
		dll|exe|com) defaultChoice=3;; # ReplaceOlder
		*) defaultChoice=1;; # EditBoth
	esac

	while true; do
		ask ' (1) Edit (2) Delete (3) Replace older (4) Replace newer' -vr 1234 -dr $defaultChoice

		case $(( $?+1 )) in

		  1) # edit
				log1 "syncDo edit: olderPath=$olderPath newerPath=$newerPath"
				merge --wait "$olderPath" "$newerPath" #  merge return values vary, Beyond Compare return 1 for "Binary Same" on all platforms except macOS
		    if ! cmp --quiet "$olderPath" "$newerPath"; then
		    	echo "$srcFile is still diferent"
	    		continue
	  		fi
	  		setFileTimes "$srcPath" "$destPath" || return
	  		;;

		  2) # delete
				log1 "syncDo delete: srcPath=$srcPath destPath=$destPath"
				if [[ $noBak ]]; then
					rm -f "$srcPath" "$destPath" || return
				else
					bak --local --quiet "$srcPath" "$destPath" || return
				fi;;
			3) replaceFile "$newerPath" "$olderPath" "$olderDesc"; return;;
	  	4) replaceFile "$olderPath" "$newerPath" "$newerDesc"; return;;
		esac
		return
	done
}

copyMissingDir()
{
	local src="$1" dest="$2"
	local finalSrcDir="$(GetFileName "$(RemoveTrailingSlash "$src")")"

	echo "$finalSrcDir..."
	CopyDir "$src" "$dest" $recursive || return
}

deleteMissingDir() 
{ 
	local ask="--ask"; [[ "$1" == "--quiet" ]] && { unset ask; shift; } 
	local dir="$1"
	
	DelDir $ask "$dir" "${globalArgs[@]}"
}

copyFile()
{
	local src="$1" dest="$2" desc="$3"

	printf "$(GetFileName "$desc")..."
	# ${G}cp --force --preserve=timestamps "$src" "$dest" || return
	${G}cp --force "$src" "$dest" || return # --preserve=timestamps does not work reliably
	${G}touch "$dest" --reference "$src" || return
}

copyFiles()
{
	local src="$1" dest="$2"; shift 2
	local files=("$@")

	for file in "${files[@]}"; do
		RunLog copyFile "$src/$file" "$dest/$file" "$src/$file" || return
	done
}

deleteFiles()
{
	local dir="$1"; shift
	local desc files=("$@")
	
	for file in "${files[@]}"; do
		if [[ $noBak ]]; then
			printf "\nRemoving \`$(desc "$dir/$file")\`..."
			RunLog rm -f "$dir/$file" || return
			printf "done\n"
		else
			RunLog bak --move --local --quiet "$dir/$file" || return
		fi
	done
}

getDirList() 
{ 
	IFS=$'\n' read -d '' -r -a $1 < <(\
		${G}find "$2" -maxdepth 1 -type d -printf "%f\n" | tail -n +2 | RemoveEmptyLines | sort); 
}

# getFileList() - get files, each file attributes requested individually, very slow over WebDAV, timestamp in milliseconds
getFileList() 
{
	local result="$1" 
	local dir="$(EnsureDir "$2")" # add trailing / to get contents of symbolic links
	local lines

 	IFS=$'\n' read -d '' -r -a lines < <(\
 		${G}find "$dir" -maxdepth 1 -type f -not -iname ".*$lastSyncSuffix" -printf "%f\t%s\t%T@\n" | sort); 

 	# always ignore ms - ignore thrash
	ignoreMs="true"

	# check if we should ignore millisconds (not present for nas)
	if [[ ! $ignoreMs ]]; then
		local ms="${lines[0]##*.}${lines[1]##*.}${lines[2]##*.}${lines[3]##*.}"
		[[ "$ms" == *(0) ]] && ignoreMs="true"
	fi

	for (( i = 0; i < ${#lines[@]}; i++ )); do
		[[ $ignoreMs ]] && line="${lines[$i]%.*}" || line="${lines[$i]}"
		printf -v $result[$i] -- "$line"
	done
}

getLastSync()
{
	lastSync=0

	if [[ -f "$lastSyncSrcFile" ]]; then
		# Call GetSeconds to ensure we have a valid timestamp
		lastSync="$(GetSeconds "$(<"$lastSyncSrcFile")" 2> /dev/null)"
		[[ ! $lastSync ]] && lastSync=0
	fi

	# printf 'lastSync="%s" (%s)\n' "$(ShowTime "@$lastSync")" "$lastSync"
	return 0
}

promptForFiles()
{
	local operation="$1" desc="$2"; shift 2
	local result items status="on"

	[[ "$operation" == "delete" ]] && status="off"

	for file in "${files[@]}"; do
		items+=( "$file" "" "$status" )
	done

	result=$(dialog --stdout --title "Synchronizing Files" \
		--backtitle "$desc" \
  	--checklist "Choose files to $operation:" $(($LINES-5)) 50 $(($LINES)) -- "${items[@]}")
	clear

	eval results=( $result )
	(( ${#results[@]} == 0 )) && return

	# operate on selected files
	"$@" "${results[@]}" || return

	# remove selected results from the files to process
	ArrayRemove files "${results[@]}"
}

replaceFile()
{
	local src="$1" dest="$2" desc="$3"

	# logging
	log1 "replaceFile: src='$src' dest='$dest' desc='$desc'"
	[[ ! $verbose ]] && printf "$(GetFileName "$desc")..."; 

	# backup file
	if [[ ! "$noBak" ]]; then
		bak --local --quiet "$dest" || return
	fi

	# replace file - cp --preserve=timestamps does not work reliably so use touch
	${G}cp --force "$src" "$dest" || return
	${G}touch "$dest" --reference "$src" || return
}

setLastSync() 
{
	[[ ! -d "$src" || ! -d "$dest" ]] && return 0
	
	local hide newSync=$(GetSeconds) hideFile

	[[ "$PLATFORM" == "win" && ! -f "$lastSyncSrcFile" ]] && hide="true"

	{ echo "@$newSync" >& "$lastSyncSrcFile"; } >& /dev/null || { rm -f "$lastSyncSrcFile"; echo "@$newSync" > "$lastSyncSrcFile" || return; }
	{ echo "@$newSync" >& "$lastSyncDestFile"; } >& /dev/null || { rm -f "$lastSyncDestFile"; echo "@$newSync" > "$lastSyncDestFile" || return; }

	if IsPlatform win && [[ $hide ]]; then
		FileHide "$lastSyncSrcFile" || return;
		FileHide "$lastSyncDestFile" || return;
	fi

	# cleanup sync files older than 30 days
	find "$src" -name ".*$lastSyncSuffix" -mtime +30 -type f -delete
	find "$dest" -name ".*$lastSyncSuffix" -mtime +30 -type f -delete

	return 0
}

# syncFileTimes() - touch not functional over WebDAV
syncFileTimes()
{
	local f1="$1" f1Age="$2" f2="$3" f2Age="$4"

	# logging
	log1 "syncFileTimes: f1='$f1' f1Age='$f1Age' f2='$f2' f2Age='$f2Age'"
	(( verboseLevel > 1 )) && { stat $f1; stat $f2; }
	[[ ! $verbose ]] && printf "."

	# sync
	if CompareSeconds "$f1Age" '>' "$f2Age"; then
		${G}touch "$f2" --reference "$f1"  
	else
		${G}touch "$f1" --reference "$f2"
	fi
}

setFileTimes()
{
	local now="$(GetSeconds)"

	for file in "$@"; do
		${G}touch "$file" -d "@$now"
	done
}

syncMissingDir()
{
	local src="$1" dest="$2"

	echo "Directory $(desc "$dest") does not exist"
	ask "Do you want to (d)elete or (c)opy directory \`$(desc "$src")?\`" -vr dc -dr c
	if [[ $? == 0 ]]; then
		deleteMissingDir "$src"
	else
		copyMissingDir "$src" "$dest"
	fi

}

syncMissingFiles()
{
	local src="$1" dest="$2"; shift 2
	local files=("$@")

	[[ ! $files ]] && return 0

	while (( ${#files[@]} != 0 )); do
		printf "\n\nSync files only in \`$(desc "$src")\` directory: "
		ArrayShow files

		ask '  (1) Copy All (2) Delete All (3) Copy Some (4) Delete Some' -vr 1234 -dr 1

		case $(( $? + 1 )) in
			1) copyFiles "$src" "$dest" "${files[@]}" || return; unset files;;
		 	2) deleteFiles "$src" "${files[@]}" || return; unset files;;
			3) promptForFiles "copy" "Synchronizing files from $src to $dest" "copyFiles" "$src" "$dest" || return;;
			4) promptForFiles "delete" "Deleting files from $src" "deleteFiles" "$src" || return;;
		esac

	done
}

ScriptRun "$@"

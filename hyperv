#!/usr/bin/env bash
. script.sh

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... hypervisor|list|start
Hyper-V commands.
	
	checkpoint|connect|create|delete|drive|exists|power		VM commands"
}

init()
{ 
	defaultCommand="gui"
	gui="virtmgmt.msc"
	disks="$DATA/appdataw/Hyper-V/Virtual Hard Disks"
	controller="2" # assume controller location 2, 0 is usually a DVD drive and 1 is usually the system hard drive
	allHelp="-a, 	--all				operate on all virtual machines"
}

existsUsage() { echot "Usage: $(ScriptName) exists VM\nReturn true if the virtual machine exists."; }
existsArgs() { getVmArg "$@"; }
existsCommand() { psRaw 'Get-VM | where {\$_.Name -eq \"'$vm'\"}' | grep "$vm" >& /dev/null; }

listUsage() { echot "Usage: $(ScriptName) list [plain]\nList all virtual machines."; }
listCommand() { RunScript --elevate "${globalArgs[@]}" -- powershell Get-VM; }
listPlainCommand() { listCommand | RemoveCarriageReturn | tail +4 | cut -d" " -f 1 | grep -v '^$'; }

checkpointUsage() { echot "Usage: $(ScriptName) checkpoint VM|all \nCheckpoint the virtual machines."; }
checkpointArgs() { getVmArg "$@"; }

checkpointCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		ps 'Get-VM \| Checkpoint-VM'
	else
		ps 'Checkpoint-VM -Name \"'$vm'\"'
	fi
}

deleteUsage() { echot "Usage: $(ScriptName) delete VM \nDelete the virtual machines."; }
deleteArgs() { getVmArg "$@"; }

deleteCommand()
{
	[[ ! $force ]] && { ask "Are you sure you want to delete the '$vm' vm completely" -dr n || return; }

	printf "deleting $vm..."
	ps 'Remove-VM -name \"'$vm'\" -force' >& /dev/null
	printf "."; deleteVmDiskFiles || return
	echo "done"
}

guiCommand()
{
	! InPath "$gui" && { EchoErr "The Hyper-V management GUI is not installed"; }
	WinList | grep "Hyper-V Manager" >& /dev/null && return 0
	cd "/mnt/c"; start "$gui" "$@"
}

#
# Config Commands
#

configUsage() { echot "Usage: $(ScriptName) guest|switch"; }

configGuestUsage()
{
	echot "Usage: $(ScriptName) guest VM [linux|win](win)
Configure guest services for a Linux or Windows guest." 
}

configureGuestArgs()
{
	getVmArg "$@"; shift
	os="win"; [[ "$1" == @(linux|win) ]] && { ((++shift)); os="$1"; }
	return 0
}

configGuestCommand()
{
	local transport="VMBus"; [[ "$os" == "linux" ]] && transport="HvSocket"
	ps 'Set-VM -VMName \"'$vm'\" -EnhancedSessionTransportType '$transport'' || return
}

configSwitchUsage()
{
	echot "Usage: $(ScriptName) switch switch VM [SWITCH](Default Switch)
Set the network switch for the virtual machine." 
}

configureSwitchArgs()
{
	getVmArg "$@"; shift
	switch="Default Switch"; [[ $1 ]] && { ((++shift)); os="$1"; }
	return 0
}

configSwitchCommand()
{
	ps 'Get-VM | Get-VMNetworkAdapter | Connect-VMNetworkAdapter -SwitchName \""'"$switch"'"\"'
}

#
# Connect Commands
#

connectUsage() { echot "Usage: $(ScriptName) [gui|edit|ssh](gui) VM\nConnect to the virtual machine."; }
connectArgs() { getVmArg "$@"; }
connectCommand() { connectGuiCommand; }

connectGuiUsage() { echot "Usage: $(ScriptName) gui VM\nConnect to the graphical GUI of the virtual machine."; }
connectGuiCommand() { elevate VmConnect.exe "$HOSTNAME" "$vm"; }

connectEditUsage() { echot "Usage: $(ScriptName) edit VM\nEdit the GUI connection configuration."; }
connectEditCommand() { elevate VmConnect.exe "$HOSTNAME" "$vm" /edit; }

connectSshUsage() { echot "Usage: $(ScriptName) edit VM\nConnect to the command line of the virtual machine using SSH."; }
connectSshCommand() { SshHelper connect -x "$vm" -- "$@"; }

#
# Create Command
#

createUsage() { echot "Usage: $(ScriptName) create VM
Create a virtual machine.

	-t, --type linux|pxe|win			type of VM defaults to configure, defaults to pxe"
	}

createArgStart() { type="pxe"; }

createOpt() 
{
	case "$1" in
		-t*|--type=*|--type)
			ScriptOptGet type "$@" && IsFunction "createBefore$(ProperCase "$type")" && return
			ScriptErr "'$type' is not a valid type"
			;;
		*) return 1
	esac
}

createArgs() { getVmArg "$@"; }

createCommand() 
{
	# remove existing VM
	echo "Checking for existing virtual machine..."
	if existsCommand; then
		[[ ! $force ]] && { ask "Virtual Machine '$vm' already exists.  Delete it completely" -dr n || return; }
		force="true" deleteCommand || return
	else # cleanup
		deleteVmDiskFiles || return
	fi

	local disk="$(utw "$disks/$vm.vhdx")"
	local f="$(mktemp --suffix=.ps1 -p "$WINDIR/Temp")"
	local hdGb="20" memoryGb="2" processors="2" secureBoot="Off" switch="Default Switch"
	local nestedVirtualization="False"

	echo "Checking switch configurating..."
	listSwitch | grep "^external$" >& /dev/null && switch="external"

	echo "Creating virtual machine..."	
	createBefore$(ProperCase "$type") "$@" || return

	cat << EOF > "$f"
New-VM -Name "$vm" -MemoryStartupBytes ${memoryGb}GB -Generation 2 -BootDevice CD -SwitchName "$switch" -ErrorAction Stop
New-VHD -Path "$disk" -SizeBytes ${hdGb}GB -Dynamic -ErrorAction Stop
Add-VMHardDiskDrive -VMName "$vm" -Path "$disk" -ErrorAction Stop
Set-VMProcessor -VMName "$vm" -Count $processors -ExposeVirtualizationExtensions \$${nestedVirtualization} -ErrorAction Stop
Enable-VMIntegrationService -VMName "$vm" -Name "Guest Service Interface" -ErrorAction Stop
Set-VMFirmware -VMName "$vm" -EnableSecureBoot "$secureBoot" -ErrorAction Stop
EOF

	[[ $verbose ]] && { cat "$f"; }
	
	ps "$(utw "$f")" || return
	rm -f "$f" || return

	createAfter$(ProperCase "$type") "$@" || return

	hilight "$type virtual machine $vm created"
}

createBeforeLinux() { :; }
createAfterLinux() { guestCommand "linux"; }

createBeforePxe() { :; }
createAfterPxe() { :; }

createBeforeWin() { hdGb="50" memoryGb="4" nestedVirtualization="True" processors="4"; }
createAfterWin() { :; }

#
# Hypervisor Commands
#

hypervisorUsage() { echot "Usage: $(ScriptName) hypervisor IsEnabled|IsInstalled|IsServiceRunning|disable|enable
Hypervisor commands."; }

hypervisorCommand() { usage; }
hypervisorIsEnabledCommand() { isEnabled; }
hypervisorIsInstalledCommand() { isInstalled; }
hypervisorIsServicerunningCommand() { isServiceRunning; }

hypervisorDisableCommand()
{
	checkInstalled
	! IsElevated && { RunScript --elevate "${globalArgs[@]}" -- hyperv disable; return; }
	isEnabled && { bcdedit.exe /set hypervisorlaunchtype off || return; }
	isServiceRunning && ask "Restart computer to finish disabling Hyper-V" && { power reboot || return; }
	return 0
}

hypervisorEnableCommand()
{
	checkInstalled
	! IsElevated && { RunScript --elevate "${globalArgs[@]}" -- hyperv enable; return; }
	! isEnabled && { bcdedit.exe /set hypervisorlaunchtype auto || return; }
	! isServiceRunning && ask "Restart computer to enable Hyper-V" && { power reboot || return; }
	return 0
}

isEnabled() { RunScript --elevate bcdedit.exe | grep -i hypervisorlaunchtype | grep -i Auto >& /dev/null; }
isInstalled() { service exists hvservice --quiet; }
isServiceRunning() { service running hvservice; }

#
# Power Commands
#

powerUsage() { echot "Usage: $(ScriptName) power off|on|reboot|sleep
Virtual Machine power commands.

	-h, 	--hard			perform a hard reboot or power off"; }

powerArgStart() { unset -v hard; }
powerArgs() { getVmArg "$@"; }

powerOpt()
{
	case "$1" in
		-H|--hard) hard="true";;
		*) return 1
	esac
}

powerCommand() { usage; }

powerOnCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Paused\"} \| Resume-VM' || return
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Off\"} \| Start-VM' || return
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Start-VM -Name "$vm"
	fi
}

powerOffCommand()
{
	local arg; [[ $hard ]] && arg="-TurnOff"

	if [[ "$vm" == "all" ]]; then
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Running\"} \| Stop-VM '$arg
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Stop-VM -Name "$vm" $arg
	fi
}

powerRebootCommand() 
{ 
	if [[ $force || $hard ]]; then
		if [[ "$vm" == "all" ]]; then
			RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Running\"} \| Restart-VM -Type Reset -Force'
		else
			RunScript --elevate "${globalArgs[@]}" -- powershell Restart-VM -Name "$vm" -Type Reset -Force
		fi
		return
	fi

	printf "rebooting..."; powerOffCommand && printf "off..."; powerOnCommand && printf "on..."; echo "done"
}

powerSleepCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		ps 'Get-VM | where {\$_.State -eq \"Running\"} | Save-VM'
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Save-VM -Name "$vm"
	fi
}

#
# Drive Commands
#

driveUsage() { echot "Usage: $(ScriptName) drive mount|unmount VM\nVirtual Machine drive commands."; }
driveArgs() { getVmArg "$@"; }
driveCommand() { usage; }

driveMountCommand()
{
	local drive="$(drive win GetOffline)"
	[[ ! $drive ]] && { ScriptErr "there are no offline drives to mount"; return 1; }

	ps 'Add-VMHardDiskDrive -VMname \"'$vm'\" -ControllerType SCSI -ControllerNumber 0 -ControllerLocation '$controller' -DiskNumber '$drive || return
}

driveUnmountCommand()
{
	ps 'Remove-VMHardDiskDrive -VMname \"'$vm'\" -ControllerType SCSI -ControllerNumber 0 -ControllerLocation '$controller || return
}

#
# helper
#

checkInstalled () { ! isInstalled && { EchoErr "Hyper-V is not installed"; exit 1; } }
deleteVmDiskFiles() { rm -f "$disks/${vm}.vhdx" "$disks/${vm}_"*".avhdx"; }
listSwitch() { ps 'Get-VMSwitch' | tail +3 | cut -d" " -f 1; }
ps() { RunScript --elevate "${globalArgs[@]}" -- powershell "$@"; }
psRaw() { RunScript --elevate "${globalArgs[@]}" -- powershell "$@"; }

getVmArg()
{
	ScriptArgGet "vm" -- "$@"
	[[ "${vm,,}" == "all" ]] && vm="all"
	[[ "$vm" != "all" && ! "$vm" =~ - ]] && vm="$HOSTNAME-$vm" # assume vm names are prefixed with HOSTNAME, i.e. oversoul-ud1 (Ubuntu Desktop 1 on oversoul)
	return 0
}

ScriptRun "$@"

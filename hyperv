#!/usr/bin/env bash
. script.sh

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... hypervisor|ls|start
Hyper-V commands.
	
	checkpoint|connect|create|delete|drive|exists|power		VM commands"
}

init()
{ 
	defaultCommand="gui"
	gui="virtmgmt.msc"
	disks="$DATA/appdataw/Hyper-V/Virtual Hard Disks"
	controller="2" # assume controller location 2, 0 is usually a DVD drive and 1 is usually the system hard drive
	allHelp="-a, 	--all				operate on all virtual machines"
}

existsUsage() { echot "Usage: $(ScriptName) exists VM\nReturn true if the virtual machine exists."; }
existsArgs() { getVmArg "$@"; }
existsCommand() { psRaw 'Get-VM | where {\$_.Name -eq \"'$vm'\"}' | grep "$vm" >& /dev/null; }

lsUsage() { echot "Usage: $(ScriptName) ls [plain]\nList all virtual machines."; }
lsCommand() { RunScript --elevate "${globalArgs[@]}" -- powershell Get-VM; }
lsPlainCommand() { lsCommand | RemoveCarriageReturn | tail +4 | cut -d" " -f 1 | grep -v '^$'; }

checkpointUsage() { echot "Usage: $(ScriptName) checkpoint VM|all \nCheckpoint the virtual machines."; }
checkpointArgs() { getVmArg "$@"; }

checkpointCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		ps 'Get-VM \| Checkpoint-VM'
	else
		ps 'Checkpoint-VM -Name \"'$vm'\"'
	fi
}

deleteUsage() { echot "Usage: $(ScriptName) delete VM \nDelete the virtual machines."; }
deleteArgs() { getVmArg "$@"; }

deleteCommand()
{
	[[ ! $force ]] && { ask "Are you sure you want to delete the '$vm' vm completely" -dr n || return; }

	printf "deleting $vm..."
	ps 'Remove-VM -name \"'$vm'\" -force' >& /dev/null
	printf "."; deleteVmDiskFiles || return
	echo "done"
}

guiCommand()
{
	! InPath "$gui" && { EchoErr "The Hyper-V management GUI is not installed"; }
	WinList | grep "Hyper-V Manager" >& /dev/null && return 0
	cd "/mnt/c"; start "$gui" "$@"
}

#
# config commands
#

configUsage() { echot "Usage: $(ScriptName) guest|switch"; }

#
# config guest command
#

configGuestUsage()
{
	echot "Usage: $(ScriptName) guest VM [linux|pxe|win](win)
Configure guest services for a Linux or Windows guest." 
}

configGuestArgStart() { os="win"; }

configGuestArgs()
{
	getVmArg "$@"; shift
	[[ "$1" == @(linux|pxe|win) ]] && { ScriptArgGet "os" -- "$@"; shift;}
	return 0
}

configGuestCommand() { configGuest "$vm" "$os"; }

# configGuest VM linux|win - configure vm for the specified operating system
configGuest()
{
	local vm="$1" os="$2" transport="VMBus"; [[ "$os" == "linux" ]] && transport="HvSocket"
	ps 'Set-VM -VMName \"'$vm'\" -EnhancedSessionTransportType '$transport'' || return
}

#
# config switch command
#

configSwitchUsage()
{
	echot "Usage: $(ScriptName) config switch VM [SWITCH](Default Switch)
Set the network switch for the virtual machine." 
}

configSwitchArgStart() { switch="Default Switch"; }

configSwitchArgs()
{
	getVmArg "$@"; shift
	[[ $1 ]] && ScriptArgGet "service" -- "$@"
	return 0
}

configSwitchCommand() {	configSwitch "$vm" "$switch"; }

# configSwitch VM SWITCH - connect the VM to a switch
configSwitch()
{
	local vm="$1" switch="${2:-Default Switch}"
	ps 'Get-VM -VMName \"'$vm'\" | Get-VMNetworkAdapter | Connect-VMNetworkAdapter -SwitchName \""'"$switch"'"\"'
}

#
# Connect Commands
#

connectUsage() { echot "Usage: $(ScriptName) [gui|edit|ssh](gui) VM\nConnect to the virtual machine."; }
connectArgs() { getVmArg "$@"; }
connectCommand() { connectGuiCommand; }

connectGuiUsage() { echot "Usage: $(ScriptName) gui VM\nConnect to the graphical GUI of the virtual machine."; }
connectGuiCommand() { elevate VmConnect.exe "$HOSTNAME" "$vm"; }

connectEditUsage() { echot "Usage: $(ScriptName) edit VM\nEdit the GUI connection configuration."; }
connectEditCommand() { elevate VmConnect.exe "$HOSTNAME" "$vm" /edit; }

connectSshUsage() { echot "Usage: $(ScriptName) edit VM\nConnect to the command line of the virtual machine using SSH."; }
connectSshCommand() { SshHelper connect -x "$vm" -- "$@"; }

#
# Create Command
#

createUsage() { echot "Usage: $(ScriptName) create VM
Create a virtual machine.

	-t, --type linux|pxe|win			type of VM defaults to configure, defaults to pxe"
	}

createArgStart() { unset -v iso; type="pxe"; }

createOpt() 
{
	case "$1" in
		-i|--iso|-i=*|--iso=*) ScriptOptGet "iso" "$@" && ScriptCheckFile "$iso";;
		-t*|--type=*|--type)
			ScriptOptGet type "$@" && IsFunction "createBefore$(ProperCase "$type")" && return
			ScriptErr "'$type' is not a valid type"
			;;
		*) return 1
	esac
}

createArgs() { getVmArg "$@"; }

createCommand() 
{
	# remove existing VM
	echo "Checking for existing virtual machine..."
	if existsCommand; then
		[[ ! $force ]] && { ask "Virtual Machine '$vm' already exists.  Delete it completely" -dr n || return; }
		force="true" deleteCommand || return
	else # cleanup
		deleteVmDiskFiles || return
	fi

	local disk="$(utw "$disks/$vm.vhdx")"
	local f="$(mktemp --suffix=.ps1 -p "$WINDIR/Temp")"
	local hdGb="50" memoryGb="2" processors="2" secureBoot="Off" tpm switch="Default Switch"
	local nestedVirtualization="False"

	echo "Checking switch configurating..."
	listSwitch | grep "^external$" >& /dev/null && switch="external"

	echo "Creating virtual machine..."	
	createBefore$(ProperCase "$type") "$@" || return

	# create script
	cat <<-EOF > "$f"
		New-VM -Name "$vm" -MemoryStartupBytes ${memoryGb}GB -Generation 2 -BootDevice CD -SwitchName "$switch" -ErrorAction Stop
		New-VHD -Path "$disk" -SizeBytes ${hdGb}GB -Dynamic -ErrorAction Stop
		Add-VMHardDiskDrive -VMName "$vm" -Path "$disk" -ErrorAction Stop
		Set-VMProcessor -VMName "$vm" -Count $processors -ExposeVirtualizationExtensions \$${nestedVirtualization} -ErrorAction Stop
		Enable-VMIntegrationService -VMName "$vm" -Name "Guest Service Interface" -ErrorAction Stop
		Set-VMFirmware -VMName "$vm" -EnableSecureBoot "$secureBoot" -ErrorAction Stop
	EOF

	#	TPM
	[[ $tpm ]] && cat <<-EOF >> "$f"
		Set-VMKeyProtector -VMName "$vm" -NewLocalKeyProtector
		Enable-VMTPM -VMName "$vm"
	EOF

	# ISO
	if [[ $iso ]]; then
		local file; file="$(isoPrep "$iso")" || return		
		cat <<-EOF >> "$f"
			Set-VMDvdDrive -VMName "$vm" -Path "$file"
		EOF
	fi

	# logging
	[[ $verbose ]] && { cat "$f"; }
	
	# run script
	RunLog ps "$(utw "$f")" || return
	rm -f "$f" || return

	createAfter$(ProperCase "$type") "$@" || return

	hilight "$type virtual machine $vm created"
}

createBeforeLinux() { :; }
createAfterLinux() { configGuest "$vm" "linux"; }

createBeforePxe() { :; }
createAfterPxe() { :; }

createBeforeWin() { hdGb="100" memoryGb="4" nestedVirtualization="True" processors="4" secureBoot="On" tpm="true"; }
createAfterWin() { :; }

# isoPrep ISO - ensure ISO is mounted in a location Hyper-V can access
isoPrep()
{
	local file="$1"

	# return if the file is on a Windows drive
	drive IsWin "$file" && { utw "$file"; return; }

	# create a local Windows directory for the ISO file
	local dir="$DATA/appdataw/iso" 
	mkdir --parents "$dir" || return

	# return if the ISO file already exists in the local ISO directory
	local newFile="$dir/$(GetFileName "$file")"
	[[ -f "$newFile" ]] && { utw "$newFile"; return; }

	# copy the ISO file to the local ISO directory
	EchoErr "Copying $(GetFileName "$file") to the local ISO directory..."
	CopyFileProgress "$file" "$dir" 1>&2 || return

	utw "$newFile"
}

#
# Hypervisor Commands
#

hypervisorUsage() { echot "Usage: $(ScriptName) hypervisor IsEnabled|IsInstalled|IsServiceRunning|disable|enable
Hypervisor commands."; }

hypervisorCommand() { usage; }
hypervisorIsEnabledCommand() { isEnabled; }
hypervisorIsInstalledCommand() { isInstalled; }
hypervisorIsServicerunningCommand() { isServiceRunning; }

hypervisorDisableCommand()
{
	checkInstalled
	! IsElevated && { RunScript --elevate "${globalArgs[@]}" -- hyperv disable; return; }
	isEnabled && { bcdedit.exe /set hypervisorlaunchtype off || return; }
	isServiceRunning && ask "Restart computer to finish disabling Hyper-V" && { power reboot || return; }
	return 0
}

hypervisorEnableCommand()
{
	checkInstalled
	! IsElevated && { RunScript --elevate "${globalArgs[@]}" -- hyperv enable; return; }
	! isEnabled && { bcdedit.exe /set hypervisorlaunchtype auto || return; }
	! isServiceRunning && ask "Restart computer to enable Hyper-V" && { power reboot || return; }
	return 0
}

isEnabled() { RunScript --elevate bcdedit.exe | grep -i hypervisorlaunchtype | grep -i Auto >& /dev/null; }
isInstalled() { service exists hvservice --quiet; }
isServiceRunning() { service running hvservice; }

#
# Power Commands
#

powerUsage() { echot "Usage: $(ScriptName) power off|on|onc|reboot|sleep
Virtual Machine power commands.

	-h, 	--hard			perform a hard reboot or power off"; }

powerArgStart() { unset -v hard; }
powerArgs() { getVmArg "$@"; }

powerOpt()
{
	case "$1" in
		-H|--hard) hard="true";;
		*) return 1
	esac
}

powerCommand() { usage; }
powerOncCommand() { powerOnCommand && connectGuiCommand; }

powerOnCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Paused\"} \| Resume-VM' || return
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Off\"} \| Start-VM' || return
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Start-VM -Name "$vm"
	fi
}

powerOffCommand()
{
	local arg; [[ $hard ]] && arg="-TurnOff"

	if [[ "$vm" == "all" ]]; then
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Running\"} \| Stop-VM '$arg
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Stop-VM -Name "$vm" $arg
	fi
}

powerRebootCommand() 
{ 
	if [[ $force || $hard ]]; then
		if [[ "$vm" == "all" ]]; then
			RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Running\"} \| Restart-VM -Type Reset -Force'
		else
			RunScript --elevate "${globalArgs[@]}" -- powershell Restart-VM -Name "$vm" -Type Reset -Force
		fi
		return
	fi

	printf "rebooting..."; powerOffCommand && printf "off..."; powerOnCommand && printf "on..."; echo "done"
}

powerSleepCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		ps 'Get-VM | where {\$_.State -eq \"Running\"} | Save-VM'
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Save-VM -Name "$vm"
	fi
}

#
# Drive Commands
#

driveUsage() { echot "Usage: $(ScriptName) drive mount|unmount VM\nVirtual Machine drive commands."; }
driveArgs() { getVmArg "$@"; }
driveCommand() { usage; }

driveMountCommand()
{
	local drive="$(drive win GetOffline)"
	[[ ! $drive ]] && { ScriptErr "there are no offline drives to mount"; return 1; }

	ps 'Add-VMHardDiskDrive -VMname \"'$vm'\" -ControllerType SCSI -ControllerNumber 0 -ControllerLocation '$controller' -DiskNumber '$drive || return
}

driveUnmountCommand()
{
	ps 'Remove-VMHardDiskDrive -VMname \"'$vm'\" -ControllerType SCSI -ControllerNumber 0 -ControllerLocation '$controller || return
}

#
# helper
#

checkInstalled () { ! isInstalled && { EchoErr "Hyper-V is not installed"; exit 1; } }
deleteVmDiskFiles() { rm -f "$disks/${vm}.vhdx" "$disks/${vm}_"*".avhdx"; }
listSwitch() { ps 'Get-VMSwitch' | tail +3 | cut -d" " -f 1; }
ps() { RunScript --elevate "${globalArgs[@]}" -- powershell "$@"; }
psRaw() { RunScript --elevate "${globalArgs[@]}" -- powershell "$@"; }

getVmArg()
{
	ScriptArgGet "vm" -- "$@"
	[[ "${vm,,}" == "all" ]] && vm="all"
	[[ "$vm" != "all" && ! "$vm" =~ - ]] && vm="$HOSTNAME-$vm" # assume vm names are prefixed with HOSTNAME, i.e. oversoul-ud1 (Ubuntu Desktop 1 on oversoul)
	return 0
}

ScriptRun "$@"

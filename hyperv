#!/usr/bin/env bash
. script.sh

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... hypervisor|ls|start
Hyper-V commands.
	
	checkpoint|connect|create|delete|drive|exists|power		VM commands"
}

init()
{ 
	defaultCommand="gui"
	gui="virtmgmt.msc"
	isoDir="$DATA/appdataw/iso" 
	disks="$DATA/appdataw/Hyper-V/Virtual Hard Disks"
	controller="2" # assume controller location 2, 0 is usually a DVD drive and 1 is usually the system hard drive
	allHelp="-a, 	--all				operate on all virtual machines"
}

existsUsage() { echot "Usage: $(ScriptName) exists VM\nReturn true if the virtual machine exists."; }
existsArgs() { getVmArg "$@"; }
existsCommand() { psRaw 'Get-VM | where {\$_.Name -eq \"'$vm'\"}' | grep "$vm" >& /dev/null; }

lsUsage() { echot "Usage: $(ScriptName) ls [plain]\nList all virtual machines."; }
lsCommand() { RunScript --elevate "${globalArgs[@]}" -- powershell Get-VM; }
lsPlainCommand() { lsCommand | RemoveCarriageReturn | tail +4 | cut -d" " -f 1 | grep -v '^$'; }

checkpointUsage() { echot "Usage: $(ScriptName) checkpoint VM|all \nCheckpoint the virtual machines."; }
checkpointArgs() { getVmArg "$@"; }

checkpointCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		ps 'Get-VM \| Checkpoint-VM'
	else
		ps 'Checkpoint-VM -Name \"'$vm'\"'
	fi
}

deleteUsage() { echot "Usage: $(ScriptName) delete VM \nDelete the virtual machines."; }
deleteArgs() { getVmArg "$@"; }

deleteCommand()
{
	[[ ! $force ]] && { ask "Are you sure you want to delete the '$vm' vm completely" -dr n || return; }

	printf "deleting $vm..."
	ps 'Remove-VM -name \"'$vm'\" -force' >& /dev/null
	printf "."; deleteVmDiskFiles || return
	echo "done"
}

guiCommand()
{
	! InPath "$gui" && { EchoErr "The Hyper-V management GUI is not installed"; }
	WinList | grep "Hyper-V Manager" >& /dev/null && return 0
	cd "/mnt/c"; start "$gui" "$@"
}

#
# config commands
#

configUsage() { echot "Usage: $(ScriptName) guest|switch"; }

#
# config guest command
#

configGuestUsage()
{
	echot "Usage: $(ScriptName) guest VM [linux|pxe|win](win)
Configure guest services for a Linux or Windows guest." 
}

configGuestArgStart() { os="win"; }

configGuestArgs()
{
	getVmArg "$@"; shift
	[[ "$1" == @(linux|pxe|win) ]] && { ScriptArgGet "os" -- "$@"; shift;}
	return 0
}

configGuestCommand() { configGuest "$vm" "$os"; }

# configGuest VM linux|win - configure vm for the specified operating system
configGuest()
{
	local vm="$1" os="$2" transport="VMBus"; [[ "$os" == "linux" ]] && transport="HvSocket"
	ps 'Set-VM -VMName \"'$vm'\" -EnhancedSessionTransportType '$transport'' || return
}

#
# config switch command
#

configSwitchUsage()
{
	echot "Usage: $(ScriptName) config switch VM [SWITCH](Default Switch)
Set the network switch for the virtual machine." 
}

configSwitchArgStart() { switch="Default Switch"; }

configSwitchArgs()
{
	getVmArg "$@"; shift
	[[ $1 ]] && ScriptArgGet "service" -- "$@"
	return 0
}

configSwitchCommand() {	configSwitch "$vm" "$switch"; }

# configSwitch VM SWITCH - connect the VM to a switch
configSwitch()
{
	local vm="$1" switch="${2:-Default Switch}"
	ps 'Get-VM -VMName \"'$vm'\" | Get-VMNetworkAdapter | Connect-VMNetworkAdapter -SwitchName \""'"$switch"'"\"'
}

#
# Connect Commands
#

connectUsage() { echot "Usage: $(ScriptName) [gui|edit|ssh](gui) VM\nConnect to the virtual machine."; }
connectArgs() { getVmArg "$@"; }
connectCommand() { connectGuiCommand; }

connectGuiUsage() { echot "Usage: $(ScriptName) gui VM\nConnect to the graphical GUI of the virtual machine."; }
connectGuiCommand() { elevate VmConnect.exe "$HOSTNAME" "$vm"; }

connectEditUsage() { echot "Usage: $(ScriptName) edit VM\nEdit the GUI connection configuration."; }
connectEditCommand() { elevate VmConnect.exe "$HOSTNAME" "$vm" /edit; }

connectSshUsage() { echot "Usage: $(ScriptName) edit VM\nConnect to the command line of the virtual machine using SSH."; }
connectSshCommand() { SshHelper connect -x "$vm" -- "$@"; }

#
# Create Command
#

createUsage() { echot "Usage: $(ScriptName) create VM
Create a virtual machine.

	-i, --iso [FILE]						connect an ISO file.  If the file is not specified an installation 
															ISO is determined.  The file is copied to a local directory if required.
	-s, --start									power on and connect to the the virtual machine
	-t, --type linux|pxe|win		type of VM defaults to configure, defaults to pxe
	"
	}

createArgStart() { unset -v iso vm; type="pxe"; }

#powerOnCommand && connectGuiCommand
createOpt() 
{
	case "$1" in
		-i|--iso|-i=*|--iso=*) ScriptOptGet --optional "iso" "$@" && ScriptCheckFile "$iso" || iso="find";;
		-s|--start) start="--start";;
		-t*|--type=*|--type) ScriptOptGet type "$@" && IsFunction "createBefore$(ProperCase "$type")" && return; ScriptErr "'$type' is not a valid type";;
		*) return 1
	esac
}

createArgs() { [[ ! $1 ]] && return; getVmArg "$@"; }

createCommand() 
{	
	# find virtual machine name
	if [[ ! $vm ]]; then
		printf "Finding virtual machine name..."
		local i="1" prefix; prefix="$HOSTNAME-$(createNamePrefix${type^})" || return
		while true; do vm="$prefix$i"; log1 "checking name $vm"; ! existsCommand && break; (( ++i )); done
		echo "$vm"

	# remove existing VM
	elif existsCommand; then
		[[ ! $force ]] && { ask "Virtual Machine '$vm' already exists.  Delete it completely" -dr n || return; }
		force="true" deleteCommand || return

	fi

	# cleanup
	deleteVmDiskFiles || return

	# variables
	local disk="$(utw "$disks/$vm.vhdx")"
	local f="$(mktemp --suffix=.ps1 -p "$WINDIR/Temp")"
	local hdGb="50" memoryGb="2" processors="2" secureBoot="Off" tpm="true" switch="Default Switch"
	local nestedVirtualization="False"

	# switch configuration
	printf "Checking switch configurating..."
	listSwitch | grep "^external$" >& /dev/null && switch="external"
	echo "$switch"

	# type specific configuration
	createBefore$(ProperCase "$type") "$@" || return

	# create script
	cat <<-EOF > "$f"
		New-VM -Name "$vm" -MemoryStartupBytes ${memoryGb}GB -Generation 2 -BootDevice CD -SwitchName "$switch" -ErrorAction Stop
		New-VHD -Path "$disk" -SizeBytes ${hdGb}GB -Dynamic -ErrorAction Stop
		Add-VMHardDiskDrive -VMName "$vm" -Path "$disk" -ErrorAction Stop
		Set-VMProcessor -VMName "$vm" -Count $processors -ExposeVirtualizationExtensions \$${nestedVirtualization} -ErrorAction Stop
		Enable-VMIntegrationService -VMName "$vm" -Name "Guest Service Interface" -ErrorAction Stop
		Set-VMFirmware -VMName "$vm" -EnableSecureBoot "$secureBoot" -ErrorAction Stop
	EOF

	#	TPM
	[[ $tpm ]] && cat <<-EOF >> "$f"
		Set-VMKeyProtector -VMName "$vm" -NewLocalKeyProtector
		Enable-VMTPM -VMName "$vm"
	EOF

	# ISO
	if [[ $iso ]]; then
		local file; file="$(isoPrep "$iso" | utw)" || return		
		cat <<-EOF >> "$f"
			Set-VMDvdDrive -VMName "$vm" -Path "$file"
		EOF
	fi

	# logging
	[[ $verbose ]] && { cat "$f"; }
	
	# run script
	echo "Creating virtual machine..."	
	RunLog ps "$(utw "$f")" || return
	rm -f "$f" || return

	createAfter$(ProperCase "$type") "$@" || return

	hilight "$type virtual machine '$vm' created"

	# start
	[[ ! $start ]] && return
	powerOnCommand && connectGuiCommand
}

createBeforeLinux() { :; }
createAfterLinux() { configGuest "$vm" "linux"; }

createBeforePxe() { :; }
createAfterPxe() { :; }

createBeforeWin() { hdGb="100" memoryGb="4" nestedVirtualization="True" processors="4" tpm="true"; }
createAfterWin() { :; }

createNamePrefixPxe() { echo "pxe"; }
createNamePrefixLinux() { echo "lvm"; }
createNamePrefixWin() { echo "wvm"; }

# isoPrep ISO - ensure ISO is mounted in a location Hyper-V can access
isoPrep()
{
	local file="$1"

	# create a local Windows directory for the ISO file
	[[ ! -d "$isoDir" ]] && { mkdir --parents "$isoDir" || return; }

	# find an ISO image for the appropriate type
	[[ "$file" == "find" ]] && { file="$(isoFind)" || return; }

	# return if the ISO file already exists in the local ISO directory
	isoCheck "$file" && return

	# copy the ISO file to the local ISO directory
	EchoErr "Copying '$(GetFileName "$file")' to the local ISO directory..."
	CopyFileProgress "$file" "$isoDir" 1>&2 || return

	# return the ISO file in the local ISO directory
	isoCheck "$file"
}

# isoCheck FILE - return true if the ISO file exists on a Windows drive or in local the ISO directory
isoCheck()
{
	drive IsWin "$file" && { echo "$file"; return; }
	local file="$isoDir/$(GetFileName "$1")"
	[[ -f "$file" ]] && echo "$file"
}

# createIsoFind - find an installation ISO for the virtual machine type
isoFind()
{
	# determine the installation ISO file for the virtual machine type
	file="$(isoFind${type^})"; [[ ! $file ]] && { ScriptErr "'$type' virtual machines do not have an installation ISO"; return 1; }

	# return if the ISO already exists or we can find it
	isoCheck "$file" || FindInstallFile "$file"
}

isoFindLinux() { echo "platform/linux/Ubuntu/image/ubuntu-21.04-desktop-amd64.iso"; }
isoFindPxe() { echo "shareware/netboot.xyz/netboot.xyz-efi.iso"; }
#isoFindWin() { echo "other/Microsoft/Windows/setup/22593/image/22593.1_MULTI_X64_EN-US.ISO"; }
isoFindWin() { echo "other/Microsoft/Windows/setup/22579/Windows11_InsiderPreview_Client_x64_en-us_22579.iso"; }
 
#
# Hypervisor Commands
#

hypervisorUsage() { echot "Usage: $(ScriptName) hypervisor IsEnabled|IsInstalled|IsServiceRunning|disable|enable
Hypervisor commands."; }

hypervisorCommand() { usage; }
hypervisorIsEnabledCommand() { isEnabled; }
hypervisorIsInstalledCommand() { isInstalled; }
hypervisorIsServicerunningCommand() { isServiceRunning; }

hypervisorDisableCommand()
{
	checkInstalled
	! IsElevated && { RunScript --elevate "${globalArgs[@]}" -- hyperv disable; return; }
	isEnabled && { bcdedit.exe /set hypervisorlaunchtype off || return; }
	isServiceRunning && ask "Restart computer to finish disabling Hyper-V" && { power reboot || return; }
	return 0
}

hypervisorEnableCommand()
{
	checkInstalled
	! IsElevated && { RunScript --elevate "${globalArgs[@]}" -- hyperv enable; return; }
	! isEnabled && { bcdedit.exe /set hypervisorlaunchtype auto || return; }
	! isServiceRunning && ask "Restart computer to enable Hyper-V" && { power reboot || return; }
	return 0
}

isEnabled() { RunScript --elevate bcdedit.exe | grep -i hypervisorlaunchtype | grep -i Auto >& /dev/null; }
isInstalled() { service exists hvservice --quiet; }
isServiceRunning() { service running hvservice; }

#
# Power Commands
#

powerUsage() { echot "Usage: $(ScriptName) power off|on|onc|reboot|sleep
Virtual Machine power commands.

	-h, 	--hard			perform a hard reboot or power off"; }

powerArgStart() { unset -v hard; }
powerArgs() { getVmArg "$@"; }

powerOpt()
{
	case "$1" in
		-H|--hard) hard="true";;
		*) return 1
	esac
}

powerCommand() { usage; }
powerOncUsage() { echot "Usage: $(ScriptName) power onc\nPower on and connect."; }
powerOncCommand() { powerOnCommand && connectGuiCommand; }

powerOnCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Paused\"} \| Resume-VM' || return
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Off\"} \| Start-VM' || return
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Start-VM -Name "$vm"
	fi
}

powerOffCommand()
{
	local arg; [[ $hard ]] && arg="-TurnOff"

	if [[ "$vm" == "all" ]]; then
		RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Running\"} \| Stop-VM '$arg
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Stop-VM -Name "$vm" $arg
	fi
}

powerRebootCommand() 
{ 
	if [[ $force || $hard ]]; then
		if [[ "$vm" == "all" ]]; then
			RunScript --elevate "${globalArgs[@]}" -- powershell 'Get-VM \| where {\$_.State -eq \"Running\"} \| Restart-VM -Type Reset -Force'
		else
			RunScript --elevate "${globalArgs[@]}" -- powershell Restart-VM -Name "$vm" -Type Reset -Force
		fi
		return
	fi

	printf "rebooting..."; powerOffCommand && printf "off..."; powerOnCommand && printf "on..."; echo "done"
}

powerSleepCommand()
{ 
	if [[ "$vm" == "all" ]]; then
		ps 'Get-VM | where {\$_.State -eq \"Running\"} | Save-VM'
	else
		RunScript --elevate "${globalArgs[@]}" -- powershell Save-VM -Name "$vm"
	fi
}

#
# Drive Commands
#

driveUsage() { echot "Usage: $(ScriptName) drive mount|unmount VM\nVirtual Machine drive commands."; }
driveArgs() { getVmArg "$@"; }
driveCommand() { usage; }

driveMountCommand()
{
	local drive="$(drive win GetOffline)"
	[[ ! $drive ]] && { ScriptErr "there are no offline drives to mount"; return 1; }

	ps 'Add-VMHardDiskDrive -VMname \"'$vm'\" -ControllerType SCSI -ControllerNumber 0 -ControllerLocation '$controller' -DiskNumber '$drive || return
}

driveUnmountCommand()
{
	ps 'Remove-VMHardDiskDrive -VMname \"'$vm'\" -ControllerType SCSI -ControllerNumber 0 -ControllerLocation '$controller || return
}

#
# helper
#

checkInstalled () { ! isInstalled && { EchoErr "Hyper-V is not installed"; exit 1; } }
deleteVmDiskFiles() { rm -f "$disks/${vm}.vhdx" "$disks/${vm}_"*".avhdx"; }
listSwitch() { ps 'Get-VMSwitch' | tail +3 | cut -d" " -f 1; }
ps() { RunScript --elevate "${globalArgs[@]}" -- powershell "$@"; }
psRaw() { RunScript --elevate "${globalArgs[@]}" -- powershell "$@"; }

getVmArg()
{
	ScriptArgGet "vm" -- "$@"
	[[ "${vm,,}" == "all" ]] && vm="all"
	[[ "$vm" != "all" && ! "$vm" =~ - ]] && vm="$HOSTNAME-$vm" # assume vm names are prefixed with HOSTNAME, i.e. oversoul-ud1 (Ubuntu Desktop 1 on oversoul)
	return 0
}

ScriptRun "$@"

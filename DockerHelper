#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" app script || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) exec|IsActive|IsInstalled|version
Docker helper commands.
	
	IsActive			return true if the Docker Swarm node is active
	IsInstalled		return true if Docker is installed"
}

init()
{
	defaultCommand="start" startupArgs=()

	case "$PLATFORM_OS" in
		mac) program="$P/Docker.app";;
		win) program="$P/Docker/Docker/Docker Desktop.exe" desktop="$P/Docker/cli-plugins/docker-desktop.exe" startupArgs=(-Autostart);;
	esac

	return 0
}

#
# commands
#

isActiveCommand() { isActive; }
isInstalledCommand() { isInstalled; }

closeCommand()
{ 
	! isRunningCommand && return
	if IsPlatform win; then "$desktop" desktop stop --timeout 5 &> /dev/null; return 0; # never returns
	else docker desktop stop; return
	fi
}

isRunningCommand()
{
	IsPlatform mac,win && { InPath docker && docker ps &> /dev/null; return; }
	service --quiet running docker
}

startCommand()
{
	AppInstallCheck || return
	if IsPlatform linux; then service start docker
	elif IsPlatform mac; then start "$program" "${startArgs[@]}"
	elif IsPlatform win; then start "$program" "${startArgs[@]}" && FileWait $quiet "/usr/bin/docker"
	fi

	# wait for docker to run (docker ps works)
	local i timeoutSeconds=20
	docker ps >& /dev/null && return
	[[ ! $quiet ]] && PrintErr "Waiting $timeoutSeconds seconds for the Docker engine..."

	for (( i=1; i<=$timeoutSeconds; ++i )); do
		docker ps >& /dev/null && { [[ ! $quiet ]] && EchoErrEnd "found"; return 0; }
		ReadChars 1 1 && { [[ ! $quiet ]] && EchoErrEnd "cancelled after $i seconds"; return 1; }
		PrintErr "."
	done

	EchoErrEnd "failed"
}

startupCommand()
{
	[[ ! $force ]] && isRunningCommand && { minimize; return; }
	startArgs="${startupArgs[@]}"; startCommand && minimize
}

versionCommand()
{
	! AppInstallCheck && return
	case "$PLATFORM_OS" in
		linux) docker --version | cut -d" " -f3 | RemoveEnd ",";;
		mac) defaults read "$P/Docker.app/Contents/Info.plist" "CFBundleShortVersionString";;
		win) CanElevate && registry get "HKLM/Software/Microsoft/Windows/CurrentVersion/Uninstall/Docker Desktop/DisplayVersion" | RemoveCarriageReturn;;
	esac
}

#
# exec command
#

execUsage() { ScriptUsageEcho "Usage: $(ScriptName) exec name"; }

execUsage()
{
	ScriptUsageEcho "\
Usage: $(ScriptName) exec name
Execute a command in the first container that contains name in the docker ps output.  If anything is specified after -- that command is run, otherwise a shell is run."
}

execArgStart() { unset -v name; }
execArgs() { ScriptArgGet "name" -- "$@"; }

execCommand()
{
	# arguments
	local args=(bash); [[ $otherArgs ]] && args=("${otherArgs[@]}")

	# get container id
	local id; id="$(docker ps | ${G}grep --extended-regexp "$name" | ${G}cut -d' ' -f1)"
	[[ ! $id ]] && { ScriptErr "could not find a container with the name '$name'"; return 1; }

	docker exec --interactive --tty "$id" "${args[@]}"
}

#
# IsHealthy Command
#

isHealthyUsage() { echot "\
Usage: $(ScriptName) IsHealthy NAME
Check the health status of container NAME.  Returns healthy (return code 0) or unhealthy (return code 1)."; }

isHealthyArgStart() { unset name; }
isHealthyArgs() { ScriptArgGet "name" -- "$@"; }

isHealthyCommand()
{
	local status; status="$(docker inspect --format='{{.State.Health.Status}}' "$name")" || return
	echo "$name is $status"
	[[ "$status" == "healthy" ]] && return 0 || return 2
}

#
# helper
#

isActive() { isInstalled && docker node inspect pi1 |& grep '"Availability": "active"' >& /dev/null; }
minimize() { WinSetState --close "ahk_exe Docker Desktop.exe|"; }

isInstalled()
{
	if IsPlatform mac,win; then [[ -e "$program" ]]
	else service exists docker --quiet
	fi
}

ScriptRun "$@"

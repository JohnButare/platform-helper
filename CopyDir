#!/usr/bin/env bash
. function.sh || exit

run() {	init && args "$@" && CopyDir "${args[@]}"; }

init() { :; }

usage()
{
	echot "usage: CopyDir SRC DEST

	SRC 		The source file or directory.  
					  If SRC is a directory with a trailing / it's contents are put in the DEST directory.
					  If SRC does not have a trailing / the SRC directory is copied to the DEST directory.

	DEST 		The destination directory.

	-a, --archive			archive a directory
	-d, --delete			delete files that do not exist in the target directory
	-r, --recursive		copy directories recursively
	-v, --verbose			maximize logging"; exit $1; 
}

args()
{
	unset archive delete help recursive verbose

	exclude=".git" args=( ) o=(--info=progress2)
	o+=(--times) # preserve times, required for incremental sync
	o+=(--links --perms --group --owner) # preserve other metadata
	#o+=(-@2) # modify window in seconds to consider files the same, 2 seconds needed for FAT file systems which use 1 second granularity

	# arguments
	for arg in "$@"; do
		[[ ! $1 ]] && { shift; continue; } # ignore empty options
		
		# archive implies -rlptgoD, or --recursive --links --perms --times --group --owner --devices --specials
		if [[ $1 == @(-a|--archive) ]]; then
			o+=( --archive )
			declare {archive,recursive}="true"
			shift; continue
		fi

		[[ $1 == @(-d|--delete) ]] && { delete="true"; shift; o+=(--delete); continue; }
		[[ $1 == @(-h|--help) ]] && usage 0
		[[ $1 == @(-r|--recursive) ]] && { recursive="true"; shift; o+=(--recursive); continue; }
		[[ $1 == @(-v|--verbose) ]] && { verbose="true"; shift; o+=(--verbose); continue; }

		args+=("$1"); shift
	done

	o+=(--exclude="$exclude")

	(( ${#args[@]} != 2 )) && usage 1

	return 0
}

CopyDir()
{	
	local src="$1" dest="$2"

	# check if the source exists
	[[ ! -e "$src" ]] && { EchoErr "CopyDir: source \"$src\" does not exist"; return 1; }

	# create destination parent directory if needed
	local parent="$(GetFullPath "$dest" | EnsureDir | GetParentDir)"
	[[ $parent && ! -d "$parent" ]] && { ${G}mkdir --parents "$parent" || return; }

	# Windows drives copy much more quickly with robocopy
	local isSrcWin; drive IsWin "$src" && isSrcWin="true"
	local isDestWin; [[ $parent ]] && drive IsWin "$parent" && isDestWin="true"

	# if the src and dest end with the same directory, ensure src ends with a slash so the directory is not duplicated in the dest
	local lastDirsMatch; [[ "$(GetLastDir "$src")" == "$(GetLastDir "$dest")" ]] && lastDirsMatch="true"
	[[ $recursive && $lastDirsMatch ]] && src="$(RemoveTrailingSlash "$src")/"

	if [[ $isSrcWin || $isDestWin ]]; then
		CopyDirWin
	else
		CopyDirRsync
	fi
}

CopyDirRsync()
{
	local result limitMemory

	# when large files are transferred WSL 2 expands Hyper-V memory until host memory is full
	IsPlatform wsl && [[ -d "/sys/fs/cgroup/memory" ]] && limitMemory="true"

	# limit the file cache memory used, otherwise all host memory will be consumed	
	if [[ $limitMemory ]]; then

		if InPath cgcreate; then
			sudoc cgcreate -g memory:backup || exit
		elif [[ ! -d "/sys/fs/cgroup/memory/backup" ]]; then
			sudo mkdir "/sys/fs/cgroup/memory/backup" || exit
		fi

		sudoc env ppid=$$ bash -c '	
			echo 256M > /sys/fs/cgroup/memory/backup/memory.limit_in_bytes || exit
			echo $ppid > /sys/fs/cgroup/memory/backup/tasks || exit
		'

	fi

	# perform the copy
	if [[ $recursive || -f "$src" ]]; then
		rsync "${o[@]}" "$src" "$dest"
	else
		rsync "${o[@]}" "$src/"* "$dest"
	fi
	result="$?"

	FileCacheFlush || return
	[[ $limitMemory ]] && InPath cgdelete && { sudoc cgdelete -g memory:backup || return; }

	return "$result"
}

CopyDirWin()
{
	o=(/e /j) 			# recursive, unbuffered IO
	o+=(/njh /ndl) 	# logging - no header, no directory list, show file progress

	[[ $archive ]] && o+=(/COPYALL)
	[[ $delete ]] && o+=(/PURGE)
	[[ $exclude ]] && o+=(/XD $exclude )
	[[ $verbose ]] && o+=(/V)
	[[ $(drive type "$src") =~ FAT || $(drive type "$dest") =~ FAT ]] && o+=(/FFT) # 2 second window to compensate for FAT file system

	# mimic rsync - if the source does not end with a slash, create the final directory of the source in the dest
	[[ ! $lastDirsMatch && ! -f "$src" && ! "$src" =~ /$ ]] && dest="$(RemoveTrailingSlash "$dest")/$(GetLastDir "$src")"

	# get files to copy if needed
	local files=()
	[[ -f "$src" ]] && { files="$(GetFileName "$src")"; GetFilePath "$src" src; }

	robocopy.exe "$(utw "$src")" "$(utw "$dest")" "${files[@]}" "${o[@]}"
	(( $? < 8 ))
}

run "$@"

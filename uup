#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
$(ScriptName) commands.
	
	build			build an ISO using a downloaded UUP script"
}

init() { defaultCommand="build"; }

#
# build commands
#

buildUsage()
{
	ScriptUsageEcho "\
Usage: $(ScriptName) build FILE|DIR... [all|init|iso|install|installers|vars](all)
Build an ISO using a downloaded UUP script from a UUP file or build ISO directory.  \
FILE format must be a UUP download file with the format MAJOR.MINOR_${supportedArchitectures}_DESC.zip.  \
DIR format must be MAJOR.MINOR_${supportedArchitectures}.

	-l,	--linux		force linux build under Windows (will not get updates, component cleanup, or Windows Store apps)"
}

buildArgStart()
{
	unset -v file buildDir
	buildScript="uup_download_windows.cmd"
	supportedArchitectures="amd64|arm64"
}

buildCommand() { buildAllCommand; }
buildArgs() { ScriptArgGet "file" -- "$@" && ScriptCheckPath "$file"; }
buildAllCommand() { buildIsoCommand && buildInstallCommand && buildInstallersCommand; }

buildOpt()
{
	case "$1" in
		--linux|-l) script="uup_download_linux.sh";;
		*) return 1;;
	esac
}

buildArgEnd()
{
	# file directory - remove directory component if it exists and change to it
	local dir="$(GetFilePath "$file")"
	[[ $dir ]] && { command cd "$dir" || return; file="$(GetFileName "$file")"; }

	# file
	if [[ -f "$file" ]]; then

		# validate zip file
		[[ "$(GetFileExtension "$file")" != "zip" ]] && { ScriptErr "UUP download file '$file' is not a ZIP file"; return 1;  }

		# get build
		build="$(echo "$file" | cut -d"_" -f1)"
		! IsNumeric "$build" && { ScriptErr "UUP script '$file' does have a numeric build number (expected format is MAJOR.MINOR_$supportedArchitectures_DESC.zip)"; return 1; }
		
		# get architecture
		[[ ! "$file" =~ _ ]] && { ScriptErr "'$file' does not contain an architecture (expected format is MAJOR.MINOR_ARCHITECTURE_DESC.zip)"; return; }
		architecture="$(echo "$file" | cut -d"_" -f2)"
		validateArchitecture "$architecture" || return

		# create build directory
		buildDir="$build-$architecture"
		if [[ "${commandNames[1]}" != "vars" ]]; then

			if [[ $force || ! -d "$buildDir" ]]; then
				rm -fr "$buildDir" || return
				${G}mkdir --parents "$buildDir" || return
				${G}unzip "$file" -d "$buildDir" || return
			fi

			bak --local --move "$file" || return
		fi

	# directory
	else
		build="$(GetWord "$file" 1 "-")"; ! IsNumeric "$build" && { ScriptErr "UUP directory '$file' does have a numeric build number (expected format is MAJOR.MINOR-$supportedArchitectures)"; return 1; }
		[[ ! "$file" =~ - ]] && { ScriptErr "'$file' does not contain an architecture (expected format is MAJOR.MINOR-$supportedArchitectures)"; return; }
		architecture="$(echo "$file" | cut -d"-" -f2)"
		validateArchitecture "$architecture" || return
		buildDir="$build-$architecture"
	fi

	# validate the build script
	IsPlatform mac && buildScript="uup_download_macos.sh"	
	[[ ! -f "$buildDir/$buildScript" ]] && { ScriptErr "the ISO build script '$buildScript' does not exist"; return 1; }

	# update the configuration (enable application download)
	sed -i "s/AppsLevel    =0/AppsLevel    =1/g" "$buildDir/ConvertConfig.ini" || return

	cd "$buildDir"
}

validateArchitecture()
{
	local architecture="$1"
	[[ "$architecture" =~ ^(${supportedArchitectures})$ ]] && return
	ScriptErr "'$architecture' is not a supported architecture, expected $supportedArchitectures"
}


buildVarsUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) build vars FILE|DIR
Return build variables for the UUP file or build ISO directory."
}

buildVarsCommand()
{
	ScriptReturn architecture build buildDir
}

buildIsoValidate()
{
	iso="$(getIso)" && return
	ScriptErr "the ISO image for Windows build $buildDir does not exist"; return 1
}

buildIsoUsage() { ScriptUsageEcho "Usage: $(ScriptName) build install FILE\n.  Build the ISO image using the build script."; }

buildIsoCommand()
{
	hilight "Building the ISO image..."
	[[ ! $force ]] && getIso > /dev/null && return
	if [[ "$buildScript" =~ cmd ]]; then
		elevate cmd.exe /c "$buildScript" || return
		pause
	else
		"./$buildScript" || return
	fi
}

buildInitUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) build init FILE
Setup the build directory.   This allows for configuration changes before a build."
}

buildInitCommand() { :; }

buildInstallUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) build install FILE
Copy the ISO to the installation directory."
}

buildInstallCommand()
{
	hilight "Copying ISO to the install directory..."
	buildIsoValidate || return	

	local setupDir; setupDir="$(FindInstallFile "other/Microsoft/Windows/setup")" || return; setupDir="$setupDir/$buildDir"	
	local destIso="$setupDir/$(GetFileName "$iso")"
	log1 "destIso=$destIso"
	[[ ! $force && -f "$destIso" ]] && return

	${G}mkdir --parents "$setupDir" && CopyFileProgress "$iso" "$setupDir"
}

buildInstallersUsage() { ScriptUsageEcho "Usage: $(ScriptName) build installers FILE\n.  Extract ISO to the installers directory."; }

buildInstallersCommand()
{
	hilight "Extracting ISO to the installers directory..."

	# validation
	buildIsoValidate || return
	log1 "buildInstallersCommand: iso=$(FileToDesc "$iso")"

	# find the installers directory for the ISO
	local server; server="$(GetServer "netbootxyz" "${globalArgs[@]}")" || return
	local dir; dir="$(unc mount "//$server/root/srv/netbootxyz/installers/windows")/$buildDir" || return
	log1 "buildInstallersCommand: dir=$dir"

	# return if the directory already exists
	[[ ! $force && -d "$dir" ]] && return
	[[ -d "$dir" ]] && { rm -fr "$dir" || return; }

	# copy the ISO
	${G}mkdir --parents "$dir" || return
	CopyFileProgress "$iso" "$dir" || return

	# extract the ISO
	cd "$dir" || return
	7z x "$iso" && rm "$dir/$(GetFileName "$iso")"
}

getIso()
{
	log2 "getIso PWD=$PWD"
	local iso="$(RunLog2 ${G}find $PWD -iname "*.ISO")"
	[[ -f "$iso" ]] || return
	echo "$iso"
}

ScriptRun "$@"
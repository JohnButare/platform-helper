#!/usr/bin/env bash
. function.sh

run() {	init || return; args "$@" || return; ${command}Command "${args[@]}"; }

init()
{
	unset efiDevice
	driveLetters=( c d e f g h i j k l m n o p q r s t u v w x y z )
	mountRoot="/mnt"; [[ -d "/media/$USER" ]] && mountRoot="/media/$USER" # Ubuntu
	return 0
}

usage()
{
	echot "\
usage: drive COMMAND(detail)
	DEVICE 	the drive device name to mount.  Ex: sdb1, d (Windows), or all (all available drives)
	DIR			a directeory in the mounted drive

	IsMounted|mount|unmount DEVICE
		IsMounted				if the specified device is mounted return the directory it is mounted to
		mount|unmount		mount or unmount the specified device and return the directory it is mounted to

	device|FileSystem|label|type|IsDrive|IsWin DEVICE|DIR
		device					get the device name of the drive
		FileSystem			get the file system of the drive
		IsWin						return true if the drive is mounted using Windows drvfs

	detail						list detailed information of all drives
	list							list device names of all drives
	mounts						list all mounted drives

	win exists|list|online|offline - windows drives

	-q, 	--quiet			hide status messages
	-v, 	--verbose		show verbose output"
	exit $1
}

args()
{
	unset -v alll command device quiet verbose

	while (( $# != 0 )); do
		case "$1" in
			-h|--help) usage 0;;
			-q|--quiet) quiet="--quiet";;
			-v|--verbose) verbose="--verbose";;
			FileSystem) command="fileSystem";; IsDrive) command="isDrive";; IsMounted) command="isMounted";; IsWin) command="isWin";;
			*)
				[[ ! $device ]] && getDeviceArg "$1" && { shift; continue; }
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(device|FileSystem|IsDrive|IsWin|label|type|win) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	command="${command:-detail}"
	[[ "$command" == @(IsMounted|mount|unmount) && ! $device ]] && MissingOperand "device"
	[[ "$device" == "all" ]] && all="true"

	args=("$@")
}

# getDeviceArg DEVICE - get the device argument (either DEVICE or /dev/DEVICE)
getDeviceArg()
{
	local check="$1"; [[ "$(GetFilePath "$check")" == "/dev" ]] && check="$(GetFileName "$check")"
	! isDevice "$check" && return 1
	device="$check"
}

#
# commands
# 

isMountedCommand() { [[ $all ]] && { areAllMounted; return; }; isMounted $quiet; }
mountCommand() { [[ $all ]] && { allMount; return; }; doMount "$quiet"; }
unmountCommand() { [[ $all ]] && { allUnmount; return; }; doUnmount "$quiet"; }

deviceCommand() { getDevice "$@" || return; echo "$device"; }
fileSystemCommand() { getDevice "$@" || return; getFileSystem; }
isDriveCommand() { getDevice "$@" || return; isDevice "$device"; }
isWinCommand() { IsPlatform win && [[ "$(typeCommand "$@")" == "9p" ]]; }
labelCommand() { getDevice "$@" || return; getLabel; }
listCommand() { getAllDrives; }
typeCommand() { getDevice "$@" || return; getType; }

detailCommand()
{
	local device devices
	IFS=$'\n' devices=( $(drive list) )

	echot "DEVICE	MOUNTPOINT	FS		LABEL"

	for device in ${devices[@]}; do
		echot "$device		$(isMounted)		$(getFs)	$(getLabel)"
	done
}

mountsCommand()
{
	local d=() device devices;

	# standard mounted drives
	IFS=$'\n' devices=( $(getAllDrives) )
	for device in "${devices[@]}"; do
		dir="$(isMounted)" && d+=( "$dir" )
	done

	# other drives
	case "$PLATFORM" in
		linux) d+=( $(find /mnt/hgfs/* /media/psf/* |& grep -v "No such file") );;
		mac) IFS=$'\n' d+=( $(df | grep "^/dev/" | awk '{print $9}' | grep -v '^/$|^/$') );;
	esac

	ListArray d
}

#
# win commands
#

winCommand()
{
	local command; CheckSubCommand win "$1"; shift
	Win${command}Command "$@"
}

WinListCommand() { diskpart "list disk" | grep -E 'Online|Offline|Status|---'; }
WinExistsCommand() { diskpart "select disk $1" | grep "Disk $1 is now the selected disk." >& /dev/null; }
WinGetofflineCommand() { drive win list | grep Offline | tr -s " " | cut -d" " -f3; }
WinOnlineCommand() { diskpart "select disk $1 \n online disk" | grep "DiskPart successfully onlined the selected disk" >& /dev/null; }
WinOfflineCommand() { diskpart "select disk $1 \n offline disk" | grep "DiskPart successfully offlined the selected disk" >& /dev/null; }

#
# helper
#

error() { EchoErr "$(ScriptName): $1"; exit 1; }
isDriveLetter() { IsPlatform win && IsInArray "$1" driveLetters; }

isDevice()
{
	[[ "$1" == @("all") || -e "/dev/$1" ]] || isDriveLetter "$1"
}

allMount()
{
	areAllMounted && return

	[[ ! $quiet ]] && printf "mounting..."

	local device devices
	IFS=$'\n' devices=( $(drive list) )

	for device in "${devices[@]}"; do
		{ isMounted --quiet || ! canMount; } && continue
		doMount --quiet || return
		[[ ! $quiet ]] && printf "$device."
	done

	[[ ! $quiet ]] && echo "done"	
	return 0
}

allUnmount()
{
	areAllUnmounted && return

	[[ ! $quiet ]] && printf "unmounting..."

	local device devices
	IFS=$'\n' devices=( $(drive list) )
	
	for device in "${devices[@]}"; do
		{ ! isMounted --quiet || ! canUnmount; } && continue
		doUnmount --quiet || return
		[[ ! $quiet ]] && printf "$device."
	done

	[[ ! $quiet ]] && echo "done"	
	return 0
}

areAllMounted()
{
	local device devices
	IFS=$'\n' devices=( $(drive list) )

	for device in "${devices[@]}"; do
		canMount && ! isMounted --quiet && return 1
	done

	return 0
}

areAllUnmounted()
{
	local device devices
	IFS=$'\n' devices=( $(drive list) )
	
	for device in "${devices[@]}"; do
		canUnmount && isMounted --quiet && return 1
	done

	return 0
}

canMount()
{
	local type="$(getType "$device")"
	[[ "$type" == "" ]] && { reason="no filesystem"; return 1; }
	[[ "$type" == "LVM2_member" ]] && { reason="logical volume member"; return 1; }
	return 0
}

canUnmount()
{
	[[ "$device" != "c" ]] && ! isEfiDevice
}

isEfiDevice()
{
	IsPlatform win && return 1
	[[ ! $efiDevice ]] && efiDevice="$(findmnt --noheadings --output=SOURCE --target "/boot/efi" | GetFileName)"
	[[ "$device" == "$efiDevice" ]]
}

cleanupMountDir() # dir
{
	local dir="$1"
	[[ ! -e "$dir" ]] && return
	findmnt "$dir" >& /dev/null && sudoc umount "$dir" >& /dev/null
	sudoc rmdir "$dir" >& /dev/null
	[[ ! -e "$dir" ]]
}

doMount()
{
	local quiet; [[ "$1" == @(-q|--quiet) ]] && quiet="--quiet"
	local result dir; dir="$(isMounted)" && { [[ ! $quiet ]] && echo "$dir"; return 0; }
	local m="$mountRoot/$device" # mount point

	# return if we cannot mount the drive
	! canMount && error "cannot mount $device ($reason)"

	# unmount a drive that is no longer present
	cleanupMountDir "$m" || return	

	# create the mount directory
	[[ ! -d "$m" ]] && { sudoc mkdir "$m" || return 1; }

	# mount the drive
	if isDriveLetter "$device"; then
		sudoc mount -t drvfs "$device:" "$m"
	else
		sudoc mount "/dev/$device" "$m"
	fi

	if isMounted "$quiet"; then
		return 0
	else
		cleanupMountDir
		return 1
	fi
}

doUnmount()
{
	local quiet; [[ "$1" == @(-q|--quiet) ]] && quiet="true"
	local dir="$(isMounted)" || return

	# return if we cannot unmount this drive
	! canUnmount && error "cannot unmount $device"

	# unmount
	sudoc umount "$dir"
	cleanupMountDir "$dir"
}

getAllDrives()
{
	local d=()

	if IsPlatform win; then
		d=( $(fsutil.exe fsinfo drives | sed 's/:\\//g' | sed 's/Drives: //g' | tr '[:upper:]' '[:lower:]' | RemoveCarriageReturn ) )
	fi

	d+=( $(find /dev/sdd /dev/sd[a-c][0-9]* /dev/mmcblk[0-9]p[0-9]* /dev/nvme0n[0-9]p[0-9] |& grep -v "No such file" | sed 's/\/dev\///g') )

	ListArray d
}

# getDevice DIR - get the devce for the passed directory
getDevice()
{
	[[ $device ]] && return

	# validate only one argument is passed and it is a directory
	local dir="$1"
	[[ "$#" != "1" ]] && usage
	[[ ! -d "$dir" ]] && error "mount directory \`$dir\` does not exist"

	# get the mount target and source for the specified directory
	read device <<<$(findmnt --noheadings --output=SOURCE --target "$dir")

	# if the device is a drive letter change it to a single letter, i.e. c:\ or c: => c
	[[ "$device" =~ : ]] && device="${device:0:1}"

	# if the device is a path to a directory (i.e. /dev/sdb1) get the actual device (i.e. sdb1)
	[[ -e "$device" ]] && device="$(GetFileName "$device")"

	return 0
}

getFs()
{	
	local fs="$(getType)"
	[[ "$fs" == "9p" ]] && fs="$(fsutil.exe fsinfo volumeinfo ${device}: | grep "File System Name" | RemoveCarriageReturn | cut -d: -f 2 | RemoveSpace)"
	echo "$fs"
}

getLabel()
{
	# drive letter
	isDriveLetter "$device" && { cmd.exe /c vol "$device": |& RemoveCarriageReturn | grep -v "has no label" | grep "Volume in" | cut -d" " -f7-; return; }

	# lsblk - except in Windows where lsblk label is empty
	! IsPlatform win && { lsblk -f -l --output LABEL --noheadings "/dev/$device" |& grep -v "not a block device"; return; }

	# blkid
	local label="$(eval $(blkid "/dev/$device" -o export); echo $LABEL)" || return; echo "$label"
}

getType()
{
	# findmnt - for mounted drives
	[[ $mountDir ]] && { findmnt --list --noheadings --output=FSTYPE --target "$mountDir"; return; }

	# drive letters - type 9p if using Windows
	isDriveLetter "$device" && { echo "9p"; return; }

	# lsblk - except in Windows where lsblk -fs file system is empty
	! IsPlatform win && { lsblk -fs --list --noheadings --output FSTYPE "/dev/$device"; return; }

	# blkid
	local type="$(eval $(sudoc blkid "/dev/$device" -o export); echo $TYPE)" || return; echo "$type"
}

isMounted() # device
{
	local quiet; [[ "$1" == @(-q|--quiet) ]] && quiet="true"
	local pattern="/dev/${device}"; isDriveLetter "$device" && pattern="^[${device}]:[\]?"
	local dir="$(findmnt --noheadings --output=SOURCE,TARGET --list | grep -Ei "^${pattern}[ ]+" | tr -s " " | cut -d" " -f2)"

	# On Windows build 20221.1000 the SOURCE is drvfs instead of the drive letter
	if [[ ! $dir ]] && isDriveLetter "$device" &&  findmnt "/mnt/$device" >& /dev/null; then
		dir="/mnt/$device"		
	fi

	[[ ! $dir ]] && return 1
	[[ ! $quiet ]] && echo "$dir"
	return 0
}

run "$@"

#!/usr/bin/env bash
. function.sh

run() {	init || return; args "$@" || return; ${command}Command "${args[@]}"; }

init()
{
	unset device devices efiDevice lvm
	driveLetters=( c d e f g h i j k l m n o p q r s t u v w x y z )
	mountRoot="/mnt"; [[ -d "/media/$USER" ]] && mountRoot="/media/$USER" # Ubuntu
	InPath lvm && lvm="true"
	return 0
}

usage()
{
	echot "\
usage: drive COMMAND(detail)
	DEVICE 	the drive device name to mount.  Ex: sdb1, d (Windows), or all (all available drives)
	DIR			a directeory in the mounted drive

	IsMounted|mount|unmount DEVICE
		IsMounted				if the specified device is mounted return the directory it is mounted to
		mount|unmount		mount or unmount the specified device and return the directory it is mounted to

	device|fs|format|IsDrive|IsWin|label|resize|SetLabel|type DEVICE|DIR
		device					get the device name of the drive
		format FS				format the device
		IsWin						return true if the drive is mounted using Windows drvfs
		fs			get the file system of the drive
		SetLabel LABEL 	set the label of the drive
		type						get the type of the drive (9p for Windows mounted drives)

	detail						list detailed information of all drives
	list							list device names of all drives
	mounts						list mount directory of all mounted drives

	win exists|list|online|offline - windows drives

	-ie,	--ignore-errors	ignore errors when operating on all drives
	-q, 	--quiet					hide status messages
	-v, 	--verbose				show verbose output"
	exit ${1:-1}
}

args()
{
	unset -v all command device ignoreErrors quiet verbose

	while (( $# != 0 )); do
		case "$1" in
			-h|--help) usage 0;;
			-ie|--ignore-errors) ignoreErrors="true";;
			-q|--quiet) quiet="--quiet";;
			-v|--verbose) verbose="--verbose";;
			IsDrive) command="isDrive";; IsMounted) command="isMounted";; IsWin) command="isWin";;
			SetLabel) command="setLabel";;
			*)
				[[ ! $device ]] && getDeviceArg "$1" && { shift; continue; }
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(device|fs|format|IsDrive|IsWin|label|resize|SetLabel|type|win) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	command="${command:-detail}"
	[[ "$command" == @(IsMounted|mount|unmount) && ! $device ]] && MissingOperand "device"
	[[ "$device" == "all" ]] && all="true"

	args=("$@")
}

# getDeviceArg DEVICE - get the device argument (either DEVICE or /dev/DEVICE)
getDeviceArg()
{
	local check="${1#/dev/}" # remove /dev/
	! isDevice "$check" && return 1
	device="$check"
}

#
# commands
# 

isMountedCommand() { [[ $all ]] && { areAllMounted; return; }; isMounted; }
mountCommand() { [[ $all ]] && { allMount; return; }; doMount; }
unmountCommand() { [[ $all ]] && { allUnmount; return; }; doUnmount; }

deviceCommand() { getDevice "$@" || return; echo "$device"; }
fsCommand() { getDevice "$@" || return; getFs; }
isDriveCommand() { getDevice "$@" || return; isDevice "$device"; }
isWinCommand() { IsPlatform win && [[ "$(typeCommand "$@")" == "9p" ]]; }
labelCommand() { getDevice "$@" || return; getLabel; }
listCommand() { getAllDevices; ListArray devices; }
typeCommand() { getDevice "$@" || return; getType; }

detailCommand()
{
	di -x cifs,9p,tmpfs || return

	getAllDevices || return

	{
	PrintErr "searching..."
	hilight "DEVICE:FS:LABEL"
	for device in ${devices[@]}; do
		PrintErr .
		echo "$device:$(getFs):$(getLabel)"
	done
	EchoErr "done"
	} | column -c $(tput cols) -t -s: -n
}

formatCommand()
{
	# get device argument
	getDevice || return

	# get file system argument
	local fs="$1"; shift; [[ $# != 0 ]] && usage
	[[ ! $fs ]] && { isDriveLetter "$device" && fs="ntfs" || fs="ext4"; }
		
	# set label
	if isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c format "$device:" "/fs:$fs"
	else
		sudo mkfs.$fs "/dev/$device"
	fi
}

mountsCommand()
{
	local d=()

	# standard mounted drives
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		dir="$(isMounted)" && d+=( "$dir" )
	done

	# other drives
	case "$PLATFORM" in
		linux) d+=( $(find /mnt/hgfs/* /media/psf/* |& grep -v "No such file") );;
		mac) IFS=$'\n' d+=( $(df | grep "^/dev/" | awk '{print $9}' | grep -v '^/$|^/$') );;
	esac

	ListArray d
}

resizeCommand()
{
	# get device argument
	getDevice || return

	# get size argument
	local size="$1"; shift; [[ $# != 0 ]] && usage
	[[ ! $size ]] && MissingOperand "size"
		
	# checks
	isDriveLetter "$device" && error "cannot resize Windows mounted drives"
	! isLvm && error "cannot resize a non-LVM drives"

	# resize
	local d="/dev/$device"

	hilight "Resizing volume..."
	sudo lvresize -L "$size" "/dev/$device" || return
	echo 

	hilight "Resizing file system..."
	sudo resize2fs "/dev/$device" || return

	hilight "Checking file system..."
	sudo e2fsck "/dev/$device" || return
	echo
}

setLabelCommand()
{
	# get device argument
	getDevice || return

	# get label argument
	local label="$1"; shift; [[ $# != 0 ]] && usage 
	[[ ! $label ]] && MissingOperand "label"
		
	# set label
	if isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c label "$device:" system "$1"
	else
		sudo e2label "/dev/$device" "$label"
	fi
}
#
# win commands
#

winCommand()
{
	local command; CheckSubCommand win "$1"; shift
	Win${command}Command "$@"
}

WinListCommand() { diskpart "list disk" | grep -E 'Online|Offline|Status|---'; }
WinExistsCommand() { diskpart "select disk $1" | grep "Disk $1 is now the selected disk." >& /dev/null; }
WinGetofflineCommand() { drive win list | grep Offline | tr -s " " | cut -d" " -f3; }
WinOnlineCommand() { diskpart "select disk $1 \n online disk" | grep "DiskPart successfully onlined the selected disk" >& /dev/null; }
WinOfflineCommand() { diskpart "select disk $1 \n offline disk" | grep "DiskPart successfully offlined the selected disk" >& /dev/null; }

#
# helper
#

error() { EchoErr "$(ScriptName): $1"; exit 1; }
isDevice() { [[ "$1" == @("all") || -e "/dev/$1" ]] || isDriveLetter "$1"; }
isDriveLetter() { IsPlatform win && IsInArray "$1" driveLetters; }
isLvm() { sudo lvdisplay -c | cut -d: -f1 | RemoveSpace | grep "^/dev/${device}$" >& /dev/null; }
log() { [[ $quiet ]] && return; printf "$@"; }
platformUnmount() { sudoc umount "$mountDir"; }
showResult() { [[ $1 && ! $all && ! $quiet ]] && echo "$1"; [[ $1 ]]; }

allMount()
{
	local result

	areAllMounted && return

	log "mounting..."
	for device in "${devices[@]}"; do

		{ isMounted || ! canMount; } && continue

		log "$device."
		doMount; result="$?"
		[[ "$result" != "0" && ! $ignoreErrors ]] && return "$result"

	done
	log "done\n"

	return 0
}

allUnmount()
{
	areAllUnmounted && return

	log "unmounting..."	
	for device in "${devices[@]}"; do
		{ ! isMounted || ! canUnmount; } && continue
		log "$device."; doUnmount; result="$?"
		[[ "$result" != "0" && ! $ignoreErrors ]] && return "$result"
	done
	log "done\n"

	return 0
}

areAllMounted()
{
	getAllDevices || return

	for device in "${devices[@]}"; do
		canMount && ! isMounted && return 1
	done

	return 0
}

areAllUnmounted()
{
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		canUnmount && isMounted && return 1
	done

	return 0
}

canMount()
{
	local type="$(getType "$device")"
	[[ "$type" == "" ]] && { reason="no filesystem"; return 1; }
	[[ "$type" == "LVM2_member" ]] && { reason="logical volume member"; return 1; }
	return 0
}

canUnmount()
{
	[[ "$device" != "c" ]] && ! isEfiDevice
}

isEfiDevice()
{
	IsPlatform win && return 1
	[[ ! $efiDevice ]] && efiDevice="$(findmnt --noheadings --output=SOURCE --target "/boot/efi" | GetFileName)"
	[[ "$device" == "$efiDevice" ]]
}

cleanupMountDir() # dir
{
	[[ ! -e "$mountDir" ]] && return
	findmnt "$mountDir" >& /dev/null && platformUnmount >& /dev/null
	sudoc rmdir "$mountDir" >& /dev/null
	[[ ! -e "$mountDir" ]]
}

doMount()
{
	# return if the drive is already mounted
	mountDir="$(isMounted)" && { showResult "$mountDir"; return; }

	# identify the mount point - use the drive label if possible
	mountDir="$mountRoot/$device" label="$(getLabel)"
	[[ $label && ! -e "$mountRoot/$label" ]] && m="$mountRoot/$label"

	# return if we cannot mount the drive
	! canMount && error "cannot mount $device ($reason)"

	# unmount a drive that is no longer present
	cleanupMountDir || return

	# create the mount directory
	[[ ! -d "$mountDir" ]] && { sudoc mkdir --parents "$mountDir" || return 1; } # use --parents for LVM

	# mount the drive - supress some errors when mounting all devices
	local desc result

	if isDriveLetter "$device"; then
		
		if [[ $all ]]; then
			local result
			desc="$(sudoc mount -t drvfs "$device:" "$mountDir" 2>&1)"; result="$?"

			if echo "$desc" | grep "No medium found" >& /dev/null; then
				log "(no media)..."; cleanupMountDir; return 0
			fi

			[[ "$result" != "0" ]] && EchoErr "$result"
		else
			sudoc mount -t drvfs "$device:" "$mountDir"
		fi

	else
		sudoc mount "/dev/$device" "$mountDir"
	fi

	# check the mounted drive
	if isMounted; then
		return 0
	else
		cleanupMountDir
		return 1
	fi
}

doUnmount()
{
	mountDir="$(isMounted)" || return

	# return if we cannot unmount this drive
	! canUnmount && error "cannot unmount $device"

	# unmount and cleanup
	platformUnmount; cleanupMountDir

	return 0
}

getAllDevices() # sets devices array
{
	[[ $devices ]] && return

	# Windows drive letters
	if IsPlatform win; then
		devices+=( $(fsutil.exe fsinfo drives | sed 's/:\\//g' | sed 's/Drives: //g' | tr '[:upper:]' '[:lower:]' | RemoveCarriageReturn ) )
	fi

	# regular disks
	local d=()
	d+=( /dev/sd[a-c][0-9]* ) 			# SATA disks
	d+=( /dev/mmcblk[0-9]p[0-9]* ) 	# SD cards
	d+=( /dev/nvme0n[0-9]p[0-9]* ) 	# NVMe
	
	# LVM logical volumes
	[[ $lvm ]] && d+=( $(sudoc lvdisplay -c | cut -d: -f1 | RemoveSpace) ) || return

	devices+=( $(find "${d[@]}" |& grep -v "No such file" | sed 's/\/dev\///g') )

	return 0
}

# getDevice DIR - get the devce for the passed directory
getDevice()
{
	[[ $device ]] && return

	# validate only one argument is passed and it is a directory
	local dir="$1"; shift; [[ "$#" != "0" ]] && usage
	[[ ! $dir ]] && MissingOperand "dir"
	[[ ! -d "$dir" ]] && error "mount directory \`$dir\` does not exist"

	# get the mount target and source for the specified directory
	read device <<<$(findmnt --noheadings --output=SOURCE --target "$dir")

	# On Windows build 20221.1000 the SOURCE is drvfs instead of the drive letter
	[[ "$device" == "drvfs" ]] && { device="$(GetFileName "$dir")"; return; }

	# LVM - i.e. /dev/mapper/vg01-p1 -> vg01/p1
	[[ "$device" =~ ^/dev/mapper/ ]] && { device="${device#/dev/mapper/}"; device="${device/-/\/}"; return; }

	# drive letter - change to single letter, i.e. c:\ or c: => c
	[[ "$device" =~ : ]] && { device="${device:0:1}"; return; }

	# deivce directory - remove /dev/, i.e. /dev/sdb1 -> sdb1
	[[ -e "$device" ]] && { device="$(GetFileName "$device")"; return; }
}

getFs()
{
	local fs="$(getType)"
	[[ "$fs" == "9p" ]] && fs="$(RunScript --elevate fsutil.exe fsinfo volumeinfo ${device}: | grep "File System Name" | RemoveCarriageReturn | cut -d: -f 2 | RemoveSpace)"
	echo "$fs"
}

getLabel()
{
	# drive letter
	isDriveLetter "$device" && { cmd.exe /c vol "$device": |& RemoveCarriageReturn | grep -v "has no label" | grep "Volume in" | cut -d" " -f7-; return; }

	# lsblk - except in Windows where lsblk label is empty
	! IsPlatform win && { lsblk -f -l --output LABEL --noheadings "/dev/$device" |& grep -v "not a block device"; return; }

	# blkid
	local label="$(eval $(blkid "/dev/$device" -o export); echo $LABEL)" || return; echo "$label"
}

getType()
{
	# findmnt - for mounted drives
	[[ $mountDir ]] && { findmnt --list --noheadings --output=FSTYPE --target "$mountDir"; return; }

	# drive letters - type 9p if using Windows
	isDriveLetter "$device" && { echo "9p"; return; }

	# lsblk - except in Windows where lsblk -fs file system is empty
	! IsPlatform win && { lsblk -fs --list --noheadings --output FSTYPE "/dev/$device"; return; }

	# blkid
	local type="$(eval $(sudoc blkid "/dev/$device" -o export); echo $TYPE)" || return; echo "$type"
}

isMounted()
{
	local pattern="/dev/${device}"; isDriveLetter "$device" && pattern="${device}:[\]?"

	local dir="$(findmnt --noheadings --output=SOURCE,TARGET --list |
		sed 's/mapper\///g' | sed 's/-/\//g' | 	# /dev/mapper/vg01-p3 -> /dev/vg01/p3
		grep -Ei "^${pattern}[ ]+" | 						# find device
		tr -s " " | cut -d" " -f2)"							# remove spaces and return target

	# On Windows build 20221.1000 the SOURCE is drvfs instead of the drive letter
	if [[ ! $dir ]] && isDriveLetter "$device" &&  findmnt "/mnt/$device" >& /dev/null; then
		dir="/mnt/$device"		
	fi

	showResult "$dir"
}

run "$@"

#!/usr/bin/env bash
. function.sh

run() {	init || return; args "$@" || return; ${command}Command "${args[@]}"; }

init()
{
	unset device devices efiDevice lvm
	driveLetters=( c d e f g h i j k l m n o p q r s t u v w x y z )
	mountRoot="/mnt"; [[ -d "/media/$USER" ]] && mountRoot="/media/$USER" # Ubuntu
	InPath lvm && lvm="true"
	$lvm
	return 0
}

usage()
{
	echot "\
usage: drive COMMAND(detail)
	DEVICE 	the drive device name to mount.  Ex: sdb1, d (Windows), or all (all available drives)
	DIR			a directeory in the mounted drive

	IsMounted|mount|unmount DEVICE
		IsMounted				if the specified device is mounted return the directory it is mounted to
		mount|unmount		mount or unmount the specified device and return the directory it is mounted to

	device|fs|format|IsDrive|IsWin|label|resize|SetLabel|type DEVICE|DIR
		device					get the device name of the drive
		format FS				format the device
		IsWin						return true if the drive is mounted using Windows drvfs
		fs							get the file system of the drive
		SetLabel LABEL 	set the label of the drive
		type						get the type of the drive (9p for Windows mounted drives)

	detail						list detailed information of all drives
	list [removable]	list device names of all or specified types of drives
	mounts						list mount directory of all mounted drives

	win exists|GetOffline|list|online|offline - windows drives
		use \`wsl mount\` to mount a windows drive in WSL

	-ie,	--ignore-errors	ignore errors when operating on all drives
	-q, 	--quiet					hide status messages
	-v, 	--verbose				show verbose output"
	exit ${1:-1}
}

args()
{
	unset -v all command device ignoreErrors quiet verbose

	while (( $# != 0 )); do
		case "$1" in
			-h|--help) usage 0;;
			-ie|--ignore-errors) ignoreErrors="true";;
			-q|--quiet) quiet="--quiet";;
			-v|--verbose) verbose="--verbose";;
			IsDrive) command="isDrive";; IsMounted) command="isMounted";; IsWin) command="isWin";;
			SetLabel) command="setLabel";;
			*)
				[[ ! $device ]] && getDeviceArg "$1" && { shift; continue; }
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(device|fs|format|IsDrive|IsWin|label|list|resize|SetLabel|type|win) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	command="${command:-detail}"
	[[ "$command" == @(IsMounted|mount|unmount) && ! $device ]] && MissingOperand "device"
	[[ "$device" == "all" ]] && all="true"

	args=("$@")
}

# getDeviceArg DEVICE - get the device argument (either DEVICE or /dev/DEVICE)
getDeviceArg()
{
	local check="${1#/dev/}" # remove /dev/
	! isDevice "$check" && return 1
	device="$check"
}

#
# commands
# 

isMountedCommand() { [[ $all ]] && { areAllMounted; return; }; isMounted; }
mountCommand() { [[ $all ]] && { allMount; return; }; doMount && returnMountDir; }
unmountCommand() { [[ $all ]] && { allUnmount; return; }; doUnmount; }

deviceCommand() { getDevice "$@" || return; echo "$device"; }
fsCommand() { getDevice "$@" || return; getFs; }
isDriveCommand() { getDevice "$@" || return; isDevice "$device"; }
isWinCommand() { IsPlatform win && [[ "$(typeCommand "$@")" == "9p" ]]; }
labelCommand() { getDevice "$@" || return; getLabel; }
typeCommand() { getDevice "$@" || return; getType; }

detailCommand()
{
	di -x cifs,9p,tmpfs || return

	getAllDevices || return

	local device fs label
	{

		PrintErr "searching..."

		hilight "DEVICE:FS:LABEL"

		for device in ${devices[@]}; do
			unset mountDir
			fs="$(getFs)" label=$(getLabel); PrintErr .
			[[ "$fs" == "LVM2_member" ]] && continue
			echo "$device:$fs:$label"
		done

		EchoErr "done"

	} | column -c $(tput cols) -t -s: -n
}

formatCommand()
{
	# get device argument
	getDevice || return

	# get file system argument
	local fs="$1"; shift; [[ $# != 0 ]] && usage
	[[ ! $fs ]] && { isDriveLetter "$device" && fs="ntfs" || fs="ext4"; }
		
	# set label
	if isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c format "$device:" "/fs:$fs"
	else
		sudo mkfs.$fs "/dev/$device"
	fi
}

listCommand()
{
	local d device devices type="$1" result=()

	# arguments
	[[ $type ]] && { shift; [[ "$type" != "removable" ]] && usage; }
	[[ $# != 0 ]] && usage

	# get devices
	getAllDevices || return

	# list devices and return if the type was not specified
	[[ ! $type ]] && { [[ $devices ]] && ListArray devices; return; }

	# filter by type, currently only removable
	for device in "${devices[@]}"; do
		isRemovable && d+=( "$device" )
	done

	[[ $d ]] && ListArray d
	return 0
}

isRemovable()
{
	isDriveLetter "$device" && fsutil.exe fsinfo driveType "${drive}:\\" |& grep "Removable Drive" >& /dev/null && return
	[[ "$(lsblk --nodeps --noheadings --output RM "/dev/$device")" == "1" ]] && return
	udevadm info --query=property --export --name="/dev/$device" | grep "ID_BUS='usb'" >& /dev/null && return
	return 1
}

mountsCommand()
{
	local d=()

	# standard mounted drives
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		mountDir="$(getMountDir)" || continue
		! canUnmount && continue
		d+=( "$mountDir" )
	done

	# other drives
	case "$PLATFORM" in
		linux) d+=( $(find /mnt/hgfs/* /media/psf/* |& grep -v "No such file") );;
		mac) IFS=$'\n' d+=( $(df | grep "^/dev/" | awk '{print $9}' | grep -v '^/$|^/$') );;
	esac

	[[ ! $d ]] && return
	ListArray d
}

resizeCommand()
{
	# get device argument
	getDevice || return

	# get size argument
	local size="$1"; shift; [[ $# != 0 ]] && usage
	[[ ! $size ]] && MissingOperand "size"
		
	# checks
	isDriveLetter "$device" && { ScriptErr "cannot resize Windows mounted drives"; return 1; }
	! isLvm && { ScriptErr "cannot resize a non-LVM drives"; return 1; }

	# resize
	local d="/dev/$device"

	hilight "Resizing volume..."
	sudo lvresize -L "$size" "/dev/$device" || return
	echo 

	hilight "Resizing file system..."
	sudo resize2fs "/dev/$device" || return

	hilight "Checking file system..."
	sudo e2fsck "/dev/$device" || return
	echo
}

setLabelCommand()
{
	# get device argument
	getDevice || return

	# get label argument
	local label="$1"; shift; [[ $# != 0 ]] && usage 
	[[ ! $label ]] && MissingOperand "label"
		
	# set label
	if isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c label "$device:" system "$1"
	elif InPath e2label; then
		sudo e2label "/dev/$device" "$label"
	elif InPath tune2fs; then
		sudo tune2fs -L "$label" "/dev/$device"
	else
		EchoErr "unable to set the label for $device"
	fi
}
#
# win commands
#

winCommand()
{
	local command; CheckSubCommand win "$1"; shift
	Win${command}Command "$@"
}

WinListCommand() { diskpart "list disk" | grep -E 'Online|Offline|Status|---'; }
WinExistsCommand() { diskpart "select disk $1" | grep "Disk $1 is now the selected disk." >& /dev/null; }
WinGetofflineCommand() { drive win list | grep Offline | tr -s " " | cut -d" " -f3; }
WinOnlineCommand() { diskpart "select disk $1 \n online disk" | grep "DiskPart successfully onlined the selected disk" >& /dev/null; }
WinOfflineCommand() { diskpart "select disk $1 \n offline disk" | grep "DiskPart successfully offlined the selected disk" >& /dev/null; }

#
# helper
#

isDevice() { [[ "$1" == @("all") || -b "/dev/$1" ]] || isDriveLetter "$1"; }
isDriveLetter() { IsPlatform win && IsInArray "$1" driveLetters && [[ ! -e "$1" ]]; } # not a drive letter if we are passed a mounted file or directory
isLvm() { sudo lvdisplay -c | cut -d: -f1 | RemoveSpace | grep "^/dev/${device}$" >& /dev/null; }
isMounted() { getMountDir >& /dev/null; }
log() { [[ $quiet ]] && return; printf "$@"; }
platformUnmount() { sudoc umount "$mountDir"; }
returnMountDir() { [[ $mountDir && ! $quiet ]] && echo "$mountDir"; [[ $mountDir ]]; }

allMount()
{
	local result

	areAllMounted && return

	log "mounting..."
	for device in "${devices[@]}"; do
		unset mountDir
		{ isMounted || ! canMount; } && continue
		log "$device..."; doMount; result="$?"
		[[ "$result" != "0" && ! $ignoreErrors ]] && return "$result"
	done
	log "done\n"

	return 0
}

allUnmount()
{
	local devicesToUnmount

	areAllUnmounted && return

	log "unmounting..."	

	for device in "${devices[@]}"; do
		unset mountDir
		{ ! isMounted || ! canUnmount; } && continue
		log "$device..."; doUnmount; result="$?"
		[[ "$result" != "0" && ! $ignoreErrors ]] && return "$result"
	done

	log "done\n"

	return 0
}

areAllMounted()
{
	getAllDevices || return

	for device in "${devices[@]}"; do
		unset mountDir
		canMount && ! isMounted && return 1
	done

	return 0
}

areAllUnmounted()
{
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		unset mountDir
		canUnmount && isMounted && return 1
	done

	return 0
}

canMount()
{
	local type="$(getType)"
	[[ "$type" == "" ]] && { reason="no filesystem"; return 1; }
	[[ "$type" == "LVM2_member" ]] && { reason="logical volume member"; return 1; }
	[[ "$type" == "swap" ]] && { reason="swap drive"; return 1; }
	return 0
}

canUnmount()
{
	[[ "$device" == "c" ]] && { reason="boot drive"; return 1; }

	! IsPlatform linux return 0

	local mountDir="$(getMountDir)"
	[[ "$mountDir" == "/boot/efi" ]] && { reason="firmware drive"; return 1; }
	[[ "$mountDir" == "/" ]] && { reason="boot drive"; return 1; }

	return 0
}

isEfiDevice()
{
	IsPlatform win && return 1
	[[ ! $efiDevice ]] && efiDevice="$(findmnt --noheadings --output=SOURCE --target "/boot/efi" | GetFileName)"
	[[ "$device" == "$efiDevice" ]]
}

cleanupMountDir() 
{
	[[ ! -e "$mountDir" ]] && return
	findmnt "$mountDir" >& /dev/null && platformUnmount >& /dev/null
	sudoc rmdir "$mountDir" || return
	sudo rmdir "${mountRoot}/"* >& /dev/null # cleanup empty mount directories
	[[ ! -e "$mountDir" ]]
}

doMount()
{
	# return if the drive is already mounted
	mountDir="$(getMountDir)" && return

	# identify the mount point - use the drive label if possible
	mountDir="$mountRoot/$device" label="$(getLabel)"
	[[ $label && ! -e "$mountRoot/$label" ]] && mountDir="$mountRoot/$label"

	# return if we cannot mount the drive
	! canMount && { ScriptErr "cannot mount $device ($reason)"; return 1; }

	# unmount a drive that is no longer present
	cleanupMountDir || return

	# create the mount directory
	[[ ! -d "$mountDir" ]] && { sudoc mkdir --parents "$mountDir" || return 1; } # use --parents for LVM

	# mount the drive - supress some errors when mounting all devices
	local desc result

	if isDriveLetter "$device"; then
		doMountDriveLetter	
	else
		sudoc mount "/dev/$device" "$mountDir"
	fi

	# check the mounted drive
	if isMounted; then
		return 0
	else
		cleanupMountDir
		return 1
	fi
}

doMountDriveLetter()
{
	[[ ! $all ]] && { sudoc mount -t drvfs "$device:" "$mountDir"; return; }

	# when mounting all drives, do not error out for empty optical media drives

	local result
	desc="$(sudoc mount -t drvfs "$device:" "$mountDir" 2>&1)"; result="$?"

	if echo "$desc" | grep "No medium found" >& /dev/null; then
		log "(no media)..."; cleanupMountDir; return 0
	fi

	[[ "$result" != "0" ]] && { ScriptErr "$result"; return $result; }

	return 0
}

doUnmount()
{
	mountDir="$(getMountDir)" || return 0
	
	# return if we cannot unmount this drive
	! canUnmount && { ScriptErr "cannot unmount $device ($reason)"; return 1; }

	platformUnmount && cleanupMountDir
}

getAllDevices() # sets devices array
{
	[[ $devices ]] && return

	# Windows drive letters
	if IsPlatform win; then
		devices+=( $(fsutil.exe fsinfo drives | sed 's/:\\//g' | sed 's/Drives: //g' | tr '[:upper:]' '[:lower:]' | RemoveCarriageReturn ) )
	fi

	# regular disks
	local d=()
	d+=( /dev/sd[a-c][0-9]* ) 			# SATA disks
	d+=( /dev/mmcblk[0-9]p[0-9]* ) 	# SD cards
	d+=( /dev/nvme0n[0-9]p[0-9]* ) 	# NVMe
	
	# LVM logical volumes
	[[ $lvm ]] && { d+=( $(sudoc lvdisplay -c | cut -d: -f1 | RemoveSpace) ) || return; }

	devices+=( $(find "${d[@]}" |& grep -v "No such file" | sed 's/\/dev\///g') )

	return 0
}

# getDevice DIR - ensure device is set from the passed mounted directory
getDevice()
{
	# use the device if set
	[[ $device ]] && return

	# get passed directory argument
	local dir="$1"; shift; [[ "$#" != "0" ]] && usage
	[[ ! $dir ]] && MissingOperand "dir"
	[[ ! -d "$dir" ]] && { ScriptErr "mount directory \`$dir\` does not exist"; return 1; }

	# get device - the source for the mounted target directory
	read device <<<$(findmnt --noheadings --output=SOURCE --target "$dir")

	# if the device (source) is drvfs, look in the mount OPTIONS for path=LETTER (Windows build 20221.1000)
	if [[ "$device" == "drvfs" ]]; then
		local options; IFS=';' o=( $(findmnt --noheadings --output=OPTIONS --target "$dir") )
		device="$(ListArray options | grep "^path=" | cut -d"=" -f2)"
	fi

	# change drive letters to a single lower case letter, i.e. C:\ -> c
	[[ "$device" =~ : ]] && { device="${device:0:1}"; device="${device,,}"; return; }

	# remove /dev from the device, i.e. /dev/sdb1 -> sdb1
	[[ "$device" =~ ^/dev/ ]] && device="${device#/dev/}"

	# ensure the device is a block device
	[[ ! -b "/dev/$device" ]] && { ScriptErr "$device is not a valid block device"; return 1; }

	return 0
}

getFs()
{
	local fs="$(getType)"
	[[ "$fs" == "9p" ]] && fs="$(RunScript --elevate fsutil.exe fsinfo volumeinfo ${device}: | grep "File System Name" | RemoveCarriageReturn | cut -d: -f 2 | RemoveSpace)"
	echo "$fs"
}

getLabel()
{
	# Windows drive letters
	isDriveLetter "$device" && { cmd.exe /c vol "$device": |& RemoveCarriageReturn | grep -v "has no label" | grep "Volume in" | cut -d" " -f7-; return; }

	# lsblk, except in Windows where the label is empty
	! IsPlatform win && { lsblk --nodeps --noheadings --output LABEL "/dev/$device" |& grep -v "not a block device"; return; }

	# blkid
	local label info="$(blkid "/dev/$device")" || return 
	if [[ $info ]]; then # block device information is in the cache
		label="$(eval $(blkid "/dev/$device" -o export); echo $LABEL)" || return
	else # probe the block device since it has no information in the cache
		label="$(eval $(sudoc -p blkid "/dev/$device" -o export); echo $LABEL)" || return
	fi

	echo "$label"
}

getMountDir()
{
	if isDriveLetter "$device"; then
		findmnt --list --output=TARGET,OPTIONS | grep -iE "path=$device"':?\\?' | cut -d" " -f1
	else
		findmnt --noheadings --output=TARGET --source "/dev/$device"
	fi
}

getType()
{
	# use findmnt to get the type if we have the mount directory
	[[ -d "$mountDir" ]] && { findmnt --noheadings --output=FSTYPE --target "$mountDir"; return; }

	# Windows drive letters - the type must be 9p
	isDriveLetter "$device" && { echo "9p"; return; }

	# lsblk, except in Windows where the file system is empty
	! IsPlatform win && { lsblk --nodeps --noheadings --output FSTYPE "/dev/$device"; return; }

	# blkid
	local type="$(eval $(sudoc blkid "/dev/$device" -o export); echo $TYPE)" || return
	echo "$type"
}

run "$@"

#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: drive COMMAND(detail)
Manipulate system drives.

	DEVICE 	the drive device name to mount or a file in the mounted drive.
				  Ex: sdb1, d (Windows), or all (all available drives)

	IsMounted|mount|unmount|remount DEVICE
		IsMounted				if the specified device is mounted return the directory it is mounted to
		mount						mount the specified device and return the directory it is mounted to

	device|fs|format|IsDrive|IsWin|label|resize|SetLabel|size|type DEVICE
		device					get the device name of the specified mounted file
		desc						get the description of the specified mounted file
		format FS				format the device
		IsWin						return true if the drive is mounted using Windows drvfs
		fs							get the file system of the drive
		root						get the root of the mounted file
		SetLabel LABEL 	set the label of the drive
		size						get the size of the drive
		type						get the type of the drive (9p for Windows mounted drives)

	detail						list detailed information of all drives
	list [removable]	list device names of all or specified types of drives
	mounts						list mount directory of all mounted drives
	win								manipulate windows drives

	-no,	 --no-optical		do not mount optical drives"
}

init()
{
	unset device devices efiDevice lvm
	driveLetters=( c d e f g h i j k l m n o p q r s t u v w x y z )
	InPath lvm && ! IsPlatform wsl1 && lvm="true"
	mountRoot="/mnt"; [[ -d "/media/$USER" ]] && mountRoot="/media/$USER" # Ubuntu
	return 0
}

opt()
{
	case "$1" in
		--no-optical|-no) noOptical="--no-optical";;
		*) return 1;;
	esac
}

argStart() { unset -v all device deviceArg noOptical; }
args() { isQuietCommand && quiet="--quiet"; getDeviceArg "$1"; }
isQuietCommand() { [[ "$command" == @(isDrive|isWin) ]]; }
needsDevice() { [[ "$command" == @(desc|device|format|fs|label|isDrive|isMounted|isWin|mount|unmount|remount|resize|root|setLabel|size|type) ]]; }

# getDeviceArg DEVICE - get the device argument (all, DEVICE or /dev/DEVICE)
getDeviceArg()
{	
	shift=0; ! needsDevice && return
	device="$1" deviceArg="$1"; ((++shift))
	[[ ! $device ]] && { [[ $quiet ]] && return 1 || MissingOperand "device"; }

	device="${device#/dev/}" 	# remove /dev/
	device="${device,,}" 			# lower case

	# drive letter - remove :
	isDriveLetter "$(RemoveEnd "$device" ":")" && device="$(RemoveEnd "$device" ":")"

	# physical device 
	[[ "$device" == "all" ]] && { all="true"; return; }
	[[ -b "/dev/$device" ]] && return
	[[ "$(GetFileExtension "$1")" == "hc" ]] && return
	isDriveLetter "$device" && ! getDevice "$device" >& /dev/null && return # mounted file or directories are not drive letters

	# mounted file
	local file="$deviceArg"
	[[ ! -e "$file" ]] && { [[ ! $quiet ]] && ScriptErr "mount location \`$file\` does not exist"; return 1; }

	# get the device for the mounted file
	device="$(getDevice "$file")" || return

	# if the device (source) is drvfs, look in the mount OPTIONS for path=LETTER (Windows build 20221.1000)
	if [[ "$device" == "drvfs" ]]; then
		local options; IFS=';' ArrayMake options "$(findmnt --noheadings --output=OPTIONS --target "$file")"
		device="$(ArrayDelimit options $'\n' | grep "^path=" | cut -d"=" -f2)"
	fi

	# change drive letters to a single lower case letter, i.e. C:\ -> c
	[[ "$device" =~ ^[a-zA-Z]: ]] && { device="${device:0:1}"; device="${device,,}"; return; }

	# remove /dev from the device, i.e. /dev/sdb1 -> sdb1
	[[ "$device" =~ ^/dev/ ]] && device="${device#/dev/}"

	# ensure the device is a block device
	[[ ! -b "/dev/$device" ]] && { [[ ! $quiet ]] && ScriptErr "$device is not a valid block device"; return 1; }

	return 0	
}

#
# commands
# 

isMountedCommand() { [[ $all ]] && { areAllMounted; return; }; isMounted; }
mountCommand() { [[ $all ]] && { allMount; return; }; doMount && returnMountDir; }
unmountCommand() { [[ $all ]] && { allUnmount; return; }; doUnmount; }
remountCommand() { [[ $all ]] && { allUnMount; allMount; return; }; doUnmount; doMount && returnMountDir; }

descCommand() { echo "$device:$(RemoveFront "$deviceArg" "$(getMountDir)")"; }
deviceCommand() { echo "$device"; }
fsCommand() { getFs; }
isDriveCommand() { :; }
isWinCommand() { IsPlatform win && [[ "$(typeCommand "$device")" == "9p" ]]; }
labelCommand() { getLabel; }
rootCommand() { getMountDir; }
typeCommand() { getType; }

detailCommand()
{
	# show disk information
	InPath di && { di -x cifs,9p,tmpfs || return; }

	# show device, file system, and label
	! InPath columns tput && return
	getAllDevices || return

	local device fs label
	{
		PrintErr "searching..."

		hilight "DEVICE:FS:LABEL"

		for device in ${devices[@]}; do
			unset mountDir
			fs="$(getFs)" label=$(getLabel); PrintErr .
			[[ "$fs" == "LVM2_member" ]] && continue
			echo "$device:$fs:$label"
		done

		EchoErr "done"

	} | column -c $(tput cols) -t -s: -n
}

mountsCommand()
{
	local d=()

	# standard mounted drives
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		mountDir="$(getMountDir)" || continue
		! canUnmount && continue
		d+=( "$mountDir" )
	done

	# other drives
	local other
	case "$PLATFORM_OS" in
		linux) IFS=$'\n' ArrayMake other "$(find /mnt/hgfs/* /media/psf/* |& grep -v "No such file")";;
		mac) IFS=$'\n' ArrayMake other "$(df | grep "^/dev/" | awk '{print $9}' | grep -v '^/$|^/$')";;
	esac
	d+=( "${other[@]}" )

	[[ ! $d ]] && return
	ArrayDelimit d $'\n'
}

sizeCommand()
{
	if isDriveLetter "$device"; then
		diskpart "list volume" | grep "^[ ]* Volume [0-9][0-9]*[ ]*${device^^} " | tr -s " " | cut -d" " -f8
	else
		lsblk -b | grep "$device " | tr -s " " | cut -d" " -f4
	fi
}

#
# Format Command
#

formatArgStart() { unset fs; }

formatArgs()
{
	[[ $1 ]] && { ScriptArgGet "fs" -- "$@"; shift; } || { isDriveLetter "$device" && fs="ntfs" || fs="ext4"; }
}

formatCommand()
{
	if isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c format "$device:" "/fs:$fs"
	else
		sudo mkfs.$fs "/dev/$device"
	fi
}

#
# List Command
#

listArgStart() { unset type; }

listArgs()
{
	(( $# == 0 )) && return
	ScriptArgGet "type" -- "${1,,}"; shift	
	[[ "$type" != @(removable) ]] && usage
}

listCommand()
{
	local d device devices result=()

	# get devices
	getAllDevices || return

	# list devices and return if the type was not specified
	[[ ! $type ]] && { [[ $devices ]] && ArrayDelimit devices $'\n'; return; }

	# filter by type, currently only removable
	for device in "${devices[@]}"; do
		isRemovable && d+=( "$device" )
	done

	[[ $d ]] && ArrayDelimit d $'\n'
	return 0
}

#
# Resize Command
#

resizeArgStart() { unset size; }
resizeArgs() { ScriptArgGet "size" -- "$@"; shift; }

resizeCommand()
{
	# checks
	isDriveLetter "$device" && { ScriptErr "cannot resize Windows mounted drives"; return 1; }
	! isLvm && { ScriptErr "cannot resize a non-LVM drives"; return 1; }

	# resize
	local d="/dev/$device"

	hilight "Resizing volume..."
	sudo lvresize -L "$size" "/dev/$device" || return
	echo 

	hilight "Resizing file system..."
	sudo resize2fs "/dev/$device" || return

	hilight "Checking file system..."
	sudo e2fsck "/dev/$device" || return
	echo
}

#
# SetLabel Command
#

setLabelArgStart() { unset label; }
setLabelArgs() { ScriptArgGet "label" - "$@"; shift; }

setLabelCommand()
{
	if isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c label "$device:" "$1"
	elif InPath e2label; then
		sudo e2label "/dev/$device" "$label"
	elif InPath tune2fs; then
		sudo tune2fs -L "$label" "/dev/$device"
	else
		EchoErr "unable to set the label for $device"
	fi
}

#
# win commands
#

winUsage() { echo "\
Usage: $(ScriptName) win exists|GetOffline|list|online|offline
Manipulate windows drives.  Use \`wsl mount\` to mount a windows drive in WSL."; }

winArgStart() { unset disk; }

winArgs()
{
	[[ "${commandNames[1]}" == @(|getoffline|list) ]] && return
	ScriptArgGet "disk" -- "$@"; shift
}

winCommand() { usage; }
winListCommand() { diskpart "list disk" | grep -E 'Online|Offline|Status|---'; }
winExistsCommand() { diskpart "select disk $disk" | grep "Disk $disk is now the selected disk." >& /dev/null; }
winGetofflineCommand() { drive win list | grep Offline | tr -s " " | cut -d" " -f3; }
winOnlineCommand() { diskpart "select disk $disk \n online disk" | grep "DiskPart successfully onlined the selected disk" >& /dev/null; }
winOfflineCommand() { diskpart "select disk $disk \n offline disk" | grep "DiskPart successfully offlined the selected disk" >& /dev/null; }

#
# helper
#

isDriveLetter() { IsPlatform win && IsInArray "$1" driveLetters; }
isLvm() { sudo lvdisplay -c | cut -d: -f1 | RemoveSpace | grep "^/dev/${device}$" >& /dev/null; }
isMounted() { getMountDir >& /dev/null; }
log() { [[ $quiet ]] && return; printf "$@"; }
platformUnmount() { sudoc umount "$mountDir"; }
returnMountDir() { [[ $mountDir && ! $quiet ]] && echo "$mountDir"; [[ $mountDir ]]; }

allMount()
{
	local result

	areAllMounted && return

	log "mounting..."

	for device in "${devices[@]}"; do
		unset mountDir
		{ isMounted || ! canMount; } && continue
		log "$device"; doMount
	done

	log "done\n"

	return 0
}

allUnmount()
{
	local devicesToUnmount

	areAllUnmounted && return

	log "unmounting..."	

	for device in "${devices[@]}"; do
		unset mountDir
		{ ! isMounted || ! canUnmount; } && continue
		log "$device"; doUnmount
	done

	log "done\n"

	return 0
}

areAllMounted()
{
	getAllDevices || return

	for device in "${devices[@]}"; do
		unset mountDir
		canMount && ! isMounted && return 1
	done

	return 0
}

areAllUnmounted()
{
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		unset mountDir
		canUnmount && isMounted && return 1
	done

	return 0
}

canMount()
{
	# check UNC share of device
	local share; share="$(getUnc)" || return
	[[ "$share" == '//Mac/Dropbox' ]] && { reason="Parallels Dropbox"; return 1; }

	# check removable
	[[ $noOptical ]] && isOptical && { reason="optical drive"; return 1; }

	# check types
	local type="$(getType)"
	[[ "$type" == "" ]] && { reason="no filesystem"; return 1; }
	[[ "$type" == "LVM2_member" ]] && { reason="logical volume member"; return 1; }
	[[ "$type" == "swap" ]] && { reason="swap drive"; return 1; }

	return 0
}

canUnmount()
{
	[[ "$device" == "c" ]] && { reason="boot drive"; return 1; }

	! IsPlatform linux && return 0

	local mountDir; mountDir="$(getMountDir)" || return
	[[ "$mountDir" == "/boot/efi" ]] && { reason="firmware drive"; return 1; }
	[[ "$mountDir" == "/" ]] && { reason="boot drive"; return 1; }

	return 0
}

cleanupMountDir() 
{
	[[ ! -e "$mountDir" ]] && return
	getDevice "$mountDir" >& /dev/null && platformUnmount >& /dev/null
	sudoc rmdir "$mountDir" || return
	sudo rmdir "${mountRoot}/"* >& /dev/null # cleanup empty mount directories
	[[ ! -e "$mountDir" ]]
}

doMount()
{	
	# mount VeraCrypt volumes
	[[ "$(GetFileExtension "$device")" == "hc" ]] && { VeraCrypt mount "$device"; return; }

	# return if the drive is already mounted
	mountDir="$(getMountDir)" && return

	# identify the mount point - use the drive label if possible	
	mountDir="$mountRoot/$device" label="$(getLabel)"
	[[ $label && ! -e "$mountRoot/$label" ]] && { mountDir="$mountRoot/$label"; log1 "label=$label"; }

	# return if we cannot mount the drive
	! canMount && { ScriptErr "cannot mount $device ($reason)"; return 1; }

	# unmount a drive that is no longer present
	cleanupMountDir || return

	# create the mount directory
	[[ ! -d "$mountDir" ]] && { sudoc mkdir --parents "$mountDir" || return 1; } # use --parents for LVM
	log1 "mountDir=$mountDir"

	# mount the drive - supress some errors when mounting all devices
	local desc result

	if isDriveLetter "$device"; then
		doMountDriveLetter	
	else
		doMountOther
	fi

	# check the mounted drive
	if isMounted; then
		return 0
	else
		cleanupMountDir
		return 1
	fi
}

doMountDriveLetter()
{
	if [[ ! $all ]]; then
		log1 "sudoc mount -t drvfs $device: $mountDir"
		sudoc mount -t drvfs "$device:" "$mountDir"; return;
	fi

	# skip some errors when mounting all drives
	local result desc
	
	log1 "sudoc mount -t drvfs $device: $mountDir"
	desc="$(sudoc mount -t drvfs "$device:" "$mountDir" 2>&1)"; result="$?"
	
	# empty optical media drives
	if echo "$desc" | grep "No medium found" >& /dev/null; then
		log " (no media)..."; cleanupMountDir; return 0

	# mount failed
	elif [[ "$result" != "0" ]]; then
		log1 "$result"; log " (failed)..."

	# mount succeeded
	else
		log "..."
	fi

	[[ "$result" == "0" ]]
}

doMountOther()
{
	[[ ! $all ]] && { sudoc mount "/dev/$device" "$mountDir"; return; }

	local result desc
	desc="$(sudoc mount "/dev/$device" "$mountDir"  2>&1)"; result="$?"
	[[ "$result" == "0" ]] && log "..." || log " (failed)..."

	[[ "$result" == "0" ]]
}

doUnmount()
{	
	mountDir="$(getMountDir)" || return 0

	# return if we cannot unmount this drive
	! canUnmount && { ScriptErr "cannot unmount $device ($reason)"; return 1; }

	[[ ! $all ]] && { platformUnmount && cleanupMountDir; return; }

	local result desc
	desc="$(platformUnmount 2>&1 && cleanupMountDir 2>&1)"; result="$?"
	[[ "$result" == "0" ]] && log "..." || log " (failed)..."

	[[ "$result" == "0" ]]	
}

# getAllDevices - sets devices array
getAllDevices() 
{
	[[ $devices ]] && return

	# Windows drive letters
	if IsPlatform win; then
		devices+=( $(fsutil.exe fsinfo drives | sed 's/:\\//g' | sed 's/Drives: //g' | tr '[:upper:]' '[:lower:]' | RemoveCarriageReturn ) )
	fi

	# regular disks
	local d=()
	d+=( /dev/sd[a-c][0-9]* ) 			# SATA disks
	d+=( /dev/mmcblk[0-9]p[0-9]* ) 	# SD cards
	d+=( /dev/nvme0n[0-9]p[0-9]* ) 	# NVMe

	# LVM logical volumes
	[[ $lvm ]] && { d+=( $(sudoc lvdisplay -c |& cut -d: -f1 |& RemoveSpace) ) || return; }

	devices+=( $(find "${d[@]}" |& grep -v "No such file" | sed 's/\/dev\///g') )

	return 0
}

# getDevice FILE - get the device the specified file is mounted on
getDevice()
{
	local file="$1"; [[ ! -e "$file" ]] && return 1
	InPath findmnt && { findmnt --noheadings --output=SOURCE --target "$file"; return; }
	InPath df && { local d="$(df -P "$file" | awk 'END{print $1}')"; [[ $d ]] && echo "$d"; }	
	return 1
}

getFs()
{
	local fs="$(getType)"
	[[ "$fs" == "9p" ]] && fs="$(RunScript --elevate fsutil.exe fsinfo volumeinfo ${device}: | grep "File System Name" | RemoveCarriageReturn | cut -d: -f 2 | RemoveSpace)"
	echo "$fs"
}

getLabel()
{
	local label

	# Windows drive letters
	if isDriveLetter "$device"; then		
		label="$(getUnc)"; [[ $label ]] && { echo "$(GetUncShare "$label")"; return; } # Parallels - drive letters UNC is inm the format \\Mac\<label>		
		label="$(cmd.exe /c vol "$device": |& RemoveCarriageReturn | grep -v "has no label" | grep "Volume in" | cut -d" " -f7-)" || return
	fi

	# lsblk, except in Windows where the label is empty
	! IsPlatform win && { lsblk --nodeps --noheadings --output LABEL "/dev/$device" |& grep -v "not a block device"; return; }

	# blkid
	local label info="$(blkid "/dev/$device")" || return 
	if [[ $info ]]; then # block device information is in the cache
		label="$(eval $(blkid "/dev/$device" -o export); echo $LABEL)" || return
	else # probe the block device since it has no information in the cache
		label="$(eval $(sudoc --preserve blkid "/dev/$device" -o export); echo $LABEL)" || return
	fi

	echo "$label"
}

# getUnc - get the UNC path for a device
getUnc() 
{
	! isDriveLetter "$device" && return
	echo "$(net.exe use | RemoveCarriageReturn | grep "${device^}": | \
		sed 's/Micorosoft Windows Network//' | \
		sed 's/Parallels Shared Folders//' | \
		tr -s " " | RemoveSpaceTrim | cut -d" " -f2- | BackToForwardSlash)"
}

getMountDir()
{
	local dir

	if isDriveLetter "$device"; then
		if IsPlatform wsl1; then			
			dir="$(findmnt --noheadings "$device:" --output=TARGET)"
		else
			dir="$(findmnt --list --output=TARGET,OPTIONS | grep -iE "path=$device"':?\\?' | cut -d" " -f1)"
		fi

	elif InPath findmnt; then
		dir="$(findmnt --noheadings --output=TARGET --source "/dev/$device")"

	elif InPath df; then
		dir="$(df -P "$file" | awk 'END{print $NF}')"

	else
		return 1
		
	fi

	[[ $dir ]] && echo "$dir"
	[[ $dir ]]
}

getType()
{
	# get the type if we have the mount directory
	if [[ -d "$mountDir" ]]; then
		InPath findmnt && { findmnt --noheadings --output=FSTYPE --target "$mountDir"; return; }
		IsPlatfor mac && { mount | grep "on $mountDir " | cut -d'(' -f2 | cut -d, -f1; return; }
		return 1
	fi

	# Windows drive letters - the type must be 9p
	isDriveLetter "$device" && { echo "9p"; return; }

	# lsblk, except in Windows where the file system is empty
	InPath lsblk && ! IsPlatform win && { lsblk --nodeps --noheadings --output FSTYPE "/dev/$device"; return; }

	# blkid
	if InPath blkid; then
		local type="$(eval $(sudoc blkid "/dev/$device" -o export); echo $TYPE)" || return
		echo "$type"
	fi

	# mac
	IsPlatform mac && { mount | grep "/dev/$device " | cut -d'(' -f2 | cut -d, -f1; }

	return 1
}

isEfiDevice()
{
	IsPlatform win && return 1
	[[ ! $efiDevice ]] && efiDevice="$(getDevice "/boot/efi" | GetFileName)"
	[[ "$device" == "$efiDevice" ]]
}

isRemovable()
{
	isDriveLetter "$device" && { fsutil.exe fsinfo driveType "${drive}:\\" |& grep -q "Removable Drive"; return; }
	[[ "$(lsblk --nodeps --noheadings --output RM "/dev/$device")" == "1" ]] && return
	udevadm info --query=property --export --name="/dev/$device" | grep "ID_BUS='usb'" >& /dev/null && return
	return 1
}

isOptical()
{
	isDriveLetter "$device" && { fsutil.exe fsinfo driveType "${device}:\\" |& grep -q "CD-ROM Drive"; return; }
	return 1
}

ScriptRun "$@"

#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]
Manage system drives.

	DEVICE 	the drive device name to mount or a file in the mounted drive.
				  Ex: sdb1, d (Windows), or all (all available drives)

	format|IsMounted|mount|unmount|remount|SetLabel DEVICE - perform an action on the device
	device|free|fs|IsDrive|IsLetter|IsRemovable|IsWin|label|list|resize|size|type DEVICE - get information about the device
	detail|mounts|win - other commands"
}

usageVerbose()
{ 
	ScriptUsageEcho "\
Usage: $(ScriptName) [OPTION]... [COMMAND]
Manage system drives.

	DEVICE 	the drive device name to mount or a file in the mounted drive.
				  Ex: sdb1, d (Windows), or all (all available drives)

	format|IsMounted|mount|unmount|remount|set DEVICE - perform an action on the device
		format FS				format the device
		IsMounted				return true if the specified device is mounted
		[re]mount				mount the specified device and return the directory it is mounted to
		SetLabel LABEL 	set the label of the drive
		unmount					unmount the specified device

	device|free|fs|IsDrive|IsLetter|IsWin|label|list|resize|size|type DEVICE - get information about the device
		device					get the device name of the specified mounted file
		desc						get the description of the specified mounted file
		IsWin						return true if the drive is mounted using Windows drvfs
		fs							get the file system of the drive
		root						get the root of the mounted file
		size						get the size of the drive
		type						get the type of the drive (9p for Windows mounted drives)

	-no,	 --no-optical		do not mount optical drives"
}

init()
{
	unset device devices efiDevice lvm
	driveLetters=( c d e f g h i j k l m n o p q r s t u v w x y z )
	InPath lvm && ! IsPlatform wsl1 && lvm="true"

	# locate the mount root directory	
	if IsPlatform debian; then mountRoot="/mnt"
	elif IsPlatform qnap; then mountRoot="/share"
	elif IsPlatform mac; then mountRoot="/Volumes"
	else ScriptExit "unable to locate mount root directory"
	fi

	return 0
}

opt()
{
	case "$1" in
		--no-optical|-no) noOptical="--no-optical";;
		*) return 1;;
	esac
}

argStart() { unset -v all device deviceArg noOptical; }
args() { isQuietCommand && quiet="--quiet"; getDeviceArg "$1"; }
isQuietCommand() { [[ "$command" == @(isDrive|isWin) ]]; }
needsDevice() { [[ "$command" == @(desc|device|format|free|fs|label|isDrive|isLetter|isMounted|isRemovable|isWin|mount|unmount|remount|resize|root|setLabel|size|type) ]]; }

# getDeviceArg DEVICE - get the device argument (all, DEVICE or /dev/DEVICE)
getDeviceArg()
{	
	shift=0; ! needsDevice && return
	device="$1" deviceArg="$1"; ((++shift))
	[[ ! $device ]] && { [[ $quiet ]] && return 1 || MissingOperand "device"; }

	device="${device#/dev/}" 	# remove /dev/
	device="${device,,}" 			# lower case

	# drive letter - remove :
	isDriveLetter "$(RemoveEnd "$device" ":")" && device="$(RemoveEnd "$device" ":")"

	# physical device 
	[[ "$device" == "all" ]] && { all="true"; return; }
	[[ -b "/dev/$device" ]] && return
	[[ "$(GetFileExtension "$1")" == "hc" ]] && return
	isDriveLetter "$device" && ! getDevice "$device" >& /dev/null && return # mounted file or directories are not drive letters

	# mounted file
	local file="$deviceArg"
	[[ ! -e "$file" ]] && { [[ ! $quiet ]] && ScriptErr "mount location \`$file\` does not exist"; return 1; }

	# get the device for the mounted file
	device="$(getDevice "$file")" || return

	# if the device (source) is drvfs (WSL 2), look in the mount OPTIONS for path=LETTER (Windows build 20221.1000)
	if [[ "$device" == "drvfs" ]]; then
		local options; IFS=';' ArrayMake options "$(findmnt --noheadings --output=OPTIONS --target "$file")"
		device="$(ArrayDelimit options $'\n' | grep "^path=" | cut -d"=" -f2)"
	fi

	# drive letter
	if IsPlatform win && [[ "$device" =~ ^[a-zA-Z]: ]]; then

		# change to a single lower case letter, i.e. C:\ -> c
		device="${device:0:1}"; device="${device,,}"

		# exclude network drives
		local shareName="$(net.exe use "$device:" |& grep "Remote name" | BackToForwardSlash | RemoveCarriageReturn | RemoveBefore " ")"
		if [[ $shareName ]]; then
			ScriptErrQuiet "'${device^}:\ ($shareName)' is not a valid block device"
			return 1
		fi

		return
	fi

	# remove /dev from the device, i.e. /dev/sdb1 -> sdb1
	[[ "$device" =~ ^/dev/ ]] && device="${device#/dev/}"

	# WSL 1 file system - rootfs
	[[ "$device" == "rootfs" ]] && return

	# real device - ensure it is a block device
	[[ ! -b "/dev/$device" ]] && { [[ ! $quiet ]] && ScriptErrQuiet "'$device' is not a valid block device"; return 1; }

	return 0	
}

#
# commands
# 

isLetterCommand() { isDriveLetter "$device"; }
isMountedCommand() { [[ $all ]] && { areAllMounted; return; }; isMounted; }
isRemovableCommand() { isRemovable "$device"; }
mountUsage() { ScriptUsageEcho "Usage: $(ScriptName) mount [root|user]\nMount a drive, or show the root or user mount directory."; }
mountCommand() { [[ $all ]] && { allMount; return; }; doMount && returnMountDir; }
mountRootCommand() { echo "$mountRoot"; }
mountUserCommand() { echo "$HOME/Volumes"; }
unmountCommand() { [[ $all ]] && { allUnmount; return; }; doUnmount; }
remountCommand() { [[ $all ]] && { allUnMount; allMount; return; }; doUnmount; doMount && returnMountDir; }

deviceCommand() { echo "$device"; }
fsCommand() { getFs; }
isDriveCommand() { :; }
isWinCommand() { IsPlatform win && [[ "$(typeCommand "$device")" == "9p" ]]; }
labelCommand() { getLabel; }
rootCommand() { getMountDir; }
typeCommand() { getType; }

descCommand()
{	
	local what="device"; isDriveLetter "$device" && what="drive"
	echo "'$deviceArg' is mounted on $what $device"; 
}

detailUsage() {	ScriptUsageEcho "Usage: $(ScriptName) detail\nList detailed information of all drives."; }

detailCommand()
{
	# show disk information
	InPath di && { di -x cifs,9p,tmpfs || return; }

	# show device, file system, and label
	! InPath columns tput && return
	getAllDevices || return

	local device fs label
	{
		PrintErr "searching..."

		hilight "DEVICE:FS:LABEL"

		for device in ${devices[@]}; do
			unset mountDir
			fs="$(getFs)" label=$(getLabel); PrintErr .
			[[ "$fs" == "LVM2_member" ]] && continue
			echo "$device:$fs:$label"
		done

		EchoErr "done"

	} | column -c $(tput cols) -t -s: -n
}

freeCommand()
{
	if IsPlatform mac; then
		getMac disk3s1s1 "Container Free Space|Volume Free Space" | cut -d"(" -f2 | cut -d" " -f1
	elif isDriveLetter "$device"; then
		RunScript --elevate fsutil.exe volume diskfree ${device}: | grep "^Total free bytes" | cut -d":" -f2 | RemoveSpaceTrim | cut -d" " -f1 | sed 's/,//g'
	elif InPath lsblk; then
		lsblk -b | grep "$device " | tr -s " " | cut -d" " -f4
	fi
}

mountsUsage() {	ScriptUsageEcho "Usage: $(ScriptName) mounts\n.List mount directory of all mounted drives"; }

mountsCommand()
{
	local d=()

	# standard mounted drives
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		mountDir="$(getMountDir)" || continue
		! canUnmount && continue
		d+=( "$mountDir" )
	done

	# other drives
	local other
	case "$PLATFORM_OS" in
		linux) IFS=$'\n' ArrayMake other "$(find /mnt/hgfs/* /media/psf/* |& grep -v "No such file")";;
		mac) IFS=$'\n' ArrayMake other "$(df | grep "^/dev/" | awk '{print $9}' | grep -v '^/$|^/$')";;
	esac
	d+=( "${other[@]}" )

	[[ ! $d ]] && return
	ArrayDelimit d $'\n' | sort | uniq | grep -v -E '^(/|/dev)$'
}

sizeCommand()
{
	if IsPlatform mac; then
		getMac "$device" "Container Total Space|Volume Total Space" | cut -d"(" -f2 | cut -d" " -f1
	elif isDriveLetter "$device"; then
		RunScript --elevate fsutil.exe volume diskfree ${device}: | grep "^Total bytes" | cut -d":" -f2 | RemoveSpaceTrim | cut -d" " -f1 | sed 's/,//g'
	elif InPath lsblk; then
		lsblk -b | grep "$device " | tr -s " " | cut -d" " -f4
	fi
}

#
# Format Command
#

formatArgStart() { unset fs; }

formatArgs()
{
	[[ $1 ]] && { ScriptArgGet "fs" -- "$@"; shift; } || { isDriveLetter "$device" && fs="ntfs" || fs="ext4"; }
}

formatCommand()
{
	if isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c format "$device:" "/fs:$fs"
	else
		sudo mkfs.$fs "/dev/$device"
	fi
}

#
# List Command
#

listUsage()
{
	ScriptUsageEcho "\
Usage: $(ScriptName) list [removable]
List device names of all or specified types of drives"
}

listArgStart() { unset type; }

listArgs()
{
	(( $# == 0 )) && return
	ScriptArgGet "type" -- "${1,,}"; shift	
	[[ "$type" != @(removable) ]] && usage
}

listCommand()
{
	local d device devices result=()

	# get devices
	getAllDevices || return

	# list devices and return if the type was not specified
	[[ ! $type ]] && { [[ $devices ]] && ArrayDelimit devices $'\n'; return; }

	# filter by type, currently only removable
	for device in "${devices[@]}"; do
		isRemovable && d+=( "$device" )
	done

	[[ $d ]] && ArrayDelimit d $'\n'
	return 0
}

#
# Resize Command
#

resizeArgStart() { unset size; }
resizeArgs() { ScriptArgGet "size" -- "$@"; shift; }

resizeCommand()
{
	# checks
	isDriveLetter "$device" && { ScriptErr "cannot resize Windows mounted drives"; return 1; }
	! isLvm && { ScriptErr "cannot resize a non-LVM drives"; return 1; }

	# resize
	local d="/dev/$device"

	hilight "Resizing volume..."
	sudo lvresize -L "$size" "/dev/$device" || return
	echo 

	hilight "Resizing file system..."
	sudo resize2fs "/dev/$device" || return

	hilight "Checking file system..."
	sudo e2fsck "/dev/$device" || return
	echo
}

#
# SetLabel Command
#

setUsage() {	ScriptUsageEcho "Usage: $(ScriptName) [set](set) label LABEL\nSet device information."; }
setArgStart() { unset label; }
setArgs() { ScriptArgGet "label" - "$@"; shift; }
setCommand() { setLabelCommand; }

setLabelCommand()
{
	if IsPlatform mac; then
		diskutil rename "$device" "$label"
	elif isDriveLetter "$device"; then
		RunScript --elevate cmd.exe /c label "$device:" "$label"
	elif InPath e2label; then
		sudo e2label "/dev/$device" "$label"
	elif InPath tune2fs; then
		sudo tune2fs -L "$label" "/dev/$device"
	else
		EchoErr "unable to set the label for $device"
	fi
}

#
# win commands
#

winUsage()
{
	ScriptUsageEcho "\
Usage: $(ScriptName) win exists|GetOffline|list|online|offline
Manage windows drives.  Use \`wsl mount\` to mount a windows drive in WSL."
}

winArgStart() { unset disk; }

winArgs()
{
	[[ "${commandNames[1]}" == @(|getoffline|list) ]] && return
	ScriptArgGet "disk" -- "$@"; shift
}

winCommand() { usage; }
winListCommand() { runDiskpart "list disk" | grep -E 'Online|Offline|Status|---'; }
winExistsCommand() { runDiskpart "select disk $disk" | grep "Disk $disk is now the selected disk." >& /dev/null; }
winGetofflineCommand() { drive win list | grep Offline | tr -s " " | cut -d" " -f3; }
winOnlineCommand() { runDiskpart "select disk $disk \n online disk" | grep "DiskPart successfully onlined the selected disk" >& /dev/null; }
winOfflineCommand() { runDiskpart "select disk $disk \n offline disk" | grep "DiskPart successfully offlined the selected disk" >& /dev/null; }

runDiskpart()
{
	local file result; file="$(mktemp --tmpdir="$WIN_ROOT/temp")"
	echo "$*" > "$file" || return
	cd "$WIN_ROOT/temp"; RunScript --elevate -- cmd.exe /c diskpart /s $(GetFileName "$file"); result=$?
	rm "$file"; return $result
}

#
# helper
#

isDriveLetter() { IsPlatform win && IsInArray "$1" driveLetters; }
isLvm() { sudo lvdisplay -c | cut -d: -f1 | RemoveSpace | grep "^/dev/${device}$" >& /dev/null; }
isMounted() { getMountDir > /dev/null; }
log() { [[ $quiet ]] && return; printf "$@"; }
platformUnmount() { sudoc umount "$mountDir"; }
returnMountDir() { [[ $mountDir && ! $quiet ]] && echo "$mountDir"; [[ $mountDir ]]; }

allMount()
{
	local result

	areAllMounted && return

	log "mounting..."

	for device in "${devices[@]}"; do
		unset mountDir
		{ isMounted || ! canMount; } && continue
		log "$device"; doMount
	done

	log "done\n"

	return 0
}

allUnmount()
{
	local devicesToUnmount

	areAllUnmounted && return

	log "unmounting..."	

	for device in "${devices[@]}"; do
		unset mountDir
		{ ! isMounted || ! canUnmount; } && continue
		log "$device"; doUnmount
	done

	log "done\n"

	return 0
}

areAllMounted()
{
	getAllDevices || return

	for device in "${devices[@]}"; do
		unset mountDir
		canMount && ! isMounted && return 1
	done

	return 0
}

areAllUnmounted()
{
	getAllDevices || return
	
	for device in "${devices[@]}"; do
		unset mountDir
		canUnmount && isMounted && return 1
	done

	return 0
}

canMount()
{
	# check UNC share of device
	local share; share="$(getUnc)" || return
	[[ "$share" == '//Mac/Dropbox' ]] && { reason="Parallels Dropbox"; return 1; }

	# check removable
	[[ $noOptical ]] && isOptical && { reason="optical drive"; return 1; }

	# check types
	local type="$(getType)"
	[[ "$type" == "" ]] && { reason="no filesystem"; return 1; }
	[[ "$type" == "LVM2_member" ]] && { reason="logical volume member"; return 1; }
	[[ "$type" == "swap" ]] && { reason="swap drive"; return 1; }

	return 0
}

canUnmount()
{
	# Windows - c drive
	[[ "$device" == "c" ]] && { reason="boot drive"; return 1; }

	local mountDir; mountDir="$(getMountDir)" || return
	[[ "$mountDir" == "/" ]] && { reason="boot drive"; return 1; }

	# Linux
	if IsPlatform linux; then
		[[ "$mountDir" == "/boot/efi" ]] && { reason="firmware drive"; return 1; }
		
	fi

	# Mac
	if IsPlatform mac; then
		local systemDirs=( "/dev" "/System/Volumes/VM" "/System/Volumes/Preboot" "/System/Volumes/Update" "/System/Volumes/xarts" "/System/Volumes/iSCPreboot" "/System/Volumes/Hardware" "/System/Volumes/Data" "/System/Volumes/Data/home" )
		IsInArray "$mountDir" systemDirs && { reason="system drive"; return 1; }
	fi

	return 0
}

cleanupMountDir() 
{
	[[ ! -e "$mountDir" ]] && return
	getDevice "$mountDir" >& /dev/null && platformUnmount >& /dev/null
	[[ -e "$mountDir" ]] && { sudoc rmdir "$mountDir" || return; }
	sudo rmdir "${mountRoot}/"* >& /dev/null # cleanup empty mount directories
	[[ ! -e "$mountDir" ]]
}

doMount()
{	
	# mount VeraCrypt volumes
	[[ "$(GetFileExtension "$device")" == "hc" ]] && { VeraCrypt mount "$device"; return; }

	# return if the drive is already mounted
	mountDir="$(getMountDir)" && return

	# identify the mount point - use the drive label if possible	
	mountDir="$mountRoot/$device" label="$(getLabel)"
	[[ $label && ! -e "$mountRoot/$label" ]] && { mountDir="$mountRoot/$label"; log1 "label=$label"; }

	# return if we cannot mount the drive
	! canMount && { ScriptErr "cannot mount $device ($reason)"; return 1; }

	# unmount a drive that is no longer present
	cleanupMountDir || return

	# create the mount directory
	[[ ! -d "$mountDir" ]] && { sudoc mkdir --parents "$mountDir" || return 1; } # use --parents for LVM
	log1 "mountDir=$mountDir"

	# mount the drive - supress some errors when mounting all devices
	local desc result

	if isDriveLetter "$device"; then
		doMountDriveLetter	
	else
		doMountOther
	fi

	# check the mounted drive
	if isMounted; then
		return 0
	else
		cleanupMountDir
		return 1
	fi
}

doMountDriveLetter()
{
	if [[ ! $all ]]; then
		log1 "sudoc mount -t drvfs $device: $mountDir"
		sudoc mount -t drvfs "$device:" "$mountDir"; return;
	fi

	# skip some errors when mounting all drives
	local result desc
	
	log1 "sudoc mount -t drvfs $device: $mountDir"
	desc="$(sudoc mount -t drvfs "$device:" "$mountDir" 2>&1)"; result="$?"
	
	# empty optical media drives
	if echo "$desc" | grep "No medium found" >& /dev/null; then
		log " (no media)..."; cleanupMountDir; return 0

	# mount failed
	elif [[ "$result" != "0" ]]; then
		log1 "$result"; log " (failed)..."

	# mount succeeded
	else
		log "..."
	fi

	[[ "$result" == "0" ]]
}

doMountOther()
{
	[[ ! $all ]] && { sudoc mount "/dev/$device" "$mountDir"; return; }

	local result desc
	desc="$(sudoc mount "/dev/$device" "$mountDir"  2>&1)"; result="$?"
	[[ "$result" == "0" ]] && log "..." || log " (failed)..."

	[[ "$result" == "0" ]]
}

doUnmount()
{	
	mountDir="$(getMountDir)" || return 0

	# return if we cannot unmount this drive
	! canUnmount && { ScriptErr "cannot unmount $device ($reason)"; return 1; }

	[[ ! $all ]] && { platformUnmount && cleanupMountDir; return; }

	local result desc
	desc="$(platformUnmount 2>&1 && cleanupMountDir 2>&1)"; result="$?"
	[[ "$result" == "0" ]] && log "..." || log " (failed)..."

	[[ "$result" == "0" ]]	
}

# getAllDevices - sets devices array
getAllDevices() 
{
	[[ $devices ]] && return

	# Windows drive letters
	if IsPlatform win; then
		devices+=( $(fsutil.exe fsinfo drives | sed 's/:\\//g' | sed 's/Drives: //g' | tr '[:upper:]' '[:lower:]' | RemoveCarriageReturn ) )
	fi

	# regular disks
	local d=()
	d+=( /dev/sd[a-c][0-9]* ) 			# SATA disks
	d+=( /dev/mmcblk[0-9]p[0-9]* ) 	# SD cards
	d+=( /dev/nvme0n[0-9]p[0-9]* ) 	# NVMe
	d+=( /dev/disk* )								# mac

	# LVM logical volumes
	[[ $lvm ]] && { d+=( $(sudoc lvdisplay -c |& cut -d: -f1 |& RemoveSpace) ) || return; }

	devices+=( $(find "${d[@]}" -maxdepth 1 -type b |& grep -v "No such file" | sed 's/\/dev\///g') )

	return 0
}

# getDevice FILE - get the device the specified file is mounted on
getDevice()
{
	local file="$1"; [[ ! -e "$file" ]] && return 1
	InPath findmnt && { findmnt --noheadings --output=SOURCE --target "$file"; return; }
	InPath df && { ${G}df -P "$file" | awk 'END{print $1}'; return; }	
	return 1
}

getFs()
{
	local fs="$(getType)"	

	# mounted Windows drives
	if [[ "$fs" == "9p" ]]; then
		fs="$(cd /; RunScript --elevate fsutil.exe fsinfo volumeinfo ${device}: | grep "File System Name" | RemoveCarriageReturn | cut -d: -f 2 | RemoveSpace)"
	fi

	[[ ! $fs ]] && return 1
	echo "$fs"
}

getLabel()
{
	local label

	# Mac
	IsPlatform mac && { getMac "$device" "Volume Name" | cut -d":" -f2 | RemoveSpaceTrim; return; }

	# Windows drive letter
	if isDriveLetter "$device"; then		
		label="$(getUnc)"; [[ $label ]] && { echo "$(GetUncShare "$label")"; return; } # in Parallels the drive letter UNC is in the format \\Mac\<label>
		cmd.exe /c vol "$device": |& RemoveCarriageReturn | grep -v "has no label" | grep "Volume in" | cut -d" " -f7-; return
	fi

	# use lsblk - in Windows the lsblk label is empty
	! IsPlatform win && InPath lsblk && { lsblk --nodeps --noheadings --output LABEL "/dev/$device" |& grep -v "not a block device"; return; }

	# use blkid
	! InPath blkid && return
	local label info="$(blkid "/dev/$device")" || return 
	if [[ $info ]]; then # block device information is in the cache
		blkid "/dev/$device" -o export | grep "^LABEL=" | cut -d"=" -f2
	else # probe the block device since it has no information in the cache
		sudoc --preserve blkid "/dev/$device" -o export | grep "^LABEL=" | cut -d"=" -f2
	fi
}

# getMac DEVICE DESC - get mac disk information
getMac() { diskutil info "$1" | grep -E "^[ ]*${2}:" | sort | head -1 | cut -d":" -f2 | RemoveSpaceTrim; }

# getMountDir - get the first mounted directory of DEVICE
getMountDir()
{
	local dir

	[[ $verbose ]] && ScriptErr "checking if $device is mounted"

	if isDriveLetter "$device"; then
		if IsPlatform wsl1; then
			[[ "$device" == "c" ]] && dir="/mnt/c" || dir="$(findmnt --noheadings "$device:" --output=TARGET)"
		else
			dir="$(findmnt --list --output=TARGET,OPTIONS | grep -iE "path=$device"':?\\?' | cut -d" " -f1)"
		fi

	elif [[ "$device" == "rootfs" ]]; then
		dir="/"
		
	elif InPath findmnt; then
		dir="$(findmnt --noheadings --output=TARGET --source "/dev/$device" | head -1)"

	elif InPath ${G}df; then
		dir="$(${G}df -P "/dev/$device" | awk 'END{print $NF}')"

	else
		return 1
		
	fi

	[[ $dir ]] && echo "$dir"
	[[ $dir ]]
}

getType()
{
	# WSL 1 rootfs has file system type of wslfs
	[[ "$device" == "rootfs" ]] && { echo "wslfs"; return; }

	# get the type if we have the mount directory
	if [[ -d "$mountDir" ]]; then
		InPath findmnt && { findmnt --noheadings --output=FSTYPE --target "$mountDir"; return; }
		IsPlatfor mac && { mount | grep "on $mountDir " | cut -d'(' -f2 | cut -d, -f1; return; }
		return 1
	fi

	# Windows drive letters - the type must be 9p
	isDriveLetter "$device" && { echo "9p"; return; }

	# lsblk, except in Windows where the file system is empty
	InPath lsblk && ! IsPlatform win && { lsblk --nodeps --noheadings --output FSTYPE "/dev/$device"; return; }

	# blkid
	if InPath blkid; then
		local type="$(eval $(sudoc blkid "/dev/$device" -o export); echo $TYPE)" || return
		echo "$type"
	fi

	# mac
	IsPlatform mac && { mount | grep "/dev/$device " | cut -d'(' -f2 | cut -d, -f1; }

	return 1
}

# getUnc - get the UNC path for a device
getUnc() 
{
	! isDriveLetter "$device" && return
	echo "$(net.exe use | RemoveCarriageReturn | grep "${device^}": | \
		sed 's/Micorosoft Windows Network//' | \
		sed 's/Parallels Shared Folders//' | \
		tr -s " " | RemoveSpaceTrim | cut -d" " -f2- | BackToForwardSlash)"
}

isEfiDevice()
{
	IsPlatform win && return 1
	[[ ! $efiDevice ]] && efiDevice="$(getDevice "/boot/efi" | GetFileName)"
	[[ "$device" == "$efiDevice" ]]
}

isRemovable()
{
	if IsPlatform mac; then
		local location; location="$(getMac "$device" "Device Location")" || return
		local removableMedia; removableMedia="$(getMac "$device" "Removable Media")" || return
	 	[[ "$location" == "External" || "$removableMedia" != "Fixed" ]]; return

	elif isDriveLetter "$device"; then fsutil.exe fsinfo driveType "${drive}:\\" |& grep -q "Removable Drive"; return
	elif InPath lsblk; then [[ "$(lsblk --nodeps --noheadings --output RM "/dev/$device")" == "1" ]]; return
	elif InPath udevadm; then udevadm info --query=property --export --name="/dev/$device" | grep "ID_BUS='usb'" >& /dev/null; return
	fi
	return 1
}

isOptical()
{
	isDriveLetter "$device" && { fsutil.exe fsinfo driveType "${device}:\\" |& grep -q "CD-ROM Drive"; return; }
	return 1
}

ScriptRun "$@"

#!/usr/bin/env bash
. function.sh
. color.sh

run() {	init && args "$@" && ${command}Command "${args[@]}"; }

init()
{
	piImage="platform/linux/Raspberry Pi/image"
	piOs="platform/linux/Raspberry Pi/Raspberry Pi OS"
	ubuntuImage="platform/linux/Ubuntu/image"
}

usage()
{
	echot "\
usage: pi balena|power
	Raspberry Pi helper commands

	image
		clone  					create an image using Pi Clone (faster file copy)
		backup					create an image from this Raspberry Pi
		restore	[IMAGE]	restore an image to a connected drive
		configure				enable ssh for images on all drives

	firmware channel|dir|info apply|configure|edit|update
		dir				return the firmware directory
		channel		edit the firmware channel (beta, stable, or critical)

		apply			apply firmware changes from a file
		configure	configure the firmware
		edit			configure and apply the firmware
		update		update the Raspberry Pi with the latests firmware

	-n, --name NAME		the name of the host to restore for cloud-init images"
	exit $1
}

args()
{
	unset file host

	while (( $# != 0 )); do
		case "$1" in "") : ;;
			--help|-h) usage 0;;
			--name|-n) host="$2"; [[ ! $host ]] && MissingOperand "host"; shift; continue;;
			EnableSsh) command="enableSsh";;
			*)
				! IsOption "$1" && [[ ! $command ]] && { CheckCommand "$1"; command="${1,,}"; shift; continue; }
				[[ "$command" == @(firmware|image) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $command ]] && { MissingOperand "command"; }
	args=("$@")
}

#
# commands
#

balenaCommand() { elevate "$ADATA/Programs/balena-etcher/balenaEtcher.exe"; }
powerCommand() { ! dmesg --time-format ctime | grep -i volt; } # check for under voltage in the log

#
# Firmware Commands
#

firmwareCommand()
{
	local channel="/etc/default/rpi-eeprom-update"
	local dir="/lib/firmware/raspberrypi/bootloader"

	local command; CheckSubCommand firmware "$1"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	$command "$@"
}

firmwareDirCommand() { echo "$dir"; }
firmwareChannelCommand() { sudoedit "$channel"; }
firmwareUpdateCommand() { sudo rpi-eeprom-update -a && { ask "Reboot" && power reboot || return 0; }; }

firmwareInfoCommand()
{
	header "Bootloader Version"
	sudoc vcgencmd bootloader_version || return
	
	[[ -f "$channel" ]] && { printf "\nUpdate channel:\n"; cat "$channel"; }
	echo

	header "Bootloader Configurationn"
	sudo vcgencmd bootloader_config | RemoveEmptyLines || return
}

firmwareApplyCommand()
{
	firmwareGetFile "$@" || return
	sudo rpi-eeprom-update -d -f "$dir/new-config.bin" || return
}

firmwareEditCommand()
{
	firmwareGetFile "$@" || return
	FirmwareConfigureCommand "@" || return
	FirmwareApplyCommand || return
}

firmwareConfigureCommand()
{
	firmwareGetFile "$@" || return

	# backup existing configuration changes
	[[ -f "$config" ]] && { sudo bak --move "$config" || return; }
	
	# extract configuration from the firmware file
	sudoc cp "$file" "$dir/current.bin" || return
	rpi-eeprom-config "$dir/current.bin" | sudo tee "$config" || return
	[[ ! -f "$config" || "$(cat "$config")" == "" ]] && { EchoErr "Unable to extract the firmware configuration from \"$file\""; return 1; }
	sudo cp "$config" "$config.orig" || return

	# edit the configuration
	sudoedit "$config" || return

	# add the configuration to the firmware file
	if ! diff "$config" "$config.orig" >& /dev/null; then
		printf "Adding the configuration changes to the firmware file..."
		sudo rpi-eeprom-config --out "$dir/new-config.bin" --config "$config" "$dir/current.bin" || return
		echo "done"
	fi

	return 0
}

firmwareGetFile() # sets file, dir, and config
{
	local FIRMWARE_RELEASE_STATUS; . "$channel" || return
	
	dir="$dir/$FIRMWARE_RELEASE_STATUS"
	config="$dir/bootconf.txt"

	[[ ! $file ]] && { file="$1"; shift; }
	[[ ! $file ]] && { file="$(dialog --title "Select Firmware" --stdout --fselect ""$dir/"" $(($LINES-12)) 100)"; clear; }
	[[ ! $file ]] && { MissingOperand "file"; return 1; }
	[[ ! -f "$file" ]] && { ScriptErr "firmware file \"$file\" does not exist"; return 1; }

	return 0
}

#
# Image Commands
#

imageCommand()
{
	local command; CheckSubCommand image "${1:-clone}"; shift
	[[ $# != 0 && "$command" != @(restore) ]] && UnknownOption "$1"
	$command "$@"
}

imageCloneCommand() 
{ 
	! InPath piclone && { package piclone || return; }
	coproc sudox dbus-launch piclone
}

# ImageBackupCommand - backup the host to an img file.   The backup is done to a remote host to
# - cannot back up to the drive we are backing up
# - faster access than Micro-SD card
# - faster compression (utilize 36 cores)
# On Windows, much faster to backup to c$ share than /root/tmp share over ssh.
imageBackupCommand()
{
	local device="mmcblk0" fileName="$HOSTNAME.$(GetDateStamp).img" 
	local host="oversoul" hostUnc="/root/tmp" win
	local dir file size="$(drive size $device)"; [[ $size ]] && size="--size ${size,,}"

	! IsPlatform PiKernel && { ScriptErr "can only backup a Raspbery Pi"; }
	! IsAvailable "$host" && { ScriptErr: "host '$host' is not available"; return 1; }

	# get compression host information
	eval "$(HostGetInfo "$host")" || return
	IsPlatform win $_platform $_platformLike $_platformId && { win="true" hostUnc="c\$/temp"; }

	# backup
	hilight "Backing up $HOSTNAME..."
	dir="$(unc mount //$host/$hostUnc)" || return	
	file="$dir/$fileName"
	sudo pv $size -tpreb "/dev/$device" | dd bs=4M > "$file" || return

	# copy
	if [[ $win ]]; then
		hilight "Copying $fileName on $host..."
		ssh "$host" -t -- CopyDir "/mnt/c/temp/$fileName" "/tmp" || return
	fi

	# compress
	hilight "Compressing $fileName..."
	file="/tmp/$fileName"
 	ssh "$host" -t -- pv $size -tpreb "$file" \| xz -1 -z -T 0 - \> "$file.xz" || return

 	# copy compressed file to image directory
	local image="$(ssh oversoul -t -- FindInstallFile --quiet "$(QuoteSpaces "$piImage")")"
 	hilight "Copying $fileName to the install server..."
	ssh "$host" -t -- CopyDir "$file.xz" "$(QuoteSpaces "$image")/$fileName.xz" || return

 	# cleanup
 	ssh "$host" -t -- rm -f "/tmp/$fileName" "/tmp/$fileName.xz" "/mnt/c/temp/$fileName" || return
}

imageRestoreCommand()
{
	IsPlatform win && ! IsElevated && { elevate RunScript --pause pi image restore "$@"; return; }

	# arguments
	local image="$1"; [[ $image ]] && shift

	# image aliases
	local selectDir="$piOs"
	case "$image" in
		image) unset image; selectDir="$piImage";;
		server|ubuntu-server) image="$(installFile "$ubuntuImage/ubuntu-20.04.1-preinstalled-server-arm64+raspi.img.xz")"
	esac

	# select the image from the selectDir
	if [[ ! $image ]]; then
		local imageDir="$(installFile "$selectDir")" || return
		image="$(dialog --title "Select image" --stdout --fselect "$imageDir/" $(($LINES-12)) 100)"
		clear
	fi
	
	# validate the image selected
	[[ ! $image ]] && { MissingOperand "image"; return 1; }
	[[ ! -f "$image" ]] && { EchoErr "pi: image \"$image\" does not exist"; return 1; }
	[[ $# != 0 ]] && usage 1

	if [[ -f "$P/balena-cli/balena.exe" ]]; then		
		#elevate RunScript --pause --wait -- "$P/balena-cli/balena.exe" local flash "$(utw "$image" | QuoteBackslashes)" --yes || return
		"$P/balena-cli/balena.exe" local flash "$(utw "$image")" --yes || return
	elif InPath flash; then
		flash "$image" || return
	else
		ScriptErr "no flash program found"; return 1
	fi

	# does not mount properly just after flash so try several times
	hilight 'configuring...'
	for (( i=1; i<=10; ++i )); do
		ImageConfigureCommand && return
		sleep 1
	done

	return 0
}

imageConfigureCommand()
{
	local drive drives found

	drive mount all || return
	IFS=$'\n' drives=( $(drive mounts) )

	printf "configuring..."
	
	for drive in "${drives[@]}"; do
		[[ ! -f "$drive/start.elf" ]] && continue
		printf "$(GetFileName "$drive")..."

		if [[ -f "$drive/user-data" ]]; then
			[[ ! $host ]] && MissingOperand "host"

			printf "${RB_BLUE}cloud-init${RESET}..."
			cp "$DATA/setup/user-data" "$drive" || return
			sed -i "s/^#hostname: HOST$/hostname: $host/" "/etc/default/locale" "$drive/user-data" || return
		else
			printf "${RB_BLUE}ssh${RESET}..."
			touch "$drive/ssh" || return
		fi
		
		found="true"
		break
	done

	echo "done" 

	drive unmount all || return

	[[ ! $found ]] && { ScriptErr "no boot images found"; return 1; }

	return 0
}

#
# helper
#

installFile() { FindInstallFile --quiet "$1"; }

run "$@"

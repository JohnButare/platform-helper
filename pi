#!/usr/bin/env bash
. function.sh

run() {	init && args "$@" && ${command}Command "${args[@]}"; }

init() { :; }

usage()
{
	echot "\
usage: pi power
	Raspberry Pi helper commands

	image gui
		balena  	create an image using Balena Etcher
		clone  		create an image using Pi Clone (faster file copy)
		backup		create an image from this Raspberry Pi
		restore		restore an image to a connected drive
		ssh				enable ssh for images on all drives

	firmware channel|dir|info apply|configure|edit|update

		dir				return the firmware directory
		channel		edit the firmware channel (beta, stable, or critical)

		apply			apply firmware changes from a file
		configure	configure the firmware
		edit			configure and apply the firmware
		update		update the Raspberry Pi with the latests firmware"
	exit $1
}

args()
{
	unset file

	while (( $# != 0 )); do
		case "$1" in "") : ;;
			--help|-h) usage 0;;
			EnableSsh) command="enableSsh";;
			*)
				! IsOption "$1" && [[ ! $command ]] && { CheckCommand "$1"; command="${1,,}"; shift; continue; }
				[[ "$command" == @(firmware|image) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $command ]] && { MissingOperand "command"; }
	args=("$@")
}

#
# commands
#

powerCommand() { ! dmesg --time-format ctime | grep -i volt; } # check for under voltage in the log

#
# Firmware Commands
#

firmwareCommand()
{
	local channel="/etc/default/rpi-eeprom-update"
	local dir="/lib/firmware/raspberrypi/bootloader"

	local command; CheckSubCommand firmware "$1"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	Firmware${command}Command "$@"
}

FirmwareDirCommand() { echo "$dir"; }
FirmwareChannelCommand() { sudoedit "$channel"; }
FirmwareUpdateCommand() { sudo rpi-eeprom-update -a && { ask "Reboot" && power reboot || return 0; }; }

FirmwareInfoCommand()
{
	header "Bootloader Version"
	sudoc vcgencmd bootloader_version || return
	
	[[ -f "$channel" ]] && { printf "\nUpdate channel:\n"; cat "$channel"; }
	echo

	header "Bootloader Configurationn"
	sudo vcgencmd bootloader_config | RemoveEmptyLines || return
}

FirmwareApplyCommand()
{
	firmwareGetFile "$@" || return
	sudo rpi-eeprom-update -d -f "$dir/new-config.bin" || return
}

FirmwareEditCommand()
{
	firmwareGetFile "$@" || return
	FirmwareConfigureCommand "@" || return
	FirmwareApplyCommand || return
}

FirmwareConfigureCommand()
{
	firmwareGetFile "$@" || return

	# backup existing configuration changes
	[[ -f "$config" ]] && { sudo bak --move "$config" || return; }
	
	# extract configuration from the firmware file
	sudoc cp "$file" "$dir/current.bin" || return
	rpi-eeprom-config "$dir/current.bin" | sudo tee "$config" || return
	[[ ! -f "$config" || "$(cat "$config")" == "" ]] && { EchoErr "Unable to extract the firmware configuration from \"$file\""; return 1; }
	sudo cp "$config" "$config.orig" || return

	# edit the configuration
	sudoedit "$config" || return

	# add the configuration to the firmware file
	if ! diff "$config" "$config.orig" >& /dev/null; then
		printf "Adding the configuration changes to the firmware file..."
		sudo rpi-eeprom-config --out "$dir/new-config.bin" --config "$config" "$dir/current.bin" || return
		echo "done"
	fi

	return 0
}

firmwareGetFile() # sets file, dir, and config
{
	local FIRMWARE_RELEASE_STATUS; . "$channel" || return
	
	dir="$dir/$FIRMWARE_RELEASE_STATUS"
	config="$dir/bootconf.txt"

	[[ ! $file ]] && { file="$1"; shift; }
	[[ ! $file ]] && { file="$(dialog --title "Select Firmware" --stdout --fselect ""$dir/"" $(($LINES-12)) 100)"; clear; }
	[[ ! $file ]] && { MissingOperand "file"; return 1; }
	[[ ! -f "$file" ]] && { ScriptErr "firmware file \"$file\" does not exist"; return 1; }

	return 0
}

#
# Image Commands
#

imageCommand()
{
	local command; CheckSubCommand image "${1:-clone}"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	Image${command}Command "$@"
}

ImageCloneCommand() { coproc sudox dbus-launch piclone; }

# ImageBackupCommand - backup the host to an img file.   The backup is done to a remote host to
# - cannot back up to the drive we are backing up
# - faster access than Micro-SD card
# - faster compression (utilize 36 cores)
ImageBackupCommand()
{
	local device="mmcblk0" fileName="$HOSTNAME.img" compressionHost="oversoul"

	! IsPlatform PiKernel && { ScriptErr "can only backup a Raspbery Pi"; }

	local dir="$(unc mount --ssh //$compressionHost/root/tmp)" || return	
	local file="$dir/$fileName" localFile="/tmp/$fileName"
	local size="$(drive size $device)"; [[ $size ]] && size="--size ${size,,}"

	hilight "Backing up $HOSTNAME to $file..."
	sudo pv $size -tpreb "/dev/$device" | dd bs=4M > "$file" || return

	hilight "Compressing $fileName..."
 	ssh "$compressionHost" -t -- pv $size -tpreb "$localFile" \| xz -1 -z -T 0 - \> "$localFile.xz" || return
}

ImageRestoreCommand()
{
	echo "Not Implemented"
}

ImageBalenaCommand()
{
	! IsElevated && { elevate RunScript --pause-error pi image balena "$@"; return; }

	local image="$(i dir)/platform/Raspberry Pi/Raspberry Pi OS" || return

	# select the firmware file
	local file="$1"; shift
	[[ ! $file ]] && { file="$(dialog --title "Select image" --stdout --fselect "$image/" $(($LINES-12)) 100)"; clear; }
	[[ ! $file ]] && { MissingOperand "file"; return 1; }
	[[ ! -f "$file" ]] && { EchoErr "pi: image \"$file\" does not exist"; return 1; }

	"$P/balena-cli/balena.exe" local flash "$(utw "$file")" --yes

	# does not mount properly just after flash so try several times
	for (( i=1; i<=10; ++i )); do
		ImageSshCommand && return
		sleep 1
	done

	return 0
}

ImageSshCommand()
{
	local drive drives found

	drive mount all || return
	IFS=$'\n' drives=( $(drive mounts) )

	printf "enabling..."
	
	for drive in "${drives[@]}"; do
		[[ ! -f "$drive/start.elf" ]] && continue
		touch "$drive/ssh" || return
		printf "$(GetFileName "$drive")..."
		found="true"
	done

	echo "done" 

	drive unmount all || return

	[[ ! $found ]] && { ScriptErr "no Raspberry Pi images found"; return 1; }

	return 0
}

run "$@"

#!/usr/bin/env bash
. script.sh
. color.sh

usage()
{
	ScriptUsage "$1" "\
usage: pi balena|firmware|image|info|power
	Raspberry Pi helper commands"
}

init()
{
	piImage="platform/linux/Raspberry Pi/image"
	piOs="platform/linux/Raspberry Pi/Raspberry Pi OS"
	ubuntuImage="platform/linux/Ubuntu/image"
}

#
# commands
#

balenaCommand() { elevate "$UADATA/Programs/balena-etcher/balenaEtcher.exe"; }
powerCommand() { ! dmesg --time-format ctime | grep -i volt; } # check for under voltage in the log

#
# Firmware Commands
#

firmwareUsage()
{
	echot "\
usage: pi firmware apply|channel|configure|dir|edit|update
	Raspberry Pi firmware commands.

	apply			apply firmware changes from a file
	channel		edit the firmware channel (beta, stable, or critical)
	configure	configure the firmware
	dir				return the firmware directory
	edit			configure and apply the firmware
	info			show firmware information
	update		update the Raspberry Pi with the latests firmware"
}

firmwareArgStart()
{
	onlyPi || return
	channel="/etc/default/rpi-eeprom-update"
	dir="/lib/firmware/raspberrypi/bootloader"

	# install firmware package
	[[ ! -d "$dir" ]] && { package rpi-eeprom || return; }

	return 0
}

firmwareCommand() { usage; }
firmwareDirCommand() { echo "$dir"; }
firmwareChannelCommand() { sudoedit "$channel"; }
firmwareUpdateCommand() { sudo rpi-eeprom-update -a && { ask "Reboot" && power reboot || return 0; }; }

firmwareInfoCommand()
{
	header "Update Status"
	sudo rpi-eeprom-update || return
	echo

	header "Bootloader Version"
	sudoc vcgencmd bootloader_version || return
	
	[[ -f "$channel" ]] && { printf "\nUpdate channel:\n"; cat "$channel"; }
	echo

	header "Bootloader Configurationn"
	sudo vcgencmd bootloader_config | RemoveEmptyLines || return
}

firmwareApplyCommand()
{
	firmwareGetFile "$@" || return
	sudo rpi-eeprom-update -d -f "$dir/new-config.bin" || return
}

firmwareEditCommand()
{
	firmwareConfigureCommand "$@" || return
	firmwareApplyCommand || return
}

firmwareConfigureCommand()
{
	firmwareGetFile "$@" || return

	# backup existing configuration changes
	[[ -f "$config" ]] && { sudo bak --move "$config" || return; }

	# extract configuration from the firmware file
	sudoc cp "$file" "$dir/current.bin" || return
	rpi-eeprom-config "$dir/current.bin" | sudo tee "$config" || return
	[[ ! -f "$config" || "$(cat "$config")" == "" ]] && { EchoErr "Unable to extract the firmware configuration from \"$file\""; return 1; }
	sudo cp "$config" "$config.orig" || return

	# edit the configuration
	sudoedit "$config" || return

	# add the configuration to the firmware file
	if ! diff "$config" "$config.orig" >& /dev/null; then
		printf "Adding the configuration changes to the firmware file..."
		sudo rpi-eeprom-config --out "$dir/new-config.bin" --config "$config" "$dir/current.bin" || return
		echo "done"
	fi

	return 0
}

firmwareGetFile() # sets file, dir, and config
{
	local FIRMWARE_RELEASE_STATUS; . "$channel" || return
	
	dir="$dir/$FIRMWARE_RELEASE_STATUS"
	config="$dir/bootconf.txt"

	[[ ! $file ]] && { file="$1"; shift; }
	[[ ! $file ]] && { file="$(dialog --title "Select Firmware" --stdout --fselect ""$dir/"" $(($LINES-12)) 100)"; clear; }
	[[ ! $file ]] && { MissingOperand "file"; return 1; }
	[[ ! -f "$file" ]] && { ScriptErr "firmware file \"$file\" does not exist"; return 1; }

	return 0
}

#
# Info Command
#

infoUsage()
{
	echot "\
usage: pi info mhz|model|temp
	Raspberry Pi information commands.

	mhz		current CPU clock speed in MHz"
}

infoCommand() { usage; }

infoMhzCommand()
{
	local mhz; mhz="$(sudoc vcgencmd measure_clock arm | cut -d= -f 2)" || return
	echo "$((mhz / 1000000))"
}

infoTempCommand()
{
	onlyPi
	local temp=$(</sys/class/thermal/thermal_zone0/temp)
	echo "$((temp/1000))'C"
}

infoModelCommand()
{
	cat /proc/cpuinfo | grep "^Model" | cut -d":" -f 2 | RemoveTrim
}


#
# Image Commands
#

imageUsage()
{
	echot "\
usage: pi image backup|clone|configure|restore
	Raspberry Pi image commands.

	backup					create an image from this Raspberry Pi
	clone  					create an image using Pi Clone (faster file copy)
	configure				enable ssh for images on all drives
	restore	[IMAGE]	restore an image to a connected drive

	-n, --name NAME		the name of the host to restore for cloud-init images"
}

imageArgStart() { unset -v host; }

imageOpt() 
{
	case "$1" in
		-n*|--name=*|--name) ScriptOptGet host "$@" || return;;
		*) return 1
	esac
}

imageCommand() { usage; }

imageCloneCommand() 
{ 
	onlyPi || return;
	! InPath piclone && { package piclone || return; }
	coproc sudox dbus-launch piclone
}

# ImageBackupCommand - backup the host to an img file.   The backup is done to a remote host to
# - cannot back up to the drive we are backing up
# - faster access than Micro-SD card
# - faster compression (utilize 36 cores)
# On Windows, much faster to backup to c$ share than /root/tmp share over ssh.
imageBackupCommand()
{
	onlyPi || return
	! IsAvailable "$host" && { ScriptErr: "host '$host' is not available"; return 1; }

	local device="mmcblk0" fileName="$HOSTNAME.$(GetDateStamp).img" 
	local host="oversoul" hostUnc="/root/tmp" win
	local size; size="$(drive size $device)" || return; [[ $size ]] && size="--size ${size,,}"

	# get compression host information
	eval "$(HostGetInfo "$host")" || return
	IsPlatformHost win && { win="true" hostUnc="c\$/temp"; }

	# backup
	hilight "Backing up $HOSTNAME..."
	local dir; dir="$(unc mount //$host/$hostUnc)" || return	
	local file="$dir/$fileName"
	sudo pv $size -tpreb "/dev/$device" | dd bs=4M > "$file" || return

	# copy
	if [[ $win ]]; then
		hilight "Copying $fileName on $host..."
		ssh "$host" -t -- CopyDir "/mnt/c/temp/$fileName" "/tmp" || return
	fi

	# compress
	hilight "Compressing $fileName..."
	file="/tmp/$fileName"
 	ssh "$host" -t -- pv $size -tpreb "$file" \| xz -1 -z -T 0 - \> "$file.xz" || return

 	# copy compressed file to image directory
	local image="$(ssh oversoul -t -- FindInstallFile --quiet "$(QuoteSpaces "$piImage")")"
 	hilight "Copying $fileName to the install server..."
	ssh "$host" -t -- CopyDir "$file.xz" "$(QuoteSpaces "$image")/$fileName.xz" || return

 	# cleanup
 	ssh "$host" -t -- rm -f "/tmp/$fileName" "/tmp/$fileName.xz" "/mnt/c/temp/$fileName" || return
}

imageRestoreArgStart() { unset -v image; }
imageRestoreArgs() { ScriptArgGet "image" -- "$@"; shift; }

imageRestoreCommand()
{
	IsPlatform win && ! IsElevated && { elevate RunScript --pause pi image restore "${originalArgs[@]}"; return; }

	# image aliases
	local selectDir="$piOs"
	case "$image" in
		image) unset image; selectDir="$piImage";;
		server|ubuntu-server) image="$(installFile "$ubuntuImage/ubuntu-20.04.1-preinstalled-server-arm64+raspi.img.xz")"
	esac

	# select the image from the selectDir
	if [[ ! $image ]]; then
		local imageDir="$(installFile "$selectDir")" || return
		image="$(dialog --title "Select image" --stdout --fselect "$imageDir/" $(($LINES-12)) 100)"
		clear
	fi
	
	# validate the image selected
	[[ ! $image ]] && { MissingOperand "image"; return 1; }
	[[ ! -f "$image" ]] && { EchoErr "pi: image \"$image\" does not exist"; return 1; }
	[[ $# != 0 ]] && usage 1

	if [[ -f "$P/balena-cli/balena.exe" ]]; then		
		#elevate RunScript --pause --wait -- "$P/balena-cli/balena.exe" local flash "$(utw "$image" | QuoteBackslashes)" --yes || return
		"$P/balena-cli/balena.exe" local flash "$(utw "$image")" --yes || return
	elif InPath flash; then
		flash "$image" || return
	else
		ScriptErr "no flash program found"; return 1
	fi

	# does not mount properly just after flash so try several times
	hilight 'configuring...'
	for (( i=1; i<=10; ++i )); do
		ImageConfigureCommand && return
		sleep 1
	done

	return 0
}

imageConfigureCommand()
{
	local drive drives found

	drive mount all || return
	IFS=$'\n' drives=( $(drive mounts) )

	printf "configuring..."
	for drive in "${drives[@]}"; do
		[[ ! -f "$drive/start.elf" ]] && continue
		printf "$(GetFileName "$drive")..."

		if [[ -f "$drive/user-data" ]]; then
			[[ ! $host ]] && MissingOperand "host"

			printf "${RB_BLUE}cloud-init${RESET}..."
			cp "$DATA/setup/user-data" "$drive" || return
			sed -i "s/^#hostname: HOST$/hostname: $host/" "/etc/default/locale" "$drive/user-data" || return
		else
			printf "${RB_BLUE}ssh${RESET}..."
			touch "$drive/ssh" || return
		fi
		
		found="true"
		break
	done

	echo "done" 

	drive unmount all || return

	[[ ! $found ]] && { ScriptErr "no boot images found"; return 1; }

	return 0
}

#
# helper
#

installFile() { FindInstallFile --quiet "$1"; }
onlyPi() { IsPlatform PiKernel && return; ScriptErr "command can only run on a Raspbery Pi"; return 1; }

ScriptRun "$@"

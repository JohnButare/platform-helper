#!/usr/bin/env bash
. function.sh

run() {	init && args "$@" && ${command}Command "${args[@]}"; }

init() { :; }

usage()
{
	echot "\
usage: pi balena|power
	Raspberry Pi helper commands

	image
		balena  	create an image using Balena Etcher
		clone  		create an image using Pi Clone (faster file copy)
		backup		create an image from this Raspberry Pi
		restore		restore an image to a connected drive
		ssh				enable ssh for images on all drives

	firmware channel|dir|info apply|configure|edit|update

		dir				return the firmware directory
		channel		edit the firmware channel (beta, stable, or critical)

		apply			apply firmware changes from a file
		configure	configure the firmware
		edit			configure and apply the firmware
		update		update the Raspberry Pi with the latests firmware"
	exit $1
}

args()
{
	unset file

	while (( $# != 0 )); do
		case "$1" in "") : ;;
			--help|-h) usage 0;;
			EnableSsh) command="enableSsh";;
			*)
				! IsOption "$1" && [[ ! $command ]] && { CheckCommand "$1"; command="${1,,}"; shift; continue; }
				[[ "$command" == @(firmware|image) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $command ]] && { MissingOperand "command"; }
	args=("$@")
}

#
# commands
#

balenaCommand() { elevate "$ADATA/Programs/balena-etcher/balenaEtcher.exe"; }
powerCommand() { ! dmesg --time-format ctime | grep -i volt; } # check for under voltage in the log

#
# Firmware Commands
#

firmwareCommand()
{
	local channel="/etc/default/rpi-eeprom-update"
	local dir="/lib/firmware/raspberrypi/bootloader"

	local command; CheckSubCommand firmware "$1"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	Firmware${command}Command "$@"
}

FirmwareDirCommand() { echo "$dir"; }
FirmwareChannelCommand() { sudoedit "$channel"; }
FirmwareUpdateCommand() { sudo rpi-eeprom-update -a && { ask "Reboot" && power reboot || return 0; }; }

FirmwareInfoCommand()
{
	header "Bootloader Version"
	sudoc vcgencmd bootloader_version || return
	
	[[ -f "$channel" ]] && { printf "\nUpdate channel:\n"; cat "$channel"; }
	echo

	header "Bootloader Configurationn"
	sudo vcgencmd bootloader_config | RemoveEmptyLines || return
}

FirmwareApplyCommand()
{
	firmwareGetFile "$@" || return
	sudo rpi-eeprom-update -d -f "$dir/new-config.bin" || return
}

FirmwareEditCommand()
{
	firmwareGetFile "$@" || return
	FirmwareConfigureCommand "@" || return
	FirmwareApplyCommand || return
}

FirmwareConfigureCommand()
{
	firmwareGetFile "$@" || return

	# backup existing configuration changes
	[[ -f "$config" ]] && { sudo bak --move "$config" || return; }
	
	# extract configuration from the firmware file
	sudoc cp "$file" "$dir/current.bin" || return
	rpi-eeprom-config "$dir/current.bin" | sudo tee "$config" || return
	[[ ! -f "$config" || "$(cat "$config")" == "" ]] && { EchoErr "Unable to extract the firmware configuration from \"$file\""; return 1; }
	sudo cp "$config" "$config.orig" || return

	# edit the configuration
	sudoedit "$config" || return

	# add the configuration to the firmware file
	if ! diff "$config" "$config.orig" >& /dev/null; then
		printf "Adding the configuration changes to the firmware file..."
		sudo rpi-eeprom-config --out "$dir/new-config.bin" --config "$config" "$dir/current.bin" || return
		echo "done"
	fi

	return 0
}

firmwareGetFile() # sets file, dir, and config
{
	local FIRMWARE_RELEASE_STATUS; . "$channel" || return
	
	dir="$dir/$FIRMWARE_RELEASE_STATUS"
	config="$dir/bootconf.txt"

	[[ ! $file ]] && { file="$1"; shift; }
	[[ ! $file ]] && { file="$(dialog --title "Select Firmware" --stdout --fselect ""$dir/"" $(($LINES-12)) 100)"; clear; }
	[[ ! $file ]] && { MissingOperand "file"; return 1; }
	[[ ! -f "$file" ]] && { ScriptErr "firmware file \"$file\" does not exist"; return 1; }

	return 0
}

#
# Image Commands
#

imageCommand()
{
	local command; CheckSubCommand image "${1:-clone}"; shift
	[[ $# != 0 ]] && UnknownOption "$1"
	Image${command}Command "$@"
}

ImageCloneCommand() { coproc sudox dbus-launch piclone; }

# ImageBackupCommand - backup the host to an img file.   The backup is done to a remote host to
# - cannot back up to the drive we are backing up
# - faster access than Micro-SD card
# - faster compression (utilize 36 cores)
# On Windows, much faster to backup to c$ share than /root/tmp share over ssh.
ImageBackupCommand()
{
	local device="mmcblk0" fileName="$HOSTNAME.$(GetDateStamp).img" 
	local host="oversoul" hostUnc="/root/tmp" win
	local dir file size="$(drive size $device)"; [[ $size ]] && size="--size ${size,,}"

	! IsPlatform PiKernel && { ScriptErr "can only backup a Raspbery Pi"; }
	! IsAvailable "$host" && { ScriptErr: "host \`$host\` is not available"; return 1; }

	# get compression host information
	eval "$(HostFindInfo "$host")" || return
	IsPlatform win $_platform $_platformLike $_platformId && { win="true" hostUnc="c\$/temp"; }

	# backup
	hilight "Backing up $HOSTNAME..."
	dir="$(unc mount //$host/$hostUnc)" || return	
	file="$dir/$fileName"
	sudo pv $size -tpreb "/dev/$device" | dd bs=4M > "$file" || return

	# copy
	if [[ $win ]]; then
		hilight "Copying $fileName on $host..."
		ssh "$host" -t -- CopyDir "/mnt/c/temp/$fileName" "/tmp" || return
	fi

	# compress
	hilight "Compressing $fileName..."
	file="/tmp/$fileName"
 	ssh "$host" -t -- pv $size -tpreb "$file" \| xz -1 -z -T 0 - \> "$file.xz" || return

 	# copy compressed file to image directory
	local image="$(ssh oversoul -t -- FindInstallFile --quiet "$(QuoteSpaces "platform/linux/Raspberry Pi/image")")"
 	hilight "Copying $fileName to the install server..."
	ssh "$host" -t -- CopyDir "$file.xz" "$(QuoteSpaces "$image")/$fileName.xz" || return

 	# cleanup
 	ssh "$host" -t -- rm -f "/tmp/$fileName" "/tmp/$fileName.xz" "/mnt/c/temp/$fileName" || return
}

ImageRestoreCommand()
{
	echo "Not Implemented"
}

ImageBalenaCommand()
{
	! IsElevated && { elevate RunScript --pause-error pi image balena "$@"; return; }

	local image="$(i dir)/platform/linux/Raspberry Pi/Raspberry Pi OS" || return

	# select the firmware file
	local file="$1"; shift
	[[ ! $file ]] && { file="$(dialog --title "Select image" --stdout --fselect "$image/" $(($LINES-12)) 100)"; clear; }
	[[ ! $file ]] && { MissingOperand "file"; return 1; }
	[[ ! -f "$file" ]] && { EchoErr "pi: image \"$file\" does not exist"; return 1; }

	"$P/balena-cli/balena.exe" local flash "$(utw "$file")" --yes

	# does not mount properly just after flash so try several times
	for (( i=1; i<=10; ++i )); do
		ImageSshCommand && return
		sleep 1
	done

	return 0
}

ImageSshCommand()
{
	local drive drives found

	drive mount all || return
	IFS=$'\n' drives=( $(drive mounts) )

	printf "enabling..."
	
	for drive in "${drives[@]}"; do
		[[ ! -f "$drive/start.elf" ]] && continue
		touch "$drive/ssh" || return
		printf "$(GetFileName "$drive")..."
		found="true"
	done

	echo "done" 

	drive unmount all || return

	[[ ! $found ]] && { ScriptErr "no Raspberry Pi images found"; return 1; }

	return 0
}

run "$@"

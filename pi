#!/usr/bin/env bash
. script.sh
. color.sh

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) balena|firmware|image|info|power
Raspberry Pi helper commands"
}

init()
{
	piImage="platform/linux/Raspberry Pi/image"
	piOs="platform/linux/Raspberry Pi/Raspberry Pi OS"
	ubuntuImage="platform/linux/Ubuntu/image"
}

#
# commands
#

balenaCommand() { elevate "$UADATA/Programs/balena-etcher/balenaEtcher.exe"; }
powerCommand() { ! dmesg --time-format ctime | grep -i volt; } # check for under voltage in the log

#
# Firmware Commands
#

firmwareUsage()
{
	echot "\
usage: pi firmware apply|channel|configure|dir|edit|update
	Raspberry Pi firmware commands.

	apply			apply firmware changes from a file
	channel		edit the firmware channel (beta, stable, or critical)
	configure	configure the firmware
	dir				return the firmware directory
	edit			configure and apply the firmware
	info			show firmware information
	update		update the Raspberry Pi with the latests firmware"
}

firmwareArgStart()
{
	onlyPi || return
	channel="/etc/default/rpi-eeprom-update"
	dir="/lib/firmware/raspberrypi/bootloader"
}

firmwareCommand() { usage; }
firmwareDirCommand() { echo "$dir"; }
firmwareChannelCommand() { sudoedit "$channel"; }
firmwareUpdateCommand() { sudo rpi-eeprom-update -a -i && { ask "Reboot" && power reboot || return 0; }; }

firmwareInfoCommand()
{
	header "Update Status"
	sudo rpi-eeprom-update
	echo

	[[ -f "$channel" ]] && { header "Update Channel"; cat "$channel"; }
	echo

	header "Bootloader Version"
	sudoc vcgencmd bootloader_version || return
	

	header "Bootloader Configurationn"
	sudo vcgencmd bootloader_config | RemoveEmptyLines || return
}

firmwareApplyCommand()
{
	firmwareGetFile "$@" || return
	sudo rpi-eeprom-update -d -f "$dir/new-config.bin" || return
}

firmwareEditCommand()
{
	firmwareConfigureCommand "$@" || return
	firmwareApplyCommand || return
}

firmwareConfigureCommand()
{
	firmwareGetFile "$@" || return

	# backup existing configuration changes
	[[ -f "$config" ]] && { sudo bak --move "$config" || return; }

	# extract configuration from the firmware file
	sudoc cp "$file" "$dir/current.bin" || return
	rpi-eeprom-config "$dir/current.bin" | sudo tee "$config" || return
	[[ ! -f "$config" || "$(cat "$config")" == "" ]] && { EchoErr "Unable to extract the firmware configuration from \"$file\""; return 1; }
	sudo cp "$config" "$config.orig" || return

	# edit the configuration
	sudoedit "$config" || return

	# add the configuration to the firmware file
	if ! diff "$config" "$config.orig" >& /dev/null; then
		printf "Adding the configuration changes to the firmware file..."
		sudo rpi-eeprom-config --out "$dir/new-config.bin" --config "$config" "$dir/current.bin" || return
		echo "done"
	fi

	return 0
}

firmwareGetFile() # sets file, dir, and config
{
	local FIRMWARE_RELEASE_STATUS; . "$channel" || return
	
	dir="$dir/$FIRMWARE_RELEASE_STATUS"
	config="$dir/bootconf.txt"

	[[ ! $file ]] && { file="$1"; shift; }
	[[ ! $file ]] && { file="$(dialog --title "Select Firmware" --stdout --fselect ""$dir/"" $(($LINES-12)) 100)"; clear; }
	[[ ! $file ]] && { MissingOperand "file"; return 1; }
	[[ ! -f "$file" ]] && { ScriptErr "firmware file \"$file\" does not exist"; return 1; }

	return 0
}

#
# Info Command
#

infoUsage()
{
	echot "\
usage: pi info mhz|model|temp
	Raspberry Pi information commands.

	mhz		current CPU clock speed in MHz"
}

infoCommand() { usage; }

infoMhzCommand()
{
	local mhz; mhz="$(sudoc vcgencmd measure_clock arm | cut -d= -f 2)" || return
	echo "$((mhz / 1000000))"
}

infoTempCommand()
{
	onlyPi
	local temp=$(</sys/class/thermal/thermal_zone0/temp)
	echo "$((temp/1000))'C"
}

infoModelCommand()
{
	cat /proc/cpuinfo | grep "^Model" | cut -d":" -f 2 | RemoveTrim
}


#
# Image Commands
#

imageUsage()
{
	echot "\
usage: pi image backup|clone|configure|restore
	Raspberry Pi image commands.

	backup					create an image from this host
	clone  					create an image on a Rapsberry Pi using the Pi Clone GUI tool.
									This has a faster file copy.
	configure				configure a newly created operating system image
	restore	[IMAGE]	restore an image to a connected drive"
}

imageArgStart() { unset -v host; }

hostOpt() 
{
	case "$1" in
		-h*|--host=*|--host) ScriptOptGet host "$@" || return;;
		*) return 1
	esac
}

imageCommand() { usage; }

imageCloneCommand() 
{ 
	onlyPi || return;
	! InPath piclone && { package piclone || return; }
	coproc sudox dbus-launch piclone
}

#
# Image Backup Command
#

imageBackupUsage()
{
	echot "\
Usage: $(ScriptName) image backup HOST
Create an OS image on the specified host.
- faster than using a local Micro-SD card
- faster compression (utilizes hosts processors)"
}

imageBackupArgs() { ScriptArgGet "host" -- "$@"; shift; }

imageBackupCommand()
{
	onlyPi || return

	# install required utilities
	! InPath pv && { package pv || return; }
	# check if host is available	
	! IsAvailable "$host" && { ScriptErr: "host '$host' is not available"; return 1; }

	# calculate backup drive size
	local device="mmcblk0" fileName="$HOSTNAME.$(GetDateStamp).img" 
	local size; size="$(drive size $device)" || return; [[ $size ]] && size="--size ${size,,}"

	# mount host directory
	hilight "Mounting $host directory..."
	ScriptEval HostGetInfo "$host" || return
	local dir; dir="$(unc mount "$_root/tmp" --protocol "$_protocol")" || return
	local file="$dir/$fileName"

	# backup
	hilight "Backing up $HOSTNAME..."
	sudo pv $size -tpreb "/dev/$device" | dd bs=4M > "$file" || return

	# compress
	hilight "Compressing backup file..."
	file="/tmp/$fileName"
 	ssh "$host" -t -- pv $size -tpreb "$file" \| xz -1 -z -T 0 - \> "$file.xz" || return

 	# copy compressed file to image directory
	local image="$(ssh oversoul -t -- FindInstallFile --quiet "$(QuoteSpaces "$piImage")")"
 	hilight "Copying $fileName to the install server..."
	ssh "$host" -t -- CopyDir "$file.xz" "$(QuoteSpaces "$image")/$fileName.xz" || return

 	# cleanup
 	ssh "$host" -t -- rm -f "/tmp/$fileName" "/tmp/$fileName.xz" "/mnt/c/temp/$fileName" || return
}

#
# Image Configure Command
#

imageConfigureUsage()
{
	echot "\
Usage: $(ScriptName) image configure
Configure a newly created operating system image.
Currently, Raspberry Pi OS and Ubuntu are supported.

	-H, --host HOST		the name of the host"
}

imageConfigureOpt() { hostOpt; }

imageConfigureCommand()
{
	local drive drives found

	drive mount all || return
	IFS=$'\n' drives=( $(drive mounts) )

	printf "configuring..."
	for drive in "${drives[@]}"; do
		[[ ! -f "$drive/start.elf" ]] && continue
		printf "$(GetFileName "$drive")..."

		# cloud-init image - deploy user-data
		if [[ -f "$drive/user-data" ]]; then
			[[ ! $host ]] && MissingOperand "host"

			printf "${RB_BLUE}cloud-init${RESET}..."
			cp "$DATA/setup/user-data" "$drive" || return
			sed -i "s/^#hostname: HOST$/hostname: $host/" "/etc/default/locale" "$drive/user-data" || return

		# Raspberry Pi OS image - enable SSH			
		else
			printf "${RB_BLUE}Raspberry Pi OS${RESET}..."
			touch "$drive/ssh" || return
		fi
		
		found="true"
		break
	done

	echo "done" 

	drive unmount all || return

	[[ ! $found ]] && { ScriptErr "no boot images found"; return 1; }

	return 0
}

imageRestoreArgStart() { unset -v image; }
imageRestoreArgs() { ScriptArgGet "image" -- "$@"; shift; }

imageRestoreCommand()
{
	IsPlatform win && ! IsElevated && { elevate RunScript --pause pi image restore "${originalArgs[@]}"; return; }

	# image aliases
	local selectDir="$piOs"
	case "$image" in
		image) unset image; selectDir="$piImage";;
		server|ubuntu-server) image="$(installFile "$ubuntuImage/ubuntu-20.04.1-preinstalled-server-arm64+raspi.img.xz")"
	esac

	# select the image from the selectDir
	if [[ ! $image ]]; then
		local imageDir="$(installFile "$selectDir")" || return
		image="$(dialog --title "Select image" --stdout --fselect "$imageDir/" $(($LINES-12)) 100)"
		clear
	fi
	
	# validate the image selected
	[[ ! $image ]] && { MissingOperand "image"; return 1; }
	[[ ! -f "$image" ]] && { EchoErr "pi: image \"$image\" does not exist"; return 1; }
	[[ $# != 0 ]] && usage 1

	if [[ -f "$P/balena-cli/balena.exe" ]]; then		
		#elevate RunScript --pause --wait -- "$P/balena-cli/balena.exe" local flash "$(utw "$image" | QuoteBackslashes)" --yes || return
		"$P/balena-cli/balena.exe" local flash "$(utw "$image")" --yes || return
	elif InPath flash; then
		flash "$image" || return
	else
		ScriptErr "no flash program found"; return 1
	fi

	# does not mount properly just after flash so try several times
	hilight 'configuring...'
	for (( i=1; i<=10; ++i )); do
		ImageConfigureCommand && return
		sleep 1
	done

	return 0
}

#
# helper
#

installFile() { FindInstallFile --quiet "$1"; }
onlyPi() { IsPlatform PiKernel && return; ScriptErr "command can only run on a Raspbery Pi"; return 1; }

ScriptRun "$@"

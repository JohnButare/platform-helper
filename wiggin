#!/usr/bin/env bash
. app.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) backup|host|network|setup|sync|update [OPTION]...
Manage the Wiggin network."
}

init()
{
	configDir="$CLOUD/network"
	hashiConfig="$configDir/system/hashi"

	# network devices
	aps=(LivingRoomAp BackYardAp FrontYardAp GarageAp StudyAp) # reboot Living Room AP first
	switches=(BackShedSwitch BensRoomSwitch DenSwitch GarageIotSwitch GarageSwitch HallSwitch LivingRoomSwitch StudyClosetSwitch1 StudyClosetSwitch2 StudyClosetSwitch3 StudyDeskSwitch)
	routers=(router)
}

#
# backup commands
#

backupCommands=( consul ContainerStation domains HomeAssistant LastPass nginx pool ProxyManager qnap web )

backupUsage() 
{
	ScriptUsageEcho "Usage: $(ScriptName) backup job|$(ArrayDelimit backupCommands "|")
Backup data for the Wiggin network.

	job			run the backup job which backs up all relevant data for the Wiggin network."
}

backupCommand() { usage; }
backupDomainsCommand() { backupDomain "butare.net" && backupDomain "juntosholdings.com"; }
backupNginxCommand() { borgBackupConfig "Nginx" "lb" "/etc/nginx"; }
backupProxymanagerCommand() { borgBackupService "ProxyManager" "nginx-proxy-manager" "/srv/nginx-proxy-manager"; }
backupHomeassistantCommand() { borgBackupService "HomeAssistant" "home-assistant" "/home/homeassistant/.homeassistant"; }
backupPoolCommand() { borgBackupService "PoolController" "pool-controller" "/opt/pool-controller" && borgBackupService "PoolDashPanel" "pool-dash-panel" "/opt/pool-dash-panel"; }
backupWebCommand() { borgBackupService "web" "web" "/srv/apache-web"; }
backupWireguardCommand() { borgBackupService "WireGuard" "wire-guard" "/etc/wireguard" "/etc/pivpn"; }

backupConsulCommand()
{
	local dest="$(AppGetBackupDir)/consul" || return
	[[ ! -d "$dest" ]] && { ${G}mkdir --parents "$dest" || return; }
	pushd "$dest" && hashi consul backup "${globalArgs[@]}" && popd
}

backupContainerstationCommand()
{ 
	local server="nas3"
	! unc IsAvailable "$server" && { ScriptErr "'$server' is not available"; return 1; }
	AppBackup "$(RemoveDnsSuffix "$server").ContainerStation" "//$server/root/share/data/Container/container-station-data/application"
}

backupDomain()
{
	local domain="$1"

	hilight "Backup up domain $domain..."
	local dest; dest="$(AppBackupFile "$domain.zip")" || return
	CloudFlare dns list "$domain" | ZipStdin "$dest" || return

  echo "Domain backup completed to '$dest'"
}

backupLastpassCommand()
{
	header "LastPass Backup"

	local dir; dir="$(mountVol "$CDATA/VeraCrypt/personal.hc")/backup/LastPass" || return

	echo "Logging in to LastPass..."
	LastPass login || return

	echo "Exporting LastPass..."
	lpass export > "$(GetDateStampNext "$dir/" "csv")" || return
		
	unmountVol || return
}

backupQnapCommand()
{
	! IsPlatform QNAP && { ScriptErr "can only backup QNAP operating system"; return 1; }

	# initialize
	local dest="$(AppGetBackupDir)/${HOSTNAME}.qnap.settings" || return
	[[ -f "$dest" ]] && { bak --move "$dest" || return; }

	# maybe intended to be a backup number, but it is filled with a constant (127) when
	# using the backup function from the webpage, file is not removed after backup, but
	# missing after next reboot...
	echo "127" | sudo tee "/etc/save_no.conf" || return

	sudoc tar cvf - "/etc/config/"* "/etc/save_no.conf" | gzip > "$dest.tgz" || return

	PC1 e ICPIPNASWAREV301 "$dest.tgz" "$dest.bin" || return
	PC2 "$dest.bin" "" "" || return

	rm "$dest.tgz" || return
}

#
# backup job command
#

backupJobCommand()
{
	header "Wiggin Backup Job"

	hilight "Configuration..."
	echo "HOSTNAME=$HOSTNAME"
	echo "USER=$USER"
	echo "PATH=$PATH"
	echo "globalArgs=${globalArgs[@]}"	
	echo

	# network current update || return
	echo

	# hilight "Testing credentials..."
	credential manager status "${globalArgs[@]}" || return
	echo "test/check=$(credential get test check "${globalArgs[@]}")"
	echo

	# hilight "SSH Agent status..."
	SshAgent status "${globalArgs[@]}" || exit

	# backup 
	local fail=0 success=0
	echo
	runAll "update" CloudFlare JumpCloud WireGuard || return
	runAll "backup" consul domains domotz HomeAssistant homebridge nginx UniFi web WireGuard || return

	# result
	header "Wiggin Backup Complete"
	(( fail > 0 )) && { HilightRed "$success succeeded, $fail failed"; return 1; }
	hilight "all $success succeeded, 0 failed"
}

HilightRed() { echo "${RED}$1${reset}"; }

runAll()
{
	local type="$1" w; shift
	for w in "$@"; do $type$(UpperCaseFirst "$w") || return; done
}

runApp()
{
	local type="$1" name="$(UpperCaseFirst "$2")"; shift 2
	local desc="$(UpperCaseFirst "$type")"
	local cache="$desc$name"

	header "$desc $name"

	! UpdateNeeded "$cache" && { echo "$name $type already done today."; runAppSuccess; return; }

	if RunLog "$@" "${globalArgs[@]}"; then
		runAppSuccess
		UpdateDone "$cache"
	else
		HilightRed "failed"; echo
		(( fail+=1 ))
	fi
}

runAppSuccess() { hilight "succeeded"; echo; (( success+=1 )); }

backupWeb() { runApp "backup" "web" wiggin backup web; }
backupConsul() { runApp "backup" "consul" wiggin backup consul; }
backupDomains() { runApp "backup" "domains" wiggin backup domains; }
backupDomotz() { runApp "backup" "domotz" DomotzHelper backup; }
backupHomeAssistant() { runApp "backup" "HomeAssistant" wiggin backup HomeAssistant; }
backupHomebridge() { runApp "backup" "homebridge" HomebridgeHelper backup "$(GetServer "homebridge")"; }
backupNginx() { runApp "backup" "Nginx" wiggin backup nginx; }
backupProxyManager() { runApp "backup" "ProxyManager" wiggin backup ProxyManager; }
backupUniFi() { runApp "backup" "UniFi" UniFiController backup; }
backupWireGuard() { runApp "backup" "WireGuard" wiggin backup WireGuard; }

updateCloudFlare() { runApp "update" "CloudFlare" wiggin update CloudFlare; }
updateJumpCloud() { runApp "update" "JumpCloud" wiggin update JumpCloud; }
updateWireGuard() { runApp "update" "WireGuard" wiggin update WireGuard; }

#
# host commands
#

hostUsage() {	ScriptUsageEcho "Usage: $(ScriptName) host fix|info|list|on|off|reboot|status|sync|update\n\n$commonUsage\n$waitUsage"; }

hostArgStart()
{
	unset -v hostArg hostOpt errors wait; hosts=(); 

	commonUsage="\
	-H,  --host [HOSTS](all)	comma separated list of hosts, or one of:
														all|down|hashi-prod|hashi-test|important|network|web
	-e, --errors							keep processing if a host operation fails, return the total number of failed hosts"
	waitUsage="	-w,  --wait								wait for the operation to finish"
}

hostOpt()
{
	ScriptOptHost "$@" && return

	case "$1" in
		--errors|-e) errors="--errors";;
		--wait|-w) wait="--wait";;
		*) return 1
	esac
}

hostArgEnd()
{
	case "${hostArg,,}" in
		cam|camera) unset hostArg; GetHostsConfigNetwork "camera";;
		down) hosts=( $(DomotzHelper down | cut -d"," -f2 | DnsResolveMacBatch) ) || ScriptExit;;
		network) hosts=("${aps[@]}" "${switches[@]}" "${routers[@]}") wait="--wait";;
		hashi-*) hosts=( $(hashi config hosts --config-prefix="$(RemoveFront "${hostArg,,}" "hashi-")") ) || ScriptExit;;
		important) hosts=( $(DomotzHelper important) ) || ScriptExit;;
	esac
}

hostCommand() { hostListCommand; }
hostFixUsage() { ScriptUsageEcho "Usage: $(ScriptName) fix\nFix host by forcing it to reconnect to the network.\n\n$commonUsage\n$waitUsage"; }
hostFixCommand() { ForAllHosts $errors --header "Fixing" hostFix ; }
hostInfoUsage() { ScriptUsageEcho "Usage: $(ScriptName) info\n\n	-d, --detail						display detailed information\n$commonUsage"; }
hostInfoArgStart() { unset -v detail; }
hostInfoOpt() { scriptOptDetail "$@"; }
hostInfoCommand() { GetHosts && RunLog os info "$(ArrayDelimit hosts ",")" $detail; }
hostListCommand() { GetHosts && ArrayDelimit hosts $'\n'; }
hostOffCommand() { ForAllHosts $errors hostOff --header "Powering Off"; }
hostOnCommand() { ForAllHosts $errors hostOn --header "Powering On"; }
hostRebootCommand() { ForAllHosts $errors hostReboot --header "Powering On"; }
hostStatusCommand() { ForAllHosts $errors hostStatus --header "Rebooting"; }
hostUpdateCommand() { setOtherHosts; ForAllHosts $errors hostUpdate; }

hostSyncUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) host sync

Synronization options:			follow --, i.e. -- --unison

Common options:
$commonUsage
$waitUsage"
}

hostSyncArgStart() { unset -v unison; }

hostSyncOpt()
{
	case "$1" in
		-u|--unison) unison="--unison";;
		*) return 1;;
	esac
}

hostSyncCommand() { setOtherHosts; ForAllHosts --errors hostSync; }

hostOff() { RunLog power off "$1" $wait "${globalArgs[@]}"; }
hostOn() { RunLog power on "$1" $wait "${globalArgs[@]}"; }
hostReboot() { RunLog power reboot "$1" $wait "${globalArgs[@]}"; }

hostFix()
{
	local host="$1"; host="$(DnsResolve "$host")" || return
	local mac; mac="$(MacLookup --ethers "$host")" || return

	# disconnect	
	log1 "host=$host mac=$mac"
	UniFiController disconnect $mac "${globalArgs[@]}" || return

	# wait
	[[ ! $wait ]] && return
	WaitForAvailable "$host"
}

hostStatus()
{
	if [[ $verbose ]]; then
		power status "$host" --verbose
	else
		local status; status="$(power status "$host")" && echo "$host is $status"
	fi
}

hostSync()
{
	local host="$1" args=($unison); 
	[[ "$(RemoveDnsSuffix "$host")" == @(nas1) ]] && args=() # these hosts do not support unison
	[[ $noPrompt ]] && args+=("--dest-older" "${globalArgs[@]}")
	{ IsLocalHost "$host" || ! HostAvailable "$host"; } && return
	SyncLocalFiles "$host" "${args[@]}" "${otherArgs[@]}"
}

hostUpdate()
{
	local host="$1" args; [[ $noPrompt ]] && args+=("--dest-older" "${globalArgs[@]}")
	[[ "$(RemoveDnsSuffix "$host")" == @(ender|nas1) ]] && return
	HostAvailable "$host" && HostUpdate "$host" --skip="file" "${args[@]}"
}

#
# network commands
#

networkUsage() { ScriptUsageEcho "Usage: $(ScriptName) network backup|config|edit|update|validate"; }

networkArgStart()
{
	unset -v hostArg hostOpt hosts

	# DNS domain
	domain="$(ConfigGetCurrent "domain")" || return
	baseDomain="$(ConfigGetCurrent "baseDomain")" || return

	# network configuration
	network="$(ConfigGet "network")"
	subnetPi1="10.10.102.1 - 10.10.102.99"
	subnetPi2="10.10.102.100 - 10.10.102.199"
	subnetPi3="10.10.103.1 - 10.10.103.99"
	subnetPi4="10.10.103.100 - 10.10.103.199"

	# server file locations
	dhcpDirPackageDir="/etc/kea" # package location
	dhcpDirBuild="/usr/local/etc/kea" # build location	
	dnsDir="/etc/bind"

	# configuration
	dhcpConfig="$configDir/system/dhcp"
	dnsConfig="$configDir/system/dns"
	dhcpReservations="$dhcpConfig/$network/kea-dhcp4-$network-reservations.json"
}

networkCommand() { usage; }

#
# Network Backup Command
#

networkBackupUsage() { ScriptUsageEcho "Usage: $(ScriptName) network backup [dns|dhcp|all](all)\nBackup the DHCP or DNC configuration of HOST.\n\n$hostUsage"; }
networkBackupCommand() { networkBackupAllCommand; }
networkBackupAllCommand() { networkBackupDhcpCommand && networkBackupDnsCommand; }
networkBackupDhcpCommand() { GetHostsConfigNetwork "dhcp" && ForAllHosts networkBackupDhcp; }
networkBackupDnsCommand() { GetHostsConfigNetwork "dns" && ForAllHosts networkBackupDns; }

networkBackupDhcp()
{
	local host="$1" hostShort hostIp stamp="$(GetDateStamp)"; getHost || return

	hilight "Backing up DHCP configuration from $hostShort..."

	# find a unique filename
	local file="$hostShort.dhcpd.zip" i=1
	local backupDir="$dhcpConfig/backup"
	while [[ -f "$backupDir/$stamp.$i.$file" ]]; do (( ++i )); done

	# create the backup	
	ssh $hostIp "rm -f ~/tmp/$file; zip -r ~/tmp/$file $dhcpDir" || return

	# copy the backup to the backup directory
	scp "$hostIp:~/tmp/$file" "$backupDir/$stamp.$i.$file" || return
}

networkBackupDns()
{
	local host="$1" hostShort hostIp stamp="$(GetDateStamp)"; getHost || return

	hilight "Backing up DNS configuration from $hostShort..."

	# find a unique filename
	local file="$hostShort.dns.zip" i="1"
	local backupDir="$dnsConfig/backup"
	while [[ -f "$backupDir/$stamp.$i.$file" ]]; do (( ++i )); done

	# create the backup
	ssh "$hostIp" "rm -f ~/tmp/$file; zip -r ~/tmp/$file $dnsDir --exclude \*.key \*.zip" || return

	# copy the backup to the backup directory
	scp "$hostIp:~/tmp/$file" "$backupDir/$stamp.$i.$file" || return
}

#
# Network Config
#


networkConfigUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) network config active|compare|current|issues|reservations
Display network configuration.

	-i, --ip		display the IP address"; 
}

networkConfigCommand() { usage; }

networkConfigArgStart() { unset -v ip; }

networkConfigOpt()
{
	case "$1" in
		-i|--ip) ip="--ip";;
	esac
}

networkConfigIssueCommand()
{
	local file="/tmp/active.json"
	UniFiController api "/stat/sta" | jq > "$file" || return

	# missign IP
	#local missingIp; missingIp="$(cat "$file" | jq '.data[] | select(has("last_ip") | not) | .name' | RemoveQuotes | toDnsName | sort | uniq)"	
	#echo $missingIp

	# MAC address with no reservation
	
	# DNS name -
	#local active; IFS=$'\n' active=( $(cat "$file" | configActive | toDnsName) )
	#time parallel -i bash -c ". function.sh; DnsResolve {}" -- "${active[@]}"

	# DNS name - check against name	
	#local active; ip=true IFS=$'\n' active=( $(cat "$file" | configActive | toDnsName) )

	# list inactive

	# IsAvailable
	local active; ip= IFS=$'\n' active=( $(cat "$file" | configActive | toDnsName) )
	time parallel -i bash -c ". function.sh; IsAvailable {} 5000 || echo {}" -- "${active[@]}"
	
	# time for a in "${active[@]}"; do DnsResolve "$a"; done
}

networkConfigActiveCommand() { UniFiController api "/stat/sta" | configActive; }

# configActive - return active host "name" or "ip,name"
configActive()
{
	if [[ $ip ]]; then
		jq '.data[] | { ip: .last_ip, name: .name } | join(",") ' | RemoveQuotes | grep -v null | ${G}sort -V | uniq
	else
		jq '.data[].name' | RemoveQuotes | sort | uniq
	fi
}

networkConfigReservationsUsage() { ScriptUsageEcho "Usage: $(ScriptName) network config reservations\nGet DHCP reservation DNS names and MAC addresses in CSV format."; }

networkConfigReservationsCommand()
{
	EchoErr "Getting device reservations..."
	local what='print $1 "," $2'; [[ $ip ]] && what+='"," $3'
	configFileToCommaDelimited "$dhcpReservations" | tr A-Z a-z | awk -F "," "{ $what }"
}

networkConfigCurrentUsage() { ScriptUsageEcho "Usage: $(ScriptName) network config current\nGet current network device DNS names and MAC addresses in CSV format."; }

networkConfigCurrentCommand()
{
	EchoErr "Getting current devices..."
	{ UniFiController api "/rest/user" | unifiToCsv; UniFiController api "/stat/device" | unifiToCsv; } | sort
}

unifiToCsv()
{
	local what='name: .name, mac: .mac'; [[ $ip ]] && what+=', ip: .last_ip, dip: .ip'
	jq '.data[]
			| select((has("note") and (.note | startswith("ignore") | not)) or (has("note") | not))
			| {'"$what"'}
			| join(",")' \
		| RemoveQuotes | toDnsName | sort | unifiIpFix; 
}

toDnsName() { sed 's/[- ()]//g' | sed 's/'\''//g' | LowerCase; }

# unifiIpFix - consolidate the IP address in columns 3, 4, and 5
unifiIpFix()
{
	[[ ! $ip ]] && { cat; return; }
	awk -F, '{ if ($3 == "") $3=$4; print $1 "," $2 "," $3 }'
}

networkConfigCompareCommand()
{
	local current="/tmp/current.csv" reservations="/tmp/reservations.csv"
	networkConfigCurrentCommand > "$current" || return
	networkConfigReservationsCommand > "$reservations" || return
	merge "$reservations" "$current"
}

#
# Network Edit Command
#

networkEditUsage() { ScriptUsageEcho "Usage: $(ScriptName) network edit\nEdit the DHCP and DNC configuration files."; }

networkEditCommand()
{
	local n="$(ConfigGet "network")"

	# edit all files to ensure retrieval from cloud
	TextEdit \
		"$DATA/setup/ports" \
		"$dnsConfig/$baseDomain" \
		"$dnsConfig/forward.txt" \
		"$dnsConfig/reverse.txt" \
		"$dhcpConfig/$n/kea-dhcp4-$n.json" \
		"$dhcpConfig/$n/kea-dhcp4-$n-reservations.json"
}

#
# Network Update Command
#

networkUpdateUsage()
{
	EchoWrap "Usage: $(ScriptName) network update [dns|dhcp|all](all)
Update the DHCP or DNS configuration of HOST.

	$hostUsage
	-nb,	--no-backup			do not backup the existing configuration before updating
	-nv,	--no-validate		do not validate the service after updating"
}

networkUpdateArgStart() { unset -v noBackup noValidate; }

networkUpdateOpt() 
{
	ScriptOptHost "$@" && return

	case "$1" in
		-nb|--no-backup) noBackup="true";;
		-nv|--no-validate) noValidate="true";;
		*) return 1
	esac
}

networkUpdateCommand() { networkUpdateAllCommand; }
networkUpdateAllCommand() { networkUpdateDhcpCommand && networkUpdateDnsCommand; }
networkUpdateDhcpCommand() { GetHostsConfigNetwork "dhcp" && ForAllHosts networkUpdateDhcp --header "Update DHCP"; }
networkUpdateDnsCommand() {	GetHostsConfigNetwork "dns" && ForAllHosts networkUpdateDns --header "Update DNS"; }

#
# Network Update DHCP Command
#

networkUpdateDhcp()
{
	local host="$1" hostShort hostIp; networkUpdateCommon "DHCP" || return
	local config="$dhcpConfig/$network"; CloudGet "$config"/* || return
	local dir="$(mktemp -d -t 'dhcp.XXXXXXXXXX')" || return
	local subnetVar="subnet$(ProperCase "$hostShort")"
	local subnet="${!subnetVar}"

	# validate subnet range for the host
	[[ ! $subnet ]] && { ScriptErr "unable to find a DHCP pool for host '$hostShort'"; return 1; }

	echo "Updating DHCP configuration for $hostShort..."
	cp "$config/"* "$dir" || return
	${G}sed -i "s/SUBNET4_POOL/$subnet/" "$dir/kea-dhcp4-$network.json" || return
	${G}sed -i "s/DHCP_DIR/$(echo "$dhcpDir" | QuotePath)/" "$dir/kea-dhcp4-$network.json" || return
	${G}sed -i "s/DHCP_DIR/$(echo "$dhcpDir" | QuotePath)/" "$dir/kea-dhcp4.conf" || return

	echo "Updating the ethers configuration file..." # downcase to make etherwake case agnostic
	configFileToCommaDelimited "$dhcpReservations" | tr A-Z a-z | awk -F "," '{ print $2 " " $1 }' > "$DATA/setup/ethers" || return

	echo "Updating the hosts configuration file..."
	configFileToCommaDelimited "$dhcpReservations" | awk -F "," '{ print $1 }' > "$DATA/setup/hosts" || return

	echo "Updating DHCP configuration on $hostShort..."
	rsync --no-perms --chmod=ugo=rw --rsync-path="sudo rsync" --info=progress2 "$dir/"* "$host:$dhcpDir" || return

	# cleanup
	rm -fr "$dir" || return

	# restart the service
	SshHelper --x-forwarding --pseudo-terminal connect "$hostIp" -- sudo service restart kea-dhcp4-server || return

	# validate
	[[ ! $noValidate ]] && { networkValidateHost "$host" DHCP || return; }

	return 0
}

#
# Network Update DNS Command
#

networkUpdateDns()
{
	local host="$1" hostShort hostIp; networkUpdateCommon "DNS" || return
	local config="$dnsConfig"; CloudGet "$config"/* || return
	local dir="$(mktemp -d -t 'dns.XXXXXXXXXX')" || return

	echo "Creating DNS configuration files..."
	cp "$config/named.conf."* "$dir" || return
	cp "$config/$baseDomain" "$dir" || return
	cp "$config/forward.txt" "$dir/$domain" || return
	configFileToCommaDelimited "$dhcpReservations" | awk -F "," '{ print $1 ".'$domain'.	A	" $3 }' | column -t	>> "$dir/$domain" || return

	# create reverse lookup zone files
	for zone in 100 101 102; do
		local z="$dir/$zone.10.10.in-addr.arpa"

		cat "$config/$zone.txt" > "$z" || return

		{ printf "\n; static\n"; cat "$config/reverse.txt" | ${G}grep "^[0-9]*.$zone.10.10"; } >> "$z"

		{ printf "\n; dynamic\n"
			configFileToCommaDelimited "$dhcpReservations" |
				grep ",10.10.$zone." |
				sed "s/10.10.$zone.//" |
				awk -F "," '{ print $3 ".'$zone'.10.10.in-addr.arpa. PTR " $1 ".'$domain'." }' |
				column -t; } >> "$z"

	done

	echo "Updating DNS configuration files on $host..."
	rsync --no-perms --chmod=ugo=rw --rsync-path="sudo rsync" "$dir/"* "$hostIp:$dnsDir" --info=progress2 || return

	# cleanup
	rm -fr "$dir" || return

	# restart the service - use X Forwarding to enable local credential manager
	SshHelper --x-forwarding --pseudo-terminal connect "$hostIp" -- sudo service restart named || return

	# validate
	if [[ ! $noValidate ]]; then
		{ DnsFlush && sleep 1 && networkValidateHost "$host" DNS; } || return
	fi

	return 0
}

#
# Network Update Helper
#

networkUpdateCommon()
{
	getHost || return	
	networkConfigFileValidate "$dhcpReservations" || return
	[[ ! $noBackup ]] && { networkBackup$(ProperCase "$1") "$host" || return; }
	return 0
}

# configFileToCommaDelimited FILE - convert a Kea configuration file to comma delimited
configFileToCommaDelimited()
{
	configFileToJson "$1" |
		jq '.[]|{a: .hostname, b: ."hw-address", c: ."ip-address"}|join(",")' | # convert to comma delimited
		sed 's/\"//g'	|	# remove quotes
		sort
}

# configFileToJson FILE - convert a Kea configuration file to valid JSON
configFileToJson()
{
	cat "$1" |
		sed '/^[	 ]*\/\//d' |  # remove comments - lines that begin with //
		sed '/<\?include/d'  	# remove <?include ?> directives
}

networkConfigFileValidate()
{
	configFileToJson "$1" | jq > /dev/null && return

	# view the file issues in a text editor
	local file="$(mktemp)" || return
	configFileToJson "$1" > "$file" 2> /dev/null
	TextEdit "$1" "$file" || return
	return 1
}

#
# Network Validate Command
#

networkValidateUsage() { ScriptUsageEcho "Usage: $(ScriptName) network validate [dns|dhcp|all](all)\nValidate the DHCP or DNC operation of HOST.\n\n$hostUsage"; }
networkValidateCommand() { networkValidateAllCommand; }
networkValidateAllCommand() { networkValidateDhcpCommand && networkValidateDnsCommand; }
networkValidateDhcpCommand() { networkValidateHosts "DHCP"; }
networkValidateDnsCommand() { networkValidateHosts "DNS"; }

networkValidateDhcp()
{
	local host="$1" hostShort hostIp; getHost || return
	if IsPlatform win; then
		dhcptest.exe --bind "$(GetAdapterIpAddress)" --query --wait --timeout 2 |& grep -q "^Received packet from $hostIp"
	else
		sudoc nmap --script broadcast-dhcp-discover -e $(GetPrimaryAdapterName) |& grep -q "Server Identifier: $hostIp"
	fi
}

networkValidateDns()
{
	local host="$1" hostShort hostIp; getHost || return
	IsAvailablePort "$hostIp" 53 || return
	nslookup router "$hostIp" >& /dev/null || return			# validate forward lookup
	nslookup 10.10.100.1 "$hostIp" >& /dev/null || return	# validate reverse lookup
}

# networkValidateHost HOST dhcp|dns - validate DHCP or DNS for the specified host
networkValidateHost()
{
	local host="$1" what="${2^^}" hostShort hostIp; getHost || return	
	printf "Waiting for $what on $hostShort..."

	if networkValidateWait "$what" 10; then
		echo "${GREEN}available${RESET}"
	else
		echo "${RED}failed${RESET}"
		return 1
	fi
}

# networkValidateHosts dhcp|dns - validate DHCP or DNS for the hosts
networkValidateHosts()
{
	local what="$1" hosts host hostShort hostIp; GetHostsConfigNetwork "${what,,}" || return

	printf "Validating ${what^^}..."
	for host in "${hosts[@]}"; do
		getHost || return	
		printf "$hostShort..."
		networkValidateWait "$what" 5 && printf "ok..." || printf "${RED}failed${RESET}..."
	done
	echo "done"
}

# networkValidateWait dns|dhcp SECONDS - wait SECONDS to validate DNS or DHCP
networkValidateWait()
{	
	local function="networkValidate$(ProperCase "$1")" seconds="$2" 

	$function "$hostIp" && return

	for (( i=1; i<=$seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; exit 1; }
 		$function "$hostIp" && return
		[[ ! $quiet ]] && printf "."
	done

	return 1
}

#
# setup command
#

setupUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup hashi"; }
setupCommand() { usage; }

#
# setup hashi command
#

setupHashiUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup hashi\nSetup programs."; }

setupHashiCommand()
{
	header "Installing Hashi jobs..."
	local job jobs=(apache-web backup file git home-assistant lb node-red pool-controller pool-dash-panel pool-temperature wire-guard)
	for job in "${jobs[@]}"; do hashiJob "backup" || return; done

	header "Installing Hashi Consul services..."
	hashiService "cups" 3 || return
	hashiService "dns.json" 1,2,3,4 || return
	hashiService "domotz-agent" 6 || return
	hashiService "nginx" 3 || return
	hashiService "nomad-web" 1,2,3 || return
	hashiService "squid-proxy" 3 || return
}

hashiRun() { hashi "$@" $force $test "${globalArgs[@]}" "${otherArgs[@]}"; }
hashiJob() { local job="$1"; shift; hashiRun nomad job run "$job" "$@"; }

hashiService()
{
	local service="$1" hostNum hostNums; StringToArray "$2" "," hostNums; shift 2

	# hcl is the default extension
	[[ "$(GetFileExtension "$service")" == "" ]] && service=+".hcl"

	# add the service
	for hostNum in "${hostNums[@]}"; do
 		hashiRun consul service add "$hashiConfig/service/$service.hcl" --host="pi$hostNum" "$@"
	done
}

#
# synchronize commands
#

syncUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) sync broadlink-manager|credential|homebridge|home-assistant|lb|lb-cert|pool-controller|pool-dash-panel|web|wire-guard
Synronize Wiggin application data.\n\n$syncUsage"
}

syncCommand() { usage; }

syncArgStart()
{
	unset hostArg hostOpt hosts noServiceRestart 
	unset unisonArgs
	syncUsage="$hostUsage\n	-nsr, --no-service-restart	do not restart services"
}

syncOpt()
{
	ScriptOptHost "$@" && return
	case "$1" in
		-nsr|--no-service-restart) noServiceRestart="--no-service-restart";;
		*) return 1;;
	esac
}

syncCredentgialUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync credential\nSyncronize frequently used credentials."; }

syncCredentialCommand()
{
	local cred creds=(borg CloudFlare domotz HomeAssistant homebridge hubitat JumpCloud unifi vera)
	for cred in "${creds[@]}"; do
		header "$cred"
		[[ ! $force ]] && credential ls --manager=local | grep --quiet "^$cred/$" && continue
		credential mirror --from remote --to local "$cred" --force "${globalArgs[@]}" || return
	done
}

syncHomebridgeUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync homebridge [cert]\nSyncronize Homebridge configuration.\n\n$syncUsage"; }
syncHomebridgeCommand() { GetHostsService "lb" && ForAllHosts syncHomebridge --header "Sync Homebridge"; }
syncHomebridge() { unisonArgs=(-ignore "Name {backups,homebridge.err,homebridge.log,node_modules}"); syncDir "$1" "/var/lib/homebridge"; }

syncBroadlink-managerUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync broadlink-manager\nSyncronize Broadlink Manager configuration.\n\n$syncUsage"; }
syncBroadlink-managerCommand() { GetHostsService "broadlink-manager" && ForAllHosts syncBroadlinkManager --header "Sync Broadlink Manager"; }
syncBroadlinkManager() { syncDir "$1" "/srv/broadlinkmanager"; }

syncLbUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb [cert]\nSyncronize load balancer configuration (NGINX rever proxy servers).\n\n$syncUsage"; }
syncLbCommand() { GetHostsService "lb" && ForAllHosts syncLb --header "Sync Load Balancer"; }
syncLb() { unisonArgs=(-ignore "Name {sites-available/*.conf}" -ignorenot "Name {outage.conf}"); syncDir "$1" "/etc/nginx,/etc/consul-template.d" "consul-template,nginx"; }

syncLb-certUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb cert\nSyncronize load balancer SSL certificates.\n\n$syncUsage"; }
syncLb-certCommand() { GetHostsService "lb" && ForAllHosts syncLbCert --header "Sync Certificates"; }
syncLbCert() { syncDir "$1" "/etc/letsencrypt"; }

syncPool-controllerUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb [cert]\nSyncronize Pool Dash Panel configuration.\n\n$syncUsage"; }
syncPool-controllerCommand() { GetHostsService "pool-controller" && ForAllHosts syncPoolController --header "Sync Pool Controller Files"; }
syncPoolController() { unisonArgs=(); syncDir "$1" "/opt/pool-controller/data"; }

syncPool-dash-panelUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb [cert]\nSyncronize Pool Dash Panel configuration.\n\n$syncUsage"; }
syncPool-dash-panelCommand() { GetHostsService "pool-dash-panel" && ForAllHosts syncPoolDashPanel --header "Sync Pool Dash Panel Files"; }
syncPoolDashPanel() { unisonArgs=(-ignorenot "Name {config.json}" -ignore "Regex .*[^.]" ); syncDir "$1" "/opt/pool-dash-panel"; }

syncWebUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb cert\nSyncronize web site data.\n\n$syncUsage"; }
syncWebCommand() { apache sync "${hostOpt[@]}" "${globalArgs[@]}"; }

syncWire-guardUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb [cert]\nSyncronize WireGuard configuration.\n\n$syncUsage"; }
syncWire-guardCommand() { GetHostsService "wire-guard" && ForAllHosts syncWireGuard --header "Sync WireGuard Files"; }
syncWireGuard() { unisonArgs=(-ignore "Name {setupVars.conf}"); syncDir "$1" "/etc/wireguard,/etc/pivpn" "wg-quick@wg0"; }

#
# sync home-assistant command
#

syncHome-assistantUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync hass [cert]\nSyncronize Home Assistant configuration.\n\n$$syncUsage"; }

syncHome-assistantCommand()
{
	local currentHost="$(GetServer home-assistant --quiet)"

	# sync active Home Assistant server
	if [[ ! $hostArg ]]; then
		if [[ $currentHost ]]; then
			header "Sync Active Home Assistant ($(RemoveDnsSuffix "$currentHost"))"
			hilight "The active Home Assistant server '$currentHost' will be syncronize first"
			syncHomeAssistant "$currentHost" || return
		else
			ScriptErr "the is current Home Assistant server is not known"	
		fi
	fi

	# sync other Home Assistant servers
	GetHostsService "home-assistant" || return
	[[ $currentHost ]] && ArrayRemove hosts "$currentHost"
	ForAllHosts syncHomeAssistant --header "Sync Home Assistant"
}

syncHomeAssistant()
{
	local host="$1"
	unisonArgs=(-ignore "Name {*.log*,*.db-shm,*.db-wal}"); syncDir "$host" "/home/homeassistant/.homeassistant" || return
	updateOwner "$host" "homeassistant" "/home/homeassistant/.homeassistant"
}

#
# update commands
#

updateUsage() { ScriptUsageEcho "Usage: $(ScriptName) update CloudFlare|JumpCloud|WireGuard\nUpdate Wiggin network configuration."; }
updateCommand() { usage; }

updateJumpcloudUsage() { ScriptUsageEcho "Usage: $(ScriptName) update JumpCloud\nUpdate JumpCloud RADIUS IP Address with the the current WAN IP addresses."; }

updateJumpcloudCommand()
{
	local ip; ip="$(network internet address 1)" || return
	hilight "Updating JumpCloud wiggin-cable RADIUS Server to $ip..."
	JumpCloud radius update wiggin-cable "$ip" > /dev/null || return; echo

	ip="$(network internet address 2)" || return
	hilight "Updating JumpCloud wiggin-dsl RADIUS Server to $ip..."
	JumpCloud radius update wiggin-dsl "$ip" > /dev/null || return; echo
}

updateWireguardUsage() { ScriptUsageEcho "Usage: $(ScriptName) update WireGuard\nUpdate the router port forward rule for the current WireGuard server."; }

updateWireguardCommand()
{
	# get current WireGuard server
	log1 "getting the current WireGuard server..."
	local currentHost; currentHost="$(UniFiController port ls | jq ".data | .[] | select(.name == \"WireGuard\").fwd" | RemoveQuotes)" || return
	[[ $currentHost ]] && { currentHost="$(DnsResolve "$currentHost")" || return; }
	log1 "currentHost=$currentHost"

	# get active WireGuard server
	log1 "getting active WireGuard server..."
	local activeHost; activeHost="$(GetServer "wire-guard")" || return
	log1 "activeHost=$activeHost"

	# return if the WireGuard server has not changed	
	[[ "$currentHost" == "$activeHost" ]] && { echo "The WireGuard server ($currentHost) has not changed."; [[ ! $force ]] && return; }

	# update the port forwarding rule
	local ip; ip="$(GetIpAddress "$activeHost")" || return
	echo "Updating the WireGuard port forwarding to $ip ($activeHost)..."
	RunLog UniFiController port host "WireGuard" "$ip"
}

updateCloudflareUsage() { ScriptUsageEcho "Usage: $(ScriptName) update CloudFlare\nUpdate CloudFlare DNS with the current WAN IP addresses."; }

updateCloudflareCommand()
{
	local domain="$(ConfigGet "baseDomain")"
	updateCloudFlareDns "vpn" && updateCloudFlareDns "wan1" "1" && updateCloudFlareDns "wan2" "2"
}

updateCloudFlareDns()
{
	local name="$1" port="$2"
	local desc="${name^^}"

	hilight "Updating $name..."

	# get the internet address
	local ip; ip="$(network internet address $port "${globalArgs[@]}")" || return

	# validate internet address
	[[ ! $ip || "$ip" == null ]] && { EchoErr "$desc internet address not found, internet may be failed over"; echo; return 0; }
	! IsIpAddress "$ip" && { EchoErr "$desc  internet address '$ip' is not valid"; return 1; }

	# update CloudFlare with the internet address
	echo "$desc address is $ip"
	CloudFlare update "$domain" "$name" "$ip" "${globalArgs[@]}" || return; echo
}

#
# helper
#

mountVol() { VeraCrypt mount "$@" p "${globalArgs[@]}"; }
unmountVol() { VeraCrypt unmount p "${globalArgs[@]}"; }

# backupBackup ARCHIVE SERVER [DIRS]
borgBackup()
{
	local archive="$1" server="$2"; shift 2
	RunLog BorgHelper remote "$server" "${globalArgs[@]}" -- backup "$@" --archive=$archive --host=all --prune=5
}

# borgBackupConfig ARCHIVE CONFIG [DIR]... - backup first availble host for the specified network configuration
borgBackupConfig()
{
	local archive="$1" config="$2"; shift 2
	local hosts; GetHostsConfigNetwork "$config" || return
	borgBackup "$archive" "${hosts[0]}" "$@"
}

# borgBackupService ARCHIVE SERVICE [DIR]... - backup first availble host directories for service
borgBackupService()
{
	local archive="$1" service="$2"; shift 2
	local host; host="$(GetServer "$service")" || return
	borgBackup "$archive" "$host" "$@"
}

getHost()
{
	! IsAvailable "$host" && { ScriptErr "host '$host' is not available"; return 1; }
	ScriptEval HostGetInfo "$host" || return
	IsPlatform pi --host && dhcpDir="$dhcpDirBuild" || dhcpDir="$dhcpDirPackageDir"
	hostShort="$(RemoveDnsSuffix "$host")"
	hostIp="$(GetIpAddress "$host")" || return	
}

setOtherHosts() 
{
	local d="$(ConfigGet "hagermanDomain")"
	getHostsOther=(ender.$d nas1.$d)
}

scriptOptDetail()
{
	case "$1" in
		-d|--detail) detail="--detail";;
		*) return 1;;
	esac
}

serviceReload()
{
	[[ $noServiceRestart ]] && return

	local service; StringToArray "$services" "," "services"
	for service in "${services[@]}"; do 

		hilight "Reloading service '$service'..."
		local error result; result="$(service reload "$service" --host="$host")"; error=$?;
		(( error == 0 )) && continue
		[[ ! "$result" =~ .*" is not active, cannot reload" ]] && { ScriptErr "$result"; return $error; } 
		
		hilight "Starting service '$service'..."
		service start "$service" --host="$host" && continue

		# can't start service, show service log
		service log "$service" --host="$host" --no-pager | tail; return 1
	done	
}

# syncDir HOST DIRS [SERVICES] - syncronize DIRS with HOST and reload SERVICES
syncDir()
{
	local host="$1" dirs="$2" services="$3"

	# validate host
	os IsServer && IsLocalHost "$host" && return # on servers do not sync to ourself
	HostAvailable "$host" || return

	# sync dirs
	local dir; StringToArray "$dirs" "," "dirs"
	for dir in "${dirs[@]}"; do 

		# create the local directory if needed
		local localDir="$dir"; ! os IsServer && localDir="$UDATA/sync$dir"
		[[ ! -d "$localDir" ]] && { RunLog sudoc ${G}mkdir --parents "$localDir" || return; }

		# sync
		hilight "Syncing '$dir' to '$host'..."
		RunLog sudor -- UnisonHelper sync "$localDir" "$host" "$dir" "${globalArgs[@]}" -- "${unisonArgs[@]}" || return		
		echo

	done	

	serviceReload "$services"
}

# updateOwner HOST OWNER DIRS
updateOwner()
{
	local host="$1" owner="$2" dirs="${@:3}" options=(--recursive --changes)

	hilight "Updating user and group ownership on '$host'..."
	RunLog SshSudoc "$host" "chown ${options[@]} $owner $dirs && sudoc chgrp ${options[@]} $owner $dirs" || return
}

ScriptRun "$@"

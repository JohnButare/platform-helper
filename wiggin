#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" app script color || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) backup|cert|config|host|maintenance|network|setup|sync|update [OPTION]...
Manage the Wiggin network."
}

init()
{
	backupDir="$DATA/.bak"
	confDir="$HOME/$(ConfigGet "confDir")"
	hashiConfig="$confDir/hashi"

	# network devices
	aps=(living-room-ap back-yard-ap front-yard-ap garage-ap study-ap) # reboot Living Room AP first
	switches=(back-shed-switch bens-room-switch den-switch garage-iot-switch garage-switch halll-switch living-room-switch study-close-switch1 study-close-switch2 study-close-switch3 StudyDeskSwitch)
	routers=(router)
	networkAll=("${aps[@]}" "${switches[@]}" "${routers[@]}")
}

#
# backup commands
#

backupCommands=( consul ContainerStation cups domains HomeAssistant LastPass nginx pool ProxyManager qnap ApacheWeb )

backupUsage() 
{
	ScriptUsageEcho "Usage: $(ScriptName) backup job|$(ArrayDelimit backupCommands "|")
Backup data for the Wiggin network.

	job			run the backup job which backs up all relevant data for the Wiggin network

	-H, --host [HOSTS](all)		$(ScriptOptHostUsage)"
}

backupCommand() { usage; }
backupArgStart() { unset -v hostArg hostOpt; borgArgs=(); }
backupOpt() {	ScriptOptHost "$@"; }
backupCupsCommand() { borgBackupService "cups" "cups" "/etc/cups"; }
backupDomainsCommand() { backupDomain "butare.net" && backupDomain "juntosholdings.com"; }
backupNginxCommand() { borgBackupService "Nginx" "lb" "/etc/nginx"; }
backupProxymanagerCommand() { borgBackupService "ProxyManager" "nginx-proxy-manager" "/srv/nginx-proxy-manager"; }
backupHomeassistantCommand() { borgBackupService "HomeAssistant" "home-assistant" "/home/homeassistant/.homeassistant"; }
backupPoolCommand() { borgBackupService "PoolController" "pool-controller" "/opt/pool-controller" && borgBackupService "PoolDashPanel" "pool-dash-panel" "/opt/pool-dash-panel"; }
backupApachewebCommand() { local borgArgs=(--exclude "/srv/apache-web/logs/"); borgBackupService "apache-web" "apache-web" "/srv/apache-web"; }
backupWireguardCommand() { borgBackupService "WireGuard" "wire-guard" "/etc/wireguard" "/etc/pivpn"; }

backupConsulCommand()
{
	local dest="$(AppGetBackupDir)/consul" || return
	[[ ! -d "$dest" ]] && { ${G}mkdir --parents "$dest" || return; }
	pushd "$dest" && hashi consul backup "${globalArgs[@]}" && popd
}

backupContainerstationCommand()
{ 
	local server="nas3"
	! unc IsAvailable "$server" && { ScriptErr "'$server' is not available"; return 1; }
	AppBackup "$(RemoveDnsSuffix "$server").ContainerStation" "//$server/root/share/data/Container/container-station-data/application"
}

backupDomain()
{
	local domain="$1"

	hilight "Backup up domain $domain..."
	local dest; dest="$(AppBackupFile "$domain.zip")" || return
	CloudFlare dns list "$domain" | ZipStdin "$dest" || return

  echo "Domain backup completed to '$dest'"
}

backupHomebridgeCommand()
{
	GetHostsApp "homebridge" available && ForAllHosts HomebridgeHelper backup --header "Homebridge Backup"
}

backupLastpassCommand()
{
	header "LastPass Backup"

	local dir; dir="$(mountVol "$CDATA/VeraCrypt/personal.hc")/backup/LastPass" || return

	echo "Logging in to LastPass..."
	LastPass login || return

	echo "Exporting LastPass..."
	lpass export > "$(GetDateStampNext "$dir/" "csv")" || return
		
	unmountVol || return
}

backupQnapCommand()
{
	! IsPlatform QNAP && { ScriptErr "can only backup QNAP operating system"; return 1; }

	# initialize
	local dest="$(AppGetBackupDir)/${HOSTNAME}.qnap.settings" || return
	[[ -f "$dest" ]] && { bak --move "$dest" || return; }

	# maybe intended to be a backup number, but it is filled with a constant (127) when
	# using the backup function from the webpage, file is not removed after backup, but
	# missing after next reboot...
	echo "127" | sudo tee "/etc/save_no.conf" || return

	sudoc tar cvf - "/etc/config/"* "/etc/save_no.conf" | gzip > "$dest.tgz" || return

	PC1 e ICPIPNASWAREV301 "$dest.tgz" "$dest.bin" || return
	PC2 "$dest.bin" "" "" || return

	rm "$dest.tgz" || return
}

#
# backup job command
#

backupJobCommand()
{
	header "Wiggin Backup Job"

	hilight "Configuration..."
	echo "HOSTNAME=$HOSTNAME"
	echo "USER=$USER"
	echo "PATH=$PATH"
	echo "globalArgs=${globalArgs[@]}"	
	echo

	# network current update || return
	echo

	# hilight "Testing credentials..."
	credential manager status "${globalArgs[@]}" || return
	echo "test/check=$(credential get test check "${globalArgs[@]}")"
	echo

	# hilight "SSH Agent status..."
	SshAgent status "${globalArgsLessForce[@]}" || exit

	# backup 
	local fail=0 success=0
	echo
	runAll "update" CloudFlare JumpCloud WireGuard || return
	runAll "backup" consul cups domains homebridge nginx UniFi ApacheWeb WireGuard || return

	# result
	header "Wiggin Backup Complete"
	(( fail > 0 )) && { HilightRed "$success succeeded, $fail failed"; return 1; }
	hilight "all $success succeeded, 0 failed"
}

HilightRed() { echo "${RED}$1${reset}"; }

runAll()
{
	local type="$1" w; shift
	for w in "$@"; do $type$(UpperCaseFirst "$w") || return; done
}

runApp()
{
	local type="$1" name="$(UpperCaseFirst "$2")"; shift 2
	local desc="$(UpperCaseFirst "$type")"
	local cache="$desc$name"

	header "$desc $name"

	! UpdateNeeded "$cache" && { echo "$name $type already done today."; runAppSuccess; return; }

	if RunLog "$@" "${globalArgs[@]}"; then
		runAppSuccess
		UpdateDone "$cache"
	else
		HilightRed "failed"; echo
		(( fail+=1 ))
	fi
}

runAppSuccess() { hilight "succeeded"; echo; (( success+=1 )); }

backupApacheWeb() { runApp "backup" "ApacheWeb" wiggin backup ApacheWeb; }
backupConsul() { runApp "backup" "consul" wiggin backup consul; }
backupCups() { runApp "backup" "cups" wiggin backup cups; }
backupDomains() { runApp "backup" "domains" wiggin backup domains; }
backupDomotz() { runApp "backup" "domotz" DomotzHelper backup; }
backupHomeAssistant() { runApp "backup" "HomeAssistant" wiggin backup HomeAssistant; }
backupHomebridge() { runApp "backup" "homebridge" wiggin backup Homebridge; }
backupNginx() { runApp "backup" "Nginx" wiggin backup nginx; }
backupProxyManager() { runApp "backup" "ProxyManager" wiggin backup ProxyManager; }
backupUniFi() { runApp "backup" "UniFi" UniFiController backup; }
backupWireGuard() { runApp "backup" "WireGuard" wiggin backup WireGuard; }

updateCloudFlare() { runApp "update" "CloudFlare" wiggin update CloudFlare; }
updateJumpCloud() { runApp "update" "JumpCloud" wiggin update JumpCloud; }
updateWireGuard() { runApp "update" "WireGuard" wiggin update WireGuard; }

#
# certificate commands
#

certUsage() {
	ScriptUsageEcho "\
Usage: $(ScriptName) cert all|info|renew|copy|update|cleanup
Certificate commands.
	-nc, --no-cleanup		do not cleanup temporary certificate files or the mounted certificate directory
	-v,  --validate			validate the encrypted cloud files are downloaded"
}

certArgStart() { unset -v noCleanup validate; }
certCommand() { usage; }
certAllUsage() { ScriptUsageEcho "Usage: $(ScriptName) renew cert all\nRenew and update certificate."; }
certAllCommand() { certRenewCommand && certCopyCommand && certUpdateAllCommand; }
certCleanupCommand() { :; }

certOpt()
{
	case "$1" in
		-nc|--no-cleanup) noCleanup="--no-cleanup";;
		-v|--validate) validate="--validate";;
		*) return 1;;
	esac
}

certArgEnd()
{

	# initialize
	log1 "initialize certificates"	
	domain="butare.net"
	certDirTmp="/tmp/cert-$domain"

	# initialize Let's Encrypt
	letsEncryptDir="/etc/letsencrypt"
	certDir="$letsEncryptDir/live"

	# no further initialization needed if cleanup up
	[[ "${commandNames[1]}" == "cleanup" ]] && return

	# mount existing certificates
	encryptedDir="$(CloudConf && RunLog encrypt mount "$CLOUD/data/app/CryFS/personal" --no-prompt $validate "${globalArgsLessVerbose[@]}")/data/letsencrypt" || return

	# initialize certificate
	cert="$certDir/$domain/cert.pem"
	certEncrypted="$encryptedDir/$domain/cert.pem"
	
	# stage existing certificates
	certStageCleanup && certStage
}

certCleanup() { [[ $noCleanup ]] && return; log1 "cleanup"; certStageCleanup && encrypt unmount "personal"; }

# certStage - copy Let's Encrypt certificates from the encrypted directory to a temp directory
certStage()
{
	local from="$encryptedDir/$domain/." to="$certDirTmp"
	[[ ! -d "$from" ]] && return # certificate does not exist yet
	log1 "copy certificate files from '$from' to '$to'"
	cp -rp "$from" "$to" || return
}

# certStageCleanup - cleanup the certificate temp directory
certStageCleanup()
{
	[[ $noCleanup || ! -d "$certDirTmp" ]] && return
	log1 "cleaning certificate temporary directory '$certDirTmp'"
	sudoc rm -fr "$certDirTmp"
}

certRenewUsage() { ScriptUsageEcho "Usage: $(ScriptName) cert renew\nRenew the certificate."; }

certRenewCommand()
{
	# check
	certInfoCommand || return
	! ask 'Do you want to renew the certificate' && return

	# install certbot
	{ ! InPath certbot || [[ ! -d "$letsEncryptDir" ]]; } && { inst certbot || return; }

	# renew cert
	sudoc certbot certonly -d '*.butare.net' --dns-cloudflare --dns-cloudflare-credentials "$letsEncryptDir/credentials/cloudflare.ini" || return
}

certCopyUsage() { ScriptUsageEcho "Usage: $(ScriptName) cert copy\nCopy the certificate to the encrypted store."; }

certCopyCommand()
{
	# check
	certInfoCommand || return
	[[ -f "$certEncrypted" ]] && ! ask 'Do you want to copy the certificate to the encrypted store' && return

	# backup existing certificate
	( cd "$encryptedDir" && bak "$domain" -d "$domain.bak") || return

	# copy certificates to the temporary certificate directory
	sudoc cp -Lr "$certDir/$domain/." "$certDirTmp" || return
	sudoc chown -R "$USER" "$certDirTmp" || return
	sudoc chgrp -R "$(GroupDefault)" "$certDirTmp" || return

	# create X.509 certificate
	( cd "$certDirTmp" && cat "cert.pem" "privkey.pem" > "certificate.pem"; ) || return

	# create PKCS#12 certificate
	echo "${GREEN}Use an empty password for the PKCS#12 (PFX) certificate...${RESET}"	
	( cd "$certDirTmp" && openssl pkcs12 -keypbe NONE -certpbe NONE -export -out certificate.pfx -inkey privkey.pem -in fullchain.pem; ) || return

	# copy certificates to the encrypted certificate directory
	cp -r "$certDirTmp/." "$encryptedDir/$domain" || return
}

#
# cert info command
#

certInfoCommand() { certInfo "$cert" "sudoc" && certInfo "$certEncrypted"; }

certInfo()
{
	local file="$1" sudo="$2"
	printf "Checking certificate file '$(FileToDesc "$file")'..."
	if $sudo ls "$file" >& /dev/null ; then
		echo "present"
		quiet="--quiet" CertGetDates "$file"
	else
		echo "not present" 
	fi
}

#
# cert update commands
#

certUpdateUsage() { ScriptUsageEcho "Usage: $(ScriptName) cert update all|hubitat|lb|nas|printer\nUpdate certificate on systems."; }
certUpdateCommand() { usage; }
certUpdateAllUsage() { ScriptUsageEcho "Usage: $(ScriptName) renew cert all\nUpdate cerrtificate on systems."; }
certUpdateAllCommand() { certUpdateLbCommand && certUpdatePrinterCommand; }

certUpdateHubitatUsage() { ScriptUsageEcho "Usage: $(ScriptName) cert update hubitat\nUpdate certificate on Hubitat 1 and 2."; }
certUpdateHubitatCommand() { ( cd "$certDirTmp" && certUpdateHubitat 1 && certUpdateHubitat 2; ); }

certUpdateHubitat()
{
	local n="$1"; hilight "Updating the Hubitat $n certificates..."
	open "https://hubitat${n}.butare.net/hub/advanced/certificate" || return

	clipw "$(cat "cert.pem")" || return
	pause "Paste certifcate, then press any key to continue..."

	clipw "$(cat "privkey.pem")"
	pause "Paste private key, then press any key to continue..."	

	echo "Save key pair, Settings, Reboot"; pause
}

certUpdateLbUsage() { ScriptUsageEcho "Usage: $(ScriptName) renew cert lb\nUpdate cerrtificate on all NGINX load balancers."; }

certUpdateLbCommand()
{
	hilight "Updating the certificate on the Load Balancer (NGINX)..."

	# update certificates used by the load balancer
	local lbDir="$UDATA/sync/etc/letsencrypt/live/$domain"
	! sudoc ls "$live" >& /dev/null && { wiggin sync lb-cert || return; }
	sudoc cp -r "$certDirTmp/." "$lbDir" || return
	sudoc chown -R root "$lbDir" || return

	# sync the load balancer certificates and the load balancer configuration
	wiggin sync lb-cert && wiggin sync lb
}

certUpdateNasUsage() { ScriptUsageEcho "Usage: $(ScriptName) renew cert nas\nUpdate cerrtificate on all NAS systems."; }
certUpdateNasCommand() { certUpdateNas 1; }

certUpdateNas()
{	
	local n="$1"; hilight "Updating the NAS $n certificates..."
	local clip; clip="$(utw "${certDirTmp}")"; clipw "$clip"
	open "https://nas${n}.butare.net:5001" || return
	EchoWrap "Control Panel, Security, Certificate, Add, Replace an existing certificate, *.butare.net, check Set as default certificate, Private Key=<paste>/privkey.pem, Certificate=<paste>/cert.pem, Intermediate certificate=<paste>/chain.pem"
	pause
}

certUpdatePrintersUsage() { ScriptUsageEcho "Usage: $(ScriptName) renew cert printer\nUpdate cerrtificate on all printers."; }
certUpdatePrinterCommand() { certStudyColorPrinter; }

# certGaragePrinter - does not work
certGaragePrinter()
{	
	local n="$1"; hilight "Updating the Garage Printer certificate..."
	local clip; clip="$(utw "${certDirTmp}/certificate.pem")"; clipw "$clip"
	open "https://garage-printer.hagerman.butare.net/net/security/certificate/ca.html" || return
	EchoWrap "Import CA Certificate, Browse..., <paste>, Submit, reboot printer from panel"	
	pause
}

certStudyColorPrinter()
{	
	local n="$1"; hilight "Updating the Study Color Printer certificate..."
	local clip; clip="$(utw "${certDirTmp}/certificate.pfx")"; clipw "$clip"
	open "https://study-color-printer.hagerman.butare.net/net/security/certificate/certificate.html" || return
	EchoWrap "Delete, Import Certificate and Private Key, Browse..., <paste>, Submit, Administrator, Reboot Menu, Reboot, Yes"	
	pause
}

#
# config commands
#

configUsage() { ScriptUsageEcho "Usage: $(ScriptName) config change|monitor\nConfigure the system."; }
configCommand() { usage; }

configChangeUsage() { ScriptUsageEcho "Usage: $(ScriptName) config change\nChange the system configuration to match the current network and number of monitors."; }

configChangeCommand()
{
	# update network
	network current update "${globalArgs[@]}" || return

	# update display configuration based on the number of attached monitors
	! IsPlatform mac && return
	local monitorGetCount; monitorGetCount="$(monitorGetCount)" || return
	wiggin config monitor "$(monitorGetCount)" "${globalArgs[@]}"
}

configMonitorUsage() { ScriptUsageEcho "Usage: $(ScriptName) config monitor N\nConfigure the system for N monitors."; }
configMonitorArgs() { ScriptArgGet --integer "monitors" -- "$@" || return; shift; }

configMonitorCommand()
{
	local autoHide; autoHide="$(defaults read com.apple.Dock autohide)" || return
	local orientation; orientation="$(defaults read com.apple.Dock orientation)" || return
	local newAutoHide newOrientation

	if (( monitors == 1 )); then
		newAutoHide="1" newOrientation="bottom"
	elif (( monitors > 1 )); then
		newAutoHide="0" newOrientation="right"
	fi

	if [[ $force || "$newAutoHide" != "$autoHide" || "$newOrientation" != "$orientation" ]]; then
		local autoHideBool="FALSE"; (( newAutoHide == 1 )) && autoHideBool="TRUE"
		defaults write com.apple.Dock orientation -string "$newOrientation" || return
		defaults write com.apple.Dock autohide -bool "$autoHideBool" || return
		killall Dock || return
		EchoQuiet "The monitor configuration was changed to ${monitors} monitor(s)."
	else
		EchoQuiet "The monitor configuration did not change."
	fi

	return 0
}

monitorGetCount() { system_profiler SPDisplaysDataType | ${G}grep -E "^\s{8}\S" | wc -l | RemoveSpaceTrim; }

#
# host commands
#

hostUsage() {	ScriptUsageEcho "Usage: $(ScriptName) host [credential|info|ls|network|power|sync|update](ls)\n$(hostUsageCommon)"; }

hostUsageCommon()
{
	EchoWrap "\

Common options:
	-H, --host [HOSTS](all)		$(ScriptOptHostUsage)
	-e, --errors							keep processing and return the total number of failed hosts
	-w, --wait								wait for the operation to finish"
}

hostArgStart()
{
	unset -v hostArg hostOpt errors wait; hosts=(); ScriptOptTimeoutArgStart
	unset -v totalErrors

	syncUsage="\
	-do, --dest-older		assume destination files are than the local source files
	-so, --src-older		assume local files are older than the destination files
	-u,  --unison				perform synchronization using Unison"
}

hostOpt()
{
	ScriptOptHost "$@" && return

	case "$1" in
		--errors|-e) errors="--errors";;
		--wait|-w) wait="--wait";;
		*) return 1
	esac
}

hostArgEnd()
{
	local resolve="DnsResolveBatch $quiet"
	local resolveMac="DnsResolveMacBatch --full $errors $quiet"
	local sort="sort --ignore-case --version-sort"

	# default host
	[[ ! $hostArg && "${commandNames[2]}" == @(reboot|unlock) ]] && hostArg="${commandNames[2]}"

	# alias
	case "${hostArg,,}" in
		network) IFS=$'\n' ArrayMake hosts "$(ArrayDelimit networkAll $'\n' | $resolve | $sort)" || return; wait="--wait";;
	esac
 
	# initialize Hashi, credentials, network, and SSH agent
	AllConf --quiet "${globalArgsLessForce[@]}" || return

	return 0
}

hostCommand() { hostLsCommand; }
hostInfoUsage() { ScriptUsageEcho "Usage: $(ScriptName) info\nDisplay host information.\n\n	-d, --detail							display detailed information\n$(hostUsageCommon)"; }
hostInfoArgStart() { unset -v detail; }
hostInfoOpt() { scriptOptDetail "$@"; }
hostInfoCommand() { GetHosts && RunLog os info "$(ArrayDelimit hosts ",")" $detail; }
hostLsUsage() { ScriptUsageEcho "Usage: $(ScriptName) info\nList hosts.\n$(hostUsageCommon)"; }
hostLsCommand() { GetHosts && ArrayDelimit hosts $'\n'; }

hostExit() { (( totalErrors+=${1:-0} )); [[ $errors ]] && return; return 1; }

#
# Host Credential Commands
#

hostCredentialUsage() { ScriptUsageEcho "Usage: $(ScriptName) host credential [unlock](unlock)\nUnlock the hosts credential store.\n$(hostUsageCommon)"; }
hostCredentialCommand() { ForAllHosts $errors hostCredentialUnlock --header "Unlock"; }

hostCredentialUnlock()
{
	# unlock
	# --credential supplies password from various sources
	# --interactive ensure credential manager unlock state is persisted after SSH terminates, otherwise the GNOME Keyring will lock after the SSH command exits
	SshHelper connect --credential --interactive "$1" -- 'HashiConfStatus '"${globalArgs[@]}"' && echo && CredentialConfStatus '"${globalArgs[@]}"' && SshAgentConfStatus '"${globalArgs[@]}"
}

#
# Host Network Commands
#

hostNetworkUsage() { ScriptUsageEcho "Usage: $(ScriptName) host network [fix](fix)\nHost network commands.\n$(hostUsageCommon)"; }
hostNetworkCommand() { hostNetworkFixCommand; }
hostNetworkFixUsage() { ScriptUsageEcho "Usage: $(ScriptName) fix\nFix hosts by forcing them to reconnect to the network.\n$(hostUsageCommon)"; }
hostNetworkFixCommand() { ForAllHosts $errors hostNetworkFix --header "Fix"; }

hostNetworkFix()
{
	local host="$1"; host="$(DnsResolve "$host" "${globalArgs[@]}")" || return
	local mac; mac="$(MacLookup --ethers "$host")" || return

	# disconnect	
	log1 "host=$host mac=$mac"
	UniFiController device disconnect "$mac" "${globalArgs[@]}" || return

	# wait
	[[ ! $wait ]] && return
	WaitForAvailable "$host" 20
}

#
# Host Power Commands
#

hostPowerUsage() {	ScriptUsageEcho "Usage: $(ScriptName) host power [on|off|reboot|status](status)\nHost power commands.\n$(hostUsageCommon)"; }
hostPowerCommand() { hostPowerStatusCommand; }
hostPowerOffCommand() { ForAllHosts $errors hostOff --header "Powering Off"; }
hostPowerOnCommand() { ForAllHosts $errors hostOn --header "Powering On"; }
hostPowerRebootCommand() { ForAllHosts $errors hostReboot --header "Reboot"; }
hostPowerStatusCommand() { ForAllHosts $errors hostStatus --header "Status"; }

hostOff() { RunLog power off "$1" $wait "${globalArgs[@]}"; }
hostOn() { RunLog power on "$1" $wait "${globalArgs[@]}"; }

hostReboot()
{
	local host="$1"
	local waitArg="$wait"; isVaultHost "$host" && waitArg="--ssh"
	RunLog power reboot "$1" $waitArg $waitSeconds "${globalArgs[@]}" && hostCredentialUnlock "$host" && vaultUnseal "$host"
}

hostStatus()
{
	if [[ $verbose ]]; then
		power status "$host" --verbose
	else
		local status; status="$(power status "$host")" && echo "$host is $status"
	fi
}

#
# Host Sync Commands
#

hostSyncUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) host sync [files|root](files)
Synchronize host files or root user configuration.

Synchronization options:
$(syncUsageText)
$(syncUsageOtherText)
$(hostUsageCommon)"
}

hostSyncCommand() { hostSyncFilesCommand; }
hostSyncRootCommand() { ForAllHosts $errors hostSyncRoot --brief --show-result; }
hostSyncRoot() { SshHelper connect --x-forwarding --interactive "$1" -- 'SshHelper config sync root'; }

hostSyncFilesUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) host sync files
Synchronize host files.

Synronization options:
$(syncUsageText)
$(syncUsageOtherText)
$(hostUsageCommon)"
}

hostSyncFilesArgStart() { unset -v method noUnison unison; }

hostSyncFilesOpt()
{
	case "$1" in
		--destination-older|--dest-older|-do) method="--dest-older";;
		--source-older|--src-older|-so) method="--src-older";;
		-u|--unison) unison="--unison";;
		-nu|--no-unison) noUnison="--no-unison";;
		*) return 1;;
	esac
}

hostSyncFilesCommand() { setOtherHosts; ForAllHosts --errors hostSyncFiles; }

hostSyncFiles()
{
	local host="$1" args=($method $noUnison "${globalArgs[@]}")
	local cache="host-sync-$host"; ! UpdateNeeded "$cache" && return
	[[ "$(RemoveDnsSuffix "$host")" != @(nas1) ]] && args+=($unison)
	{ IsLocalHost "$host" || ! HostAvailable "$host"; } && return
	SyncLocalFiles "$host" "${args[@]}" "${otherArgs[@]}"
	UpdateDone "$cache" || return
}

#
# Host Update Command
#

hostUpdateUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) host update [all|reboot|restart|update](all)
Update hosts, then reboot hosts if needed.

	all			perform all actions
	reboot	only reboot hosts which require it
	restart	only restart required processes
	update	only update hosts

Synronization options:
$(syncUsageText)
$(syncUsageOtherText)
$(hostUsageCommon)"
}

hostUpdateArgStart() { hostSyncFilesArgStart; }
hostUpdateOpt() { hostSyncFilesOpt "$@"; }
hostUpdateCommand() { hostUpdateAllCommand; }
hostUpdateUpdateCommand() { ForAllHosts $errors hostUpdate; }

hostUpdateAllCommand()
{
	hostUpdateUpdateCommand || hostExit;
	header "reboot"; hostUpdateRebootCommand || hostExit
	header "restart"; hostUpdateRestartCommand || hostExit
	return $totalErrors
}

hostUpdate()
{
	local cache="wiggin-host-update-$host"; ! UpdateNeeded "$cache" && return
	local host="$1" 

	# arguments
	local args=($method)
	[[ "$(RemoveDnsSuffix "$host")" != @(nas1) ]] && args+=($unison)
	
	HostAvailable "$host" && HostUpdate "$host" update "${args[@]}" "${globalArgsLessForce[@]}" "${otherArgs[@]}" && UpdateDone "$cache"
}

#
# Host Update Reboot Command
#

hostUpdateRebootCommand() { hostUpdateRebootFindHost && hostUpdateReboot; }

# hostUpdateRebootFindHost - sets hosts to the hosts which require reboot
hostUpdateRebootFindHost()
{
	printf "hosts..."
	local host rebootHosts=(); GetHosts || return

	for host in "${hosts[@]}"; do
		local cache="wiggin-host-reboot-$host"
		! UpdateNeeded "$cache" && continue
		IsPlatform win --host "$host" && continue # skip Windows reboot, Linux distribution does not start automatically
		local status; status="$(os info -w=reboot $host)" || return
		if echo "$status" | ${G}grep --quiet " yes"; then
			printf "$(RemoveDnsSuffix "$host")..."; rebootHosts+=("$host")
		else
			printf "."; UpdateDone "$cache"
		fi
	done

	echo "done"
	ArrayCopy rebootHosts hosts
}

hostUpdateReboot() { wait="--ssh" ForAllHosts --no-get $errors hostUpdateRebootHost --header "reboot"; }
hostUpdateRebootHost() { wait="--wait" waitSeconds="--wait-seconds 240" hostReboot "$1"; }

#
# Host Update Restart Command
#

hostUpdateRestartCommand()
{
	local hostsOrig; ArrayCopy hosts hostsOrig || return

	# restart processes
	unset hosts; hostUpdateRestartFindHost || hostExit; [[ ! $hosts ]] && return
	ForAllHosts --no-get $errors hostUpdateRestartHost --header "restart" || return

	# reboot hosts where the restart was not enough
	header "checking restart"
	ArrayCopy hostsOrig hosts || return
	unset hosts; hostUpdateRestartFindHost || hostExit; [[ ! $hosts ]] && return
	hostUpdateReboot || hostExit
	return $totalErrors
}

# hostUpdateRestartFindHost - sets hosts to the hosts which require process restarts
hostUpdateRestartFindHost()
{
	printf "hosts..."
	local host restartHosts=(); GetHosts || return
	
	for host in "${hosts[@]}"; do
		local cache="wiggin-host-restart-$host"
		! UpdateNeeded "$cache" && continue
		local status; status="$(os info -w=restart $host)" || return
		if echo "$status" | ${G}grep --quiet " yes"; then
			printf "$(RemoveDnsSuffix "$host")..."; restartHosts+=("$host")
		else
			printf "."; UpdateDone "$cache"
		fi
	done
	
	echo "done"
	ArrayCopy restartHosts hosts
}

hostUpdateRestartHost() { SshHelper connect --x-forwarding --interactive "$1" -- sudoc needrestart -r a; }

#
# Maintenance Commands
#

maintenanceUsage() 
{
	ScriptUsageEcho "Usage: $(ScriptName) maintenance all|ap
Perform network maintenance.

	all			perform all maintenance tasks
	ap			perform a controlled reboot of all access points.  The Living Room access point is rebooted.   When it is back online, all other access points are rebooted."
}

maintenanceCommand() { usage; }
maintenanceAllCommand() { maintenanceApCommand; }

maintenanceApCommand()
{
	header "AP Maintenance"
	local firstAp="living-room-ap.hagerman.butare.net"
	# local firstAp="garage-ap.hagerman.butare.net"

	# reboot first (preferred) AP
	RunLog power reboot --wait --wait-seconds=240 "$firstAp" "${globalArgs[@]}" || return
	SleepStatus 30 || return # --wait-ssh fails running under Nomad

	# reboot other APs
	local ap aps=(); IFS=$'\n' ArrayMakeC aps UniFiController ls --access-point || return
	local skipAps=("$firstAp" "PortableAp*")
	for ap in "${aps[@]}"; do
		IsInArray --case-insensitive --array-wild "$ap" skipAps && continue
		echo "Reboot $ap..."
		RunLog power reboot "$ap" "${globalArgs[@]}" || { ScriptErr "failed to reboot '$ap'"; }		
	done
}

#
# network commands
#

networkUsage() { ScriptUsageEcho "Usage: $(ScriptName) network backup|config|edit|update"; }

networkArgStart()
{
	unset -v hostArg hostOpt hosts

	# DNS domain
	domain="$(GetDnsDomain)" || return
	baseDomain="$(GetDnsBaseDomain)" || return

	# network configuration
	network="$(GetDnsDomain | RemoveDnsSuffix)"
	
	subnetPool4Pi1="10.10.102.1 - 10.10.102.99"	subnetPool4Pi2="10.10.102.100 - 10.10.102.199"
	subnetPool4Pi3="10.10.103.1 - 10.10.103.99" subnetPool4Pi4="10.10.103.100 - 10.10.103.199" subnetPool4Pi4n="10.10.103.200 - 10.10.103.209"

	networkPrefix6="$(network current info prefix)" || return
	networkPrefixLength6="$(network current info prefix length)" || return
	subnetPool6Pi1=":1::/80"
	subnetPool6Pi2=":2::/80"
	subnetPool6Pi3=":3::/80"
	subnetPool6Pi4=":4::/80"

	# server file locations
	dhcpDirPackageDir="/etc/kea" # package location
	dhcpDirBuild="/usr/local/etc/kea" # build location	
	dnsDir="/etc/bind"

	# configuration
	dhcpConfig="$confDir/dhcp"
	dnsConfig="$confDir/dns"
	dhcpReservations4="$dhcpConfig/$network/kea-dhcp4-$network-reservations.jsonc"
	dhcpReservations6="$dhcpConfig/$network/kea-dhcp6-$network-reservations.jsonc"
}

networkCommand() { usage; }

# getDhpDir HOST - get dhcpDir variable for the host
getDhcpDir()
{
	local host="$1"
	ScriptEval HostGetInfoCache "$host" "${globalArgs[@]}" || return
	IsPlatform pi --host && echo "$dhcpDirBuild" || echo "$dhcpDirPackageDir"
}

#
# Network Backup Command
#

networkBackupUsage() { ScriptUsageEcho "Usage: $(ScriptName) network backup [dns|dhcp|all](all)\nBackup the DHCP or DNC configuration of HOST.\n\n$	-H, --host [HOSTS](all)	(ScriptOptHostUsage)"; }
networkBackupCommand() { networkBackupAllCommand; }
networkBackupAllCommand() { networkBackupDhcpCommand && networkBackupDnsCommand; }
networkBackupDhcpCommand() { getDhcpHosts && ForAllHosts networkBackupDhcp; }
networkBackupDnsCommand() { getDnsHosts && ForAllHosts networkBackupDns; }

networkBackupDhcp()
{
	local host="$1" stamp="$(GetDateStamp)"
	local hostShort; hostShort="$(RemoveDnsSuffix "$host")" || return

	HostAvailable "$host" || return
	hilight "Backing up DHCP configuration from $hostShort..."

	# find a unique filename
	local file="$hostShort.dhcpd.zip" i=1
	while [[ -f "$backupDir/$stamp.$i.$file" ]]; do (( ++i )); done

	# create the backup
	local dhcpDir; dhcpDir="$(getDhcpDir "$host")" || return
	ssh "$host" "rm -f ~/tmp/$file; zip -r ~/tmp/$file $dhcpDir" || return

	# copy the backup to the backup directory
	scp "$host:~/tmp/$file" "$backupDir/$stamp.$i.$file" || return
}

networkBackupDns()
{
	local host="$1" stamp="$(GetDateStamp)"
	local hostShort; hostShort="$(RemoveDnsSuffix "$host")" || return

	HostAvailable "$host" || return
	hilight "Backing up DNS configuration from $hostShort..."

	# find a unique filename
	local file="$hostShort.dns.zip" i="1"
	while [[ -f "$backupDir/$stamp.$i.$file" ]]; do (( ++i )); done

	# create the backup
	SshHelper connect "$host" -- "rm -f ~/tmp/$file; zip -r ~/tmp/$file $dnsDir --exclude \*.key \*.zip" || return

	# copy the backup to the backup directory
	scp "$(GetIpAddress "$host"):~/tmp/$file" "$backupDir/$stamp.$i.$file" || return
}

#
# Network Config
#

networkConfigUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) network config active|compare|current|issues|reservations
Display network configuration.

	-i, --ip		display the IP address"; 
}

networkConfigCommand() { usage; }

networkConfigArgStart() { unset -v ip; }

networkConfigOpt()
{
	case "$1" in
		-i|--ip) ip="--ip";;
	esac
}

networkConfigIssueCommand()
{
	local file="/tmp/active.json"
	UniFiController api "/stat/sta" | jq > "$file" || return

	# missign IP
	#local missingIp; missingIp="$(cat "$file" | jq '.data[] | select(has("last_ip") | not) | .name' | RemoveQuotes | toDnsName | sort | uniq)"	
	#echo $missingIp

	# MAC address with no reservation
	
	# DNS name -
	#local active; IFS=$'\n' active=( $(cat "$file" | configActive | toDnsName) )
	#time parallel -i bash -c ". function.sh \"\"; DnsResolve {}" -- "${active[@]}"

	# DNS name - check against name	
	#local active; ip=true IFS=$'\n' active=( $(cat "$file" | configActive | toDnsName) )

	# list inactive

	# IsAvailable
	local active; ip= IFS=$'\n' active=( $(cat "$file" | configActive | toDnsName) )
	time parallel -i bash -c ". function.sh \"\"; IsAvailable {} 5000 || echo {}" -- "${active[@]}"
	
	# time for a in "${active[@]}"; do DnsResolve "$a"; done
}

networkConfigActiveCommand() { UniFiController api "/stat/sta" | configActive; }

# configActive - return active host "name" or "ip,name"
configActive()
{
	if [[ $ip ]]; then
		jq '.data[] | { ip: .last_ip, name: .name } | join(",") ' | RemoveQuotes | grep -v null | ${G}sort -V | uniq
	else
		jq '.data[].name' | RemoveQuotes | sort | uniq
	fi
}

networkConfigReservationsUsage() { ScriptUsageEcho "Usage: $(ScriptName) network config reservations\nGet DHCP reservation DNS names and MAC addresses in CSV format."; }

networkConfigReservationsCommand()
{
	EchoErr "Getting device reservations..."
	local what='print $1 "," $2'; [[ $ip ]] && what+='"," $3'
	configFileToCommaDelimited "$dhcpReservations4" | ${G}sort --field-separator='.' --key=1 | ${G}tr A-Z a-z | ${G}awk -F "," "{ $what }"
}

networkConfigCurrentUsage() { ScriptUsageEcho "Usage: $(ScriptName) network config current\nGet current network device DNS names and MAC addresses in CSV format."; }

networkConfigCurrentCommand()
{
	EchoErr "Getting current devices..."
	{ UniFiController api "/rest/user" | unifiToCsv; UniFiController api "/stat/device" | unifiToCsv; } | sort
}

unifiToCsv()
{
	local what='name: .name, mac: .mac'; [[ $ip ]] && what+=', ip: .last_ip, dip: .ip'
	jq '.data[]
			| select((has("note") and (.note | startswith("ignore") | not)) or (has("note") | not))
			| {'"$what"'}
			| join(",")' \
		| RemoveQuotes | toDnsName | sort | unifiIpFix; 
}

toDnsName() { sed 's/[- ()]//g' | sed 's/'\''//g' | LowerCase; }

# unifiIpFix - consolidate the IP address in columns 3, 4, and 5
unifiIpFix()
{
	[[ ! $ip ]] && { cat; return; }
	awk -F, '{ if ($3 == "") $3=$4; print $1 "," $2 "," $3 }'
}

networkConfigCompareCommand()
{
	local current="/tmp/current.csv" reservations="/tmp/reservations.csv"
	networkConfigCurrentCommand > "$current" || return
	networkConfigReservationsCommand > "$reservations" || return
	merge "$reservations" "$current"
}

#
# Network Edit Command
#

networkEditUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) network edit [ports|domain|forward|reverse|config|reservations](all)
Edit the DHCP and DNC configuration files.

	-4|-6 	edit only IPv4 or IPv6 files"
}

networkEditArgStart() { unset -v ipv ipvArg; n="$(GetDnsDomain | RemoveDnsSuffix)"; }

networkEditOpt() 
{
	case "$1" in
		-4) ipv="4" ipvArg="-4";;
		-6) ipv="6" ipvArg="-6";;
		*) return 1
	esac
}

networkEditCommand() { networkEditAllCommand; }

networkEditAllCommand()
{
	files=(
		"$DATA/setup/ports" \
		"$dnsConfig/$baseDomain" \
		"$dnsConfig/forward.txt" \
		"$dnsConfig/reverse.txt"
	)
	networkEditConfigFiles || return
	networkEditReservationFiles || return
	(( verboseLevel > 1 )) && ArrayShow files

	# edit all files to ensure retrieval from cloud
	TextEdit "${files[@]}"
}

networkEditPortsCommand() { TextEdit "$DATA/setup/ports"; }
networkEditDomainCommand() { TextEdit "$dnsConfig/$baseDomain"; }
networkEditForwardCommand() { TextEdit "$dnsConfig/forward.txt" ; }
networkEditReverseCommand() { TextEdit "$dnsConfig/reverse.txt"; }
networkEditConfigCommand() { local files=(); networkEditConfigFiles && TextEdit "${files[@]}"; }
networkEditReservationsCommand() { local files=(); networkEditReservationFiles && TextEdit "${files[@]}"; }

networkEditConfigFiles()
{
	[[ ! $ipv || "$ipv" == "4" ]] && files+=( "$dhcpConfig/$n/kea-dhcp4-$n.jsonc" )
	[[ ! $ipv || "$ipv" == "6" ]] && files+=( "$dhcpConfig/$n/kea-dhcp6-$n.jsonc" )
	return 0
}

networkEditReservationFiles()
{
	[[ ! $ipv || "$ipv" == "6" ]] && files+=( "$dhcpConfig/$n/kea-dhcp6-$n-reservations.jsonc" )
	[[ ! $ipv || "$ipv" == "4" ]] && files+=( "$dhcpConfig/$n/kea-dhcp4-$n-reservations.jsonc" )
	return 0
}

#
# Network Update Command
#

networkUpdateUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) network update [dns|dhcp|all](all)
Update the DHCP or DNS configuration of HOST.

	-4|-6 										use only IPv4 or IPv6
	-H,  --host [HOSTS](all)	$(ScriptOptHostUsage)
	-nb, --no-backup					do not backup the existing configuration before updating
	-nv, --no-validate				do not validate the service after updating"
}

networkUpdateArgStart() { unset -v ipv noBackup noValidate; }

networkUpdateOpt() 
{
	ScriptOptHost "$@" && return

	case "$1" in
		-4) ipv="4";;
		-6) ipv="6";;
		-nb|--no-backup) noBackup="true";;
		-nv|--no-validate) noValidate="true";;
		*) return 1
	esac
}

networkUpdateCommand() { networkUpdateAllCommand; }
networkUpdateAllCommand() { networkUpdateDhcpCommand && networkUpdateDnsCommand; }

#
# Network Update DHCP Command
#

networkUpdateDhcpCommand() { getDhcpHosts && ForAllHosts networkUpdateDhcp "$ipv" --header "Update DHCP"; }

# networkUpdateDhcp [4|6](both) HOST
networkUpdateDhcp()
{
	local ipv="$1" host="$2"; host="$(DnsResolve "$host")" || return
	local hostShort; hostShort="$(RemoveDnsSuffix "$host")"
	local dhcpDir; dhcpDir="$(getDhcpDir "$host")" || return
	[[ ! $noBackup ]] && { networkBackupDhcp "$host" || return; }
	[[ $ipv ]] && { networkUpdateDhcpDo "$ipv"; return; }
	networkUpdateDhcpDo 4 && networkUpdateDhcpDo 6
}

networkUpdateDhcpDo()
{
	local ipv="$1"

	# find a subnet pool for the host
	local subnetPoolVar="subnetPool${ipv}$(ProperCase "$hostShort")"
	local subnetPool="${!subnetPoolVar}"; [[ "$ipv" == "6" ]] && subnetPool="$networkPrefix6$(QuoteForwardslashes "${!subnetPoolVar}")"
	[[ ! $subnetPool ]] && { ScriptErr "unable to find a DHCPv$ipv pool for host '$hostShort'"; return 1; }

	# common configuration
	networkUpdateCommon "DHCP" "$host" || return
	hilight "Updating DHCPv$ipv on $hostShort..."

	# create DHCP configuration files
	echo "Creating DHCPv$ipv configuration files..."
	local config="$dhcpConfig/$network"; CloudGet "$config"/* || return
	local dir; dir="$(mktemp -d -t 'dhcp.XXXXXXXXXX')" || return
	cp "$config/"*${ipv}* "$dir" || return

	# protocl specific substitutions
	networkUpdateDhcp$ipv || return

	# basic substitutions
	${G}sed -i "s/SUBNET_POOL/$subnetPool/" "$dir/kea-dhcp$ipv-$network.jsonc" || return
	${G}sed -i "s/DHCP_DIR/$(echo "$dhcpDir" | QuotePath)/" "$dir/kea-dhcp$ipv-$network.jsonc" || return
	${G}sed -i "s/DHCP_DIR/$(echo "$dhcpDir" | QuotePath)/" "$dir/kea-dhcp$ipv.conf" || return

	# network interface
	local interface; interface="$(SshHelper connect --function "$host" GetInterface)" || return
	[[ $interface != "eth0" ]] && { ${G}sed -i "s/eth0/$interface/" "$dir/kea-dhcp$ipv-$network.jsonc" || return; }

	# copy configuration files to host
	echo "Copying DHCPv$ipv configuration files to $hostShort..."
	local pw; pw="$(credential get secure default)" || return
	rsync --no-perms --chmod=ugo=rw --info=progress2 "$dir/"* "root@$host:$dhcpDir" || return

	# restart the service
	echo "Restarting the DHCPv$ipv service on $host..."
	service restart kea-dhcp$ipv-server --host="$host" || return

	# validate
	[[ ! $noValidate ]] && { network validate DHCP $ipvArg --wait --host="$host" || return; }

	# cleanup
	rm -fr "$dir" || return
}

networkUpdateDhcp4()
{
	# update ethers files - downcase to make etherwake case agnostic
	configFileToCommaDelimited "$dhcpReservations4" | ${G}tr A-Z a-z | ${G}awk -F "," '{ print $2 " " $1 }' > "$DATA/setup/ethers" || return

	# update the hosts configuration file
	configFileToCommaDelimited "$dhcpReservations4" | ${G}awk -F "," '{ print $1 }' > "$DATA/setup/hosts" || return
}

networkUpdateDhcp6()
{
	${G}sed -i "s/NETWORK_PREFIX/$networkPrefix6/" "$dir/kea-dhcp6-$network.jsonc" || return
	${G}sed -i "s/NETWORK_LEN/$networkPrefixLength6/" "$dir/kea-dhcp6-$network.jsonc" || return
	${G}sed -i "s/NETWORK_PREFIX/$networkPrefix6/g" "$dir/$(GetFileName "$dhcpReservations6")" || return
}

#
# Network Update DNS Command
#

networkUpdateDnsCommand() {	getDnsHosts && ForAllHosts networkUpdateDns --header "Update DNS"; }

# networkUpdateDns HOST
networkUpdateDns()
{
	local host="$1"; host="$(DnsResolve "$host")" || return
	local hostShort; hostShort="$(RemoveDnsSuffix "$host")" || return

	# backup
	[[ ! $noBackup ]] && { networkBackupDns "$host" || return; }

	# common configuration
	networkUpdateCommon "DNS" "$host" || return
	hilight "Updating DNS on $hostShort..."
	
	# create DNS configuration files
	echo "Creating DNS configuration files..."
	local config="$dnsConfig"; CloudGet "$config" "${globalArgs[@]}" || return
	local dir="$(mktemp -d -t 'dns.XXXXXXXXXX')" || return
	cp "$config/named.conf."* "$dir" || return
	cp "$config/$baseDomain" "$dir" || return
	cp "$config/forward.txt" "$dir/$domain" || return
	
	# A records - IPv4
	configFileToCommaDelimited "$dhcpReservations4" | awk -F "," '{ print $1 ".'$domain'.	A	" $3 }' | column -t	>> "$dir/$domain" || return

	# AAAA records - IPv6
	local line lines items
	IFS=$'\n' ArrayMake lines "$(configFileToCommaDelimited "$dhcpReservations4" | awk -F "," '{ print $1 " " $3 }' | column -t | awk -F "," '{ print $1 " " $3 }' | column -t)"
	{ 
		for line in "${lines[@]}"; do
			StringToArray "$line" " " items
			echo "${items[0]}    AAAA       NETWORK_PREFIX$(Ipv6Token "${items[1]}")"
		done
	} | column -t >> "$dir/$domain" || return

	# names
	${G}sed -i "s/NETWORK_PREFIX/$networkPrefix6/g" "$dir/$domain" || return

	# create IPv4 reverse lookup zone files
	for zone in 100 101 102; do
		local z="$dir/$zone.10.10.in-addr.arpa"

		cat "$config/$zone.txt" > "$z" || return

		{ printf "\n; static\n"; cat "$config/reverse.txt" | ${G}grep "^[0-9]*.$zone.10.10"; } >> "$z"

		{ printf "\n; dynamic\n"
			configFileToCommaDelimited "$dhcpReservations4" |
				grep ",10.10.$zone." |
				sed "s/10.10.$zone.//" |
				awk -F "," '{ print $3 ".'$zone'.10.10.in-addr.arpa. PTR " $1 ".'$domain'." }' |
				column -t; } >> "$z"
	done

	# create IPv6 reverse lookup zone file
	local nibble; nibble="$(Ipv6Nibble "$networkPrefix6::" $networkPrefixLength6)" || return
	${G}sed -i "s/NETWORK_PREFIX_NIBBLE/$nibble/g" "$dir/named.conf.local" || return
	${G}sed -i "s/NETWORK_PREFIX/$networkPrefix6/g" "$dir/named.conf.local" || return

	local file="$dir/db.$networkPrefix6"
	cat <<-EOF > "$file" || return
		\$TTL 86400
		@ IN SOA ns.$domain. admin.$domain. (
		  2020080901  ; serial
		  12H         ; refresh 
		  3H          ; retry
		  2W          ; expire
		  3H          ; ttl for nxdomain
		)

		; Name servers
		@   IN  NS  ns.$domain.

		; PTR records for hosts
	EOF

	{ 
		for line in "${lines[@]}"; do
			StringToArray "$line" " " items
			echo "$(Ipv6Nibble "$(Ipv6Token "${items[1]}")" -64) IN PTR ${items[0]}."
		done
	} | column -t >> "$file" || return

	# copy configuration files to host
	echo "Copying DNS configuration files to $hostShort..."
	RunLog rsync --no-perms --chmod=ugo=rw "$dir/"* "root@$host:$dnsDir" --info=progress2 || return

	# restart the service - use X Forwarding to enable local credential manager
	echo "Restarting the DNS service on $hostShort..."
	service restart named --host="$host" || return

	# validate
	if [[ ! $noValidate ]]; then
		{ network dns flush && sleep 1 && network validate DNS $ipvArg --wait --host="$host"; } || return
	fi

	# cleanup
	rm -fr "$dir" || return
}

#
# Network Update Helper
#

# networkUpdateCommon dhcp|dns HOST - common code for DHCP and DNS update
networkUpdateCommon()
{
	local what="$1" host="$2"
	HostAvailable "$host" && networkConfigFileValidate "$dhcpReservations4"
}

# configFileToCommaDelimited FILE - convert a Kea configuration file to comma delimited
configFileToCommaDelimited()
{
	configFileToJson "$1" |
		jq '.[]|{a: .hostname, b: ."hw-address", c: ."ip-address"}|join(",")' | # convert to comma delimited
		${G}sed 's/\"//g'	|	# remove quotes
		${G}sort
}

# configFileToJson FILE - convert a Kea configuration file to valid JSON
configFileToJson()
{
	${G}cat "$1" |
		${G}sed '/^[	 ]*\/\//d' |  # remove comments - lines that begin with //
		${G}sed '/<\?include/d'  	# remove <?include ?> directives
}

networkConfigFileValidate()
{
	configFileToJson "$1" | jq > /dev/null && return

	# view the file issues in a text editor
	local file="$(mktemp)" || return
	configFileToJson "$1" > "$file" 2> /dev/null
	TextEdit "$1" "$file" || return
	return 1
}

#
# setup command
#

setupUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup hashi|printers|software"; }
setupCommand() { usage; }
setupSoftwareUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup software\nSetup software."; }
setupSoftwareCommand() { echot "- configure software using 'Software Configuration.docx'"; pause; }

setupPrinterUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup printers\nSetup printer [dymo|HpScan|other](all)."; }
setupPrinterArgEnd() { export PRINTER_NAME_CACHE="$(os printer ls)"; }
setupPrinterCommand() { setupPrinterAllCommand; }
setupPrinterAllCommand() { setupPrinterOtherCommand && setupPrinterDymoCommand && setupPrinterHpScanCommand; }

# Dymo Label Maker Printers
setupPrinterDymoCommand()
{
	# install Dymo
	inst install dymo "${globalArgs[@]}" "${otherArgs[@]}" || return

	# return if printers exist
	local printer printers=("Study Label Printer 1" "Study Label Printer 2")
	[[ ! $force ]] && os printer exist "$(ArrayDelimit printers)"  "${globalArgs[@]}" && return

	# configure labels
	if CloudConf --quiet; then
		local dir="$CLOUD/data/app/DYMO/2 up.dymo"; [[ ! -f "$dir" ]] && return
		dir="$(utw "$dir")"; clipw "$dir"
		echo -E "- File, Open, Browse..., File name=<paste> ($dir)"
	fi

	# add printers
	echot "\
- File, Add network printer
	- DYMO LabelWriter 550 Turbo on DYMOLW550T22477aE, name=${printers[0]}
	- DYMO LabelWriter 550 Turbo on DYMOLW550T2479b3E, name=${printers[1]}"
	dymo start "${globalArgs[@]}" && pause
}

setupPrinterHpScanCommand()
{
	# mac - use VueScan (HP Easy Start is depracated no longer recognizes the HP ScanJet Pro N4600 fnw1)
	if IsPlatform mac; then inst install VueScan "${globalArgs[@]}"  "${otherArgs[@]}"
	else inst install HpScanner "${globalArgs[@]}" "${otherArgs[@]}"
	fi
}

setupPrinterOtherCommand()
{
	HeaderBig "Add Printers"

	# return if printers exist
	local printer printers=("Garage Printer" "Study Color Printer")
	[[ ! $force ]] && os printer exist "$(ArrayDelimit printers)"  "${globalArgs[@]}" && return

	# add printers
	os printers && echot "- Add device, $(ArrayDelimit printers "|")" && pause
}

#
# setup hashi command
#

setupHashiUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup hashi\nSetup HashiCorp programs."; }

setupHashiCommand()
{
	HeaderBig "Setup Hashi Jobs"
	local job jobs=(backup chrony file git home-assistant lb node-red pool-controller pool-dash-panel pool-temperature squid wire-guard)
	for job in "${jobs[@]}"; do hashiJob "backup" || return; done

	HeaderBig "Setup Hashi Consul Services"
	hashiService "cups" 3 || return
	hashiService "hubitat" 3 || return
	hashiService "nomad-web" 1,2,3,4 || return
}

hashiRun() { hashi "$@" $force $test "${globalArgs[@]}" "${otherArgs[@]}"; }
hashiJob() { local job="$1"; shift; hashiRun nomad job run "$job" "$@"; }

hashiService()
{
	local service="$1" hostNum hostNums; StringToArray "$2" "," hostNums; shift 2

	# hcl is the default extension
	[[ "$(GetFileExtension "$service")" == "" ]] && service=+".hcl"

	# add the service
	for hostNum in "${hostNums[@]}"; do
 		hashiRun consul service add "$hashiConfig/service/$service.hcl" --api="pi$hostNum" "$@"
	done
}

#
# synchronize commands
#

syncUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) sync WHAT
Synchronize Wiggin application data with '$(FileToDesc "$UDATA/sync")'.

what: apache-web broadlink-manager credential home-assistant lb lb-cert netbootxyz pool-controller pool-dash-panel public wire-guard

options:
$(syncUsageText)"
}

syncUsageText()
{
	ScriptUsageEcho "\
	-do, --dest-older						assume destination files are than the local source files
	-so, --src-older						assume local files are older than the destination files
	-H,   --host [HOSTS](all) 	$(ScriptOptHostUsage)
	-nsr, --no-service-restart	do not restart services
	-t,   --timeout							$(ScriptOptTimeoutUsage)"
}

syncUsageOtherText() { ScriptUsageEcho "	-- [OPTION]...							other synchronization options"; }

syncCommand() { usage; }

syncArgStart()
{
	unset -v hostArg hostOpt hosts method noServiceRestart; ScriptOptTimeoutArgStart
	unset -v unisonArgs
}

syncOpt()
{
	ScriptOptHost "$@" && return
	case "$1" in
		--destination-older|--dest-older|-do) method="--dest-older";;
		--source-older|--src-older|-so) method="--src-older";;
		--no-service-restart|-nsr) noServiceRestart="--no-service-restart";;
		--timeout|--timeout=*|-t|-t=*) ScriptOptTimeout "$@";;
		*) return 1;;
	esac
}

syncCredentialUsage()
{
		echot "Usage: $(ScriptName) sync credential
Synchronize frequently used credentials from one credential manager to another.

	-fm,	--from		from credential manager, defaults to remote
	-tm,	--to			to credential manager, defaults to local"
}

syncCredentialArgStart() { from="remote" to="local"; }

syncCredentialOpt() 
{
	case "$1" in
		--from|--from=*|-fm|-fm=*) ScriptOptGet from "$@";;
		--to|--to=*|-tm|-tm=*) ScriptOptGet to "$@";;
		*) return 1
	esac
}

syncCredentialCommand()
{
	local cred creds=(1Password BeyondCompare certbot CloudFlare dropbox firefox GitKraken hashi HomeAssistant homebridge hubitat Microsoft namecheap obsidian PostgreSQL secure ssh sublime system unifi)

	# keep GnomeKeyring in sync with the Windows credential store
	local gk gkDesc; IsPlatform wsl2 && [[ "$from" == @(r|remote) ]] && [[ "$to" == @(l|local) ]] && credential manager IsAvailable --manager=GnomeKeyring && gk="true" gkDesc=" gk"

	HeaderBig "Sync Credential ($from -> $to$gkDesc)"
	log1 "sync credential: from=$from to=$to gk=$gk"

	# sync credentials
	for cred in "${creds[@]}"; do
		header "$cred"

		if [[ $force ]] || ! credential ls --manager="$to" $timeoutArg | grep --quiet "^$cred/$"; then
			RunLog credential sync "$cred" -m1="$from" -m2="$to" --recursive $timeoutArg "${globalArgs[@]}" || return
		fi

		if [[ $gk ]] && { [[ $force ]] || ! credential ls --manager="gk" $timeoutArg | grep --quiet "^$cred/$"; }; then
			RunLog credential sync "$cred" --exclude="cache" -m1="local" -m2="GnomeKeyring" --recursive $timeoutArg "${globalArgs[@]}" || return
		fi

	done

	return 0
}

# local sync

syncApache-webUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync apache-web\nSyncronize Apache web site data.\n\n$(syncUsageText)"; }
syncApache-webCommand() { apache sync "${hostOpt[@]}" "${globalArgs[@]}"; }

syncBroadlink-managerUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync broadlink-manager\nSyncronize Broadlink Manager configuration.\n\n$(syncUsageText)"; }
syncBroadlink-managerCommand() { GetHostsApp "broadlink-manager" available && ForAllHosts syncBroadlinkManager --header "Sync Broadlink Manager"; }
syncBroadlinkManager() { syncDir "$1" "/srv/broadlinkmanager"; }

syncLbUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb\nSyncronize load balancer configuration (NGINX rever proxy servers).\n\n$(syncUsageText)"; }
syncLbCommand() { GetHostsApp "lb" available && ForAllHosts syncLb --header "Sync Load Balancer"; }
syncLb() { unisonArgs=(-ignore "Name {sites-available/*.conf}" -ignorenot "Name {default.conf,outage.conf}"); syncDir "$1" "/etc/nginx,/etc/consul-template.d" "consul-template,nginx"; }

syncLb-certUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync lb-cert\nSyncronize load balancer SSL certificates.\n\n$(syncUsageText)"; }
syncLb-certCommand() { GetHostsApp "lb" available && ForAllHosts syncLbCert --header "Sync Certificates"; }
syncLbCert() { syncDir "$1" "/etc/letsencrypt"; }

syncPool-controllerUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync pool-controller\nSyncronize Pool Dash Panel configuration.\n\n$(syncUsageText)"; }
syncPool-controllerCommand() { GetHostsApp "pool-controller" available && ForAllHosts syncPoolController --header "Sync Pool Controller Files"; }
syncPoolController() { unisonArgs=(); syncDir "$1" "/opt/pool-controller/data"; }

syncPool-dash-panelUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync poo-dash-panel\nSyncronize Pool Dash Panel configuration.\n\n$(syncUsageText)"; }
syncPool-dash-panelCommand() { GetHostsApp "pool-dash-panel" available && ForAllHosts syncPoolDashPanel --header "Sync Pool Dash Panel Files"; }
syncPoolDashPanel() { unisonArgs=(-ignorenot "Name {config.json}" -ignore "Regex .*[^.]" ); syncDir "$1" "/opt/pool-dash-panel"; }

syncWire-guardUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync wire-guard\nSyncronize WireGuard configuration.\n\n$(syncUsageText)"; }
syncWire-guardCommand() { GetHostsApp "wire-guard" available && ForAllHosts syncWireGuard --header "Sync WireGuard Files"; }
syncWireGuard() { unisonArgs=(-ignore "Name {setupVars.conf}"); syncDir "$1" "/etc/wireguard,/etc/pivpn" "wg-quick@wg0"; }

# remote sync

syncNetbootxyzUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) sync netbootxyz
Syncronize netboot.xyz data (assets, assets-custom, config, and installers).

$(syncUsageText)" 
}

syncNetbootxyzCommand() { syncFiles "netboot.xyz" "netbootxyz" "syncNetbootxyz"; }

syncNetbootxyz()
{
	[[ "$syncHost" == "$host" ]] && return
	log1 "syncNetbootxyz: synchronizing $syncHost to $host"
	UnisonHelper sync --host="$syncHost" "$ADATA/netbootxyz" "$host" --no-props --root $method "${globalArgs[@]}" -- -ignore "'Name {*.log}'"
}

syncPublicUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) sync public [local]
Syncronize public files.\n\n$(syncUsageText)"
}

# syncPublicCommand - two sync passes to get changes on alls servers
syncPublicCommand() { syncFiles "Public Files" "file" "syncPublic" "ender,shrike"; }

syncPublic()
{
	local dir="/mnt/data/public"; ! SshHelper connect "$host" ls "$dir" >& /dev/null && dir="$ADATA/public"
	UnisonHelper sync --host=ender "/Volumes/data/public" "$host" "$dir" "${globalArgs[@]}"
}

syncPublicLocalUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync public local\nSyncronize local public files if present.\n\n$(syncUsageText)"; }
syncPublicLocalCommand()
{
	local dir; dir="$(FindInstallFile --all | grep -v "^//" | grep "public" | head -1)" || return 0
	hilight 'Synchronizing ender <-> local...'
	UnisonHelper sync --no-props $method "$(GetFilePath "$dir")" "ender" "/Volumes/data/public" "${globalArgs[@]}" || return
}

#
# sync home-assistant command
#

syncHome-assistantUsage() { ScriptUsageEcho "Usage: $(ScriptName) sync hass [cert]\nSyncronize Home Assistant configuration.\n\n$(syncUsageText)"; }

syncHome-assistantCommand()
{
	local currentHost="$(GetServer home-assistant --quiet "${globalArgs[@]}")"

	# sync active Home Assistant server
	if [[ ! $hostArg ]]; then
		if [[ $currentHost ]]; then
			header "Sync Active Home Assistant ($(RemoveDnsSuffix "$currentHost"))"
			hilight "The active Home Assistant server '$currentHost' will be syncronize first"
			syncHomeAssistant "$currentHost" || return
		else
			ScriptErr "the is current Home Assistant server is not known"	
		fi
	fi

	# sync other Home Assistant servers
	GetHostsApp "home-assistant" available || return
	[[ $currentHost ]] && ArrayRemove hosts "$currentHost"
	ForAllHosts syncHomeAssistant --header "Sync Home Assistant"
}

syncHomeAssistant()
{
	local host="$1"
	unisonArgs=(-ignore "Name {*.log*,*.db-shm,*.db-wal}"); syncDir "$host" "/home/homeassistant/.homeassistant" || return
	updateOwner "$host" "homeassistant" "/home/homeassistant/.homeassistant"
}

#
# update commands
#

updateUsage() { ScriptUsageEcho "Usage: $(ScriptName) update CloudFlare|JumpCloud|WireGuard\nUpdate Wiggin network configuration."; }
updateCommand() { usage; }

updateJumpcloudUsage() { ScriptUsageEcho "Usage: $(ScriptName) update JumpCloud\nUpdate JumpCloud RADIUS IP Address with the the current WAN IP addresses."; }

updateJumpcloudCommand()
{
	local ip; ip="$(network internet address 1)" || return
	hilight "Updating JumpCloud wiggin-cable RADIUS Server to $ip..."
	JumpCloud radius update wiggin-cable "$ip" > /dev/null || return; echo

	ip="$(network internet address 2)" || return
	hilight "Updating JumpCloud wiggin-dsl RADIUS Server to $ip..."
	JumpCloud radius update wiggin-dsl "$ip" > /dev/null || return; echo
}

updateWireguardUsage() { ScriptUsageEcho "Usage: $(ScriptName) update WireGuard\nUpdate the router port forward rule for the current WireGuard server."; }

updateWireguardCommand()
{
	# get current WireGuard server
	log1 "getting the current WireGuard server..."
	local currentHost; currentHost="$(UniFiController port ls | jq ".data | .[] | select(.name == \"WireGuard\").fwd" | RemoveQuotes)" || return
	[[ $currentHost ]] && { currentHost="$(DnsResolve "$currentHost" "${globalArgs[@]}")" || return; }
	log1 "currentHost=$currentHost"

	# get active WireGuard server
	log1 "getting active WireGuard server..."
	local activeHost; activeHost="$(GetServer "wire-guard" "${globalArgs[@]}")" || return
	log1 "activeHost=$activeHost"

	# return if the WireGuard server has not changed	
	[[ "$currentHost" == "$activeHost" ]] && { echo "The WireGuard server ($currentHost) has not changed."; [[ ! $force ]] && return; }

	# update the port forwarding rule
	local ip; ip="$(GetIpAddress "$activeHost")" || return
	echo "Updating the WireGuard port forwarding to $ip ($activeHost)..."
	RunLog UniFiController port host "WireGuard" "$ip"
}

updateCloudflareUsage() { ScriptUsageEcho "Usage: $(ScriptName) update CloudFlare\nUpdate CloudFlare DNS with the current WAN IP addresses."; }

updateCloudflareCommand()
{
	local domain="$(GetDnsBaseDomain)"
	updateCloudFlareDns "wan" && updateCloudFlareDns "wan1" "1" && updateCloudFlareDns "wan2" "2"
}

updateCloudFlareDns()
{
	local name="$1" port="$2"
	local desc="${name^^}"

	hilight "Updating $name..."

	# get the internet address
	local ip; ip="$(network internet address $port "${globalArgs[@]}")" || return

	# validate internet address
	[[ ! $ip || "$ip" == null ]] && { EchoErr "$desc internet address not found, internet may be failed over"; echo; return 0; }
	! IsIpAddress "$ip" && { EchoErr "$desc  internet address '$ip' is not valid"; return 1; }

	# update CloudFlare with the internet address
	echo "$desc address is $ip"
	CloudFlare update "$domain" "$name" "$ip" "${globalArgs[@]}" || return; echo
}

#
# helper
#

encm() { encrypt mount "$cdata/app/CryFS/personal" "$@"; }
encum() { cd && encrypt unmount "personal" "$@"; }
getDnsHosts() { GetHostsApp "dns" active ; }
getDhcpHosts() { GetHostsApp "dhcp" active ; }
mountVol() { VeraCrypt mount "$@" p "${globalArgs[@]}"; }
unmountVol() { VeraCrypt unmount p "${globalArgs[@]}"; }

# backupBackupHost HOST - assumes archive, dirs, and borgArgs are set.
borgBackup()
{
	echo "${GREEN}Backing up ${service^} ($host)...${RESET}"
	echo "directories: ${dirs[@]}"
	[[ $borgArgs ]] && echo "borg arguments: ${borgArgs[@]}"

	RunLog BorgHelper remote "$1" "${globalArgs[@]}" -- backup "${dirs[@]}" --archive=$archive --host=all --prune=5 -- "${borgArgs[@]}"; 
}

# borgBackupService ARCHIVE SERVICE [DIR]... - backup service of first available host
borgBackupService()
{
	local archive="$1" service="$2" dirs=("${@:3}")
	[[ ! $hostArg ]] && { hostArg="$(GetServer "$service" "${globalArgs[@]}")" || return; }
	ForAllHosts borgBackup --header "Backup ${service^}"
}

isVaultHost()
{
	local host="$1" servers; StringToArray "$(ConfigGet hashiVaultServers)" "," servers
	IsInArray "$(RemoveDnsSuffix "$host")" servers
}

setOtherHosts() 
{
	local d="$(ConfigGet "butareDnsDomain")"
	getHostsOther=(ender.$d) # nas1.$d
}

scriptOptDetail()
{
	case "$1" in
		-d|--detail) detail="--detail";;
		*) return 1;;
	esac
}

serviceReload()
{
	[[ $noServiceRestart ]] && return

	local service; StringToArray "$services" "," "services"
	for service in "${services[@]}"; do 

		hilight "Reloading service '$service'..."
		local error result; result="$(service reload "$service" --host="$host")"; error=$?;
		(( error == 0 )) && continue
		
		hilight "Starting service '$service'..."
		service start "$service" --host="$host" && continue

		# can't start service, show service log
		service log "$service" --host="$host" --no-pager | tail; return 1
	done	
}

# syncDir HOST DIRS [SERVICES] - syncronize DIRS with HOST and reload SERVICES
syncDir()
{
	local host="$1" dirs="$2" services="$3"

	# validate host
	os IsServer && IsLocalHost "$host" && return # on servers do not sync to ourself
	HostAvailable "$host" || return

	# sync dirs
	local dir; StringToArray "$dirs" "," "dirs"
	for dir in "${dirs[@]}"; do 

		# create the local directory if needed
		local localDir="$dir"; ! os IsServer && localDir="$UDATA/sync$dir"
		[[ ! -d "$localDir" ]] && { RunLog sudoc ${G}mkdir --parents "$localDir" || return; }

		# sync
		hilight "Syncing '$dir' to '$host'..."
		UnisonHelper sync "$localDir" "$host" "$dir" --root $method "${globalArgs[@]}" -- "${unisonArgs[@]}" || return		
		echo

	done	

	serviceReload "$services"
}

# syncFiles DESC SERVICE SYNC_FUNCTION [FAST_HOSTS](shrike,ender) - sync files with two passes to ensure all files are copied
syncFiles()
{
	local desc="$1" service="$2" syncFunction="$3" fastHostsArg="${4:-shrike,ender}"
	header "Sync $desc"
	local syncHost hosts
	
	# get hosts
	if [[ $hostArg ]]; then
		GetHosts || return
	else
		GetHostsApp "$service" available || return
	fi

	# add fast hosts
	local fastHost fastHosts; StringToArray "$fastHostsArg" "," fastHosts
	syncHost="${fastHosts[0]}"; ArrayShift fastHosts # fixed host for a consistent common Unison index
	for fastHost in "${fastHosts[@]}"; do
		IsAvailable "$fastHost" && hosts=("$fastHost" "${hosts[@]}")
	done
	log1 "syncFiles: syncHost=$syncHost hosts=$(ArrayDelimit hosts)"
	(( ${#hosts[@]} < 2 )) && { ScriptErr "there are not enough hosts to synchronize"; return 1; }

	# sync twice
	ForAllHosts $syncFunction --ignore-host "$syncHost" --header "Sync $desc: pass 1" || return
	ForAllHosts $syncFunction --ignore-host "$syncHost" --header "Sync $desc: pass 2" || return
}

# updateOwner HOST OWNER DIRS
updateOwner()
{
	local host="$1" owner="$2" dirs="${@:3}" options=(--recursive --changes)

	hilight "Updating user and group ownership on '$host'..."
	RunLog SshSudoc "$host" "chown ${options[@]} $owner $dirs && sudoc chgrp ${options[@]} $owner $dirs" || return
}

# vaultUnseal HOST - unseal Vault if the host is a vault host, useful if host was rebooted
vaultUnseal()
{
	local host="$1"
	! isVaultHost "$host" && return
	hashi vault unseal
}

ScriptRun "$@"

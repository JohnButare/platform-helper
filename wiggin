#!/usr/bin/env bash
. app.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Manage the Wiggin network.

	backup	backup wiggin data
	device	control devices
	remove	remove applications from the environment
	setup		setup the network
	network	configure network	
	sync		syncronize items"
}

init()
{
	# credentials
	credentialPaths=( CloudFlare domotz JumpCloud LastPass namecheap ssh system unifi )

	# devices
	camDevices=(BackShedCamera BackYardEastCamera ChickenYardNorthCamera ChickenYardSouthCamera FrontPatioCamera FrontYardEastCamera FrontYardWestCamera LivingRoomCamera)

	# file server
	fileServer="$(UpdateGet "FileServer")" || return
	domain="$(ConfigGet "domain")" || return
	baseDomain="$(ConfigGet "baseDomain")" || return

	# configuration
	ncd="$CLOUD/network"
	hashiConfig="$ncd/system/hashi"

	# borgBackup cache variables
	unset backupHosts
}

#
# Backup Commands
#

backupCommands=( consul ContainerStation domains HomeAssistant LastPass ProxyManager qnap web )

backupUsage() 
{
	echot "Usage: $(ScriptName) backup job|$(ArrayDelimit backupCommands "|")
Backup data for the Wiggin network.

	job			run the backup job which backs up all relevant data for the Wiggin network."
}

backupCommand() { usage; }

backupContainerstationCommand()
{ 
	local server="nas3"
	! unc IsAvailable "$server" && { ScriptErr "'$server' is not available"; return 1; }
	AppBackup "$(RemoveDnsSuffix "$server").ContainerStation" "//$server/root/share/data/Container/container-station-data/application"
}

backupConsulCommand()
{
	local dest="$(AppGetBackupDir)/consul" || return
	[[ ! -d "$dest" ]] && { ${G}mkdir --parents "$dest" || return; }
	pushd "$dest" || return
	hashi consul backup || return
}

backupDomainsCommand() { backupDomain "butare.net" && backupDomain "juntosholdings.com"; }

backupDomain()
{
	local domain="$1"

	hilight "Backup up domain $domain..."
	local dest; dest="$(AppBackupFile "$domain.zip")" || return
	CloudFlare dns list "$domain" | ZipStdin "$dest" || return

  echo "Domain backup completed to '$dest'"
}

backupHomeassistantCommand()
{
	local host
	for host in $(GetServers home-assistant); do
		borgBackup "HomeAssistant" "$host" "/home/homeassistant/.homeassistant" || return
	done
}


backupLastpassCommand()
{
	header "LastPass Backup"

	local dir; dir="$(mountVol "$CDATA/VeraCrypt/personal.hc")/backup/LastPass" || return

	echo "Logging in to LastPass..."
	LastPass login || return

	echo "Exporting LastPass..."
	lpass export > "$(GetDateStampNext "$dir/" "csv")" || return
		
	unmountVol || return
}

backupProxymanagerCommand()
{
	local host
	for host in $(GetServers nginx-proxy-manager); do
		borgBackup "ProxyManager" "$host" "/srv/nginx-proxy-manager" || return
	done
}

backupQnapCommand()
{
	! IsPlatform QNAP && { ScriptErr "can only backup QNAP operating system"; return 1; }

	# initialize
	local dest="$(AppGetBackupDir)/${HOSTNAME}.qnap.settings" || return
	[[ -f "$dest" ]] && { bak --move "$dest" || return; }

	# maybe intended to be a backup number, but it is filled with a constant (127) when
	# using the backup function from the webpage, file is not removed after backup, but
	# missing after next reboot...
	echo "127" | sudo tee "/etc/save_no.conf" || return

	sudoc tar cvf - "/etc/config/"* "/etc/save_no.conf" | gzip > "$dest.tgz" || return

	PC1 e ICPIPNASWAREV301 "$dest.tgz" "$dest.bin" || return
	PC2 "$dest.bin" "" "" || return

	rm "$dest.tgz" || return
}

# backupWebCommand - backup the first web server since the files should all be in sync
backupWebCommand()
{
	# pipe error without the uniq call 
	local host; host="$(GetServers web | uniq | head -1)" && borgBackup "web" "$host" "/srv/apache-web"
}

backupWireguardCommand()
{
	local server servers=(); StringToArray "$(network current servers wireguard)" "," servers

	log1 "backup WireGuard: servers="${servers[@]}

	for server in "${servers[@]}"; do
		borgBackup "WireGuard" "$server" "/etc/wireguard" "/etc/pivpn" || return
	done
}

#
# Backup Job Command
#

backupJobCommand()
{
	header "Wiggin Backup Job"

	hilight "Configuration..."
	echo "HOSTNAME=$HOSTNAME"
	echo "USER=$USER"
	echo "PATH=$PATH"
	echo "globalArgs=${globalArgs[@]}"	
	echo

	# network current update || return
	echo

	# hilight "Testing credentials..."
	credential manager status "${globalArgs[@]}" || return
	echo "test/check=$(credential get test check "${globalArgs[@]}")"
	echo

	# hilight "SSH Agent status..."
	SshAgent status "${globalArgs[@]}" || exit

	# backup 
	local fail=0 success=0
	echo
	runAll "sync" internet JumpCloud WireGuard || return
	runAll "backup" consul domains domotz HomeAssistant homebridge ProxyManager UniFi web WireGuard || return

	# result
	header "Wiggin Backup Complete"
	(( fail > 0 )) && { HilightRed "$success succeeded, $fail failed"; return 1; }
	hilight "all $success succeeded, 0 failed"
}

HilightRed() { echo "${RED}$1${reset}"; }

runAll()
{
	local type="$1" w; shift
	for w in "$@"; do $type$(UpperCaseFirst "$w") || return; done
}

runApp()
{
	local type="$1" name="$(UpperCaseFirst "$2")"; shift 2
	local desc="$(UpperCaseFirst "$type")"
	local cache="$desc$name"

	header "$desc $name"

	! UpdateNeeded "$cache" && { echo "$name $type already done today."; runAppSuccess; return; }

	if RunLog "$@" "${globalArgs[@]}"; then
		runAppSuccess
		UpdateDone "$cache"
	else
		HilightRed "failed"; echo
		(( fail+=1 ))
	fi
}

runAppSuccess() { hilight "succeeded"; echo; (( success+=1 )); }

backupConsul() { runApp "backup" "consul" wiggin backup consul; }
backupDomains() { runApp "backup" "domains" wiggin backup domains; }
backupDomotz() { runApp "backup" "domotz" DomotzHelper backup; }
backupHomeAssistant() { runApp "backup" "HomeAssistant" wiggin backup HomeAssistant; }
backupHomebridge() { runApp "backup" "homebridge" HomebridgeHelper backup pi1 pi2; }
backupProxyManager() { runApp "backup" "ProxyManager" wiggin backup ProxyManager; }
backupUniFi() { runApp "backup" "UniFi" UniFiController backup; }
backupWeb() { runApp "backup" "web" wiggin backup web; }
backupWireGuard() { runApp "backup" "WireGuard" wiggin backup WireGuard; }
syncInternet() { runApp "sync" "internet" wiggin sync internet; }
syncJumpCloud() { runApp "sync" "JumpCloud" wiggin sync JumpCloud; }
syncWireGuard() { runApp "sync" "WireGuard" wiggin sync WireGuard; }

#
# Remove Command
#

removeUsage() { echo "Usage: $(ScriptName) remove hashi [test]
Remove applications from the environment."; }

removeCommand() { usage; }

removeHashiArgStart() { unset -v configPrefixArg; }
removeHashiCommand() { hashiRun remove --what=program,service,consul-vault-data,local-certs,local-credentials,private-certs,public-certs; }
removeHashiTestCommand() { configPrefixArg=( --config-prefix=test ); removeHashiCommand; }

#
# Network Commands
#

networkUsage() { echo "Usage: $(ScriptName) network backup|edit|update|validate"; }

networkArgStart()
{
	unset hostsArg

	# network configuration
	network="$(ConfigGet "network")"
	subnetPi1="10.10.102.1 - 10.10.102.99"
	subnetPi2="10.10.102.100 - 10.10.102.199"
	subnetDefault="10.10.102.200 - 10.10.102.254"
	subnetPi3="10.10.103.1 - 10.10.103.99"
	subnetPi4="10.10.103.100 - 10.10.103.199"

	# server file locations
	dhcpDirPackageDir="/etc/kea" # package location
	dhcpDirBuild="/usr/local/etc/kea" # build location
	dnsDir="/etc/bind"

	dhcpConfig="$ncd/system/dhcp"
	dnsConfig="$ncd/system/dns"
}

networkArgs() { hostsArg=( "$@" ); (( shift+=$# )); true; }

networkArgEnd()
{
	[[ "$command" == @(networkEdit) ]] && return
	[[ ! $hostsArg && "$command" != @(networkEdit) ]] && MissingOperand "host"
	return 0
}

networkCommand() { usage; }

#
# Network Backup Command
#

networkBackupUsage() { echo "Usage: $(ScriptName) network backup [dns|dhcp|all](all) [HOST|all]...
Backup the DHCP or DNC configuration of HOST."; }

networkBackupCommand() { networkBackupAllCommand; }
networkBackupAllCommand() { networkBackupDhcpCommand && networkBackupDnsCommand; }

#
# Network Backup DHCP Command
#

networkBackupDhcpCommand()
{	
	local hosts host; getHosts "dhcpServers" || return

	for host in "${hosts[@]}"; do
		networkBackupDhcp "$host" || return
	done
}

networkBackupDhcp()
{
	local host="$1" hostShort hostIp stamp="$(GetDateStamp)"; getHost || return

	hilight "Backing up DHCP configuration from $hostShort..."

	# find a unique filename
	local file="$hostShort.dhcpd.zip" i=1
	local backupDir="$dhcpConfig/backup"
	while [[ -f "$backupDir/$stamp.$i.$file" ]]; do (( ++i )); done

	# create the backup	
	ssh $hostIp "rm -f ~/tmp/$file; zip -r ~/tmp/$file $dhcpDir" || return

	# copy the backup to the backup directory
	scp "$hostIp:~/tmp/$file" "$backupDir/$stamp.$i.$file" || return
}

#
# Network Backup DNS Command
#

networkBackupDnsCommand()
{	
	local hosts host; getHosts "dnsServers" || return

	for host in "${hosts[@]}"; do
		networkBackupDns "$host" || return
	done
}

networkBackupDns()
{
	local host="$1" hostShort hostIp stamp="$(GetDateStamp)"; getHost || return

	hilight "Backing up DNS configuration from $hostShort..."

	# find a unique filename
	local file="$hostShort.dns.zip" i="1"
	local backupDir="$dnsConfig/backup"
	while [[ -f "$backupDir/$stamp.$i.$file" ]]; do (( ++i )); done

	# create the backup
	ssh "$hostIp" "rm -f ~/tmp/$file; zip -r ~/tmp/$file $dnsDir --exclude \*.key \*.zip" || return

	# copy the backup to the backup directory
	scp "$hostIp:~/tmp/$file" "$backupDir/$stamp.$i.$file" || return
}

#
# Network Edit Command
#

networkEditUsage() { echo "Usage: $(ScriptName) network edit
Edit the DHCP and DNC configuration files."; }

networkEditCommand()
{
	local n="$(ConfigGet "network")"

	# edit all files to ensure retrieval from cloud
	TextEdit \
		"$DATA/setup/ports" \
		"$dnsConfig/$baseDomain" \
		"$dnsConfig/forward.txt" \
		"$dhcpConfig/$n/kea-dhcp4-$n.json" \
		"$dhcpConfig/$n/kea-dhcp4-$n-reservations.json"
}

#
# Network Update Command
#

networkUpdateUsage() { echot "Usage: $(ScriptName) network update [dns|dhcp|all](all) [HOST|all]...
Update the DHCP or DNS configuration of HOST.

	-nb,	--no-backup			do not backup the existing configuration before updating
	-nv,	--no-validate		do not validate the service after updating"; }

networkUpdateArgStart() { unset -v noBackup noValidate; }

networkUpdateOpt() 
{
	case "$1" in
		-nb|--no-backup) noBackup="true";;
		-nv|--no-validate) noValidate="true";;
		*) return 1
	esac
}

networkUpdateCommand() { networkUpdateAllCommand; }
networkUpdateAllCommand() { networkUpdateDhcpCommand && networkUpdateDnsCommand; }

#
# Network Update DHCP Command
#

networkUpdateDhcpCommand()
{	
	local hosts host; getHosts "dhcpServers" || return

	for host in "${hosts[@]}"; do
		(( ${#hosts[@]} > 1 )) && header "Update DHCP ($host)"
		networkUpdateDhcp "$host" || return
	done
}

networkUpdateDhcp()
{
	local host="$1" hostShort hostIp reservations; networkUpdateCommon "DHCP" || return
	local config="$dhcpConfig/$network"; CloudGet "$config"/* || return
	local dir="$(mktemp -d -t 'dhcp.XXXXXXXXXX')" || return
	local subnetVar="subnet$(ProperCase "$hostShort")"
	local subnet="${!subnetVar:-$subnetDefault}"


	echo "Updating DHCP configuration for $hostShort..."
	cp "$config/"* "$dir" || return
	${G}sed -i "s/SUBNET4_POOL/$subnet/" "$dir/kea-dhcp4-$network.json" || return
	${G}sed -i "s/DHCP_DIR/$(echo "$dhcpDir" | QuotePath)/" "$dir/kea-dhcp4-$network.json" || return
	${G}sed -i "s/DHCP_DIR/$(echo "$dhcpDir" | QuotePath)/" "$dir/kea-dhcp4.conf" || return

	echo "Updating the ethers configuration file..." # downcase to make etherwake case agnostic
	configFileToCommaDelimited "$reservations" | tr A-Z a-z | awk -F "," '{ print $2 " " $1 }' > "$DATA/setup/ethers" || return

	echo "Updating the hosts configuration file..."
	configFileToCommaDelimited "$reservations" |  awk -F "," '{ print $1 }' > "$DATA/setup/hosts" || return

	echo "Updating DHCP configuration on $hostShort..."
	rsync --no-perms --chmod=ugo=rw --rsync-path="sudo rsync" --info=progress2 "$dir/"* "$host:$dhcpDir" || return

	# cleanup
	rm -fr "$dir" || return

	# restart the service
	SshHelper --x-forwarding connect "$hostIp" -- service restart kea-dhcp4-server || return

	# validate
	[[ ! $noValidate ]] && { networkValidateHost "$host" DHCP || return; }

	return 0
}

#
# Network Update DNS Command
#

networkUpdateDnsCommand()
{	
	local hosts host; getHosts "dnsServers" || return

	for host in "${hosts[@]}"; do
		(( ${#hosts[@]} > 1 )) && header "Update DNS ($host)"
		networkUpdateDns "$host" || return
	done
}

networkUpdateDns()
{
	local host="$1" hostShort hostIp reservations; networkUpdateCommon "DNS" || return
	local config="$dnsConfig"; CloudGet "$config"/* || return
	local dir="$(mktemp -d -t 'dns.XXXXXXXXXX')" || return

	echo "Creating DNS configuration files..."
	cp "$config/named.conf."* "$dir" || return
	cp "$config/$baseDomain" "$dir" || return
	cp "$config/forward.txt" "$dir/$domain" || return
	configFileToCommaDelimited "$reservations" | awk -F "," '{ print $1 ".'$domain'.	A	" $3 }' | column -t	>> "$dir/$domain" || return

	# create reverse lookup zone files
	for zone in 100 101 102; do
		local z="$dir/$zone.10.10.in-addr.arpa"

		cat "$config/$zone.txt" > "$z" || return

		{ printf "\n; static\n"; cat "$config/reverse.txt" | ${G}grep "^[0-9]*.$zone.10.10"; } >> "$z"

		{ printf "\n; dynamic\n"
			configFileToCommaDelimited "$reservations" |
				grep ",10.10.$zone." |
				sed "s/10.10.$zone.//" |
				awk -F "," '{ print $3 ".'$zone'.10.10.in-addr.arpa. PTR " $1 ".'$domain'." }' |
				column -t; } >> "$z"

	done

	echo "Updating DNS configuration files on $host..."
	rsync --no-perms --chmod=ugo=rw --rsync-path="sudo rsync" "$dir/"* "$hostIp:$dnsDir" --info=progress2 || return

	# cleanup
	rm -fr "$dir" || return

	# restart the service - use X Forwarding to enable local credential manager
	SshHelper --x-forwarding connect "$hostIp" -- service restart bind9 || return

	# validate
	[[ ! $noValidate ]] && { networkValidateHost "$host" DNS || return; }

	return 0
}

#
# Network Update Helper
#

networkUpdateCommon()
{
	getHost || return
	reservations="$dhcpConfig/$network/kea-dhcp4-$network-reservations.json"
	networkConfigFileValidate "$reservations" || return
	[[ ! $noBackup ]] && { networkBackup$(ProperCase "$1") "$host" || return; }
	return 0
}

configFileToCommaDelimited() # configFileToCommaDelimited FILE - convert a Kea configuration file to comma delimited
{
	configFileToJson "$1" |
		jq '.[]|{a: .hostname, b: ."hw-address", c: ."ip-address"}|join(",")' | # convert to comma delimited
		sed 's/\"//g'	|	# remove quotes
		sort
}

configFileToJson() # configFileToJson FILE - convert a Kea configuration file to valid JSON
{
	cat "$1" |
		sed '/^[	 ]*\/\//d' |  # remove comments - lines that begin with //
		sed '/<\?include/d'  	# remove <?include ?> directives
}

networkConfigFileValidate()
{
	configFileToJson "$1" | jq > /dev/null && return

	# view the file issues in a text editor
	local file="$(mktemp)" || return
	configFileToJson "$1" > "$file" 2> /dev/null
	TextEdit "$1" "$file" || return
	return 1
}

#
# Network Validate Command
#

networkValidateUsage() { echo "Usage: $(ScriptName) network validate [dns|dhcp|all](all) [HOST|all]...
Validate the DHCP or DNC operation of HOST."; }

networkValidateCommand() { networkValidateAllCommand; }
networkValidateAllCommand() { networkValidateDhcpCommand && networkValidateDnsCommand; }
networkValidateDhcpCommand() { networkValidateHosts "DHCP"; }
networkValidateDnsCommand() { networkValidateHosts "DNS"; }

networkValidateDhcp()
{
	local host="$1" hostShort hostIp; getHost || return
	if IsPlatform win; then
		dhcptest.exe --bind "$(GetAdapterIpAddress)" --query --wait --timeout 2 |& grep -q "^Received packet from $hostIp"
	else
		sudoc nmap --script broadcast-dhcp-discover -e $(GetPrimaryAdapterName) |& grep -q "Server Identifier: $hostIp"
	fi
}

networkValidateDns()
{
	local host="$1" hostShort hostIp; getHost || return
	IsAvailablePort "$hostIp" 53 || return
	nslookup router "$hostIp" >& /dev/null || return			# validate forward lookup
	nslookup 10.10.100.1 "$hostIp" >& /dev/null || return	# validate reverse lookup
}

# networkValidateHost HOST dhcp|dns - validate DHCP or DNS for the specified host
networkValidateHost()
{
	local host="$1" what="${2^^}" hostShort hostIp; getHost || return	
	printf "Waiting for $what on $hostShort..."

	if networkValidateWait "$what" 10; then
		echo "${GREEN}available${RESET}"
	else
		echo "${RED}failed${RESET}"
		return 1
	fi
}

# networkValidateHosts dhcp|dns - validate DHCP or DNS for the hosts
networkValidateHosts()
{
	local what="$1" hosts host hostShort hostIp; getHosts "${what,,}Servers" || return

	printf "Validating ${what^^}..."
	for host in "${hosts[@]}"; do
		getHost || return	
		printf "$hostShort..."
		networkValidateWait "$what" 5 && printf "ok..." || printf "${RED}failed${RESET}..."
	done
	echo "done"
}

# networkValidateWait dns|dhcp SECONDS - wait SECONDS to validate DNS or DHCP
networkValidateWait()
{	
	local function="networkValidate$(ProperCase "$1")" seconds="$2" 

	$function "$hostIp" && return

	for (( i=1; i<=$seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; exit 1; }
 		$function "$hostIp" && return
		[[ ! $quiet ]] && printf "."
	done

	return 1
}

#
# Setup Command
#

setupUsage() { echo "Usage: $(ScriptName) setup all|hashi"; }
setupCommand() { usage; }

setupAllCommand() {	setupHashiCommand && setupHashiFinalCommand; }

#
# Setup Hashi Command
#

setupHashiUsage() { echot "\
Usage: $(ScriptName) setup hashi [final|service|test]
Setup HashiCorp programs."; }

setupHashiArgStart() { unset -v configPrefixArg; }
setupHashiCommand() {	inst HashiServer; }
setupHashiTestCommand() { inst HashiServer --test; }

setupHashiFinalCommand()
{
	hilight  "Copying local credentials to the remote Vault server..."
	hashiRun config set remote || return
}

setupHashiServiceCommand()
{
	header "Installing Hashi jobs..."
	hashiJob "backup" || return
	inst "ApacheNomad" || return
	inst "NginxProxyManagerNomad" || return

	header "Installing Hashi Consul services..."
	hashiService "cups" 3 || return
	hashiService "dns" 1,2 || return
	hashiService "domotz-agent" 2 || return
	hashiService "hass" 3 || return
	hashiService "node-red" 3 || return
	hashiService "nomad-web" 1,23 || return
	hashiService "squid-proxy" 3 || return
	hashiService "unifi-controller" 2 || return
}

hashiRun() { hashi "$@" $force $test $verbose "${configPrefixArg[@]}" "${otherArgs[@]}"; }
hashiJob() { local job="$1"; shift; hashiRun nomad job run "$job" "$@"; }

hashiService()
{
	local service="$1" hostNum hostNums; StringToArray "$2" "," hostNums; shift 2

	for hostNum in "${hostNums[@]}"; do
 		hashiRun consul service register "$hashiConfig/service/$service.hcl" --host="$hostNum" "$@"
	done
}

#
# Syncronize Commands
#

syncUsage() { echo "Usage: $(ScriptName) sync credential|internet|JumpCloud|web|WireGuard"; }

syncCommand() { usage; }

syncCredentialCommand()
{
	local p
	for p in "${credentialPaths[@]}"; do
		credential sync "$p" $verbose || return
	done
}

syncInternetCommand()
{
	local domain="$(ConfigGet "baseDomain")"
	updateIp "vpn" && updateIp "wan1" "1" && updateIp "wan2" "2"
}

updateIp()
{
	local name="$1" port="$2"
	local desc="${name^^}"

	hilight "Updating $name..."

	# get the internet address
	local ip; ip="$(network internet address $port "${globalArgs[@]}")" || return

	# validate internet address
	[[ ! $ip || "$ip" == null ]] && { EchoErr "$desc internet address not found, internet may be failed over"; echo; return 0; }
	! IsIpAddress "$ip" && { EchoErr "$desc  internet address '$ip' is not valid"; return 1; }

	# update CloudFlare with the internet address
	echo "$desc address is $ip"
	CloudFlare update "$domain" "$name" "$ip" "${globalArgs[@]}" || return; echo
}

syncJumpcloudCommand()
{
	local ip; ip="$(network internet address 1)" || return
	hilight "Updating JumpCloud wiggin-cable RADIUS Server to $ip..."
	JumpCloud radius update wiggin-cable "$ip" > /dev/null || return; echo

	ip="$(network internet address 2)" || return
	hilight "Updating JumpCloud wiggin-dsl RADIUS Server to $ip..."
	JumpCloud radius update wiggin-dsl "$ip" > /dev/null || return; echo
}

syncWireguardCommand()
{
	local port="51820"

	# get an available WireGuard server
	log1 "getting current WireGuard servers..."
	local servers=(); StringToArray "$(network current servers wireguard)" "," servers
	local newIndex newName; 
	newIndex="$(network find "${servers[@]}" --service "$port" --udp)" || return
	newName="${servers[$newIndex]}"
	log1 "the activate WireGuard server is $newName"
	
	# return if the WireGuard server has not changed
	local currentName="$(UpdateGet "WireGuardServer")"
	[[ "$currentName" == "$newName" ]] && { echo "The WireGuard server ($currentName) has not changed."; return; }

	# enable port forwarding for the selected WireGuard server
	echo "Enabling WireGuard port forwarding for $newName..."
	UniFiController port enable "WireGuard ($(RemoveDnsSuffix "$newName"))" || return

	# disable port forwarding for other WireGuard servers
	local i
	for (( i = 0; i < ${#servers[@]}; i++ )); do

		(( i == newIndex )) && continue

		local server="${servers[$i]}"
		echo "Disabling WireGuard port forwarding for $server..."
		UniFiController port disable "WireGuard ($(RemoveDnsSuffix "$server"))" || return
		
	done

	UpdateSet "WireGuardServer" "$newName"
}

#
# device commands
#

deviceUsage() { echo "Usage: $(ScriptName) info|list|on|off|status|sync|update [cam|prod|test|SERVICE](nomad-client)"; }
deviceCommand() { usage; }

deviceArgs()
{
	service="nomad-client"; [[ $1 ]] && ScriptArgGet "service" -- "$@"
	case "${service,,}" in
		cam) ArrayCopy camDevices devices;;
		prod|test) devices=( $(hashi config hosts --config-prefix="${service,,}") ) || return;;
		*) devices=( $(GetServers "$service") ) || return;;
	esac
}

deviceListCommand() { deviceList "${devices[@]}"; }
deviceOffCommand() { deviceOff "${devices[@]}"; }
deviceOnCommand() { deviceOn "${devices[@]}"; }
deviceStatusCommand() { deviceStatus "${devices[@]}"; }
deviceSyncCommand() { deviceSync "${devices[@]}"; }
deviceUpdateCommand() { deviceUpdate "${devices[@]}"; }

deviceList() { local devices=("$@"); ArrayDelimit devices $'\n'; }
deviceOff() { local h; for h in "$@"; do power off "$h" "${globalArgs[@]}" || return; done; }
deviceOn() { local h; for h in "$@"; do power on "$h" "${globalArgs[@]}" || return; done; }

deviceSync()
{
	local host args; [[ $noPrompt ]] && args+=("--dest-older" "${globalArgs[@]}")
	for host in "$@"; do
		IsLocalHost "$host" && continue
		HostAvailable "$host" || continue
		SyncLocalFiles "$host" "${args[@]}" || return
	done
}

deviceUpdate()
{
	local host args; [[ $noPrompt ]] && args+=("--dest-older" "${globalArgs[@]}")
	for host in "$@"; do
		HostAvailable "$host" || continue
		HostUpdate "$host" "${args[@]}" || return
	done
}

deviceStatus()
{
	local host
	for host in "$@"; do
		if [[ $verbose ]]; then
			power status "$host" --verbose || return
		else
			local status; status="$(power status "$host")" || return
			echo "$host is $status"
		fi
	done
}

#
# device info command
#

deviceInfoUsage() { echo "Usage: $(ScriptName) info [-d|--detail]"; }
deviceInfoArgStart() { unset -v detail; }

deviceInfoOpt()
{
	case "$1" in
		-d|--detail) detail="--detail";;
		*) return 1;;
	esac
}

deviceInfoCommand() { deviceInfo "${devices[@]}"; }
deviceInfo() { local h; for h in "$@"; do header "$h"; os info "$h" $detail || return; done; }

#
# Helper
#

mountVol() { VeraCrypt mount "$@" p "${globalArgs[@]}"; }
unmountVol() { VeraCrypt unmount p "${globalArgs[@]}"; }

# backupApp ARCHIVE SERVER [DIRS]
borgBackup()
{
	local archive="$1" server="$2"; shift 2
	[[ ! $backupHosts ]] && { backupHosts="$(network current servers backup)" || return; }
	BorgHelper remote "$server" "${globalArgs[@]}" -- backup "$@" --archive="$archive" --repository="$server" --backup-host="$backupHosts" --prune 5
}

getHosts() 
{
	[[ "$hostsArg" != "all" ]] && { ArrayCopy hostsArg hosts; return; }
	StringToArray "$(ConfigGet "$1")" "," hosts
	[[ ! $hosts ]] && MissingOperand "hosts"
	return 0
}

getHost()
{
	! IsAvailable "$host" && { ScriptErr "host '$host' is not available"; return 1; }
	ScriptEval HostGetInfo "$host" || return
	IsPlatform pi --host && dhcpDir="$dhcpDirBuild" || dhcpDir="$dhcpDirPackageDir"
	hostShort="$(RemoveDnsSuffix "$host")"
	hostIp="$(GetIpAddress "$host")" || return	
}

ScriptRun "$@"

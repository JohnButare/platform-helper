#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Manage the Wiggin network.

	backup	backup data
	device	control devices
	remove	remove applications from the environment
	setup		setup the environment
	network	configure network	
	sync		syncronize items"
}

init()
{
	# credentials
	credentialPaths=( domotz LastPass secure ssh system unifi )

	# devices
	camDevices=(BackShed BackYardEast ChickenYardNorth ChickenYardSouth FrontPatio FrontYardEast FrontYardWest LivingRoom)
	coreDevices=( pi1 pi2 pi3 )
	testDevices=( pi4 pi5 pi6 pi7 ) # pi8 rp1

	# file server
	fileServer="$(ConfigGet "fs")" || return
	domain="$(ConfigGet "domain")" || return
	baseDomain="$(ConfigGet "baseDomain")" || return

	# configuration
	ncd="$CLOUD/network"
	hashiConfig="$ncd/system/hashi"
}

#
# Backup Commands
#

backupCommands=( ContainerStation LastPass web qnap )

backupUsage() { echo "Usage: $(ScriptName) backup all|$(ArrayDelimit backupCommands "|")"; }
backupCommand() { usage; }
backupAllCommand() { local c; for c in "${backupCommands[@]}"; do $(FindFunction "backup${c}Command") || return; done; }
backupContainerStationCommand() { AppBackup "$(RemoveDnsSuffix "$fileServer").ContainerStation" "//$fileServer/root/share/data/Container/container-station-data/application" || return; }
backupWebCommand() { AppBackup "$(RemoveDnsSuffix "$fileServer").web" "//$fileServer/root/share/CACHEDEV1_DATA/Web" || return; }

backupLastpassCommand()
{
	header "LastPass Backup"

	local dir; dir="$(mountVol "$CDATA/VeraCrypt/personal.hc")/backup/LastPass" || return

	echo "Logging in to LastPass..."
	LastPass login || return

	echo "Exporting LastPass..."
	lpass export > "$(GetDateStampNext "$dir/" "csv")" || return
		
	unmountVol || return
}

backupQnapCommand()
{
	! IsPlatform QNAP && { ScriptErr "can only backup QNAP operating system"; return 1; }

	local file="$(AppGetBackupDir)/${HOSTNAME}.settings" || return

	# maybe intended to be a backup number, but it is filled with a constant (127) when
	# using the backup function from the webpage, file is not removed after backup, but
	# missing after next reboot...
	echo "127" | sudo tee "/etc/save_no.conf" || return

	sudo tar cvf - "/etc/config/"* "/etc/save_no.conf" | gzip > "$file.tgz" || return

	PC1 e ICPIPNASWAREV301 "$file.tgz" "$file.bin" || return
	PC2 "$file.bin" "" "" || return

	rm "$file.tgz" || return
}

#
# Remove Command
#

removeUsage() { echo "Usage: $(ScriptName) remove hashi [test]
Remove applications from the environment."; }

removeCommand() { usage; }

removeHashiArgStart() { unset -v configPrefixArg; }
removeHashiCommand() { hashiRun remove --what=program,service,consul-vault-data,local-certs,local-credentials,private-certs,public-certs; }
removeHashiTestCommand() { configPrefixArg=( --config-prefix=test ); removeHashiCommand; }

#
# Network Commands
#

networkUsage() { echo "Usage: $(ScriptName) network backup|edit|update|validate"; }

networkArgStart()
{
	unset hostsArg

	# network configuration
	network="$(ConfigGet "network")"
	subnetPi1="192.168.102.1 - 192.168.102.254"
	subnetPi2="192.168.103.1 - 192.168.103.254"
	subnetDefault="$subnetPi1"

	# server file locations
	dhcpDir="/etc/kea"
	dnsDir="/etc/bind"

	dhcpConfig="$ncd/system/dhcp"
	dnsConfig="$ncd/system/dns"
}

networkArgs() { hostsArg=( "$@" ); (( shift+=$# )); true; }

networkArgEnd()
{
	[[ "$command" == @(networkEdit) ]] && return
	[[ ! $hostsArg && "$command" != @(networkEdit) ]] && MissingOperand "host"
	return 0
}

networkCommand() { usage; }

#
# Network Backup Command
#

networkBackupUsage() { echo "Usage: $(ScriptName) network backup [dns|dhcp|all](all) [HOST|all]...
Backup the DHCP or DNC configuration of HOST."; }

networkBackupCommand() { networkBackupAllCommand; }
networkBackupAllCommand() { networkBackupDhcpCommand && networkBackupDnsCommand; }

#
# Network Backup DHCP Command
#

networkBackupDhcpCommand()
{	
	local hosts host; getHosts "dhcpServers" || return

	for host in "${hosts[@]}"; do
		networkBackupDhcp "$host" || return
	done
}

networkBackupDhcp()
{
	local host="$1" hostShort hostIp stamp="$(GetDateStamp)"; getHost || return

	hilight "Backing up DHCP configuration from $hostShort..."

	local f="$hostShort.dhcpd.zip" i=1
	local d="$dhcpConfig/backup"
	while [[ -f "$d/$stamp.$i.$f" ]]; do (( ++i )); done
	ssh $hostIp "rm -f $f; zip -r $f $dhcpDir" || return
	scp $hostIp:~/$f "$d/$stamp.$i.$f" || return
}

#
# Network Backup DNS Command
#

networkBackupDnsCommand()
{	
	local hosts host; getHosts "dnsServers" || return

	for host in "${hosts[@]}"; do
		networkBackupDns "$host" || return
	done
}

networkBackupDns()
{
	local host="$1" hostShort hostIp stamp="$(GetDateStamp)"; getHost || return

	hilight "Backing up DNS configuration from $hostShort..."

	f="$hostShort.dns.zip" i="1"
	d="$dnsConfig/backup"
	while [[ -f "$d/$stamp.$i.$f" ]]; do (( ++i )); done
	ssh $hostIp "rm -f $f; zip -r $f $dnsDir --exclude \*.key \*.zip" || return
	scp $hostIp:~/$f "$d/$stamp.$i.$f" || return
}

#
# Network Edit Command
#

networkEditUsage() { echo "Usage: $(ScriptName) network edit
Edit the DHCP and DNC configuration files."; }

networkEditCommand() { TextEdit "$DATA/setup/ports" "$dnsConfig/$baseDomain" "$dnsConfig/forward.txt" "$dhcpConfig/wiggin/kea-dhcp4-wiggin-reservations.json"; }

#
# Network Update Command
#

networkUpdateUsage() { echo "Usage: $(ScriptName) network update [dns|dhcp|all](all) [HOST|all]...
Update the DHCP or DNS configuration of HOST."; }

networkUpdateArgStart() { unset -v noBackup; }
networkUpdateOpt() 
{
	case "$1" in
		-nb|--no-backup) noBackup="true";;
		*) return 1
	esac
}

networkUpdateCommand() { networkUpdateAllCommand; }
networkUpdateAllCommand() { networkUpdateDhcpCommand && networkUpdateDnsCommand; }

#
# Network Update DHCP Command
#

networkUpdateDhcpCommand()
{	
	local hosts host; getHosts "dhcpServers" || return

	for host in "${hosts[@]}"; do
		(( ${#hosts[@]} > 1 )) && header "Update DHCP ($host)"
		networkUpdateDhcp "$host" || return
	done
}

networkUpdateDhcp()
{
	local host="$1" hostShort hostIp reservations; networkUpdateCommon "DHCP" || return
	local config="$dhcpConfig/$network"
	local dir="$(mktemp -d -t 'dhcp.XXXXXXXXXX')" || return
	local subnetVar="subnet$(ProperCase "$hostShort")"
	local subnet="${!subnetVar:-$subnetDefault}"

	echo "Updating DHCP configuration for $hostShort..."
	cp "$config/"* "$dir" || return
	sed -i "s/SUBNET4_POOL/$subnet/" "$dir/kea-dhcp4-$network.json" || return

	echo "Updating the ethers configuration file..." # downcase to make etherwake case agnostic
	configFileToCommaDelimited "$reservations" | tr A-Z a-z | awk -F "," '{ print $2 " " $1 }' > "$DATA/setup/ethers" || return

	echo "Updating the hosts configuration file..."
	configFileToCommaDelimited "$reservations" |  awk -F "," '{ print $1 }' > "$DATA/setup/hosts" || return

	echo "Updating DHCP configuration on $hostShort..."
	rsync --no-perms --chmod=ugo=rw --rsync-path="sudo rsync" --info=progress2 "$dir/"* "$host:$dhcpDir" || return

	# cleanup
	rm -fr "$dir" || return

	# restart the service
	SshHelper --x-forwarding connect "$hostIp" -- service restart kea-dhcp4-server || return

	# validate
	networkValidateHost "$host" DHCP || return
}

#
# Network Update DNS Command
#

networkUpdateDnsCommand()
{	
	local hosts host; getHosts "dnsServers" || return

	for host in "${hosts[@]}"; do
		(( ${#hosts[@]} > 1 )) && header "Update DNS ($host)"
		networkUpdateDns "$host" || return
	done
}

networkUpdateDns()
{
	local host="$1" hostShort hostIp reservations; networkUpdateCommon "DNS" || return
	local config="$dnsConfig"
	local dir="$(mktemp -d -t 'dns.XXXXXXXXXX')" || return

	echo "Creating DNS configuration files..."
	cp "$config/named.conf."* "$dir" || return
	cp "$config/$baseDomain" "$dir" || return
	cp "$config/forward.txt" "$dir/$domain" || return
	configFileToCommaDelimited "$reservations" | awk -F "," '{ print $1 ".'$domain'.	A	" $3 }' | column -t	>> "$dir/$domain" || return

	for zone in 100 101 102; do
		local z="$dir/$zone.168.192.in-addr.arpa"

		cat "$config/$zone.txt" > "$z"

		{ printf "\n; static\n"; cat "$config/reverse.txt" | grep "^[0-10]*.$zone.168.192"; } >> "$z"

		{ printf "\n; dynamic\n"
			configFileToCommaDelimited "$reservations" |
				grep ",192.168.$zone." |
				sed "s/192.168.$zone.//" |
				awk -F "," '{ print $3 ".'$zone'.168.192.in-addr.arpa. PTR " $1 ".'$domain'." }' |
				column -t; } >> "$z"

	done

	echo "Updating DNS configuration files on $host..."
	rsync --no-perms --chmod=ugo=rw --rsync-path="sudo rsync" "$dir/"* "$hostIp:$dnsDir" --info=progress2 || return

	# cleanup
	rm -fr "$dir" || return

	# restart the service - use X Forwarding to enable local credential manager
	SshHelper --x-forwarding connect "$hostIp" -- service restart bind9 || return

	# validate
	networkValidateHost "$host" DNS || return
}

#
# Network Update Helper
#

networkUpdateCommon()
{
	getHost || return
	reservations="$dhcpConfig/$network/kea-dhcp4-$network-reservations.json"
	networkConfigFileValidate "$reservations" || return
	[[ ! $noBackup ]] && { networkBackup$(ProperCase "$1") "$host" || return; }
	return 0
}

configFileToCommaDelimited() # configFileToCommaDelimited FILE - convert a Kea configuration file to comma delimited
{
	configFileToJson "$1" |
		jq '.[]|{a: .hostname, b: ."hw-address", c: ."ip-address"}|join(",")' | # convert to comma delimited
		sed 's/\"//g'	|	# remove quotes
		sort
}

configFileToJson() # configFileToJson FILE - convert a Kea configuration file to valid JSON
{
	cat "$1" |
		sed '/^[	 ]*\/\//d' |  # remove comments - lines that begin with //
		sed '/<\?include/d'  	# remove <?include ?> directives
}

networkConfigFileValidate()
{
	configFileToJson "$1" | jq > /dev/null && return

	# view the file issues in a text editor
	local file="$(mktemp)" || return
	configFileToJson "$1" > "$file" 2> /dev/null
	TextEdit "$1" "$file" || return
	return 1
}

#
# Network Validate Command
#

networkValidateUsage() { echo "Usage: $(ScriptName) network validate [dns|dhcp|all](all) [HOST|all]...
Validate the DHCP or DNC operation of HOST."; }

networkValidateCommand() { networkValidateAllCommand; }
networkValidateAllCommand() { networkValidateDhcpCommand && networkValidateDnsCommand; }
networkValidateDhcpCommand() { networkValidateHosts "DHCP"; }
networkValidateDnsCommand() { networkValidateHosts "DNS"; }

networkValidateDhcp()
{
	local host="$1" hostShort hostIp; getHost || return
	dhcptest.exe --bind "$(GetAdapterIpAddress)" --query --wait --timeout 1 |& grep -q "^Received packet from $hostIp"
}

networkValidateDns()
{
	local host="$1" hostShort hostIp; getHost || return
	IsAvailablePort "$hostIp" 53 || return
	nslookup router "$hostIp" >& /dev/null || return
}

# networkValidateHost HOST dhcp|dns - validate DHCP or DNS for the specified host
networkValidateHost()
{
	local host="$1" what="${2^^}" hostShort hostIp; getHost || return	
	printf "Waiting for $what on $hostShort..."

	if networkValidateWait "$what" 10; then
		echo "${GREEN}available${RESET}"
	else
		echo "${RED}failed${RESET}"
		return 1
	fi
}

# networkValidateHosts dhcp|dns - validate DHCP or DNS for the hosts
networkValidateHosts()
{
	local what="$1" hosts host hostShort hostIp; getHosts "${what,,}Servers" || return

	printf "Validating ${what^^}..."
	for host in "${hosts[@]}"; do
		getHost || return	
		printf "$hostShort..."
		networkValidateWait "$what" 5 && printf "ok..." || printf "${RED}failed${RESET}..."
	done
	echo "done"
}

# networkValidateWait dns|dhcp SECONDS - wait SECONDS to validate DNS or DHCP
networkValidateWait()
{	
	local function="networkValidate$(ProperCase "$1")" seconds="$2" 

	$function "$hostIp" && return

	for (( i=1; i<=$seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled"; exit 1; }
 		$function "$hostIp" && return
		[[ ! $quiet ]] && printf "."
	done

	return 1
}

#
# Setup Command
#

setupUsage() { echo "Usage: $(ScriptName) setup all|hashi|SystemUser"; }
setupCommand() { usage; }

setupAllCommand() {	setupSystemUserCommand && setupHashiCommand && syncCredentialCommand; }

setupSystemUserCommand()
{
	local user="$systemUser"

	if ! grep "^$user" "/etc/passwd" >& /dev/null; then
		sudoc adduser "$user" --gecos "" --disabled-login || return
		password linux --user "$user" --password "$(credential gets system default --fallback)" || return
	fi

	local file="/etc/sudoers.d/020_$user-nopasswd"
	if ! sudoc ls "$file" >& /dev/null; then 
		echo "$user ALL=(ALL) NOPASSWD: ALL" | sudo tee "/etc/sudoers.d/020_$user-nopasswd" || return
	fi
	
	if [[ ! -d "$USERS/$user/.ssh" ]]; then
		sudoc cp -r "$HOME/.ssh" "$USERS/$user/.ssh" || return
		SshHelper permission "wsystem" || return
	fi
}

#
# Setup Hashi Command
#

setupHashiUsage() { echot "\
Usage: $(ScriptName) setup hashi [test]
Setup HashiCorp programs."; }

setupHashiArgStart()
{
	unset -v configPrefixArg
}

setupHashiCommand() 
{	
	hashiRun install --encrypt || return
	[[ ! $otherArgs ]] && { setupHashiFinalCommand || return; }
	return 0
}

setupHashiTestCommand() { configPrefixArg=( --config-prefix=test ); setupHashiCommand; }

setupHashiFinalCommand()
{
	header "Remote Configuration"
	hashiRun config set remote || return

	header "Service Configuration"
	hashiService "dns1" --host=first || return
	hashiService "dns2" --host=second || return
	hashiService "domotz-agent" --host=second || return
	hashiService "unifi-controller" --host=second || return
}

hashiRun() { hashi "$@" $force $test $verbose $yes "${configPrefixArg[@]}" "${otherArgs[@]}"; }
hashiService() { local service="$1"; shift; hashiRun consul service register "$hashiConfig/services/$service.hcl" "$@"; }

#
# Syncronize Commands
#

syncUsage() { echo "Usage: $(ScriptName) sync credential"; }
syncCommand() { usage; }

syncCredentialCommand()
{
	local p
	for p in "${credentialPaths[@]}"; do
		credential sync "$p" || return
	done
}


#
# Device Commands
#

deviceUsage() { echo "Usage: $(ScriptName) info|list|on|off|status|update cam|core|test"; }
deviceCommand() { usage; }

deviceInfoUsage() { deviceUsage; }
deviceInfoCommand() { usage; }
deviceInfoCamCommand() { deviceInfo "${camDevices[@]}"; }
deviceInfoCoreCommand() { deviceInfo "${coreDevices[@]}"; }
deviceInfoTestCommand() { deviceInfo "${testDevices[@]}"; }

deviceListUsage() { deviceUsage; }
deviceListCommand() { usage; }
deviceListCamCommand() { deviceList "${camDevices[@]}"; }
deviceListCoreCommand() { deviceList "${coreDevices[@]}"; }
deviceListTestCommand() { deviceList "${testDevices[@]}"; }

deviceOffUsage() { deviceUsage; }
deviceOffCommand() { usage; }
deviceOffCamCommand() { suffix="Camera"; deviceOff "${camDevices[@]}"; }
deviceOffCoreCommand() { deviceOff "${coreDevices[@]}"; }
deviceOffTestCommand() { deviceOff "${testDevices[@]}"; }

deviceOnUsage() { deviceUsage; }
deviceOnCommand() { usage; }
deviceOnCamCommand() { suffix="Camera"; deviceOn "${camDevices[@]}"; }
deviceOnCoreCommand() { deviceOn "${coreDevices[@]}"; }
deviceOnTestCommand() { deviceOn "${testDevices[@]}"; }

deviceStatusUsage() { deviceUsage; }
deviceStatusCommand() { usage; }
deviceStatusCamCommand() { suffix="Camera"; deviceStatus "${camDevices[@]}"; }
deviceStatusCoreCommand() { deviceStatus "${coreDevices[@]}"; }
deviceStatusTestCommand() { deviceStatus "${testDevices[@]}"; }

deviceUpdateUsage() { deviceUsage; }
deviceUpdateCommand() { usage; }
deviceUpdateCoreCommand() { deviceUpdate "${coreDevices[@]}"; }
deviceUpdateTestCommand() { deviceUpdate "${testDevices[@]}"; }

deviceList() { local devices="$@"; ArrayDelimit devices; }
deviceOff() { local d; for d in "$@"; do d+="${suffix^}"; power off "$d" $force $test $verbose || return; done; }
deviceOn() { local d; for d in "$@"; do d+="${suffix^}"; power on "$d" $force $test $verbose || return; done; }

deviceInfo()
{
	local device
	for device in "$@"; do
		! IsAvailable "$device" && continue
		header "$device"
		device+="${suffix^}"
		HostGetInfo show "$device" || return
	done
}

deviceUpdate()
{
	local device
	for device in "$@"; do
		! IsAvailable "$device" && continue
		header "$device"
		device+="${suffix^}"
		HostUpdate --host "$device" || return
	done
}

deviceStatus()
{
	local device
	for device in "$@"; do
		device+="${suffix^}"
		if [[ $verbose ]]; then
			power status "$device" --verbose || return
		else
			local status; status="$(power status "$device")" || return
			echo "$device is $status"
		fi
	done
}

#
# Helper
#

mountVol() { VeraCrypt mount "$@" p; }
unmountVol() { VeraCrypt unmount p; }

getHosts() 
{
	[[ "$hostsArg" != "all" ]] && { ArrayCopy hostsArg hosts; return; }
	StringToArray "$(ConfigGet "$1")" "," hosts
	[[ ! $hosts ]] && MissingOperand "hosts"
	return 0
}

getHost()
{
	! IsAvailable "$host" && { ScriptErr "host '$host' is not available"; return 1; }
	hostShort="$(RemoveDnsSuffix "$host")"	
	hostIp="$(GetIpAddress "$host")" || return
}

ScriptRun "$@"

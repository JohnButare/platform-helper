#!/usr/bin/env bash
# test: RunScript -v -nh --elevate -- touch /mnt/c/hi.txt \; sleep 2 \; echo \"all done\"
# no dependencies: do not source other scripts here as we do not assume other scripts are in the path

run() {	init && args "$@" && runScript; }

init() { LoadFunctions; }

usage()
{
	echot "\
usage: RunScript [OPTION]... [--] SCRIPT
	Run a shell script, executable, or a series of commands.	

	-c, --credential		configure a credential manager
	-e, --elevate				in Windows run the script with an elevated (Administrator) token
	-H, --hashi					configure Hashi tools
	-m, --multiple			allow multiple commands, i.e. \"sudo RunScript --multiple 'ls; pause'\"
											Useful in cases where bash -c cannot be used.
	-nh, --no-hide			do not hide the elevated script window
	-p, --pause					pause after the command is run, useful for transitory windows
	-pe, --pause-error	pause after the command is run with an error, useful for transitory windows
	-sa, --ssh-agent		configure the SSH agent
	-s, --ssh HOST			run the script on the host using SSH
	-v, --verbose				display detailed output
	-x									force initialization of the X server
	--     							Signal the end of options. This is useful to allow further arguments to the script
											program itself to start with a  “-”.  This provides consistency with the 
											argument parsing convention used by most other POSIX programs.

	Notes:
	- finds function.sh even if it is not in the PATH.  This is useful for initial startup, non-login shells,
	  or running as root.
	- simplifies pausing the script.  This is useful when running elevated in Windows, 
	  i.e. elevate RunScript --pause-error service start WpnUserService_5f5dbe
	- all diagnostic (verbose) output is sent to the standard error so RunScript can be called from 
	  a subshell, i.e. dir=\"\$(RunScript --elevate --verbose -- unc mount "//pi1/root")\""
	exit $1
}

args()
{
	declare -g script=() windowStyle="--window-style hidden"
	unset -v credential elevate hashi hashiService multiple pause pauseError ssh sshAgent verbose verboseLevel
			
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-c|--credential) credential="true";;
			-e|--elevate) elevate="true";;
			-f|--force) ;; # not used, allows other scripts to pass globalArgs
			-h|--help) usage 0;;
			-hs|--hashi-service) hashiService="true";;
			-H|--hashi) hashi="true";;
			-nh|--no-hide) windowStyle="";;
			-m|--multiple) multiple="eval";;
			-p|--pause) pause="true";;
			-pe|--pause-error) pauseError="true";;
			-sa|--ssh-agent) sshAgent="true";;
			-s|--ssh) ssh="$2"; shift;;
			-v|--verbose) verbose="-v"; verboseLevel=1;;
			-vv) verbose="-vv"; verboseLevel=2;;
			-vvv) verbose="-vvv"; verboseLevel=3;;
			-vvvv) verbose="-vvvv"; verboseLevel=4;;
			-x) InitializeXServer || return;;
			*)
				[[ "$1" == "--" ]] && { shift; script+=( "$@" ); break; }
				! IsOption "$1" &&  { script+=( "$1" ); shift; continue; }
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $script ]] && MissingOperand "script"
	
	return 0
}

runScript()
{
	# elevate	
	[[ $elevate ]] && IsPlatform win && ! IsElevated && { runScriptElevated; return; }

	# configure Hashi tools
	[[ $hashi ]] && { HashiConf $verbose || return; }

	# configure credential manager
	[[ $credential ]] && { CredentialConf --unlock $verbose || return; }

	# configure the SSH agent
	[[ $sshAgent ]] && { SshAgentConf "$verbose" || return; }

	# run the script
	if [[ $ssh ]]; then
		runScriptSsh "$ssh" "${script[@]}"
	else
		[[ $verbose ]] && { ScriptErr "running the following script locally:"; echo "$multiple \"${script[@]}\"" | AddTab >& /dev/stderr; }
		$multiple "${script[@]}"
	fi
	local result="$?"
	[[ $verbose ]] && ScriptErr "the script returned $result"

	# pause
	if [[ "$result" != "0" && $pauseError ]]; then
		EchoErr "The script returned error $result."
		pause
	elif [[ $pause ]]; then
		pause
	fi

	# return errors for a HashiCorp service where 0=success 1=warning 2=error
	[[ $hashiService ]] && (( result > 0 )) && (( result+=1 ))

	return $result
}

runScriptSsh()
{
	local host="$1"; shift
	local script="$(cat <<-EOF
		[[ -f "$f" ]] && { . "$f" || exit; }
		$@
		EOF
	)"

	if IsLocalHost "$host"; then
		[[ $verbose ]] && { ScriptErr "running the following script locally:"; echo "$script" | AddTab >& /dev/stderr; }
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		local args=(-q -X -t)

		[[ $verbose ]] && { ScriptErr "running the following script on '$host':"; echo "$script" | AddTab >& /dev/stderr; }
		DISPLAY="" ssh "${args[@]}" "$host" "$script"
	fi
}

runScriptElevated() # run commands elevated that has quoted arguments
{
	local dir="$(mktemp -d -t 'RunScript.XXXXXXXXXX')" || return

	# script: the script file
	# scriptLog: a file which contains the standard output and error of the script
	# scriptResult: a file which contains the return code (result) of the script
	local scriptFile="$dir/script.sh" scriptLog="$dir/log.txt" scriptResult="$dir/result.txt"

	# create the script log file now so inotifywait does not return when it is created
	touch "$scriptLog" || return

	# create the script and run it elevated.  ArrayShow is used to quote each argument of the script.
	# This ensure script arguments with spaces are preserved as a single argument.
	cat > "$scriptFile" <<-EOF
		#!/usr/bin/env bash
		$(ArrayShow script) |& tee $scriptLog
		echo \${PIPESTATUS[0]} > $scriptResult
		EOF

	[[ $verbose ]] && { ScriptErr "elevating the following script using '$scriptFile':"; cat "$scriptFile" | AddTab >& /dev/stderr; unset windowStyle; }

	# ensure the user with an elevated token can run the script
	chmod ugo+x "$scriptFile" || return

	# execute the script
	start --elevate $windowStyle "${globalArgs[@]}" RunScript "${scriptFile}" || return

	# wait for the creation of the script result file
	[[ $verbose ]] && PrintErr "Waiting for log file in '$dir'..."
	inotifywait -e create --quiet --quiet "$dir/"
	[[ $verbose ]] && EchoErr "found"

	# show the script log if it was created
	[[ $verbose ]] && { EchoErr "Script file output:"; }
	[[ -f "$scriptLog" ]] && cat "$scriptLog"
	
	# get the script result (return code) if it was created (if the script was killed, cancelled, or interrupted it will not have a result)
	[[ -f "$scriptResult" ]] && scriptResult="$(cat "$scriptResult")"
	[[ $verbose ]] && ScriptErr "script result: ${RESET}${scriptResult}"

	# cleanup
	rm -fr "$dir"
	
	return "$scriptResult"
}

# functions which may be used before we load function.sh
EchoErr() { echo "$@" > /dev/stderr; }
pause() { local response; read -n 1 -s -p "${*-Press any key when ready...}"; echo; }

# LoadFunctions - load functions from function.sh
# - look in the path, the current directory, the script directory, and /usr/local/bin
# - sets f to the function file found
LoadFunctions() 
{
	f="$(type -P "function.sh")"
	if (( $? != 0 )); then
		f="$PWD/function.sh"
		if [[ ! -f "$f" ]]; then f="${BASH_SOURCE[0]%/*}/function.sh"
		elif [[ ! -f "$f" ]]; then f="/usr/local/data/bin/function.sh"
		elif [[ ! -f "$f" ]]; then EchoErr "Unable to find function.sh"; pause; return 1
		fi
	fi
	. "$f" || { EchoErr "RunScript: unexpected error sourcing function.sh"; pause; return 1; }
}

run "$@"

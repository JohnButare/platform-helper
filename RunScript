#!/usr/bin/env bash
# test: RunScript -v -nh --elevate -- touch /mnt/c/hi.txt \; sleep 2 \; echo \"all done\"
# no dependencies: do not source other scripts here as we do not assume other scripts are in the path

usage()
{
	ScriptUsage "$1" "\
Usage: RunScript [OPTION]... SCRIPT
	Run a shell script, executable, or a series of commands.	

	-s,  --ssh HOST					run the script on the host using SSH
	-x	 --x-server					force initialization of the X server"
	exit $1
}

usageVerbose()
{ 
	ScriptUsageEcho "
Environment options:
	-c,  --credential				configure a credential manager
	-cm, --manager=MANAGER	use a specific credential manager
	-H,  --hashi						configure Hashi tools
	-sa, --ssh-agent				configure the SSH agent

Other options:
	-e,  --elevate					in Windows run the script with an elevated (Administrator) token
			 --functions				use functions in the script
	-nh, --no-hide					do not hide the elevated script window
	-m,  --multiple					allow multiple commands, i.e. \"sudo RunScript --multiple 'ls; pause'\"
													Useful in cases where bash -c cannot be used
	-p,  --pause						pause after the command is run, useful for transitory windows
	-pe, --pause-error			pause after the command is run with an error, useful for transitory windows

Notes:
	- finds function.sh even if it is not in the PATH.  This is useful for initial startup, non-login shells,
	  or running as root.
	- simplifies pausing the script.  This is useful when running elevated in Windows, 
	  i.e. elevate RunScript --pause-error service start WpnUserService_5f5dbe
	- all diagnostic (verbose) output is sent to the standard error so RunScript can be called from 
	  a subshell, i.e. dir=\"\$(RunScript --elevate --verbose -- unc mount "//pi1/root")\""
}

init() { defaultCommand="run"; }

#
# run command
#

runArgStart()
{
	unset -v credential credentialManager elevate functions hashi hashiService multiple pause pauseError ssh sshAgent verbose verboseLevel
	credentialManager=() script=() windowStyle="--window-style hidden"
}

runArgs() {  (( $# == 0 )) && return; script=( "$@" ); (( shift+=$# )); }
runArgEnd() { [[ $script || $otherArgs ]] && return; MissingOperand "script"; }

runOpt()
{
	case "$1" in
		--credential|-c) credential="true";;
		--credential-manager|--credential-manager=*|-cm|-cm=*) ScriptOptGet "credentialManager" "credential-manager" "$@"; credentialManagerArg=(--manager "$credentialManager");;
		--elevate|-e) elevate="true";;
		--functions) functions=(". function.sh || return");;
		--hashi-service|-hs) hashiService="true";;
		--hashi|-H) hashi="true";;
		--no-hide|-nh) windowStyle="";;
		--multiple|-m) multiple="eval";;
		--pause|-p) pause="true";;
		--pause-error|-pe) pauseError="true";;
		--ssh-agent|-sa) sshAgent="true";;
		--ssh|-s) ScriptOptGet "ssh" -- "$@";;
		--x-server|-x) InitializeXServer || return;;
		*) return 1;;
	esac
}
#. function.sh || return

#
# run command
#

runCommand()
{
	set -- "${script[@]}" "${otherArgs[@]}"

	# elevate	
	[[ $elevate ]] && ! IsElevated && { runElevated "$@"; return; }

	# configure credential manager
	[[ $credential ]] && { RunLog CredentialConf --unlock "${credentialManagerArg[@]}" "${globalArgs[@]}" || return; }

	# configure Hashi tools
	[[ $hashi ]] && { RunLog HashiConf "${globalArgs[@]}" || return; }

	# configure the SSH agent
	[[ $sshAgent ]] && { RunLog SshAgentConf "${globalArgs[@]}" || return; }

	# run the script
	if [[ $ssh ]]; then
		runSsh "$ssh" "$@"
	else
		[[ $verbose || ! $quiet ]] && LogScript "$verboseLevel" $multiple "$@"
		$multiple "$@"
	fi

	local result="$?"
	log1 "the script returned $result"

	# pause
	if [[ "$result" != "0" && $pauseError ]]; then
		EchoErr "The script returned error $result."
		pause
	elif [[ $pause ]]; then
		pause
	fi

	# return errors for a HashiCorp service where 0=success 1=warning 2=error
	[[ $hashiService ]] && (( result > 0 )) && (( result+=1 ))

	return $result
}

runSsh()
{
	local host="$1"; shift
	local script="$(cat <<-EOF
		[[ -f "$functionFile" ]] && { . "$functionFile" || exit; }
		$@
		EOF
	)"

	if IsLocalHost "$host"; then
		[[ $verbose ]] && { ScriptErr "running the following script locally:"; echo "$script" | AddTab >& /dev/stderr; }
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		local args=(-q -X -t)

		[[ $verbose ]] && { ScriptErr "running the following script on '$host':"; echo "$script" | AddTab >& /dev/stderr; }
		DISPLAY="" ssh "${args[@]}" "$host" "$script"
	fi
}

runElevated() # run commands elevated that has quoted arguments
{
	local dir="$(mktemp -d -t 'RunScript.XXXXXXXXXX')" || return	

	# script: the script file
	# scriptLog: a file which contains the standard output and error of the script
	# scriptResult: a file which contains the return code (result) of the script
	local scriptFile="$dir/script.sh" scriptLog="$dir/log.txt" scriptResult="$dir/result.txt"

	# create the script log file now so inotifywait does not return when it is created
	touch "$scriptLog" || return

	# create the script and run it elevated
	# - ScriptReturn sets script to an array of quoted arguments so spaces, single, and double quotes are preserved
	local script=("$@")

	cat > "$scriptFile" <<-EOF
		#!/usr/bin/env bash
		$functions
		$(ScriptReturn script)
		"\${script[@]}" |& tee $scriptLog
		echo \${PIPESTATUS[0]} > $scriptResult
		EOF

	[[ $verbose ]] && { ScriptErr "elevating the following script using '$scriptFile':"; cat "$scriptFile" | AddTab >& /dev/stderr; unset windowStyle; }

	# ensure the user with an elevated token can run the script
	chmod ugo+x "$scriptFile" || return

	# execute the script
	start --elevate $windowStyle $verbose RunScript "${scriptFile}" || return

	# wait for the creation of the script result file
	[[ $verbose ]] && PrintErr "Waiting for log file in '$dir'..."
	inotifywait --event create --quiet --quiet "$dir/" # two quiets for very silent (no output)
	[[ $verbose ]] && EchoErr "found"

	# show the script log if it was created
	[[ $verbose ]] && { EchoErr "Script file output:"; }
	[[ -f "$scriptLog" ]] && cat "$scriptLog"
	
	# get the script result (return code) if it was created (if the script was killed, cancelled, or interrupted it will not have a result)
	[[ -f "$scriptResult" ]] && scriptResult="$(cat "$scriptResult")"
	log1 "script result: ${RESET}${scriptResult}"

	# cleanup
	rm -fr "$dir"
	
	return "$scriptResult"
}

#
# helper
#

# functions which may be used before we load function.sh
EchoErr() { echo "$@" > /dev/stderr; }
pause() { local response; read -n 1 -s -p "${*-Press any key when ready...}"; echo; }

# loadFunctions - load functions from function.sh
# - look in the path, the current directory, the script directory, and /usr/local/bin
# - sets functionFile to the function file
# - sets scriptDir to the script directory
loadFunctions() 
{
	local file="function.sh" # for debugging
	functionFile="$(type -P "$file")"
	if (( $? != 0 )); then
		functionFile="$PWD/function.sh"
		if [[ ! -f "$functionFile" ]]; then functionFile="${BASH_SOURCE[0]%/*}/$file"
		elif [[ ! -f "$functionFile" ]]; then functionFile="/usr/local/data/bin/$file"
		elif [[ ! -f "$functionFile" ]]; then EchoErr "Unable to find $file"; pause; return 1
		fi
	fi

	[[ ! $functionFile ]] && { EchoErr "RunScript: unable to find the '$file' script"; return 1; }
	. "$functionFile" || { EchoErr "RunScript: unable to run the '$file' script"; pause; return 1; }
	scriptDir="$(GetFilePath "$functionFile")"
}

loadFunctions && . "$scriptDir/script.sh" && ScriptRun "$@"

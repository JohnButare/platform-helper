#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
Manipulate network volumes using the UNC (Universal Naming Convention) format.
The UNC format is //[USER@]SERVER/SHARE[/DIRS].

	get 								get UNC information
	browse							list UNC shares on the local network
	IsAvailable HOST		return true if a host is available for UNC connections
	IsMounted TARGET		return true if the target UNC or path is mounted 
	list HOST						list UNC shares on the specified host
	mount UNC						mount the specified UNC
	unmount TARGET|all	unmount the specified target UNC or path"
}

init()
{
	volumeDir="$(GetRealPath "$HOME/Volumes")"; initVolumeDir || return
	protocolUsage="-p, --protocol=[NFS|SMB|SSH|INTEGER](SMB)"
	uncTypes="cifs,nfs,nfs4,fuse.sshfs"
	uncTypesDf="-t nfs -t nfs4 -t smbfs -t fuse.sshfs"
	uncTypesGrep="${uncTypes//,/|}"
	return 0
}

argStart() { unset -v protocol unc; }

#
# Get Commands
#

getUsage() { echot "\
Usage: unc get [OPTION]... [COMMAND]...
Get information.

	detail								return detailed information for shares mounted in ~/Volumes
	dir UNC	[--root]			return the mounted path of the UNC, i.e. ~/Volumes/server_share/dir1/dir2.
												If --root is specified omit the subdirectories, i.e. ~/Volumes/server_share
	mounts								return all mounted shares in ~/Volumes
	port [-p|--protocol]	return the port for the specified protocol	
	protocol PATH					the protocol used for the mounted path
	protocols [HOST]			return the protocols supported by specified host, or all valid protocols
	unc PATH [--root]			return the UNC of a mounted path, i.e. //server/share/dir1/dir2.
												If --root is specified omit the subdirectories, i.e. //server/share

	$protocolUsage"
}

getCommand() { usage; }

getDetailCommand()
{
	if InPath findmnt; then findmnt --output=TARGET,SOURCE,FSTYPE --types=$uncTypes | grep -e "^TARGET\|$volumeDir"
	elif InPath ${G}df; then ${G}df $uncTypesDf
	else noUncCommand
	fi
}

getMountsCommand()
{
	if InPath findmnt; then findmnt --output=TARGET --types=$uncTypes --noheadings | grep "^$volumeDir"
	elif InPath ${G}df; then ${G}df $uncTypesDf |& ${G}tail -n +2 | awk '{ print $NF }'
	elif InPath mount; then mount | grep -E "type ($uncTypesGrep) " | cut -d" " -f3
	else noUncCommand
	fi
}

# dir
getDirArgStart() { unset -v root unc; }
getDirArgs() { getUncArg "$@"; }
getDirOpt() { getRootOpt "$@"; }
getDirCommand() { getDir$root "$unc"; }

# port
getPortOpt() { protocolOpt "$@"; }
getPortCommand() { getPort "$protocol"; }

# protocol
getProtocolArgs() { getPathArg "$@"; }
getProtocolCommand() { getProtocol "$path"; }

# protocols
getProtocolsArgStart() { unset host; }
getProtocolsArgs() { [[ ! $1 ]] && return; ScriptArgGet "host" -- "$@"; }
getProtocolsCommand() { getProtocols "$host"; }

# UNC
getUncArgStart() { unset -v root; }
getUncArgs() { getPathArg "$@"; }
getUncOpt() { getRootOpt "$@"; }
getUncCommand() {	getUnc$root "$path"; }

#
# IsAvailable Command
#

isAvailableUsage() { echot "Usage: unc IsAvailable [HOST](localhost)
Return true if the specified HOST is available using the specified protocols.
If no protocols are specified search for a protocol to use.

	$protocolUsage"
}

isAvailableArgStart() { unset -v host; }
isAvailableOpt() { protocolOpt "$@"; }
isAvailableArgs() { ScriptArgGet "host" -- "$@"; shift; }
isAvailableCommand() { findProtocol "$host"; }

#
# IsMounted Command
#

isMountedArgs() { ScriptArgGet "target" -- "$@"; shift; }

isMountedCommand()
{
	# check UNC
	if IsUncPath "$target"; then
		getDir "$target" >& /dev/null

	# check path
	elif [[ -e "$target" ]]; then
		getUncRoot "$target" >& /dev/null

	# something else
	else
		false

	fi

	local result="$?"

	# logging
	logMounted "$result" "$target"

	# return result
	return "$result"
}

#
# List Command
#

listUsage()
{
	echot "\
Usage: unc list HOST
List UNC shares on the specified host.

	$protocolUsage
	-N, --no-host-check					do not check host availability"
}

listArgStart() { unset -v port protocol; }
listOpt() { protocolOpt "$@"; }
listArgs() { ScriptArgGet "host" -- "$@" && HostAvailable "$host"; }
listCommand() { protocol="${protocol:-smb}"; RunFunction "list${protocol^}"; }
listNfs() { ssh -t "$host" sudoc exportfs; }
listSsh() { echo "root"; }

listSmb()
{
	if InPath smbutil; then smbutil view "//$host" | grep "Disk"
	elif InPath smbclient; then sudoc smbclient -L $host -U$USER%$(credential -q get secure default) |& grep -v "tdb_new_database" |& grep -v "option is deprecated"
	else EchoErr "unc: unable to list shares for $host"; return 1
	fi
}

#
# Browse Command
#

browseUsage() { echot "Usage: unc browse
List UNC shares on the local network."; }

browseCommand()
{
	{ IsPlatform win || ! InPath "smbtree"; } && { ScriptErr "unable to browse the network"; return 1; }
	sudoc smbtree
}

#
# Mount Command
#

mountUsage()
{
	echot "Usage: unc mount UNC
Mount the specified UNC.

	$protocolUsage
	-N, --no-host-check					do not check host availability"
}

mountArgStart() { unset -v noHostCheck port protocol; }
mountArgs() { getTargetArg "$@"; }

mountOpt() 
{
	protocolOpt "$@" && return
	case "$1" in
		-N|--no-host-check) noHostCheck="true";;
		*) return 1
	esac
}

mountCommand()
{
	local result

	isMountedCheck "$unc" && return

	# ensure server is available
	if ! findProtocol "$server"; then
		[[ ! "$quiet" ]] && ScriptErr "host '$server' is not available"
		return 1
	fi
	log1 "connection will use $protocol"

	# remove an existing share in the mountRoot
	unmount || return

	# create the mount directory
	if [[ ! -d "$mountRoot" ]]; then
		log1 "creating mount root directory '$mountRoot'"
		! ${G}mkdir "$mountRoot" --parents && { ScriptErr "could not create the mount root directory '$mountRoot'"; return 1; }
	fi

	# mount

	# WSL 1
	if [[ "$PLATFORM_KERNEL" == "wsl1" ]] || isWslshare; then
		sudoc mount -t drvfs "//$server/$share" "$mountRoot"

	# NFS
	elif [[ "$protocol" == "nfs" ]]; then
		local options=(); IsPlatform win && options+=( -o nolock )
		sudoc mount "${options[@]}" -t nfs "$server:/$share" "$mountRoot"

	# SSH
	elif [[ "$protocol" == "ssh" ]] || IsInteger "$protocol"; then
		local portArg; IsInteger "$protocol" && portArg=(-p "${protocol}")
		local sudo; IsPlatform qnap && sudo="sudo"
		[[ "$share" == "root" ]] && share=""
		$sudo sshfs -o reconnect -o allow_other -o follow_symlinks "$user@$server:/$share" "$mountRoot" "${portArg[@]}"

	# linux and WSL 2
	elif IsPlatform linux,wsl2; then		

		# add an entry to /etc/fstab so sudo is not required to write to the share		
		if ! grep -i "//$server/$shareId\\\$* $mountRoot cifs username=$user,noauto,rw,users 0 0" /etc/fstab >& /dev/null; then
			local line="//$server/$share $(GetRealPath "$mountRoot") cifs username=$user,noauto,rw,users 0 0"
			sudoc bash -c "echo \"$line\" >> /etc/fstab" || return
		fi

		local password="$(credential -q get secure default)"
		[[ $password ]] && log1 "password found in the credential store"

		[[ $password ]] && export PASSWD="$password"
		$sudo mount.cifs "//$server/$share" "$mountRoot" -o user=$user sec=ntlmsspi
		[[ $password ]] && unset PASSWD

	# macOS
	elif IsPlatform mac; then
		local password="$(credential -q get secure default)"
		[[ $password ]] && log1 "password found in the credential store"

		if [[ $password ]]; then
			log1 "mounting using: mount_smbfs \"smb://$user:XXX@$server/$share\" \"$mountRoot\""
			mount_smbfs "smb://$user:$password@$server/$share" "$mountRoot"
		else
			RunLog mount_smbfs "smb://$user@$server/$share" "$mountRoot"
		fi

	fi

	# return the mounted directory	
	isMountedCheck "$unc" && return

	# mount failed, cleanup 
	unmount; return 1
}

#
# Unmount Command
#

unmountUsage() { echot "Usage: unc unmount UNC|all
Unmount the specified or all mounted UNCs."; }

unmountArgs()
{ 
	[[ "$1" == "all" ]] && { shift=1; unc="all"; return; }
	getTargetArg "$@"
}

unmountCommand()
{
	[[ "$unc" != "all" ]] && { unmount; return; }

	local dirs
	IFS=$'\n' dirs=( $(unc get mounts) )
	[[ ! $dirs ]] && return

	log "unmounting..."
	for mountRoot in "${dirs[@]}"; do
		log "$(GetFileName "$mountRoot")..."; unmount || return
	done
	log "done\n"
	
	return 0
}

#
# Mount/Unmount Helper
#

# assumes the following functions were called: 
# - getTargetArg sets: target unc 
# - getUncInfo sets: unc user server share dirs shareId mountRoot mountDir

# unmount - unmount a share and remove the mount directory
#   The mounted directory may be in an invalid state, and normal file operations on it will fail.
#   To test an invalid state, mount an SSHFS share, logout and reconnect.  ls "$mountRoot" will error with:
#   "ls: cannot access rosie.hagerman.butare.net_root: Input/output error"
unmount()
{
	local dir="$mountRoot"

	# cannot unmount local directories
	isUncLocal "$unc" && return

	# return if the mount directory does not exist
	! mountDirExists "$dir" && return

	# unmount - ignore errors
	case "$PLATFORM" in
		mac)
			local args=(); [[ $force ]] && args+=(force)
			log1 "unmounting with: diskutil unmount ${args[@]} $dir"
			diskutil unmount "${args[@]}" "$dir" >& /dev/null
			;;
		linux|win) 
			log1 "unmounting with: sudoc umount \"$dir\""
			sudoc umount "$dir" >& /dev/null
			;;
	esac
	
	# remove directory - ignore errors
	if [[ -d "$dir" ]]; then
		log1 "removing mount directory '$dir'"
		rmdir "$dir" >& /dev/null
	fi

	# validate removal
	! mountDirExists "$dir" && return

	# unable to remove
	[[ ! $quiet ]] && { EchoErr "unable to remove mount directory '$dir', try --force"; }
	return 1
}

# mountDirExists DIR - return true if the specified mounted directory exists
mountDirExists()
{
	local dir="$1"

	# remove directories, i.e. /home/jjbutare/Volumes/server_share/dir1/dir2 -> /home/jjbutare/Volumes/server_share	
	dir="$(pathRoot "$1")" || return 

	# return if the directory exists
	[[ -e "$dir" ]] && return

	# remove volumeDir path, i.e. /home/jjbutare/Volumes/server_share -> server_share
	local mountDir=

	# check if the mount directory does not exist by looking at the files in the directory
	# as ls "$dir" and "-e $dir" may return return false if the share is in an invalid state
	command ls -1 "$volumeDir" |& grep -q "^"$(GetFileName "$dir")"$"
}

#
# Argument Helpers
#

getPathArg() { ScriptArgGet "path" -- "$@" && ScriptCheckPath "$path"; }
getUncArg() { ScriptArgGet "unc" -- "$@" && ScriptCheckUnc "$unc"; }
getRootOpt() { [[ "$1" == @(-r|--root) ]] && root="Root"; }

# getTargetArg - get target that is either a UNC or a path that is a mounted UNC.  Sets target and unc on return.
getTargetArg()
{
	ScriptArgGet "target" -- "$@"

	# target aliases
	[[ "$target" == "//nas3/root" ]] && target="//nas3/homes/admin/root"

	# target is a mounted file or directory
	[[ -e "$target" ]] && { unc="$(getUnc "$target")" && getUncInfo "$unc"; return; }
	
	# target is a UNC
	validateUnc "$target" || return

	# unc
	getUncInfo "$target" || return

	# file server aliases
	if [[ "$server" == @(home|media|public) ]]; then
		server="$(UpdateGet "FileServer")"; server="$(DnsResolve "$server")" || return
		ScriptEval HostGetInfo "$server" "${protocolArg[@]}" || return
		unc="$(UncMake "$user" "$(GetUncServer "$_root")" "$(GetUncShare "$_root")" "$dirs" "$_protocol")" || return
		noHostCheck="true"
	fi
	
	return 0	
}

#
# Protocol Helper
#

# findProtocol HOST - find a file sharing protocol for HOST.   
findProtocol()
{
	local host="$1"; noHostCheck && return

	log1 "findProtocol: host='$host'"

	# Synology SMB mount.cifs does not work, use sshfs
  IsPlatform synology && [[ "$protocol" == @(|smb) ]] && protocol="ssh"

	# if a specific protocol was requested check it
	[[ $protocol ]] && { isAvailable "$host" "$protocol"; return; }

	isAvailable "$host" "smb" || isAvailable "$host" "nfs" "mount.nfs" || isAvailable "$host" "ssh" "sshfs"
}

getPort()
{
	local protocol="$1" host="$2"

	case "${protocol:-smb}" in
		nfs) echo "111";; # 111 and 2049 
		smb) echo "445";; # 135 and 445
		ssh) SshHelper config get "$host" port;;
		*) echo "$protocol"
	esac
}

#
# helper
#

log() { [[ $quiet ]] && return; printf "$@"; }
noHostCheck() { [[ $noHostCheck ]] || isWslshare; }
protocolOpt() { [[ "$1" == @(-p|--protocol|-p*|--protocol=*) ]] && ScriptOptNetworkProtocol "$@"; }
isWslshare() { [[ "$server" == @(wsl$|wsl) ]]; }
validateUnc() { IsUncPath "$1" && return; [[ ! $quiet ]] && ScriptErr "'$1' is not a UNC"; ScriptExit; }

initVolumeDir()
{
	[[ -d "$volumeDir" ]] && return
	! ${G}mkdir "$volumeDir" && { ScriptErr "Could not create the volume directory $volumeDir"; return 1; }
	return 0
}

# getDir UNC - return the mounted path of the UNC, i.e. ~/Volumes/server_share/dir1/dir2
getDir()
{
	local unc="$1"; validateUnc "$unc"
	local dirs="$(GetUncDirs "$unc")"

	# unc is local to this system
	isUncLocal "$unc" && { echo "/$dirs"; return; }

	# get the mounted root directory of the unc	
	local mountRoot; mountRoot="$(getDirRoot "$unc")" || return

	# return the directory
	echo "$mountRoot/$dirs"
}

# getDirRoot UNC - return the root mounted path of the UNC, i.e. ~/Volumes/server_share
getDirRoot()
{
	local root unc="$1"; validateUnc "$unc"

	# ensure the UNC has the fully qualified server name
	unc="$(GetFullUnc "$unc")" || return

	# get the mountDir from the UNC
	local user server share dirs shareId mountRoot mountDir
	getUncInfo "$unc" || return

	# find the mounted directory
	# - search for mounted UNC types where the destination is the specified mountRoot
	# - do not search for the UNC source as it is different for each protocol and platform.
	#   For example macOS includes the username in in the SMB source.

	# findmnt
	if InPath findmnt; then
		root="$(findmnt --target="$mountRoot" --output=TARGET --types=$uncTypes --noheadings)" || { notAUncShare "$unc"; return; }

	# df
	elif InPath df; then
		root="$(${G}df -P $uncTypesDf |& grep " ${mountRoot}$" | awk '{print $NF}')" || { notAUncShare "$unc"; return; };

	else
		noUncCommand; return

	fi

	echo "$root"
}

# getProtocol PATH - the protocol used for the mounted path
getProtocol() 
{
	local path="$1"

	! InPath findmnt && { noUncCommand; return; }

	local type="$(findmnt --target "$path" --output=FSTYPE --noheadings)"

	case "$type" in
		cifs) echo "smb";;
		fuse.sshfs) echo "ssh";;
		*) echo "$type";;
	esac
}

# getProtocols [HOST] - return the protocols supported by specified host, or all valid protocols
getProtocols()
{
	[[ ! $host ]] && { echo "nfs smb ssh"; return; }
	
	local hostIp; hostIp="$(GetIpAddress "$host")" || return
	local protocols=() 
	IsAvailablePort "$hostIp" "$(getPort "nfs")" && protocols+=( "nfs" )
	IsAvailablePort "$hostIp" "$(getPort "smb")" && protocols+=( "smb" )
	SshIsAvailable "$host" && protocols+=( "ssh" )

	[[ $protocols ]] && ArrayDelimit protocols " " || echo "none"
}

# getUnc PATH - return the UNC of a mounted path, i.e. //server/share/dir1/dir2
getUnc()
{
	local path; path="$(GetFullPath "$1")" || return

	local uncRoot; uncRoot="$(getUncRoot "$path")" || return
	local mountRoot; mountRoot="$(getDirRoot "$uncRoot")" || return
	echo "${path/$mountRoot/$uncRoot}"
}

# getUncRoot PATH - return the root UNC of a mounted path, i.e. //server/share
getUncRoot()
{
	local uncRoot path="$1"; path="$(GetFullPath "$1")" || return

	# use findmnt
	if InPath findmnt; then 
		uncRoot="$(findmnt --target "$path" --output=SOURCE --types=$uncTypes --noheadings)" || { notAUncShare "$path"; return; }

	# use df
	elif InPath ${G}df; then
		local check; check="$(pathRoot "$path")" || return
		uncRoot="$(${G}df -P |& grep " ${check}$" | awk '{print $1}')" || { notAUncShare "$path"; return; }

	else 
		noUncCommand; return

	fi

	# no changes for cifs, i.e. //nas3/public->no change
	[[ "$uncRoot" =~ //.* ]] && { echo "$uncRoot"; return; } 

	# update unc for sshfs, i.e. jjbutare@nas3:/tmp->//nas3/tmp jjbutare@nas3:/->//nas3/root
	uncRoot="//$(RemoveBefore $uncRoot @ | RemoveChar :)"
	[[ "$(GetUncShare "$uncRoot")" == "" ]] && uncRoot="${uncRoot}root"
	echo "$uncRoot"
}

# getUncInfo UNC - UNC format is //[USER@]SERVER/SHARE[/DIRS]
# sets variables: unc user server share dirs shareId mountRoot mountDir
# - unc user server share dirs (parsed from UNC)
# - shareId: santized share name (with dollar signs removed)
# - mountRoot: the root directory for the mounted volume, i.e. ~/Volumes/$server_$shareId.  
#   In Windows shares created when elevated will end in _elevated.
# - mountDir: the full path to the mounted directory, i.e. $mountRoot/$dirs
getUncInfo()
{	
	unc="$1"; validateUnc "$unc" || return

	GetUncUser "$unc" user; [[ ! $user ]] && user="$USER"
	GetUncServer "$unc" server || return; [[ ! $server ]] && { ScriptErr "UNC '$unc' does not include a server"; return 1; }
	GetUncShare "$unc" share || return; [[ ! $share ]] && share="root" 
	GetUncDirs "$unc" dirs
	local p; GetUncProtocol "$unc" p || return; [[ $p ]] && protocol="$p"

	# resolve aliass such as web->pi3.hagerman.butare.net
	# this ensures we can mount the same share under a different alias
	server="$(os name "$server")"

	shareId="${share%%\$}"
	mountRoot="$volumeDir/${server}_${shareId}"
	mountDir="$mountRoot";  [[ $dirs ]] && mountDir="$mountDir/$dirs"

	# WSL 2 elevation - mounted network shares are not visible when not elevated, must mount them to a distinct location
	IsPlatform wsl2 && IsElevated && mountRoot="${mountRoot}_elevated" 

	# MDNS name resolution - Windows does not resolve MDNS natively
	IsPlatform win && IsMdnsName "$server" && { server="$(MdnsResolve "$server")" || return; }

	# log
	[[ ! $getUncInfoLogged ]] && log1 "unc $command: unc='$unc'\n	user=$user protocol=$protocol server=$server share='$share' shareId=$shareId dirs='$dirs'\n	mountRoot='$mountRoot'\n	mountDir='$mountDir'"
	getUncInfoLogged="true"

	return 0
}

# isAvailable HOST PROTOCOL PROGRAM - return true if the file sharing PROGRAM is installed
# and the host is available on the port required for the protcol.   Sets protocol on return.
isAvailable()
{
	protocol="$2"
	local host="$1" program="$3"
	local port="$(getPort "$protocol" "$host")"

	if [[ $program ]] && ! InPath "$program"; then
		log1 "$protocol protocol unavailable ($program not installed)"
		return 1
	fi

	noHostCheck && return

	if [[ $verbose ]]; then
		IsInteger "$protocol" && protocol="ssh"
		PrintErr "$(ScriptPrefix)checking $host $protocol protocol (port $port)..."
		IsAvailablePort "$host" "$port" && EchoErr "available" || EchoErr "not available"
	fi

	IsAvailablePort "$host" "$port"
}

# isMountedCheck UNC - if the UNC is mounted show it's path and return true
isMountedCheck()
{
	local unc="$1"
	local dir; dir="$(quiet="true" getDir "$unc")"
	local result="$?"

	logMounted "$result" "$unc"
	(( $result == 0 )) && [[ ! $quiet ]] && echo "$dir"
	(( $result == 0 ))
}

# isUncLocal UNC - the UNC specifies a location and this machine, and we can determine the full path to the directory (the share is root)
isUncLocal()
{
	local unc="$1"
	! IsUncPath "$1" && return 1
	IsLocalHost "$(GetUncServer "$unc")" && [[ "$(GetUncShare "$unc")" == "root" ]]
}

logMounted()
{
	local result="$1" target="$2"
	[[ ! $verbose ]] && return
	local not; [[ "$result" != "0" ]] && not=" not"
	log1 "'$target' is$not mounted"
}

notAUncShare()
{
	[[ ! "$quiet" ]] && ScriptErr "'$1' is not on a UNC share"
	return 1
}

noUncCommand()
{
	[[ ! "$quiet" ]] && ScriptErr "No UNC commands available (findmnt or df)"
	return 1
}

# pathRoot PATH - return the root of specified path, i.e. /home/jjbutare/Volumes/pi1_root/tmp -> /home/jjbutare/Volumes/pi1_root
pathRoot()
{
	local check
	check="$(GetFullPath "$1")" || return
	check="$(RemoveFront "$check" "$volumeDir/")"
	echo "$volumeDir/${check%%/*}"
}

ScriptRun "$@"
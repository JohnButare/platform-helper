#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
Manipulate network volumes using the UNC (Universal Naming Convention) format.
The UNC format is //[USER@]SERVER/SHARE[/DIRS].

	get 							get UNC information
	browse						list UNC shares on the local network
	IsAvailable HOST	check if a host is available for UNC connections
	IsMounted UNC			check if a UNC is mounted 
	IsUnc FILE				check if a file is a mounted UNC
	list HOST					list UNC shares on the specified host
	mount UNC					mount the specified UNC
	unmount UNC|all		unmount the specified UNC"
}

init()
{
	volumeDir="$HOME/Volumes"; initVolumeDir || return
	protocolUsage="-p, --protocol=[NFS|SMB|SSH|INTEGER](SMB)"
	uncTypes="cifs,nfs,nfs4,fuse.sshfs"; IsPlatform mac && uncTypes="nfs,nfs4,smbfs,fuse.sshfs"
	return 0
}

argStart() { unset -v protocol unc; }
args() { getUncArg "$1"; }

#
# Get Commands
#

getUsage() { echot "\
Usage: unc get [OPTION]... [COMMAND]...
Get information.  TARGET is a UNC or mounted FILE.

	detail						return detailed information for shares mounted in ~/Volumes
	mounts						return all mounted shares in ~/Volumes
	port							return the port for the protocol specified by the protocol argument	
	protocol TARGET		the protocol used for the target
	protocols [HOST]	return the protocols supported by specified host, or all valid protocols
	root TARGET				the mounted root directory of the targer, i.e. ~/Volumes/server_share
	share	TARGET			the UNC server and share of the target, i.e. //server/share
	unc	TARGET				the UNC of the target, i.e. //server/share/dir1/dir2

	$protocolUsage"
}

getArgStart() { file=""; }

getArgs() 
{
	[[ "$command" == @(getDetail|getMounts|getPort|getProtocols) ]] && return
	IsUncPath "$1" && { file="$1"; ((++shift)); return; }
	[[ ! $1 ]] && MissingOperand "TARGET"
	ScriptArgGet "file" -- "$@"; ScriptCheckPath "$file"
}

getCommand() { usage; }

getDetailCommand()
{
	if InPath findmnt; then findmnt --types=$uncTypes --output=TARGET,SOURCE,FSTYPE | grep -e "^TARGET\|$volumeDir"
	elif InPath df; then df -T $uncTypes
	else noUncCommand
	fi
}

# mounts
getMountsCommand()
{
	if InPath findmnt; then findmnt --types=$uncTypes --noheadings --output=TARGET | grep "$volumeDir"
	elif InPath df; then df -T $uncTypes | ${G}tail -n +2 | tr -s " " | cut -d" " -f9-
	else noUncCommand
	fi
}

# port
getPortOpt() { protocolOpt "$@"; }
getPortCommand() { getPort "$protocol"; }

# protocol
getProtocolCommand()
{
	! InPath findmnt && { noUncCommand; return; }

	local fstype="$(findmnt --noheadings --output=FSTYPE --target "$file")"

	case "$fstype" in
		cifs) echo "smb";;
		fuse.sshfs) echo "ssh";;
		*) echo "$fstype";;
	esac
}

# protocols
getProtocolsArgStart() { unset host; }
getProtocolsArgs() { [[ ! $1 ]] && return; ScriptArgGet "host" -- "$@"; }

getProtocolsCommand()
{
	[[ ! $host ]] && { echo "nfs smb ssh"; return; }
	
	local hostIp; hostIp="$(GetIpAddress "$host")" || return
	local protocols=() 
	IsAvailablePort "$hostIp" "$(getPort "nfs")" && protocols+=( "nfs" )
	IsAvailablePort "$hostIp" "$(getPort "smb")" && protocols+=( "smb" )
	SshIsAvailable "$host" && protocols+=( "ssh" )

	[[ $protocols ]] && ArrayDelimit protocols " " || echo "none"
}

getRootCommand()
{
	IsUncPath "$file" && { echo "$(GetUncRoot "$file")"; return; }

	local root result;
	if InPath findmnt; then
		root="$(findmnt --types=$uncTypes --noheadings --output=TARGET --target "$file")" || { notAUncShare; return; }

	elif InPath df; then
		local line; line="$(df -P "$file" | tail -1)" || { notAUncShare; return; };
		! [[ "$line" =~ //.* ]] && { notAUncShare; return; } # UNC shares must start with //
		root="$(echo "$line" | awk '{print $NF}')"

	else
		noUncCommand; return

	fi

	echo "$root"
}

getShareCommand()
{
	IsUncPath "$file" && { echo "$(GetUncShare "$file")"; return; }

	# get the share
	local share
	if InPath findmnt; then 
		share="$(findmnt --types=$uncTypes --noheadings --output=SOURCE --target "$file")" || { notAUncShare; return; }

	elif InPath df; then
		local share; share="$(df -P "$file" | awk 'END{print $1}')" || { notAUncShare; return; }
		! [[ "$share" =~ //.* ]] && { notAUncShare; return; } # UNC shares must start with //

	else 
		noUncCommand; return

	fi

	# cifs: //nas3/public->no change
	[[ "$share" =~ //.* ]] && { echo "$share"; return; } 

	# sshfs: jjbutare@nas3:/tmp->//nas3/tmp jjbutare@nas3:/->//nas3/root
	share="//$(RemoveBefore $share @ | RemoveChar :)"
	[[ "$(GetUncShare "$share")" == "" ]] && share="${share}root"
	echo $share
}

# unc
getUncCommand()
{
	IsUncPath "$file" && { echo "$file"; return; }

	file="$(GetFullPath "$file")" || return
	local root; root="$(getRootCommand)" || return
	
	local share; share="$(getShareCommand)" || return
	echo "${file/$root/$share}"
}

#
# IsAvailable Command
#

isAvailableUsage() { echot "Usage: unc IsAvailable [HOST](localhost)
Return true if the specified HOST is available using the specified protocols.
If no protocols are specified search for a protocol to use.

	$protocolUsage"
}

isAvailableArgStart() { unset -v host; }
isAvailableOpt() { protocolOpt "$@"; }
isAvailableArgs() { ScriptArgGet "host" -- "$@"; shift; }
isAvailableCommand() { findProtocol "$host"; }

#
# List Command
#

listUsage()
{
	echot "\
Usage: unc list HOST
List UNC shares on the specified host.

	$protocolUsage
	-N, --no-host-check					do not check host availability"
}

listArgStart() { unset -v port protocol; }

listOpt() { protocolOpt "$@"; }

listArgs()
{
	ScriptArgGet "host" -- "$@"
	! IsAvailable "$host" && { ScriptErr "host '$host' is not available"; return 1; }
	return 0
}

listCommand() { protocol="${protocol:-smb}"; RunFunction "list${protocol^}"; }

listNfs() { ssh -t "$host" sudoc exportfs; }
listSsh() { echo "root"; }

listSmb()
{
	if InPath smbutil; then smbutil view "//$host" | grep "Disk"
	elif InPath smbclient; then sudoc smbclient -L $host -U$USER%$(credential -q get secure default) |& grep -v "tdb_new_database" |& grep -v "option is deprecated"
	else EchoErr "unc: unable to list shares for $host"; return 1
	fi
}

#
# Browse Command
#

browseUsage() { echot "Usage: unc browse
List UNC shares on the local network."; }

browseCommand()
{
	{ IsPlatform win || ! InPath "smbtree"; } && { ScriptErr "unable to browse the network"; return 1; }
	sudoc smbtree
}

#
# IsMounted Command
#

isMountedUsage() { echot "Usage: unc IsMounted TARGET
List UNC shares on the local network.
TARGET is a UNC or mounted FILE."; }

isMountedCommand() { isMounted; }

#
# IsUnc Command
#

isUncUsage() { echot "Usage: unc IsUnc FILE
Return true if the specified file is a mounted UNC."; }

isUncArgs() { getArgs "$@"; }

isUncCommand() { quiet="--quiet"; [[ $(getRootCommand) ]]; }

#
# Mount Command
#

mountUsage()
{
	echot "Usage: unc mount UNC
Mount the specified UNC.

	$protocolUsage
	-N, --no-host-check					do not check host availability"
}

mountArgStart() { unset -v noHostCheck port protocol; }

mountOpt() 
{
	protocolOpt "$@" && return
	case "$1" in
		-N|--no-host-check) noHostCheck="true";;
		*) return 1
	esac
}

mountCommand()
{
	local result

	# return if the directory is already mounted
	unc="$(isMounted)" && { showResult "$unc"; return; }

	# ensure server is available
	if ! findProtocol "$server"; then
		[[ ! "$quiet" ]] && ScriptErr "host '$server' is not available"
		return 1
	fi
	[[ $verbose ]] && EchoErr "connection will use $protocol"

	# remove an existing share in the mountDir
	cleanupMountDir "$mountDir" || return

	# create the mount directory
	[[ $verbose && ! -d "$mountDir" ]] && { EchoErr "creating mount directory '$mountDir'"; }
	! ${G}mkdir --parents "$mountDir" && { ScriptErr "could not create the mount directory '$mountDir'"; return 1; }

	# mount

	# WSL 1
	if [[ "$PLATFORM_KERNEL" == "wsl1" ]] || isWslshare; then
		sudoc mount -t drvfs "//$server/$share" "$mountDir"

	# NFS
	elif [[ "$protocol" == "nfs" ]]; then
		local options=(); IsPlatform win && options+=( -o nolock )
		sudoc mount "${options[@]}" -t nfs "$server:/$share" "$mountDir"

	# SSH
	elif [[ "$protocol" == "ssh" ]] || IsInteger "$protocol"; then
		local portArg; IsInteger "$protocol" && portArg=(-p "${protocol}")
		[[ "$share" == "root" ]] && share=""
		sshfs -o reconnect -o allow_other -o follow_symlinks "$user@$server:/$share" "$mountDir" "${portArg[@]}"

	# linux and WSL 2
	elif IsPlatform linux,wsl2; then		

		# add an entry to /etc/fstab so sudo is not required to write to the share		
		if ! grep -i "//$server/$shareId\\\$* $mountDir cifs username=$user,noauto,rw,users 0 0" /etc/fstab >& /dev/null; then
			local line="//$server/$share $(GetRealPath "$mountDir") cifs username=$user,noauto,rw,users 0 0"
			sudoc bash -c "echo \"$line\" >> /etc/fstab" || return
		fi

		local password="$(credential -q get secure default)"
		[[ $verbose && $password ]] && EchoErr "password found in the credential store"

		[[ $password ]] && export PASSWD="$password"
		$sudo mount.cifs "//$server/$share" "$mountDir" -o user=$user sec=ntlmsspi
		[[ $password ]] && unset PASSWD

	# macOS
	elif IsPlatform mac; then
		local password="$(credential -q get secure default)"
		[[ $verbose && $password ]] && EchoErr "password found in the credential store"

		if [[ $password ]]; then
			[[ $verbose ]] && { EchoErr "mounting using: mount_smbfs \"smb://$user:XXX@$server/$share\" \"$mountDir\""; }
			mount_smbfs "smb://$user:$password@$server/$share" "$mountDir"
		else
			[[ $verbose ]] && { EchoErr "mounting using: mount_smbfs \"smb://$user@$server/$share\" \"$mountDir\""; }
			mount_smbfs "smb://$user@$server/$share" "$mountDir"
		fi

	fi

	# return the mounted directory
	if isMounted; then
		return 0
	else
		cleanupMountDir
		return 1
	fi
}

#
# Unmount Command
#

unmountUsage() { echot "Usage: unc unmount UNC|all
Unmount the specified or all mounted UNCs."; }

unmountCommand()
{
	[[ "$unc" != "all" ]] && { doUnmount; return; }

	IFS=$'\n' mountDirs=( $(unc get mounts) )
	[[ ! $mountDirs ]] && return

	log "unmounting..."
	for mountDir in "${mountDirs[@]}"; do
		log "$(GetFileName "$mountDir")..."; doUnmount || return
	done
	log "done\n"
	
	return 0
}

#
# Protocol Helper
#

# findProtocol HOST - find a file sharing protocol for HOST.   
findProtocol()
{
	local host="$1"; noHostCheck && return

	# Synology SMB mount.cifs does not work, use sshfs
  IsPlatform synology && [[ "$protocol" == @(|smb) ]] && protocol="ssh"

	# if a specific protocol was requested check it
	[[ $protocol ]] && { isAvailable "$host" "$protocol"; return; }

	isAvailable "$host" "smb" || isAvailable "$host" "nfs" "mount.nfs" || isAvailable "$host" "ssh" "sshfs"
}

# isAvailable HOST PROTOCOL PROGRAM - return true if the file sharing PROGRAM is installed
# and the host is available on the port required for the protcol.   Sets protocol on return.
isAvailable()
{
	protocol="$2"
	local host="$1" program="$3"
	local port="$(getPort "$protocol" "$host")"

	if [[ $program ]] && ! InPath "$program"; then
		[[ $verbose ]] && EchoErr "$protocol protocol unavailable ($program not installed)"
		return 1
	fi

	noHostCheck && return

	if [[ $verbose ]]; then
		IsInteger "$protocol" && protocol="ssh"
		PrintErr "checking $host $protocol protocol (port $port)..."
		IsAvailablePort "$host" "$port" && EchoErr "available" || EchoErr "not available"
	fi

	IsAvailablePort "$host" "$port"
}

getPort()
{
	local protocol="$1" host="$2"

	case "${protocol:-smb}" in
		nfs) echo "111";; # 111 and 2049 
		smb) echo "445";; # 135 and 445
		ssh) SshHelper config "$host" port;;
		*) echo "$protocol"
	esac
}

#
# helper
#

doUnmount() { platformUnmount; cleanupMountDir; }
log() { [[ $quiet ]] && return; printf "$@"; }
needsUnc() { [[ "$command" == @(isMounted|mount|unmount) ]]; }
noHostCheck() { [[ $noHostCheck ]] || isWslshare; }
showResult() { [[ $1 && ! $quiet ]] && echo "$1"; [[ $1 ]]; }
isWslshare() { [[ "$server" == @(wsl$|wsl) ]]; }

cleanupMountDir()
{
	[[ ! -e "$mountDir" ]] && return
	findmnt "$mountDir" >& /dev/null && platformUnmount >& /dev/null
	[[ $verbose && -d "$moundDir" ]] && { EchoErr "removing mount directory '$mountDir'"; }
	rmdir "$mountDir" >& /dev/null
	[[ ! -e "$mountDir" ]]
}

initVolumeDir()
{
	[[ -d "$volumeDir" ]] && return
	! ${G}mkdir "$volumeDir" && { ScriptErr "Could not create the volume directory $volumeDir"; return 1; }
	return 0
}

protocolOpt()
{
	case "$1" in
		-p|--protocol|-p*|--protocol=*) ScriptOptNetworkProtocol "$@";;
		*) return 1
	esac
}

getUncArg()
{
	shift=0; ! needsUnc && return

	local target="$1"; ((++shift))
	unset alias

	# all - valid for unmount command
	[[ "$command" == "unmount" && "$target" == "all" ]] && { unc="all"; return; }

	# alias
	if [[ "$target" == @(home|media|public) ]]; then
		ScriptEval HostGetInfo "$(UpdateGet "FileServer")" "${protocolArg[@]}" || return
		noHostCheck="true" protocol="$_protocol" port="$_port"
		eval target="\$_$target"
	
	# mounted file or directory
	elif [[ -e "$target" ]]; then
		file="$target"; target="$(getUncCommand)"

	fi
	
	# unc
	IsUncPath "$target" && { getUncInfo "$target"; return; }

	MissingOperand "unc"
}

getUncInfo() # GetUncInfo unc - sets server share dirs user shareId mountDir
{	
	unc="$1"; [[ ! $unc ]] && return 1

	GetUncUser "$unc" user
	GetUncServer "$unc" server || return; [[ ! $server ]] && { ScriptErr "UNC '$unc' does not include a server"; return 1; }
	GetUncShare "$unc" share || return; [[ ! $share ]] && share="root" 
	GetUncDirs "$unc" dirs
	local p; GetUncProtocol "$unc" p || return; [[ $p ]] && protocol="$p"

	# resolve aliass such as web->pi3.hagerman.butare.net
	# this ensures we can mount the same share under a different alias
	server="$(os name "$server")"

	shareId="${share%%\$}"
	mountDir="$volumeDir/${server}_${shareId}"

	# WSL 2 elevation - mounted network shares are not visible, must mount them to a distinct location
	IsPlatform wsl2 && IsElevated && mountDir="${mountDir}_elevated" 

	# MDSN name resolution - Windows does not resolve MDNS natively
	IsPlatform win && IsMdnsName "$server" && { server="$(MdnsResolve "$server")" || return; }

	[[ $verbose ]] && HilightErr "unc $command: protocol=$protocol user=$user\n	unc=$unc\n	mountDir=$mountDir\n"

	return 0
}

isMounted()
{
	local unc prefix; IsPlatform mac && prefix="$user@"

	# server is local and we can determine the full path to the locaL directory
	IsLocalHost "$server" && [[ "$share" == "root" ]] && { showResult "/$dirs"; return; }

	# check for a WSL share	
	[[ ! $unc ]] && unc="$(mount | grep "^drvfs on $mountDir" | head -n 1 | cut -d" " -f 3)"

	# check for an SMB share
	[[ ! $unc ]] && unc="$(mount | grep "^//$prefix${server%%.*}.*/$shareId\\\$* on " | head -n 1 | cut -d" " -f 3)"

	# check for an NFS share
	[[ ! $unc ]] && unc="$(mount | grep "^${server%%.*}.*:/$shareId$* on " | head -n 1 | cut -d" " -f 3)"

	# check for an ssh share
	if [[ ! $unc ]]; then
		[[ "$shareId" == "root" ]] && shareId=
		unc="$(mount | grep "^$user@$server:/$shareId on " | head -n 1 | cut -d" " -f 3)"
	fi		
	
	[[ $unc && $dirs ]] && unc="$unc/$dirs"

	showResult "$unc"
}

notAUncShare()
{
	[[ ! "$quiet" ]] && ScriptErr "'$file' is not on a UNC share"
	return 1
}

noUncCommand()
{
	[[ ! "$quiet" ]] && ScriptErr "No UNC commands available (findmnt or df)"
	return 1
}

platformUnmount()
{
	case "$PLATFORM" in
		mac) 
			[[ $verbose ]] && EchoErr "unmounting with: osascript -e \"tell application Finder -e "eject $(GetFileName "$mountDir") -e "end tell"
			osascript -e "tell application \"Finder\"" -e "eject \"$(GetFileName "$mountDir")\"" -e "end tell"
			;;
		linux|win) 
			[[ $verbose ]] && EchoErr "unmounting with: sudoc umount \"$mountDir\""
			sudoc umount "$mountDir"
			;;
	esac
}

ScriptRun "$@"

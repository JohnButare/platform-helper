#!/usr/bin/env bash
. function.sh

usage()
{
	echot "\
usage: HostUtil available|boot|connect|info|start|ip
	available	<host>						check if host is available, use fully qualified DNS 
															host name to avoid name resolution lookup time
	boot <host>|(<ip> <mac>)		boot the host
	connect <host>|(<ip> <mac>)	boot and remote control the host
	file cd|view|edit|update		manipulate the local host name files
	info <host> [<var>]		 			get host information, variables are
		${fields[*]}
	start <host> <program>			start a program on host using ssh or psexe
	-e, --eval									return variables to evaluate
	-t, --timeout								milliseconds to wait for the host, default 500
	-w, --wait [seconds](120)		wait for the host to become available 
	-q, --quiet									minimize messages"
	exit $1
}

init() 
{
	unset command host quiet wait
	fields=(host network sleep backup mobile install virtual platform port wake ips macs)
	fieldDefaults=(- - no no no no no - yes no -)
	timeout=(--timeout 500)
}

args()
{
	while [ "$1" != "" ]; do
		case "$1" in
			--eval|-e) eval="true";;
			--help) usage 0;;
			--timeout|-t) timeout=(--timeout $2); shift;;
			--quiet|-q) quiet=(--quiet);;
			--wait|-w) IsInteger $2 && { wait=(--wait $2); shift; } || wait=(--wait 120);;
			*) 
				[[ ! $command ]] && IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				! IsOption "$1" && [[ ! $host && "$command" == @(available|boot|connect|info|name|start) ]] && { GetHostArg "$@"; shift; continue; }	
	 			[[ "$command" == @(file|info|start) ]] && break
				UnknownOption "$1"
		esac
		shift
	done
	[[ ! $command ]] && MissingOperand "command"
	[[ ! $host && "$command" == *(available|boot|connect|info|name|start) ]] && MissingOperand "host"
	args=("$@")
}

GetHostArg()
{
	[[ $# == 0 ]] && MissingOperand "host"
	host="${1,,}"
}

GetMacAddressArg()
{
	[[ $# == 0 ]] && MissingOperand "mac address"
	mac="$1"
}

run() {	init; args "$@"; ${command}Command "${args[@]}"; }

availableCommand()
{
	case "$host" in
		butare.net) return 0
	esac

	AvailableCheck && { AvailableReturn; return 0; }
	[[ ! $wait ]] && return 1

	PrintErr "Waiting ${wait[1]} seconds for $host..."

	for (( i=1; i<=${wait[1]}; ++i )); do
 		read -n 1 -t 1 -s && { EchoErr "cancelled after $i seconds"; return 1; }
		AvailableCheck && { EchoErr "found in $i seconds"; AvailableReturn; return 0; }
		PrintErr "."
	done

	PrintErr "not found"
	return 1
}

AvailableCheck() { CheckHost $host ${timeout[1]}; }
AvailableReturn() { [[ $eval ]] && ScriptReturn pingTime; }

# CheckHost HOST TIMEOUT, sets pingTime - check if HOST is available minimizing the time taken
#	if the hostname is not found, or if the hostname is found and the host is not available
CheckHost()
{
	local host="$1" timeout="$2" timeoutIncrease=0 ip port platform
	unset pingTime 

	case "$host" in
		ExampleHostNeedingExtraPingTime) timeoutIncrease=200;;
	esac
	(( timeout += $timeoutIncrease ))

	if ! IsIpAddress "$host" && ScriptEval HostUtil info $host && [[ "$network" == "Wiggin" ]]; then
		host="${ips[0]}"
	fi

	# Mac's respond to ping when asleep if any sharing services are enabled
	{ ! IsInteger "$port" && [[ "$platform" == "mac" ]] ; } && port=88
	CheckHost${PLATFORM^}  # uses host ip timeout, sets pingTime
}

CheckHostMac()
{
	if IsInteger "$port"; then
		! ConnectToPort $host $port $timeout && return 1
		[[ ! $eval ]] && return 0
	fi
	pingTime="$(PingResponse $host $timeout)"
}

CheckHostWin()
{
	local pingResult

	if IsInteger "$port"; then
		ConnectToPort $host $port $(( timeout * 2 )) || return 1
		[[ $eval ]] && PingWin "$host"
	else
		# two checks increase reliability over a shorter timeout
		local pingHost="$host" result; [[ $ip ]] && pingHost="$ip"	
		PingWin "$pingHost"; [[ "$pingResult" == "Request timed out." ]] && PingWin "$pingHost" 
		[[ "$pingResult" == @(|Request timed out.) ]] && return 1
	fi
	return 0
}

PingWin()
{
	local timeoutCheck="^Request timed out.$" successCheck="^Reply from .*time(=|<).*$" 
	pingResult="$(ping -n 1 -w $timeout $host |& egrep "$timeoutCheck|$successCheck")"
	pingTime="${pingResult#*time@(=|<)}"; pingTime="${pingTime%ms *}"
}

nameCommand()
{
	case "$host" in
		$COMPUTERNAME) echo "${host}"; return 0;;
		nas) echo "nas"; return 0;; 
		nasc) echo "nasc"; return 0;; 
	esac

	infoCommand > /dev/null && { echo "${host%w}"; return 0; } # remove wireless nomenclature (w at end) for HostInfo.txt

	quiet=(--quiet)
	name="$(startCommand hostname)"
	[[ ! $name ]] && name="$host"
	name="${name,,}" # remove spaces
	name="${name%%\.*}" # remove DNS suffix
	echo "$name"	
}

startCommand()
{
	availableCommand || { [[ ! $quiet ]] && echo "$host is not available"; return 1; }

	if ConnectToPort $host 22 $(( ${timeout[1]}*3 )) ; then
		ssh $host "$@"
	else
		platform="$(infoCommand platform)"
		[[ "$platform" == "win" ]] && psexec '\\'$host "$@" 2> /dev/null
	fi
}

infoCommand()
{
	local field

	(( $# > 0 )) && { field="$1"; shift; GetInfoFieldIndex "$field"; fieldIndex="$?"; }

	[[ $# != 0 ]] && usage 1

	local file="$BIN/HostInfo.txt"
	[[ ! -f "$file" ]] && file="$(GetBatchDir)/HostInfo.txt"
	[[ ! -f "$file" ]] && { EchoErr "HostUtil: unable to locate HostInfo.txt"; return 1; }

	line=( $(grep -i "^$host[	 ]" "$file") )
	[[ ! $line ]] && return 1

	# Specific field
	[[ $field ]] && { GetInfoValue $fieldIndex; echo "${!field}"; return; }

	# All fields
 	for (( i=0; i<${#fields[@]}; ++i )); do GetInfoValue $i; done
 	ScriptReturn "${fields[@]}"
}

GetInfoValue() # GetInfoValue index - uses fields, fieldDefaults, line[], sets the field name
{
	local index="$1" 
	local field="${fields[$index]}"
	eval ${field}="${line[$index]}"

	case "$field" in
		ips|macs) IFS='-' read -r -a $field <<< "${!field}";;
		*) [[ "$value" == "-" ]] && $field="${fieldDefaults[$index]}";;
	esac
}

GetInfoFieldIndex()
{
	IsInArray "$1" fields && return $isInIndex
	EchoErr "$field is not a valid variable.  Valid variables are ${fields[@]}"; exit 1;
}

connectCommand()
{
	if ! HostUtil available "$host" && [[ "$(HostUtil info "$host" macs)" != "" ]]; then
		HostUtil boot "$host" --wait 30 || return
	fi
	
	# [[ "$(HostUtil info "$host" platform)" == "win" ]] && ConnectWindows || ConnectOther
	ConnectWindows
}

ConnectOther() { echo VisionApp "$host"; }

ConnectWindows()
{
	local suffix="Remote Desktop/$host.rdp" rdp

	ScriptEval os FindDirs || return

	if [[ -f "$_udata/$suffix" ]]; then
		rdp="$_udata/$suffix"
	elif [[ -f "$_cloud/data/$suffix" ]]; then
		rdp="$_cloud/data/$suffix"
	fi

	if [[ $rdp ]]; then
		start "$rdp"
	else
		start mstsc /f /v:$host
	fi
}

bootCommand()
{
	local ip="$host" mac subNet=255.255.255.0

	IsIpAddress "$host" && { GetMacAddressArg "$1"; shift; }
	[[ $# != 0 ]] && UnknownOption "$1"

 	HostUtil available "$host" && { echo "Host $host is already awake"; return; }

	if [[ ! $mac ]]; then
		ScriptEval HostUtil info "$host" && { ip="${ips[0]}"; mac="${macs[0]}"; }
	fi

	[[ ! $mac ]] && { MissingOperand "mac address"; }

 	echo "Sending wakeup packet to $host..."
	case "$PLATFORM" in
		win) PowerOff wol -ip "$ip" -subnet "$subNet" -mac "$mac" || return;;
		mac) wakeonlan "${mac:0:2}:${mac:2:2}:${mac:4:2}:${mac:6:2}:${mac:8:2}:${mac:10:2}" || return;; # 00113217a755
	esac
}

fileCommand()
{
	local hostFileDir="$WINDIR/system32/drivers/etc"
	local command="file"; [[ $# > 0 ]] && ProperCase "$1" command; IsFunction File${command}Command && shift;
	[[ $# != 0 ]] && UnknownOption "$1"
	File${command}Command "$@"
}

FileCdCommand() { echo "$hostFileDir"; }
FileEditCommand() { IsElevated && start notepad "$hostFileDir/hosts" || sudo --hide HostUtil file edit; }

run "$@"

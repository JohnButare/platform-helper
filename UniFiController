#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" app script || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [api|backup|device|disconnect|info|ls|network|port](api)
Manage the UniFi controller.

	ap 					Access Point commands
	api 				call an API command
	backup			backup the controller configuration
	info				show UniFi device and client information
	port				configure port forwarding"
}

init()
{	
	site="default"
  cookie=$(mktemp)
	curl="curl --tlsv1 --cookie $cookie --cookie-jar $cookie --insecure"
}

argStart() { unset -v apiInitialized; }

cleanup()
{
	[[ $apiInitialized ]] && { apiCleanup || return; }
	return 0
}

#
# commands
#

networkUsage() { echot "Usage: $(ScriptName) network [ls](ls)"; }
networkCommand() { networkLsCommand; }
networkLsCommand() { apiGetDevice | jq '.data[1].network_table[] | { network: .name, interface: .gateway_interface_name } | select(.interface != null)'; }

#
# Access Point (AP) commands
#

apUsage() {	echot "Usage: $(ScriptName) ap [status](status) [HOST]"; }
apArgs() { ScriptArgGet "host" -- "$@"; }
apCommand() { apStatusCommand; }
apStatusUsage() { EchoWrap "Usage: $(ScriptName) ap status\nShow the status of all wireless interfaces on the access point."; }
apStatusCommand() { SshHelper "$host" iwconfig |& grep -v "no wireless" | grep -v '^$' | grep -v "Invalid misc" | grep -v "xauth" | sed 's/sh: //'; }

#
# API command
#

apiUsage()
{
	EchoWrap "Usage: $(ScriptName) api [available|put] [URI](/stat/sta) [JSON]({})
Perform an API command.

Examples:
	/stat/sta - all client status
	/stat/health
	/stat/device"
}

apiArgStart() { uri="/stat/sta" json="{}"; }

apiArgs()
{
	(( ! $# )) && return; ScriptArgGet "uri" -- "$@" || return; shift
	(( ! $# )) && return; ScriptArgGet "json" -- "$@" || return; shift
	return 0
}

apiCommand() { api "$uri" "$json"; }
apiAvailableCommand() { apiInit; }
apiPutCommand() { apiPut "$uri" "$json"; }

#
# backup command
#

backupCommand()
{
	hilight "Backing up UniFiController..."

	# initialize
	apiInit || return
	local dest="$1" result; [[ ! $dest ]] && { dest="$(AppGetBackupDir)/unifi.controller.unf" || return; }
	[[ -f "$dest" ]] && { bak --move "$dest" || return; }

  # ask controller to do a backup, response contains the path to the backup file
  printf "backup..."
  result="$($curl --silent --data '{"cmd":"backup", "days": 0}' "$url/api/s/$site/cmd/backup")"
  path="$(echo $result | sed -n 's/.*\(\/dl.*unf\).*/\1/p')"

  # download the backup to the destinated output file
  echo "download..."
  $curl "$url$path" -o "$dest"
}

#
# device commands
#

deviceUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) device delete|disconnect|default
Device commands."
}

deviceDefaultCommand() { UniFiController api /rest/user | jq '.data[] | select(.name == null) | .mac' | RemoveQuotes | sort; }

# macArgs - set macs to ["mac1",...]
macArgs()
{
	[[ ! $1 ]] && { MissingOperand "mac"; return; }
	shift="$#"

	# get default (unconfigured) devices
	if [[ "${1,,}" == "default" ]]; then
		macs="$(deviceDefaultCommand | NewlineToSpace;)" || return
		set -- $macs
	fi

	# format the macs as a JSON array
	local mac; macList="$@" macs="["
	for mac in "$@"; do
		ScriptCheckMac "$mac"
		macs+="\"$mac\","
	done
	macs="$(RemoveEnd "$macs", ",")]" && macCount="$#"
}

deviceCommand() { usage; }

#
# device delete command
#

deviceDeleteUsage() { ScriptUsageEcho "Usage: $(ScriptName) device delete MAC default|MAC...\nDelete the device with the specified MAC address, or all default (unconfigured) device."; }
deviceDeleteArgs() { macArgs "$@"; }

deviceDeleteCommand() 
{
	apiInit || return

	printf "Deleting ${macCount} device(s)..."
 	local result; result="$($curl --silent --data '{"cmd":"forget-sta", "macs": '$macs'}' "$url/api/s/$site/cmd/stamgr")"
 	apiError "$result" && echo "done"
}

#
# device disconnect command
#

deviceDisconnectUsage() { ScriptUsageEcho "Usage: $(ScriptName) device disconnect MAC\nDisconnect the device with the specified MAC address."; }
deviceDisconnectArgs() { ScriptArgGet "mac" -- "$@" && ScriptCheckMac "$mac"; }

deviceDisconnectCommand() 
{
	local name="$(DnsResolveMac "$mac")"
	local desc="$mac"; [[ $name ]] && desc="$name ($mac)"
	apiInit || return

	printf "Disconnecting $desc..."
 	local result; result="$($curl --silent --data '{"cmd":"kick-sta", "mac": "'$mac'"}' "$url/api/s/$site/cmd/stamgr")"
 	apiError "$result" && echo "done"
}

#
# Info Commands
#

infoUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) info [summary]
Show UniFi device and client information.

	-c,	--clients		show clients (hosts) that are connected to the UniFi Controller network
	-d,	--devices		show UniFi devices
	-w, --wireless	show wireless clients
	-wi, --wired		show wired clients"
}

infoArgStart() { unset -v clients devices summary wired wireless; }

infoOpt() 
{
	case "$1" in
		-c|--clients) clients="true";;
		-d|--devices) devices="true";;
		-wi|--wired) wired="true";;
		-w|--wireless) wireless="true";;
		*) return 1
	esac
}

infoCommand()
{
	[[ $devices ]] && { apiGetDevice | jq; return; }
	[[ $clients ]] && { api "/stat/sta" | jq; return; }
	[[ $wired ]] && { api "/stat/sta" | jq '.data | .[] | select(.is_wired == true)'; return; }
	[[ $wireless ]] && { api "/stat/sta" | jq '.data | .[] | select(.is_wired == false)'; return; }
}

infoSummaryCommand()
{
	InitColor || return
	[[ $devices ]] && { infoSummaryDevices || return; }
	[[ $clients ]] && { infoSummaryWired || return; infoSummaryWireless || return; }
	[[ ! $clients && $wired ]] && { infoSummaryWired || return; }
	[[ ! $clients ]] && [[ $wireless ]] && { infoSummaryWireless || return; }
	return 0
}

infoSummaryDevices()
{
	local sep="#"	
	{		
		hilight ${GREEN}"name${sep}type${sep}model${sep}ap${sep}depth${sep}architecture${sep}cpu${sep}mem${sep}power${sep}used${sep}ports${sep}clients${sep}temp${sep}fan${sep}EOL${RESET}"
		apiGetDevice | jq '.data | .[] | { a: .name, b: .type, c: .model, d: .is_access_point, e: .uplink_depth, f: .architecture, g: .["system-stats"].cpu, h: .["system-stats"].mem, i: .total_max_power,
			j: if (.total_used_power | type) == "number" then ((.total_used_power * 100 | round) / 100) else .total_used_power end,
			k: .port_table | length, l: .num_sta, m: .general_temperature, n: .fan_level, o: .model_in_eol } | join("'${sep}'")' | \
			RemoveQuotes | sort --ignore-case | \
			awk 'BEGIN { FS="'${sep}'"; }; { print $1 FS $2 FS $3 FS $4 FS $5 FS $6 FS $7 FS $8 FS $9 FS $10 FS $11 FS $12 FS $13 FS $14 FS $15; }'
	} | ${G}column -c $(tput cols -T "$TERM") -t -s${sep}
}

infoSummaryWired()
{
	local sep="#"	
	{
		hilight ${GREEN}"DNS${sep}switch${sep}port${sep}depth${sep}Mbps${sep}sat${sep}anomalies${sep}retries${RESET}"
		apiGetClient | jq '.data | .[] | select(.is_wired == true) | { a: .name, b: .sw_mac, c: .sw_port, d: .sw_depth, e: .wired_rate_mbps, f: .satisfaction, g: .anomalies, h: .tx_retries } | join("'${sep}'")' | \
			RemoveQuotes | sort --ignore-case | \
			awk 'BEGIN { FS="'${sep}'"; }; { cmd="RunFunction.sh DnsResolveMac --quiet " $2; cmd | getline sw; close(cmd); print $1 FS sw FS $3 FS $4 FS $5 FS $6 FS $7 FS $8; }'
	} | ${G}column -c $(tput cols -T "$TERM") -t -s${sep}
}

infoSummaryWireless()
{
	local sep="#"
	{
		hilight "${GREEN}DNS${sep}network${sep}AP${sep}channel${sep}sat${sep}retries${sep}signal${sep}noise${RESET}"
		apiGetClient | jq '.data | .[] | select(.is_wired == false) | { a: .name, b: .essid, c: .ap_mac, d: .channel, e: .satisfaction, f: .tx_retries, g: .signal, h: .noise } | join("'${sep}'")' | \
			RemoveQuotes | sort --ignore-case | \
			awk 'BEGIN { FS="'${sep}'"; }; { cmd="[[ '$3' != '' ]] && RunFunction.sh DnsResolveMac --quiet " $3; cmd | getline ap; close(cmd); print $1 FS $2 FS -$3- FS $4 FS $5 FS $6 FS $7 FS $8; }'
	} | ${G}column -c $(tput cols -T "$TERM") -t -s${sep}
}

infoTempCommand()
{
	apiGetDevice | jq '.data | .[] | select(.has_temperature == true) | "\(.name),\(.general_temperature)"' | RemoveQuotes | ${G}sed 's/,/: /' | ${G}sed 's/$/Â°C/'; 
}

#
# Ls Commands
#

lsUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) ls
List UniFi devices.

	-d, 		 --detail					show more detail
	-a,	-ap, --access-point		access points
	-s,	-sw, --switch					switches
	-g, -gw, --gateway				gateways"
}

lsArgStart() { unset -v detail what; }

lsOpt() 
{
	case "$1" in
		-d|--detail) detail="--detail";;
		-a|-ap|--access-point) what="uap";;
		-s|-sw|--switch) what="usw";;
		-g|-gw|--gateway) what="uxg";;
		*) return 1
	esac
}

lsCommand()
{
	local type; [[ $what ]] && type='select(.type == "'$what'") |'

	if [[ $detail ]]; then
		apiGetDevice | jq "$(cat <<-EOF
			.data | .[] |
			$type
			"\(.name),\(.model),\(.mac),\(if .lan_ip != null then .lan_ip else .ip end),\(.device_id)"
			EOF
		)" | RemoveQuotes
		return
	fi

	apiGetDevice | jq "$(cat <<-EOF
		.data | .[] | $type if .lan_ip != null then .lan_ip else .ip end
		EOF
	)" | RemoveQuotes | DnsResolveBatch | sort
}

#
# PoE Commands
#

poeUsage()
{
	echot "Usage: $(ScriptName) poe HOST PORT|all on|off|status
Control PoE ports for host."
}

poeArgStart() { unset -v host; port="all"; }

poeArgs()
{
	ScriptArgGet "host" -- "$@" || return; shift
	(( ! $# )) && return
	ScriptArgGet "port" -- "$@" || return; shift
}

poeCommand() { usage; }

poeStatusUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) poe status HOST PORT|all
Show PoE port status.

	-d, 		 --detail					show more detail"
}

poeStatusOpt() 
{
	case "$1" in
		-d|--detail) detail="--detail";;
		*) return 1
	esac
}

poeStatusArgStart() { unset -v detail; }
poeStatusCommand() { poeStatus "$host" "$port"; }
poeOnCommand() { poeEnable "$host" "$port" true; }
poeOffCommand() { poeEnable "$host" "$port" false; }

# poeEnable HOST PORT true|false - enable or disable PoE on the port
poeEnable()
{
	local info; info="$(force="--force" deviceInfo "$host")" || return
	
	# SSH turns ports on and off faster
	if sshAvailable "$info"; then
		poeEnableSsh "$@"
	else
		poeEnableApi "$info" "$@"
	fi
}

# poeEnableApi HOST PORT true|false - enable or disable PoE on the port using the API
poeEnableApi()
{
	local info="$1" host="$2" port="$3" mode="auto"; [[ "$4" == "false" ]] && mode="off"	
	local id; id="$(deviceId "$info")" || return
	local portInfo; portInfo="$(poeInfo "$info" "$port")" || return
	local currentMode; currentMode="$(echo "$portInfo" | jq '.poe_mode' | RemoveQuotes)" || return

	# check current status
	log1 "mode=$mode currentMode=$currentMode"
	if [[ ! $force && "$currentMode" == "$mode" ]]; then
		[[ ! $quiet ]] && echo "'$host' port '$port' is already $([[ "$mode" == "off" ]] && echo "disabled" || echo "enabled")"
		return
	fi

	# change status
	local result; result="$(apiPut "/rest/device/$id" "$(cat <<-EOF
		{
      "port_overrides": [{
        "port_idx": $port,
        "poe_mode": "$mode"
			}]
  	}
		EOF
	)")" || return

	log2 "$(echo "$result" | jq)"
}

# poeEnableSsh HOST PORT true|false - enable or disable PoE on the port using SSH
poeEnableSsh()
{
	local host="$1" port="$2" enable="$3"

	# turn on the switch port
	if [[ "$enable" == "true" ]]; then
		sshSwitch "admin@$host" swctrl poe set auto id $port || { ScriptErr "unable to turn on '$host' port '$port'"; return 1; }	
		return 0
	fi

	# turn off the switch port - first try can fail
	if ! sshSwitch "admin@$host" swctrl poe set off id $port; then
		printf "port..."
		if ! sshSwitch "admin@$host" swctrl poe set off id $port; then
			ScriptErr "unable to turn off '$host' port '$port'"
			return 1
		fi
	fi

	return 0	
}

# poeInfo DEVICE_INFO PORT - return port information from the device information
poeInfo()
{
	local info="$1" port="$2"

	# integer
	! IsInteger "$port" && { ScriptErr "port '$port' must be numeric"; return ; }

	# in range
	local portInfo; portInfo="$(echo "$info" | jq '.port_table | .[] | select(.port_idx == '$port')' | RemoveQuotes)" || return
	[[ ! $portInfo ]] && { ScriptErr "port '$port' is not valid"; return; }

	echo "$portInfo"
}

# poeStatus HOST PORT
poeStatus()
{
	local info; info="$(force="--force" deviceInfo "$host")" || return

	# API status not valid for some time if used SSH to turn ports on or off
	if sshAvailable "$info"; then
		poeStatusSsh "$@"
	else
		poeStatusApi "$info" "$@"
	fi
}

poeStatusApi()
{
	local info="$1" host="$2" port="$3"
	local portDetail='"\(.port_idx),\(.poe_mode),\(.media),\(.speed) Mbps,\(.poe_class),\(.poe_power) W,\(.max_poe_power) W"'

	# all ports
	if [[ "$port" == "all" ]]; then
		echo "$info" | jq '.port_table | .[] | '"$portDetail" | RemoveQuotes
		return
	fi

	# specific port
	local portInfo; portInfo="$(poeInfo "$info" "$port")" || return

	if [[ $detail ]]; then
		echo "$portInfo" | jq "$portDetail" | RemoveQuotes
	else
		local mode; mode="$(echo "$portInfo" | jq '.poe_mode' | RemoveQuotes)"
		case "$mode" in
			auto) echo "on";;
			off) echo "off";;
			*) echo "$mode";;
		esac
	fi
}

poeStatusSsh()
{
	local host="$1" port="$2"

	# logging
	(( verboseLevel > 1 )) && SshHelper connect "admin@$host" "${globalArgsLessVerbose[@]}" -- swctrl poe show id "$port" >& /dev/stderr

	# get the status
	local result status; status="$(SshHelper connect "admin@$host" "${globalArgsLessVerbose[@]}" -- swctrl poe show id "$port" 2>&1)"
	if (( $? != 0 )); then
		[[ "$status" =~ ': Invalid "id"'$ ]] && { ScriptErr "switch '$host' port $port is not valid"; return 1; }
		EchoErr "$status"; return 1
	fi

	# parse the status
	echo "$status" |& cut -c7-13 | grep --quiet "Auto" && echo "on" || echo "off"
}
#
# Port Commands
#

portUsage()
{
	echot "Usage: $(ScriptName) port [ls|enable|disable|host](list)
Perform an API command.

	ls							list all port forwarding rules
	enable PORT			enable specified port forwarding rule
	disable PORT		disable specified port forwarding rule
	host PORT HOST 	update the host for the specified port forwarding rule"
}

portCommand() { portLsCommand; }
portLsCommand() { getPorts; }

portDisableArgs() { ScriptArgGet "port" -- "$@"; }
portDisableCommand() { portEnable "$port" "false"; }
portEnableArgs() { ScriptArgGet "port" -- "$@"; }
portEnableCommand() { portEnable "$port" "true"; }
portHostArgs() { ScriptArgGet "port" -- "$@" && shift && ScriptArgGet "host" -- "$@"; }
portHostCommand() { portHost "$port" "$host"; }

# portEnable PORT true|false - enable or disable the specified port forwarding rule
portEnable()
{
	local port="$1" status="$2"
	local id; id="$(getPortId "$port")" || return
	apiPut "/rest/portforward/$id" '{ "enabled": '$status' }' | jq
}
# portHost PORT HOST - update the host for the specified port forwarding rule
portHost()
{
	local port="$1" host="$2"
	local id; id="$(getPortId "$port")" || return
	apiPut "/rest/portforward/$id" '{ "fwd": "'$host'" }' | jq
}

# getPortId NAME - get the ID of the specified port forwarding rule
getPortId()
{
	local name="$1"
	local id; id="$(getPorts | jq ".data[] | select(.name == \"$name\")._id" | RemoveQuotes)" || return
	[[ "$id" == "null" ]] && unset id
	[[ ! $quiet && ! $id ]] && EchoErr "port forwarding rule '$name' not found"
	[[ $id ]] && echo "$id"
}

getPorts() { api "/list/portforward"; }

#
# API Helper
#

api()
{
	local uri="$1" json="$2"
	apiInit || return
	RunLog $curl -X GET --silent --data "$json" "$url/api/s/$site/$(echo "$uri" | RemoveFront "/")"
}

apiPut()
{
	local uri="$1" json="$2"
	apiInit || return
	RunLog $curl -X PUT --silent --data "$json" "$url/api/s/$site/$(echo "$uri" | RemoveFront "/")"
}

apiInit()
{
	[[ $apiInitialized ]] && return
	
	# get configuration

	log1 "getting API username and password from the credential store"
  user="$(credential get unifi user --fallback)" || return
  password="$(credential get unifi password --fallback)" || return

  log1 "getting API URL from the service catalog or credential store"
  if ! url="https://$(GetServer "unifi" --quiet "${globalArgs[@]}"):8443"; then
  	log1 "getting API username and password from the credential store"
  	url="$(credential get unifi url --fallback | RemoveTrailingSlash)" || return
  fi

  server="$(GetUriServer "$url")" || return
  port="$(GetUrlPort "$url")" || return

	log1 "user='$user' url='$url' server='$server' port='$port'"

	# check if the API is available
	if ! IsAvailablePort "$server" "$port"; then
		ScriptErrQuiet "The UniFi Controller on '$server' is not available on port '$port'" 
		return 1
	fi

	# initialize API
	if [[ $verbose ]]; then
  	RunLog $curl --silent --data '{"username":"'$user'", "password":"'$password'"}' "$url/api/login"
  else
  	RunLog $curl --silent --data '{"username":"'$user'", "password":"'$password'"}' "$url/api/login" > /dev/null
  fi
  local result="$?"

  # error
  if (( $result != 0 )); then
  	ScriptErr "unable to initialize API"
  	$curl --data '{"username":"'$user'", "password":"'$password'"}' "$url/api/login"
  	return 1
  fi

  apiInitialized="true"
}

apiCleanup()
{
	$curl --silent "$url/logout" > /dev/null
	rm -f "$cookie"
}

# apiError JSON - show and return an error from the API
apiError()
{
	local json="$1"
	local rc="$(echo "$json" | jq '.meta.rc' | RemoveQuotes)"
	[[ "$rc" == "ok" ]] && return
	ScriptErrQuiet "$(echo "$json" | jq '.meta.msg' | RemoveQuotes)"
}

apiGetClient()
{
	local cache="unifi-controller-client"
	[[ ! $force ]] && { UpdateGet "$cache" && return; }
	local client; client="$(api "/stat/sta" | jq)" || return
	UpdateSet "$cache" "$client"
	echo "$client"
}

apiGetDevice()
{
	local cache="unifi-controller-device"
	[[ ! $force ]] && { UpdateGet "$cache" && return; }
	local device; device="$(api "/stat/device" | jq)" || return
	UpdateSet "$cache" "$device"
	echo "$device"
}

#
# helper
#

# deviceInfo DEVICE_INFO - get device ID from device information
deviceId() { echo "$1" | jq '.device_id' | RemoveQuotes; }

# deviceInfo HOST - get device information for host
deviceInfo()
{
	local host="$1"
	local mac; mac="$(MacLookup "$host")" || return
	local info; info="$(apiGetDevice | jq '.data | .[] | select(.mac == "'$mac'")')" || return
	[[ ! $info ]] && { ScriptErr "'$host' is not a valid Unifi device"; return 1; }
	echo "$info"
}

# sshAvailable DEVICE_INFO - return true if the device is able to SSH
sshAvailable()
{
	local info="$1"
	local model; model="$(echo "$info" | jq '.model' | RemoveQuotes)" || return 
	[[ "$model" != @(USWED37) ]]
}

# study-desk-old-switch requires ServerAliveInterval >= 2
sshSwitch() { ssh -o ServerAliveInterval=2 "$@"; }

ScriptRun "$@"

#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: credential
Interact with a credential store.

Common commands:
	get[s]		get a credential
	set				set a credential

Other commands:
	check		check if a credential manager is installed
	copy		copy credentials from one path to another
	delete  delete a credential
	engine	manage credential engines
	exists 	check if a credential exists
	list 		list credentials
	manager	show the the GUI manager
	mirror	mirror credentials from one credential manager to another
	status	show the credential manager status
	sync		synronize credentials from one credential manager to another
	type		show the type of the credential manager in use

Options:
	-e, --engine=ENGINE 	physical storage engine for credentials
	-f, --fallback			 	fallback to a remote credential manager if possible
	-x, --exclude-managers=MANAGERS	exclude the comma separated list of managers
	-m, --manager					force the use of a specific credential manager
		
Environment variables:
	CREDENTIAL_MANAGER		if set use the specified credential manager (see below)
	CREDENTIAL_ENGINE			if set, specify the secret engine to use (Vault)

Credential managers: 
	local|l|remote|r			find a local or remote (network) credential manager
	platform							find a credential manager for the current platform (default)
	none									do not use a credential manager

	mac|win 							use the native credential manager for the platform
	pass|SecretTool				use the pass or SecretTool credential managers
	vault|v		 						use HashiCorp Vault"
}

init()
{
	unset -v path key # getCredentialArg
	sep="-"
	pathUsage="\
	path		credential location, i.e. folder or /folder1/folder2"
}

argStart()
{ 
	unset -v engine fallback type
	excludeManagers=() excludeManagersArg=() engineArg=()
}

opt()
{
	case "$1" in
		-e|--engine|-e=*|--engine=*) ScriptOptGet engine "$@"; engineArg=( --engine "$engine" );;
		-F|--fallback) fallback="--fallback";;
		-m|--manager|-m=*|--manager=*) ScriptOptGet "type" "manager" "$@"; validateManager;;
		-x|--exclude-managers|-x=*|--exclude-managers=*) getExcludeManagerOpt "$@";;
		*) return 1;;
	esac
}

argEnd()
{
	[[ ! $type && $CREDENTIAL_MANAGER ]] && { type="$CREDENTIAL_MANAGER"; validateManager || type="local"; }
 	[[ -z ${engine+x} ]] && { [[ $CREDENTIAL_ENGINE ]] && engine="$CREDENTIAL_ENGINE" || engine="secret"; }
 	findManager && initManager
}

getCredentialArg() # PATH [KEY](default)
{
	ScriptArgGet "path" -- "$@"; shift
	[[ $1 ]] && { ScriptArgGet "key" -- "$@"; shift; } || key="default"
}

getExcludeManagerOpt()
{
	ScriptOptGet "excludeManagers" "exclude-managers" "$@"
	excludeManagersArg=( --exclude-managers "$excludeManagers" )
	StringToArray "${excludeManagers,,}" "," excludeManagers
}

#
# Commands
#

checkCommand() { return 0; }
typeCommand() { echo "$type"; }

managerCommand()
{
	if IsPlatform win; then 
		control.exe /name Microsoft.CredentialManager
	elif IsPlatform debian; then
		start seahorse
	fi
}

statusCommand()
{
	echo "Credential store is $type"
	
	if [[ "$type" == "vault" ]]; then
		echo; vault status 
	elif findManagerVault; then
		echo "Vault is available"
	fi
		
	return 0
}

#
# Copy Command
#

copyUsage() { echot "Usage: $(ScriptName) copy SRC DEST
Copy credentials from one path to another."; }

copyArgStart() { unset -v src dest; }

copyArgs()
{
	ScriptArgGet "src" -- "$@"; shift
	ScriptArgGet "dest" -- "$@"; shift
}

copyCommand()
{
	local path="$originalPath"

	[[ $verbose ]] && echo "Copying path $src to $dest..."
	initPath "$src" || return

	local key keys value; IFS=$'\n' keys=( $(listCommand) )
	for key in "${keys[@]}"; do
		value="$(getCommand)" || return
		$testEcho cred set "$dest" "$key" "$value" || return
	done

}

#
# Delete Command
#

deleteUsage() { echot "Usage: $(ScriptName) delete PATH [KEY|all](default)
Delete a credential.

If the key is all, all keys at the path are deleted.   If --force is specified,
permanently delete all keys at the path.\n\n$pathUsage"; }

deleteArgs() { getCredentialArg "$@"; }

deleteCommand()
{
	[[ "$key" != "all" || "$type" == "vault" ]] && { RunFunction "delete" "$type"; return; }

	local key keys onlyKeys="true"; IFS=$'\n' keys=( $(listCommand) )
	for key in "${keys[@]}"; do RunFunction "delete" "$type" || return; done
}

deleteMac() { security delete-generic-password -a $USER -s "$path-$key"; }
deletePass() { pass rm "$path-$key"; }
deleteWin() { wincred.exe delete "$path-$key"; }
deleteSecretTool() { secret-tool clear "$path" "$key"; }

deleteVault()
{ 
	# delete a single key
	if [[ "$key" != "all" ]]; then
		! vaultKeyExists "$path" "$key" && return
		vault kv get -format=json "$path" | jq ".data.data|del(.$key)" | vault kv put "$path" -
		return
	fi

	# delete all keys at a leaf node
	! vaultIsLeaf "$path" && return

	# permanently delete all keys at the leaf node
	[[ $force ]] && { vault kv metadata delete "$path"; return; }

	# if the leaf node has data delete it
	vaultLeafHasData "$path" && { vault kv delete "$path"; return; }
		
	return 0
}

#
# Engine Commands
#

engineUsage() { echot "Usage: $(ScriptName) engine add|list
Manage credential engines."; }

engineCommand() { engineListCommand; }

engineListCommand() { RunFunction "engineList" "$type"; }
engineListVault() {	vault secrets list; }

engineAddUsage() { echot "Usage: $(ScriptName) engine add NAME"; }
engineAddArgs() { ScriptArgGet "name" -- "$@"; shift; }
engineAddCommand() { RunFunction "engineAdd" "$type"; }
engineAddVault() { vault secrets enable -path="$name" kv-v2; }

#
# Exist Command
#

existsUsage() { echot "Usage: $(ScriptName) exists PATH [KEY](default)
Return 0 if the specified credential exists.\n\n$pathUsage"; }

existsArgs() { getCredentialArg "$@"; }

existsCommand()
{
	RunFunction "exists" "$type" && return
	! canFallback && return 1
	[[ $verbose ]] && EchoErr "credential '$originalPath $key' does not exist in the local store, falling back to remote store"
	cred exists "$originalPath" "$key" --manager=remote
}

existsMac() { security find-generic-password -gwa $USER -s "$path-$key" > /dev/null; }
existsPass() { [[ -f "$HOME/.password-store/$path-$key.gpg" ]]; }
existsSecretTool() { secret-tool search $path $key |& grep label > /dev/null; }
existsVault() { vaultKeyExists "$path" "$key"; }
existsWin() { wincred.exe exists "$path-$key"; }

canFallback() { ! isManagerRemote && [[ $fallback ]] && checkManagerRemote; }

#
# Get Command
#

getUsage() { echot "Usage: $(ScriptName) get [time] PATH [KEY](default)
Get a credential.

$pathUsage
	time		return the UTC time the specified credential was last modified"; }

getArgs()  { getCredentialArg "$@"; }

getCommand()
{
	RunFunction "get" "$type" && return
	! canFallback && return 1		
	[[ $verbose ]] && EchoErr "credential '$originalPath $key' does not exist in the local store, falling back to remote store"
	cred get "$originalPath" "$key" --manager=remote
}

getMac() { security find-generic-password -gwa $USER -s "$path-$key" 2> /dev/null; }
getPass() { pass show "$path-$key"; }
getSecretTool() { secret-tool lookup "$path" "$key" | RemoveNewline; [[ "${PIPESTATUS[0]}" == 0 ]] && return; keyNotFound "$key"; }
getVault() { vault kv get -field="$key" "$path" | RemoveNewline; return "${PIPESTATUS[0]}"; }
getWin() { wincred.exe get "$path-$key"; }

getTimeCommand()
{
	local time="$(RunFunction "getTime" "$type")"; 
	[[ ! $time ]] && { ScriptErr "unable to determine '$originalPath $key' modifification time"; return 1; }
	printf "$time"
}

getTimeSecretTool() { date -u --date="$(secret-tool search secret-test other |& grep '^modified =' | GetAfter "=" | RemoveSpaceTrim)"; }
getTimeVault() { vault kv get --format=json "$path" | jq -r .data.metadata.created_time; }
getTimeWin() { wincred.exe detail "$path-$key" | jq -r .[0].LastWriteTimeUtc; }

#
# Gets Command - get silent
#

getsUsage() { echot "Usage: $(ScriptName) gets PATH [KEY](default)
Get a credential silently (without showing an error).
This is useful if the key does not exist.\n\n$pathUsage"; }

getsArgs() { getCredentialArg "$@"; }
getsCommand() { getCommand 2> /dev/null; return 0; }

#
# List Command
#

listUsage() { echot "Usage: $(ScriptName) list [path]
List all the paths or all keys at the specified path.\n\n$pathUsage

	-p, --paths		list paths at specified path and below
	-k, --keys		list only keys at specified path"; }

listArgStart() { unset onlyPaths onlyKeys; }

listOpt() 
{
	case "$1" in
		-p|--paths) onlyPaths="true";;
		-k|--keys) onlyKeys="true";;
		*) return 1
	esac
}

listArgs() 
{
	[[ $1 ]] && ScriptArgGet "path" -- "$@"; shift
	return 0
}

listCommand() { RunFunction "list" "$type"; }
listMac() { listDo "listMacFilter"; }
listPass() { pass show; } 
listSecretTool() { listDo "listSecretToolFilter"; }
listWin() {	listDo "listWinFilter"; }

listMacFilter() { security dump-keychain -r login.keychain | grep '0x00000007 <blob>=' | cut -d= -f2 | RemoveQuotes | grep "^$path$sep" | sort | uniq; }
listSecretToolFilter() { lssecret | grep "^Item:" | cut -d$'\t' -f2 | grep "^$path$sep" | sort; }
listWinFilter() { wincred.exe list "$path$sep*" | RemoveCarriageReturn | sort; }

listVault()
{	
	local path="$(RemoveTrim "$path" "/")"

	# paths
	if [[ ! $onlyKeys ]] && vaultPathHasChildren "$path"; then

		if [[ $onlyPaths ]]; then
			local p paths; IFS=$'\n' paths=( $(vault kv list "$path" | tail +3 | sort | sed 's/\/$//' | sed 's/$/\//' | uniq) )
			local origPath="$path"
			local prefix="$origPath/$p"; prefix="${prefix/$engine\//}"
			for p in "${paths[@]}"; do echo "$prefix$p"; path="$origPath/$p"; listVault; done
			return
		fi

		vault kv list "$path" | tail +3 | sort | sed 's/\/$//' | sed 's/$/\//' | uniq # add / suffix
		(( ${PIPESTATUS[0]} != 0 )) && return 1
	fi

	# keys
	if [[ ! $onlyPaths ]] && vaultLeafHasData "$path"; then
		vault kv get -format=json "$path" | jq '.data.data|keys|.[]' -r
		(( ${PIPESTATUS[0]} != 0 )) && return 1
	fi
	
}

listDo()
{
	local filter="$1"
	local path="$(RemoveTrim "$path" "$sep")"

	if [[ $onlyPaths ]]; then listPathsRecursive
	elif [[ $onlyKeys ]]; then listKeys
	else listPaths && listKeys
	fi
}

listKeys()
{
	$filter |
		sed "s/^$path$sep//" | 		# remove path prefix
		grep -v "$sep" |					# remove child paths 
		sort
}

listPaths()
{
	$filter |
		grep "$sep"	|						# include paths
		sed "s/^$path$sep//" | 	# remove path prefix
		grep "$sep"	|						# remove keys
		sed "s/$sep.*$//" |			# remove child paths
		sed 's/$/\//'	|					# add / suffix
		uniq
}

listPathsRecursive()
{	
	$filter |
		sed "s/$sep[^$sep]*$//" | 	# remove leaves
		grep -v "^${path}$" |				# remove exact path
		sed "s/^$engine$sep//" | 		# remove engine prefix
		sed "s/$sep/\//g" |					# replace sepator with /
		uniq
}

#
# Set Command
#

setUsage() { echot "Usage: $(ScriptName) set PATH [KEY](default) value
Set a credential."; }

setArgs() 
{
	ScriptArgGet "path" -- "$@"; shift
	(( $# > 1 )) && { ScriptArgGet "key" -- "$@"; shift; } || key="default"
	ScriptArgGet "value" -- "$@"; shift
}

setCommand() { RunFunction "set" "$type"; }
setMac() { security add-generic-password -U -a $USER -s "$path-$key" -w "$value"; }
setPass() { pass insert -m --force "$path-$key"<<< "success" 2> /dev/null; }
setSecretTool() { echo "$value" | secret-tool store --label "$path-$key" "$path" "$key"; }
setWin() { wincred.exe set "$path-$key" "$value"; }

setVault()
{	
	if ! vaultLeafHasData "$path"; then
		vault kv put "$path" "$key"="$value"
	else
		vault kv patch "$path" "$key"="$value"
	fi
}

#
# Sync Command
#

syncUsage()
{
		echot "Usage: $(ScriptName) sync PATH [KEY](default)
Syncronize keys betwen the specified credential managers.

	-m1,	--manager1			first secret manager, defaults to local
	-m2,	--manager2			second secret manager, defaults to remote"
}

syncArgStart()
{
	unset -v key path
	m1="local" m2="remote"
}

syncOpt() 
{
	case "$1" in
		-m1|--manager1|-m1=*|--manager1=*) ScriptOptGet m1 "$@"; m1="$(resolveAlias "$m1")";;
		-m2|--manager2|-m2=*|--manager2=*) ScriptOptGet m2 "$@"; m2="$(resolveAlias "$m2")";;
		*) return 1
	esac
}

syncArgs()
{
	ScriptArgGet "path" -- "$@"; shift
	[[ $1 ]] && { ScriptArgGet "key" -- "$@"; shift; }
	return 0
}

syncCommand()
{
	local path="$originalPath"

	[[ $verbose ]] && echo "credential: syncing $path from $m1 to $m2"

	[[ $key ]] && { syncKey; return; }
	
	# get all keys at path
	local key keys; IFS=$'\n' keys=( $({ cred1 list --keys "$path"; cred2 list --keys "$path"; } | sort | uniq) )
	[[ $verbose ]] && { printf "credential: all keys: "; ArrayShow keys; }

	for key in "${keys[@]}"; do
		header "$path $key"
		cred sync "$path" "$key" "-m1=$m1" "-m2=$m2" || return
	done
}

syncKey()
{
	# key does not exist in m1
	if ! cred1 exists "$path" "$key"; then
		echo "Creating '$path $key' in $m1..."
		local value; value="$(cred2 get "$path" "$key")" || return
		cred1 set "$path" "$key" "$value" || return
		return
	fi

	# key does not exist in m2
	if ! cred2 exists "$path" "$key"; then
		echo "Creating '$path $key' in $m2..."
		local value; value="$(cred1 get "$path" "$key")" || return
		cred2 set "$path" "$key" "$value" || return
		return
	fi

	# compare values
	local value1; value1="$(cred1 get "$path" "$key")" || return
	local value2; value2="$(cred2 get "$path" "$key")" || return

	if [[ "$value1" == "$value2" ]]; then
		echo "$path $key is the same in $m1 and $m2"
		return
	fi

	# compare time
	local time1; time1="$(cred1 get time "$path" "$key" | GetSeconds -)" || return
	local time2; time2="$(cred2 get time "$path" "$key" | GetSeconds -)" || return

	if [[ $verbose ]]; then
		echo "credential: $m1 modifification time is $(cred1 get time "$path" "$key") ($time1 seconds)"
		echo "credential: $m2 modifification time is $(cred2 get time "$path" "$key") ($time2 seconds)"
	fi

	if (( $(echo "$time1 > $time2" | bc -l) )); then
		echo "Updating $m2 ($m1 value is newer)..."
		cred2 set "$path" "$key" "$value1" || return
	else
		echo "Updating $m1 ($m2 value is newer)..."
		cred1 set "$path" "$key" "$value2" || return
	fi
}

#
# Mirror Command
#

mirrorUsage()
{
		echot "Usage: $(ScriptName) mirror PATH [KEY]
Mirror keys from one credential manager to another.
This will ensure the 'to' credential manager is identical to 
the 'from' credential manager at the specified PATH and KEY.

	-F,	--from MANAGER	first secret manager, defaults to local
	-T,	--to MANAGER		second secret manager, defaults to remote"
}

mirrorArgStart() { syncArgStart "$@"; }

mirrorOpt() 
{
	case "$1" in
		-F|--to|-F=*|--from=*) ScriptOptGet m1 "$@"; m1="$(resolveAlias "$m1")";;
		-T|--to|-T=*|--to=*) ScriptOptGet m2 "$@"; m2="$(resolveAlias "$m2")";;
		*) return 1
	esac
}

mirrorArgs() { syncArgs "$@"; }

mirrorCommand()
{
	local path="$originalPath"

	[[ $verbose ]] && echo "credential: mirroring $path from $m1 to $m2..."

	[[ $key ]] && { mirrorKey; return; }

	[[ ! $force ]] && { ScriptErr "to overwrite all values at '$path' in $m2 --force must be specified."; return 1; }

	# get m1 keys at path
	local key keys; IFS=$'\n' keys=( $(cred1 list --keys "$path") )
	[[ ! $keys ]] && { ScriptErr "no permission or no keys at '$path' in $m1"; return 1; }
	[[ $verbose ]] && { printf "credential: $m1 keys: "; ArrayShow keys; }

	echo "Deleting all keys at '$path' in $m2..."
	$testEcho cred2 delete "$path" all || return

	for key in "${keys[@]}"; do
		echo "Adding '$path $key' to $m2..."
		local value; value="$(cred1 get "$path" "$key")" || return
		$testEcho cred2 set "$path" "$key" "$value" || return
	done
}

cred1() { cred "--manager=$m1" "$@"; }
cred2() { cred "--manager=$m2" "$@"; }

mirrorKey()
{
	! cred1 exists "$path" "$key" && { ScriptErr "'$path $key' does not exist in $m1"; return; }
	local value; value="$(cred1 get "$path" "$key")" || return
	cred2 set "$path" "$key" "$value"
}

#
# Validate and Find Credential Manager Helper
#

validateManager()
{
	[[ $type ]] && type="$(resolveAlias "$type" | LowerCase)" || type="local"

	# ensure correct case
	if [[ "$type" == "secrettool" ]]; then type="SecretTool"
	else type="$(ProperCase "$type")"
	fi

	# check if the credential manage is valid
	if ! IsFunction "findManager${type}"; then
		[[ ! $quiet ]] && EchoErr "credential: '$type' is not a valid credential manager"
		return 1
	fi

	return 0
}

findManager()
{
	[[ ! $type ]] && type="local"

	if ! "findManager${type^}"; then
		[[ ! $quiet ]] && ScriptErr "the '$type' credential manager is not available"
		[[ "$command" == "type" ]] && echo "none"
		return 1
	fi

	(( verboseLevel > 1 )) && ScriptErr "using the '$type' credential manager"
	return 0
}

isManagerRemote() { [[ "$type" == @(vault) ]]; }

findManagerLocal() { findManagerPlatform; }
findManagerRemote() { findManagerVault; }

findManagerPlatform() { RunPlatform "findManagerPlatform"; }
findManagerPlatformLinux() { findManagerSecretTool || findManagerPass || findManagerVault; }
findManagerPlatformMac() { findManagerMac || findManagerPass || findManagerVault; }
findManagerPlatformWin() { findManagerWin || findManagerSecretTool || findManagerPass || findManagerVault; }

findManagerMac() { checkManagerMac && type="mac"; }
findManagerNone() { return 1; }
findManagerPass() { checkManagerPass && type="pass"; }
findManagerSecretTool() { checkManagerSecretTool && type="SecretTool"; }
findManagerVault() { checkManagerVault && type="vault"; }
findManagerWin() { checkManagerWin && type="win"; }

checkManagerRemote() { checkManagerVault; }
checkManagerMac() { ! IsInArray "mac" excludeManagers && IsPlatform mac && InPath security; } 			# MacOS Keychain
checkManagerWin() { ! IsInArray "win" excludeManagers && IsPlatform win &&  InPath "wincred.exe"; } # Windows Credential Manager

checkManagerPass() 
{
	{ IsInArray "secrettool" excludeManagers || ! InPath pass; } && return 1
	pass insert -m --force test-default<<< "success" >& /dev/null
}

checkManagerSecretTool()
{
	# ensure SecretTool is installed and we are using an X display
	{ IsInArray "secrettool" excludeManagers || [[ ! $DISPLAY ]] || ! InPath secret-tool; } && return 1

	# ensure DBUS can be configured correctly over SSH (so we get the Ubuntu Gnome keyring password prompt)
	if IsSsh && InPath dbus-launch dbus-update-activation-environment; then
		local result; result="$(dbus-update-activation-environment --systemd DISPLAY 2>&1)" || return
		[[ "$result" != "" ]] && return 1 # returns error text if there is an issue
	fi 

	echo "success" | secret-tool store --label "secret-test-check" secret-test-check default >& /dev/null
}

checkManagerVault()
{
	# return if Vault is excluded or not installed
	{ IsInArray "vault" excludeManagers || ! InPath vault; } && return 1

	# ensure the vault configuration is set
	[[ ! $VAULT_ADDR || ! $VAULT_TOKEN ]] && { eval "$(hashi vault environment $quiet)" || return; }
	[[ ! $VAULT_ADDR || ! $VAULT_TOKEN ]] && return 1

	# check if the Vault verver is available
	local server="$(GetUriServer "$VAULT_ADDR")" port="$(GetUriPort "$VAULT_ADDR")"
	if ! IsAvailablePort "$server" "$port"; then
		EchoErr "The Vault server $server is not responding on port $port"
		return 1
	fi

	# logging
	if (( verboseLevel > 1 )); then
		hashi config environment vault
		vault status >& /dev/stderr || return
	fi

	vault status >& /dev/null
}

#
# Initializion Helper
#

initManager() { [[ ! $type ]] && return; RunFunction "initManager" "$type"; initPath "$path"; }

initPath() { path="$1"; RunFunction "initPath" "$type"; }
initPathMac()  { initPathGeneric; }
initPathSecretTool() { initPathGeneric; }
initPathWin() { initPathGeneric; }

# initPath: /a/b/ -> $engine-a-b	
initPathGeneric()
{
	originalPath="$path"
	local prefix; [[ $engine ]] && prefix="$engine-"
	path="$prefix$(RemoveTrim "${path//\//-}" "-")"
}

# initPathVault: /a/b/ -> /$engine/a/b
initPathVault()
{
	originalPath="$path"
	path="/$engine/$(RemoveTrim "$path" "/")"
}

#
# Vault Helper
#

vaultIsLeaf() { vault kv get "$1" >& /dev/null; } 												# vaultIsLeaf PATH - return 0 if the path is a leaf node
vaultKeyExists() { vault kv get -field="$2" "$1" >& /dev/null; }					# vaultKeyExists PATH KEY - return 0 if the key exists at path, 1 if it does not
vaultLeafHasData() { vault kv get "$1" |& grep -q -E "(=)+ Data (=)+"; } 	# vaultLeafHasData PATH - leaf node contains data (contains non-deleted keys)
vaultPathHasChildren() { vault kv list "$1" >& /dev/null; } 							# vaultPathHasChildren PATH - return 0 if the path has children

#
# helper
#

cred()
{
	[[ $verbose ]] && EchoErr credential: credential "${engineArg[@]}" "${excludeManagersArg[@]}" $fallback $force $quiet $verbose "$@"
	credential "${engineArg[@]}" "${excludeManagersArg[@]}" $fallback $force $quiet $verbose "$@"
}

keyNotFound() { EchoErr "key '$1' does not exist in the '$type' credential store"; return 1; }
 
resolveAlias()
{
	case "${1,,}" in
		l) echo "local";;
		r) echo "remote";;
		v) echo "vault";;
		st|secrettool) echo "SecretTool";;
		*) echo "${1,,}";;
	esac
}

ScriptRun "$@"

#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script || exit

# notes:
# - avoid any calls to credential in the credential unlock flow.   For exmaple, SshAgent uses credential to unlock 
#   the ssh-agent, so this must not be called when this script, or a manager helper script such as hashi or 1PasswordHelper,
#   unlocks a credential manager.  
# - unlock flows:
#   - RunScript → hashi, SshAgent, credential
#   - credential → hashi, 1PasswordHelper
#   - SshAgent → credential
#   - hashi → credential
#   - 1PasswordHelper → credential

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName)
Interact with a credential store.

Common commands:
	exists 		check if a credential exists
	get[s]		get a credential
	ls 				list credentials
	manager		manage credetnial managers
	rm  			remove a credential
	set				set a credential

Common options:
	-F, --fallback			 							fallback to a remote credential manager if possible
	-em, --exclude-managers=MANAGERS	comma separated list of managers to exclude
	-m, --manager=MANAGER							use a specific credential manager
	-u, --unlock											unlock the credential manager"
}

usageVerbose()
{ 
	ScriptUsageEcho "
Copy commands:
	copy		copy credentials from one path to another
	mirror	mirror credentials from one credential manager to another
	sync		synronize credentials from one credential manager to another

Other commands:
	environment			return environment variables
	gui							show the the GUI manager
	store						manage credential stores
	test						test the credential manager

Store options:
	-s, --store=STORE 				credential store name, defaults to secret
	-pp, --path-prefix=PATH 	path prefix, defaults to none

Other options:
	-g, --gui									use a GUI prompt for the password
	-nfp, --no-find-pass			do not search for a password to unlock this manager
	-p, --password=PASSWORD 	password to unlock the credential manager
	-t, --timeout							$(ScriptOptTimeoutUsage)

Environment variables (writable):
	CREDENTIAL_MANAGER			if set, the credential manager to use

Environment variables (view):
	CREDENTIAL_MANAGER_CHECKED  if true, a search for a credential manager was performed.  Otherwise unset.
	CREDENTIAL_UNLOCK_PATH			path for the secret used to unlock this credential manager

Credential managers:
	mac|win 	MacOS Keychain or Windows Credential Manager
	op				1Password credential manager 				aliases: 1p|op|OnePassword
	pass			pass credential manager
	gk				GNOME Keyring credential manager, 	aliases: gk|GnomeKeyring|st|SecretTool
	vault			HashiCorp Vault credential manager 	aliases: v

Credential manager aliases:
	all									all credential managers (default)
	local|l|remote|r		local or remote (network) credential managers
	native							the native credential manager for the current platform
	none								no credential manager"

}

init()
{
	allManagers=(mac op pass gk vault win)
	sep="-"
	pathUsage="	path		credential location, i.e. folder or /folder1/folder2"
}

argStart()
{
	unset -v fallback gui manager noFindPass password pathPrefix store unlock; ScriptOptTimeoutArgStart
	unset -v path key # for getCredentialArg
	excludeManagers=() excludeManagersArg=() pathPrefixArg=() storeArg=()
}

opt()
{
	case "$1" in
		--exclude-managers|--exclude-managers=*|-em|-em=*) getExcludeManagersOpt "$@";;
		--fallback|-F) fallback="--fallback";;
		--gui|-g) gui="--gui";;
		--manager|--manager=*|-m|-m=*) ScriptOptGet "manager" "$@" && aliasValidate "$manager";;
		--no-find-pass|-nfp) noFindPass="--no-find-pass";;
		--password|--password=*|-p|-p=*) ScriptOptGet "password" "$@";;
		--path-prefix|--path-prefix=*|-pp|-pp=*) ScriptOptGet "pathPrefix" "$@" && pathPrefixArg=( --path-prefix "$pathPrefix" );;
		--store|--store=*|-s|-s=*) ScriptOptGet "store" "$@" && storeArg=( --store "$store" );;
		--timeout|--timeout=*|-t|-t=*) ScriptOptTimeout "$@";;
		--unlock|-u) unlock="--unlock";;
		*) return 1;;
	esac
}

argEnd()
{
 	# set configuration
 	[[ ! $password ]] && password="$CREDENTIAL_MANAGER_PASSWORD"

	# determine if we need to unlock the manager
 	[[ "$command" == @(copy|exists|get|ls|managerPassword|rm|set|store|testAll|testRead|testWrite) ]] && unlock="--unlock";

	# determine if we need to force operations
	unset forceEnvironment forceUnlock forceLock
	[[ $force && "$command" == @(environment) ]] && forceEnvironment="true" forceUnlock="true"
	[[ $force && "$command" == @(managerLock) ]] && forceLock="true"
	[[ $force && "$command" == @(managerUnlock) ]] && forceUnlock="true"

	# find a manager if needed
	local find="true"
	[[ "$command" == @(managerFind|managerList*|managerRebuild) ]] && unset find
	[[ "$command" == @(managerIs*) && $manager ]] && unset find
	[[ $find ]] && { managerFind "$manager" || return; }

	# determine store
 	if [[ ! $store ]]; then
 		store="$(ConfigGetCurrent "${manager}StoreDefault")"
 		store="${store:-secret}"
 	fi

	# determine path prefix
 	[[ ! $pathPrefix ]] && pathPrefix="$(ConfigGetCurrent "${manager}PathPrefix")"
 	
	return 0
}

#
# commands
#

guiCommand() { RunFunction "gui" "$manager"; }
guiOp() { 1PasswordHelper start; }
guiGk() { start seahorse; }
guiWin() { ( cd /; start control.exe /name Microsoft.CredentialManager ) }

#
# copy command
#

copyUsage() { echot "Usage: $(ScriptName) copy SRC DEST\nCopy credentials from one path to another."; }
copyArgStart() { unset -v src dest; }
copyArgs() { ScriptArgGet "src" -- "$@" && shift && ScriptArgGet "dest" -- "$@"; }

copyCommand()
{
	log1 "copying path $src to $dest..."
	initPath "$src" || return

	local key keys value; IFS=$'\n' ArrayMake keys "$(lsCommand)"
	for key in "${keys[@]}"; do
		value="$(getCommand)" || return
		cred set "$dest" "$key" "$value" || return
	done
}

#
# environment command
#

environmentCommand() { environment && environmentManager; }

# environment [MANAGER] - return the generic environment variables
environment()
{
	local manager="${1:-$manager}"

	# standard variables
	cat <<-EOF
		export CREDENTIAL_MANAGER="$manager"
		export CREDENTIAL_MANAGER_CHECKED="true"
		export CREDENTIAL_UNLOCK_PATH="/secure/default"
	EOF

	# credential manager password
	[[ $password ]] && echo "export CREDENTIAL_MANAGER_PASSWORD=\"$password\""

	# manager specific variables
	RunFunction "environment" "$manager" || return
}

environmentOp() { echo "export CREDENTIAL_UNLOCK_PATH=\"1Password/password\""; }
environmentVault() { echo "export CREDENTIAL_UNLOCK_PATH=\"hashi/$(GetNetworkDnsBaseDomain)/vault/token\""; }

# environmentManager [MANAGER] - return the manager specific environment variables
environmentManager() { local manager="${1:-$manager}"; RunFunction "environmentManager" "$manager"; }
environmentManagerOp() { 1PasswordHelper environment "${globalArgsLessVerbose[@]}"; }
environmentManagerVault() { hashi vault environment --no-token $timeoutArg "${globalArgsLessVerbose[@]}"; }
environmentManagerGk() { gnomeKeyringDaemonEnvironment && echo "export GNOME_KEYRING_CONTROL=\"$GNOME_KEYRING_CONTROL\""; }

#
# exist command
#

existsUsage() { echot "Usage: $(ScriptName) exists PATH [KEY](default)
Return 0 if the specified credential exists.\n\n$pathUsage"; }

existsArgs() { getCredentialArg "$@"; }
existsCommand() { exists "$path" "$key" || existsFallbackRemote "$path" "$key"; }

existsFallbackRemote()
{
	local path="$1" key="$2"; ! canFallbackRemote "$manager" && return 1
	log1 "credential '$path $key' does not exist in the $(description) credential store, falling back to a remote store"
	test="" cred exists "$path" "$key" --manager=remote "${globalArgs[@]}"
}

exists()
{
	local path="$1" key="$2"; operationInit "exists" "$path" "$key" || return
	local result return; result="$(RunFunction "exists" "$manager")"; return="$?"
	log1 "exists '$path' '$key': return=$return"
	return "$return"
}

existsMac() { security find-generic-password -gwa $USER -s "$managerPathKey" 2>&1; }
existsOp() { op item get "$managerPathKey" --cache >& /dev/null; }
existsPass() { [[ -f "$HOME/.password-store/$managerPathKey.gpg" ]]; }
existsVault() { vaultKeyExists "$managerPath" "$key"; }
existsWin() { RunWin wincred.exe exists "$managerPathKey"; }
existsGk() { secret-tool search "$managerPath" "$key" |& ${G}grep --quiet "^label ="; }

#
# get command
#

getUsage() { echot "Usage: $(ScriptName) get [time] PATH [KEY](default)
Get a credential.

$pathUsage
	time		return the UTC time the specified credential was last modified

	-p, --prompt	prompt for the credential if not found"; }

getArgStart() { unset prompt; }
getArgs()  { getCredentialArg "$@"; }

getOpt() 
{
	case "$1" in
		-p|--prompt) prompt="--prompt";;
		*) return 1
	esac
}

getCommand() { get "$path" "$key" || getFallbackRemote "$path" "$key" || getPrompt "$path" "$key"; }

# get PATH KET - get a value from the credential store.
#   The value is not logged since it likely contains a credential.
get()
{
	local path="$1" key="$2"; operationInit "get" "$path" "$key" || return	
	local return value; value="$(RunFunction "get" "$manager" | RemoveEnd '\n')"; return="$?"
	log1 "get '$path' '$key': value_length=${#value} return=$return"; 
	(( return != 0 )) && { keyNotFound "$path" "$key"; return 1; }
	printf "%s" "$value"
}

getOp() { op item get "$managerPathKey" --fields "password" --cache; }
getPass() { pass show "$managerPathKey"; }
getGk() {	secret-tool lookup "$managerPath" "$key"; }
getMac() { security find-generic-password -gwa $USER -s "$managerPathKey" 2>&1 | xxd -p -r; } # assume mac returns hex
getVault() { vaultGet "$managerPath" "$key"; }
getWin() { RunWin wincred.exe get "$managerPathKey" 2>&1; }

getFallbackRemote()
{
	local path="$1" key="$2"; ! canFallbackRemote "$manager" && return 1		
	log1 "credential '$path $key' does not exist in the '$(description)' credential manager, falling back to a remote store"
	test="" cred get "$path" "$key" --manager=remote
}

getPrompt()
{
	local path="$1" key="$2"; shift 2

	[[ ! $prompt ]] && return 1

	# prompt for the credential
	local prompt="${1:-Enter the new credential for $path $key: }"
	read -s -p "$prompt" value; echo
	[[ ! $value ]] && { ScriptErr "no credential specified"; return 1; }

	# set the credential
	log1 "setting credential '$path $key' to '$value'"
	setCommand || return

	# set the credential in the remote credential store if needed
	{ isManagerRemote "$manager" || [[ ! $fallback ]] || ! isManagerAvailable "remote"; } && return
	log1 "setting credential '$path $key' to '$value' in the remote credential store"
	cred set "$path" "$key" "$value" --manager=remote || return

	printf "%s" "$value"
}

#
# get time Command
#

getTimeCommand() { getTime "$path" "$key"; }

getTime()
{
	local path="$1" key="$2"; operationInit "get time" "$path" "$key" || return
	local time; time="$(RunFunction "getTime" "$manager" 2>&1)"
	[[ ! $time ]] && { ScriptErr "unable to determine '$path $key' modifification time"; return 1; }
	log1 "time: time='$time'"; printf "$time"
}

getTimeVault() { vault kv get --format=json -mount="$store" "$managerPath" | jq -r .data.metadata.created_time; }
getTimeWin() { RunWin wincred.exe detail "$managerPathKey" | jq -r .[0].LastWriteTimeUtc; }

getTimeMac()
{
	local date; date="$(security find-generic-password -a $USER -s "$managerPathKey" | grep "\"mdat\"<timedate>=" | tr -s " " | cut -d" " -f3 | RemoveQuotes | RemoveEnd 'Z\\000')" || return
	[[ ! $date ]] && return
	date -j -f "%Y%m%d%H%M%S%z" "${date}-0000"
}

getTimeGk()
{
	local date; date="$(secret-tool search "$managerPath" "$key" |& grep '^modified =' | GetAfter "=" | RemoveSpaceTrim)" || return
	[[ ! $date ]] && return
	date -u --date="$date"
}

#
# ls command
#

lsUsage() { echot "Usage: $(ScriptName) ls [path]
List all the paths or all keys at the specified path.\n\n$pathUsage

	-p, --paths		list paths at specified path and below
	-k, --keys		list only keys at specified path"; }

lsArgStart() { unset onlyPaths onlyKeys; }

lsOpt() 
{
	case "$1" in
		-p|--paths) onlyPaths="true";;
		-k|--keys) onlyKeys="true";;
		*) return 1
	esac
}

lsArgs() { (( ! $#  )) && return; ScriptArgGet "path" -- "$@"; }
lsCommand() { lsDo "$path"; }

lsDo()
{
	local path="$1"; operationInit "ls" "$path" && RunFunction "ls" "$manager" && return
	ScriptErrQuiet "unable to list '$1'"
}

lsMac() { lsWorker "lsMacFilter"; }
lsOp() {	lsWorker "lsOpFilter"; }
lsGk() { lsWorker "lsGkFilter"; }
lsWin() {	lsWorker "lsWinFilter"; }

lsMacFilter() { security dump-keychain -r login.keychain | ${G}grep '0x00000007 <blob>=' | cut -d= -f2 | RemoveQuotes | ${G}grep "^$path$sep" | sort | uniq; }
lsOpFilter() { op item list --tags=credential${sep}${store} --format=json --cache | jq ".[].title" | RemoveQuotes | sort; }
lsGkFilter() { lssecret | ${G}grep "^Item:" | cut -d$'\t' -f2 | ${G}grep "^$path$sep" | sort; }
lsWinFilter() { RunWin wincred.exe list "$path$sep*" | RemoveCarriageReturn | sort; }

lsPass()
{
	local path="$(RemoveTrailingSlash "$HOME/.password-store/$managerPath")/"
	[[ ! -d "$path" ]] && return 
	find "$path" -maxdepth 1 -type d | ${G}tail --lines=+2 | sed 's/^'"$(echo "$path" | QuotePath)"'//' | sed 's/$/\//'
	find "$path" -maxdepth 1 -type f -name "*.gpg" | sed 's/^'"$(echo "$path" | QuotePath)"'//' | sed 's/.gpg$//'
}

lsVault() {	lsVaultDo "$(RemoveTrim "$managerPath" "/")"; }

lsVaultDo()
{
	local path="$1"

	# paths
	local hasChildren; vaultPathHasChildren "$path"; hasChildren="$?"; (( hasChildren > 1 )) && return 1

	if [[ ! $onlyKeys ]] && (( hasChildren == 0 )); then
		[[ $onlyPaths ]] && { lsVaultPaths "$path"; return; }
		vaultLs "$path" | sort --ignore-case | sed 's/\/$//' | sed 's/$/\//' | uniq || return
	fi

	# keys
	[[ ! $onlyPaths ]] && lsVaultKeys

	return 0	
}

lsVaultKeys()
{
	log3 "command: vault kv get -format=json -mount=\"$store\" \"$path\""
	local result="$(vault kv get -format=json -mount="$store" "$path" 2> /dev/null)" || return 0
	echo "$result" | jq '.data.data|keys|.[]' -r 2> /dev/null
}

lsVaultPaths()
{
	local path="$1" 
	local result; result="$(vaultLs "$path" | sort --ignore-case | uniq)" || return

	# list each path
	local p paths; IFS=$'\n' ArrayMake paths "$result"
	for p in "${paths[@]}"; do
		#echo "$(RemoveTrailingSlash "${path/$store/}")/$p" | RemoveTrimLeft "/");
		echo "$(RemoveTrailingSlash "${path/$store/}")/$p"
		IsPath "$p" && { lsVaultDo "$path/$p" || return; }
	done

	return 0
}

lsWorker()
{
	local filter="$1"
	local path="$(RemoveTrim "$managerPath" "$sep")"

	if [[ $onlyPaths ]]; then lsPathsRecursive
	elif [[ $onlyKeys ]]; then lsKeys
	else lsPaths && lsKeys
	fi
}

lsKeys()
{
	$filter |
		sed "s/^$path$sep//" | 		# remove path prefix
		tgrep -v "$sep" |					# remove child paths 
		sort
}

lsPaths()
{
	$filter |
		tgrep "$sep" |					# include paths
		sed "s/^$path$sep//" | 	# remove path prefix
		tgrep "$sep"	|					# remove keys
		sed "s/$sep.*$//" |			# remove child paths
		sed 's/$/\//'	|					# add / suffix
		uniq
}

lsPathsRecursive()
{	
	$filter |
		sed "s/$sep[^$sep]*$//" | 	# remove leaves
		${G}grep -v "^${path}$" |		# remove exact path
		sed "s/^$store$sep//" | 		# remove store prefix
		sed "s/$sep/\//g" |					# replace sepator with /
		uniq
}

#
# manager commands
#

managerUsage() { echot "Usage: $(ScriptName) manager [cleanup|debug|find|is|list|lock|login|name|password|rebuild|status|unlock](status)\nManage credential managers."; }
managerCommand() { managerStatus "$manager"; }

managerNameUsage() { echot "Usage: $(ScriptName) manager name\nShow the name of the credential manager."; }
managerNameCommand() { local m="${manager:-none}"; echo "${m,,}"; }

managerLoginUsage() { echot "Usage: $(ScriptName) manager login\nLogin to the credential manager and store the token locally."; }
managerLoginCommand() { RunFunction "managerLogin" "$manager"; }

managerLoginVault()
{
	# login and get the new token
	local result; result="$(vault login -method=oidc)" || return
	local token; token="$(${G}grep '^token ' | tr -s " " | ${G}cut -d" " -f2)"

	# update the token in the local credential store
	eval "$(environment)" || return # CREDENTIAL_UNLOCK_PATH=hashi/DOMAIN/vault/token
	local path="$(GetFilePath "$CREDENTIAL_UNLOCK_PATH")"
	local ket="$(GetFileName "$CREDENTIAL_UNLOCK_PATH")"
	cred1Args=(--manager=local) cred1 set "$path" "$key" "$token" || return
}

managerInvalid() { ScriptErrQuiet "'$1' is not a valid credential manager"; return; }
managerNameValidate() { isManager "$1" && return; managerInvalid "$1"; }

#
# manager cleanup command
#

managerCleanupUsage() { echot "Usage: $(ScriptName) manager cleanup\nCleanup the credential manager by terminating resident processes."; }
managerCleanupCommand() { cleanupDo "$manager"; }

cleanupDo() { local manager="$1"; lock "$manager"; RunFunction "cleanup" "$manager"; }
cleanupGk() { ProcessCloseWait --full "gnome-keyring-daemon"; }
cleanupOp() { ProcessCloseWait "op"; }

#
# manager debug command
#

managerDebugUsage() { echot "Usage: $(ScriptName) manager debug \nShow diagnostic information for the credential manager."; }

managerDebugCommand()
{
	hilight "status..."
	managerStatus || return

	hilight "\nenvironment..."
	environment || return

	RunFunction "managerDebug" "$manager";
}

managerDebugGk()
{
	hilight "\ngnome-keyring-daemon control..."
	echo "GNOME_KEYRING_CONTROL='$GNOME_KEYRING_CONTROL'"
	find "$GNOME_KEYRING_CONTROL" -type s | sudoc xargs --no-run-if-empty fuser

	hilight "\ngnome-keyring-daemon processes..."
	ps -aux | grep "gnome-keyring-daemon" | grep -v "grep"
}

#
# manager find command
#

managerFindUsage() { echot "Usage: $(ScriptName) find\nFind a credential manager."; }
managerFindCommand() { managerFind "$manager" && managerStatus; }

managerFind()
{
	local alias="$1"

	log2 "managerFind: alias=$alias unlock=$unlock force=$force forceUnlock=$forceUnlock forceEnvironment=$forceEnvironment"

	# determine what credential manager to find
 	if [[ $alias ]]; then
 		log2 "managerFind: using the passed credential manager '$alias'"
 	elif [[ $CREDENTIAL_MANAGER ]]; then
 		log2 "managerFind: using the saved credential manager '$CREDENTIAL_MANAGER' (from the CREDENTIAL_MANAGER environment variable)"
 		alias="$CREDENTIAL_MANAGER"
 	else
 		log2 "managerFind: no credential manager specified, searching for all credential managers"
 		alias="all"
 	fi

 	# validate the credential manager alias
	if ! aliasValidate "$alias"; then
		log2 "managerFind: the credential manager '$alias' is not valid, searching for all credential managers"
		alias="all"
	fi

	# search for all credential managers if no manager was found previously found (alias==none) and we are forcing a check
	if [[ "${alias,,}" == "none" && $force ]]; then
		alias="all"
		log2 "managerFind: a manager search is forced, using credential manager 'all' even though no credential manager was previously found"
	fi

	# find all of the managers for the alias
	local managers; managers=( $(listManagers "$alias") ) || return
	(( verboseLevel > 1 )) && log2 "managerFind: searching for managers: $(ArrayDelimit managers " ")"

	# single manager specified - find and try to unlock it if needed
	if (( ${#managers[@]} == 1 )); then
		manager="${managers[0]}"
		isAvailable "$manager" && { [[ ! $unlock ]] || unlock; } && { managerFound "$manager"; return; }
		managerNotFound "$alias"; return
	fi

	# search for the first manager, or the first unlocked manager
	local available=()
	for manager in "${managers[@]}"; do
		log2 "managerFind: checking if the '$manager' credential manager is available"
		isAvailable "$manager" && available+=("$manager") || continue
		[[ $unlock ]] && log2 "managerFind: checking if the '$manager' credential manager is unlocked"
		{ [[ ! $unlock ]] || isUnlocked "$manager"; } && { managerFound "$manager"; return; }
	done

	# search for the first available manager which we can unlock
	if [[ $unlock ]]; then
		for manager in "${available[@]}"; do
			log2 "managerFind: attempting to unlock the '$manager' credential manager"
			quiet="--quiet" unlock && { managerFound "$manager"; return; }
		done
	fi

	# no manager found
	managerNotFound "$alias"
}

managerFound() { local manager="$1"; log2 "managerFind: using the '$(description "$manager")' credential manager"; }

managerNotFound()
{
	local manager="$1" message

	if [[ "${manager,,}" == @(|all|none) ]]; then
		message="no credential manager is available"
	else
		message="the '$(description "$manager")' credential manager is not available"
	fi

	[[ $quiet ]] && log2 "managerFind: $message" || ScriptErr "$message"
	return 1
}

#
# manager is command
#

managerIsUsage() { echot "Usage: $(ScriptName) manager is [available|unlocked|locked](available)\nReturn 0 if the credential manager is in the specified state."; }
managerIsCommand() { managerIsAvailableCommand; }

#
# manager is available command
#

managerIsAvailableUsage() { echot "Usage: $(ScriptName) is available\nReturn 0 if the credential manager is available."; }
managerIsAvailableCommand() { isAvailable "$manager"; }

# isAvailable [MANAGER]($manager)
isAvailable()
{
	local alias="${1:-$manager}" manager 

	for manager in $(listManagers "$alias"); do 
		{ isExcluded "$manager" || ! isAvailableBasic; } && continue
		local cache="credential-manager-$manager-ok"; isAvailableCache && ! UpdateNeeded "$cache" "$(GetSeconds "-1 hour")" && return # return if recently checked
		log3 "isAvailable: checking if the '$(description)' credential manager is available"; 
		RunFunctionLog "isAvailable" "$manager" 3 "isAvailable: the '$(description)' credential manager IS\$fail available" " NOT" && { UpdateDone "$cache"; return; }
	done

	return 1
}

# isAvailableBasic - basic checks we should not cache
isAvailableBasic() { RunFunction "isAvailableBasic" "$manager"; }
isAvailableBasicMac() { ! IsSsh; }

# isAvailableCache - validate the cached manager environment
isAvailableCache() { RunFunction "isAvailableCache" "$manager"; }
isAvailableCacheVault() { [[ $VAULT_ADDR  && $VAULT_TOKEN ]]; }

# isAvailable - check if a manager is available
isAvailableMac() { IsPlatform mac && InPath security && ! IsSsh; }
isAvailableNone() { return 1; }
isAvailableOp() { InPath op; }
isAvailablePass() { InPath pass && [[ -d "$HOME/.password-store" ]]; }
isAvailableVault() { vaultValidate; }

isAvailableGk()
{
	# check D-Bus: dbus.service (Debian), dbus-broker.service (RedHat)
	! [[ -f "/lib/systemd/system/dbus.service" || -f "/usr/lib/systemd/system/dbus-broker.service" ]] && return 1

	 # check programs
	 InPath gnome-keyring-daemon lssecret secret-tool secret-check
}

isAvailableWin()
{
	# check if not Windows
	! IsPlatform win && return 1

	# check wincred.exe
	InPath "wincred.exe" || \
		{ log3 "isAvailableWin: wincred.exe is not in the path"; return 1; }

	# test a set and get as Windows credential manager sometimes stops working and requires a reboot
	RunWin wincred.exe set secret-test-check win-success >& /dev/null || \
		{ log3 "isAvailableWin: 'wincred.exe set secret-test-check win-success' failed "; return 1; }

	# test a get
	[[ "$(RunWin wincred.exe get secret-test-check 2>&1)" == "win-success" ]] || \
		{ log3 "isAvailableWin: 'wincred.exe get secret-test-check' failed (expected win-success) "; return 1; }

	return 0
}

# vaultValidate - verify Vault is accessible, as a side effect Vault environment variables are set
vaultValidate() { vaultValidatePath && vaultValidateEnvironment && vaultValidateServer && vaultValidateUnsealed; }

# vaultValidateEnvironment - get the VAULT_ADDR environment variable if needed.  We should not get the token to prevent a credential lookup.
vaultValidateEnvironment()
{
	DbusConf || return # Vault error if DBUS_SESSION_BUS_ADDRESS is not set
	
	if [[ ! "$VAULT_ADDR" || ! "$VAULT_TOKEN" || $forceEnvironment ]]; then
		log3 "vaultValidateEnvironment: getting the Vault environment variables"
		eval "$(hashi vault environment $quiet --no-token $timeoutArg "${globalArgsLessVerbose[@]}")" || return
	fi

	log3 "vaultValidateEnvironment: the Vault address is '$VAULT_ADDR'"
	return 0
}

vaultValidatePath()
{
	InPath "vault" && { log3 "Vault is installed and in the path"; return; }
	ScriptErrQuiet "Vault is not installed or not in the path"
}

vaultValidateServer()
{
	[[ ! $VAULT_ADDR ]] && { ScriptErrQuiet "the Vault environment is not set."; return 1; }

	local server="$(GetUriServer "$VAULT_ADDR")" port="$(GetUrlPort "$VAULT_ADDR")"
	log3 "vaultValidateServer: server=$server port=$port"
	
	if IsAvailablePort "$server" "$port" $timeout; then
		log3 "vaultValidateServer: the Vault server '$server' is available on port $port"
	else
		ScriptErrQuiet "the Vault server '$server' is ${RED}not responding${RESET} on port $port"
	fi
}

# vaultIsUnsealed - check if the Vault is selaed - https://www.vaultproject.io/docs/commands/status
vaultValidateUnsealed()
{
	local result; vault status -format=json >& /dev/null; result="$?" && { log3 "the Vault server is unsealed"; return; }
	(( result == 2 )) && { ScriptErrQuiet "Vault is sealed"; return 1; }
	return "$result" # some other error
}

#
# manager is locked command
#

managerIsLockedUsage() { echot "Usage: $(ScriptName) is available\nReturn 0 if the credential manager is locked."; }
managerIsLockedCommand() { isLocked "$manager"; }

isLocked() { ! isUnlocked "$1"; }

#
# manager is unlocked command
#

managerIsUnlockedUsage() { echot "Usage: $(ScriptName) is available\nReturn 0 if the credential manager is unlocked."; }
managerIsUnlockedCommand() { isUnlocked "$manager"; }

# isUnlocked MANAGER
isUnlocked()
{
	local manager="$1" manager

	for manager in $(listManagers "$manager"); do 
		{ isExcluded "$manager" || ! isAvailable "$manager"; } && continue
		log2 "isUnlocked: checking if the '$(description)' credential manager is unlocked"; 	
		RunFunctionLog "isUnlocked" "$manager" 2 "isUnlocked: the '$(description)' credential manager IS\$fail unlocked" " NOT" && return
	done

	return 1
}

isUnlockedMac() { IsPlatform mac; }
isUnlockedOp() { 1PasswordHelper IsUnlocked; }
isUnlockedPass() { echo -n BOGUS | pass |& grep --quiet -v "gpg: decryption failed: No secret key"; }
isUnlockedGk() { gnomeKeyringDaemonIsHealthy && [[ "$(secret-check)" == "unlocked" ]]; }
isUnlockedVault() { [[ $VAULT_TOKEN ]]; }
isUnlockedWin() { IsPlatform win; }

#
# manager list command
#

managerListUsage() { echot "Usage: $(ScriptName) manager list [all|available|locked|managers|unlocked](available)\nList credential managers."; }
managerListCommand() { managerListAvailableCommand; }
managerListAllCommand() { ArraySort allManagers && echo -n "${allManagers[@]}"; }

#
# manager list available command
#

managerListAvailableUsage() { echot "Usage: $(ScriptName) available\nShow the available credential managers."; }
managerListAvailableCommand() { listAvailable "$manager"; }

listAvailable()
{
	local alias="$1" manager available=()

	log2 "listAvailable: begin"

	for manager in $(listManagers "$alias"); do
		isAvailable "$manager" && available+=($manager)
	done

	ArraySort available || return

	log2 "listAvailable: end: ${available[@]}"

	echo -n "${available[@]}"
}

#
# manager list locked command
#

managerListLockedUsage() { echot "Usage: $(ScriptName) list locked\nShow the locked credential managers."; }
managerListLockedCommand() { listLocked "$manager"; }

listLocked()
{
	local alias="$1" manager locked=()

	log2 "listLocked: begin"

	for manager in $(listManagers "$alias"); do
		isLocked "$manager" && locked+=($manager)
	done

	log2 "listLocked: end: ${locked[@]}"

	echo -n "${locked[@]}"
}

#
# manager list managers command
#

managerListManagersUsage() { echot "Usage: $(ScriptName) manager list managers\nShow the credential managers for the specified manager alias."; }
managerListManagersCommand() { listManagers "$manager"; }

listManagers()
{
	local alias="${1:-all}"

	# get credential managers for the current platform
	local platform
	case "$PLATFORM_OS" in 
		linux) platform="gk";;
		mac) platform="mac";;
		win) platform="win gk";; # may want to prefer the GNOME Keyring in Windows if the Windows credential manager does not show credentials when elevated
	esac

	# list managers for the alias in the preferred search order
	case "${alias,,}" in
		all) echo "$platform pass vault op";;
		local|l) echo "$platform pass";;
		remote|r) echo "vault op";;

		mac|none|pass|win) echo "${alias,,}";;
		gk|gnomekeyring|st|secrettool) echo "gk";;
		op|1p|1password|OnePassword) echo "op";;
		vault|v) echo "vault";;
		*) managerInvalid "$alias";;
	esac
}

#
# manager list unlocked command
#

managerListUnlockedUsage() { echot "Usage: $(ScriptName) unlocked\nShow the unlocked credential managers."; }
managerListUnlockedCommand() { listUnlocked "$manager"; }

listUnlocked()
{
	local alias="$1" manager unlocked=()

	log2 "listUnlocked: begin"

	for manager in $(listManagers "$alias"); do
		isUnlocked "$manager" && unlocked+=($manager)
	done

	log2 "listUnlocked: end: ${unlocked[@]}"

	echo -n "${unlocked[@]}"
}

#
# manager lock command
#

managerLockUsage() { echot "Usage: $(ScriptName) lock\nLock the credential manager."; }

managerLockCommand()
{
	! RunFunctionExists "lock" "$manager" && return
	lock "$manager" || { ScriptErrQuiet "unable to lock the $(description) credential manager."; return 1; }
	EchoQuiet "The $(description) credential manager was locked."
}

# lock MANAGER
lock()
{ 
	local manager="$1"

	# manager does not support locking
	! RunFunctionExists "lock" "$manager" && return

	# already locked
	[[ ! $forceLock ]] && isLocked && return

	log1 "locking the '$(description)' credential manager"
	RunFunction "lock" "$manager"
}

lockGk() { gnomeKeyringDaemonIsHealthy && RunSilent secret-lock; }
lockOp() { op signout; }
lockPass() { gpgconf --kill gpg-agent; }

#
# manager password
#

managerPasswordUsage() { echot "Usage: $(ScriptName) manager password MANAGER\nGet the password for the specified credential manager."; }
managerPasswordArgStart() { unset -v managerArg; }
managerPasswordArgs() {	ScriptArgGet "managerArg" "manager" -- "$@" && managerNameValidate "$managerArg"; }

managerPasswordCommand()
{
	# find the location of the credential manager password
	local unlockPath
	unlockPath="$(
		local environment; environment="$(environment "$managerArg")" || return
		eval "$environment" || return
		echo "$CREDENTIAL_UNLOCK_PATH"
	)" || return
	
	log1 "manager password: looking for the '$(description "$managerArg")' password at '$unlockPath' in '$(description)'"
	local path key; pathToKey "$unlockPath" && get "$path" "$key"
}

managerPasswordNeeded() {  ! RunFunctionExists "managerPasswordNeeded" "$manager" || RunFunction "managerPasswordNeeded" "$manager"; }
managerPasswordNeededWin() { return 1; }
managerPasswordNeededMac() { return 1; }

#
# manager rebuild command
#

managerRebuildUsage() { echot "Usage: $(ScriptName) manager rebuild MANAGER\nDelete and rebuild the specified credential manager."; }
managerRebuildArgStart() { unset -v managerArg; }
managerRebuildArgs() { ScriptArgGet "managerArg" "manager" -- "$@" && managerNameValidate "$managerArg"; }

managerRebuildCommand()
{
	# require force as all passwords are deleted
	[[ ! $force ]] && { ScriptErr "to rebuild the '$(description "$managerArg")' credential manager --force is required."; return 1; }

	# check if the manager is available
	! isAvailable${managerArg^} && { managerNotFound "$managerArg"; return 1; }

	# cleanup
	hilight "Cleaning up the '$(description "$managerArg")' credential manager..."
	cleanupDo "$managerArg" || return

	# rebuild
	hilight "Cleaning the '$(description "$managerArg")' credential manager..."
	RunFunction managerClean "$managerArg";

	# initialize
	hilight "Initializing the '$(description "$managerArg")' credential manager..."
	ScriptEval credential environment --manager="$managerArg" -vvv --unlock --force "${globalArgs}" || return
	credential test all -vvv --manager="$managerArg"  || return

}

managerCleanGk() { rm -fr "$HOME/.local/share/keyrings"; }

#
# manager status command
#

managerStatusUsage() { echot "Usage: $(ScriptName) status\nShow the credential manager status."; }
managerStatusCommand() { managerStatus "$manager"; }

# managerStatus MANAGER
managerStatus()
{
	local manager="${1:-$manager}"
	[[ $quiet ]] && return
	EchoWrap "Using the '$(description "$manager")' credential manager ($(lockedStatus "$manager"))"
}

#
# manager unlock command
#

managerUnlockCommand()
{
	! RunFunctionExists "unlock" "$manager" && return
	unlock "$manager" && EchoQuiet "The $(description) credential manager was unlocked."
}

# unlock [MANAGER]($manager) - unlock the credential manager
unlock()
{
	local manager="${1:-$manager}"

	# manager does not support unlocking
	! RunFunctionExists "unlock" "$manager" && return

	# already unlocked
	[[ ! $forceUnlock ]] && isUnlocked "$manager" && return

	log1 "unlock: unlocking the '$(description)' credential manager"

	# try and find a password to unlock the credential manager
	[[ ! $password && ! $noFindPass ]] && { unlockFindPassword || return; }
		
	# unlock the credential manager
	RunFunction "unlock" "$manager" && isUnlocked "$manager" && return

	# unable to unlock
 	ScriptErrQuiet "unable to unlock the '$(description)' credential manager"
}

unlockOp() { [[ $password || unlockTerminalCheck ]] && eval "$(1PasswordHelper unlock $password "${args[@]}")"; }
unlockPass() { unlockTerminalCheck && pass | grep --quiet "1"; }

unlockGk()
{
	# unlock with password argument
  if [[ $password ]]; then
		echo -n "$password" | gnomeKeyringDaemonStart --unlock || return

	# unlock with password from console prompt
  elif [[ ! $gui && ! $noPrompt ]] && IsStdIn; then

  	local i password
		for (( i=1; i<=3; ++i )); do
	  	password="$(askPassword)" || return		
			echo -n "$password" | gnomeKeyringDaemonStart --unlock
			isUnlockedGk && break
		done

	# unlock with an X Windows dialog, which retries if the password is not correct
	elif [[ $DISPLAY && ! $noPrompt ]]; then
		[[ ! $DISPLAY ]] && { ! [[ $quiet ]] && ScriptErr "a display is required to read the $(description) password"; return 1; }
		gnomeKeyringDaemonStart || return
		RunSilent secret-unlock || return

	# unable to get a password
	else	
		unlockTerminalRequired || return

	fi
}
 
unlockVault()
{
	# use the password for the Vault token if specified
	[[ $password ]] && export VAULT_TOKEN="$password"

	# Vault is considered unlocked if we have a token for it
	[[ $VAULT_TOKEN ]]
}

# unlockFindPassword - find a password for the credential manager
unlockFindPassword()
{
	log1 "unlockFindPassword: finding the '$(description)' credential manager password"

	local managerTry
	
	# return if the credential manager doe not need a password
	! managerPasswordNeeded && return

	# try to find the password for the manager in an unlocked credential managers first
	for managerTry in $(listUnlocked); do
		unlockFindPasswordTry "$managerTry" && return
	done

	# try to find the password for manager in the locked credential managers in case it can be unlocked without a prompt,
	# i.e. with an environment variable like VAULT_TOKEN
	for managerTry in $(listLocked); do
		unlockFindPasswordTry "$managerTry" && return
	done

	return 1
}

unlockFindPasswordTry()
{
	[[ "$manager" == "$managerTry" ]] && return

	log1 "looking for the '$(description)' password in '$(description "$managerTry")'"	
	password="$(RunLog credential manager password "$manager" --manager="$managerTry" "$(excludeManagers "$manager")" --no-find-pass --quiet --no-prompt "${globalArgs[@]}")" || return
	log1 "found the '$(description)' password in '$(description "$managerTry")'"
}

unlockTerminalCheck() { IsStdIn || unlockTerminalRequired; }
unlockTerminalRequired() { ScriptErrQuiet "a terminal is required to read the $(description) password."; }

#
# mirror command
#

mirrorUsage()
{
		echot "Usage: $(ScriptName) mirror PATH [KEY]
Mirror keys from one credential manager to another.  This will ensure the 'to' credential manager is identical to \
the 'from' credential manager at the specified PATH and KEY.  The 'from' credential manager is not modified.

	-ie, --ignore-empty						ignore paths with no keys
	-r, --recursive								copy all paths starting at PATH

	-F, --from=MANAGER						from credential manager, defaults to local
	-fpp, --from-path-prefix=PATH	from path prefix, defaults to none
	-fs, --from-store=STORE				from credential store name, defaults to secret

	-T,	--to MANAGER							to credential manager, defaults to remote
	-tpp, --to-path-prefix=PATH		to path prefix, defaults to none
	-ts, --to-store=STORE					to credential store name, defaults to secret"
}

mirrorArgStart() { syncArgStart "$@"; }

mirrorOpt() 
{
	case "$1" in
		--ignore-empty|-ie) ignoreEmpty="--ignore-empty";;
		--recursive|-r) recursive="--recursive" ignoreEmpty="--ignore-empty";;

		--from|--from=*|-F|-F=*) ScriptOptGet m1 "$@" && aliasValidate "$m1";;
		--from-path-prefix|--from-path-prefix=*|-fpp|-fpp=*) ScriptOptGet "o" "$@" && cred1Args+=(--path-prefix="$o") credBothArgs+=(--from-path-prefix="$o");;
		--from-store|--from-store=*|-fs|-fs=*) ScriptOptGet "o" "$@" && cred1Args+=(--store="$o") credBothArgs+=(--from-store="$o");;

		--to|--to=*|-T|-T=*) ScriptOptGet m2 "$@" && aliasValidate "$m2";;
		--to-path-prefix|--to-path-prefix=*|-tpp|-tpp=*) ScriptOptGet "o" "$@" && cred2Args+=(--path-prefix="$o") credBothArgs+=(--to-path-prefix="$o");;
		--to-store|--to-store=*|-ts|-ts=*) ScriptOptGet "o" "$@" && cred2Args+=(--store="$o") credBothArgs+=(--to-store="$o");;

		*) return 1
	esac
}

mirrorArgs() { syncArgs "$@"; }

mirrorArgEnd()
{
	cred1Args+=(--manager=$m1) credBothArgs+=(--from=$m1)
	cred2Args+=(--manager=$m2) credBothArgs+=(--to=$m2)
}

mirrorCommand()
{
	log1 "mirroring $path from $(description "$m1")' to '$(description "$m2")'..."

	[[ $key ]] && { mirrorKey; return; }

	# require force as can't check if a path exists, only a specific credential
	[[ ! $force ]] && { ScriptErr "to overwrite all values at '$path' in '$(description "$m2")' --force is required."; return 1; }

	# get m1 keys at path
	local key keys; IFS=$'\n' ArrayMake keys "$(cred1 ls --keys "$path")"

	[[ ! $keys && ! $ignoreEmpty ]] && { ScriptErr "no permission or no keys at '$path' in '$(description "$m1")'"; return 1; }
	[[ $verbose ]] && { PrintErr "$m1 keys: "; ArrayShow keys; }

	echo "Deleting all keys at '$path' in '$(description "$m2")'..."
	cred2 rm --force --quiet "$path" all || return

	for key in "${keys[@]}"; do
		echo "Adding '$path $key' to '$(description "$m2")'..."
		local value; value="$(cred1 get "$path" "$key")" || return
		cred2 set "$path" "$key" --value="$value" || return
	done

	[[ ! $recursive ]] && return
	local paths; IFS=$'\n' ArrayMake paths "$(cred1 ls --paths "$path")"
	for path in "${paths[@]}"; do
		echo "Mirroring '$path to '$(description "$m2")'..."
		credBoth mirror "$path" $ignoreEmpty || return
	done	
}

mirrorKey()
{
	! cred1 exists "$path" "$key" && { ScriptErrQuiet "'$path $key' does not exist in $m1"; return; }
	local value; value="$(cred1 get "$path" "$key")" || return
	cred2 set "$path" "$key" "$value"
}

#
# rm command
#

rmUsage() { ScriptUsageEcho "Usage: $(ScriptName) rm PATH [KEY|all](default)
Remove a credential.

If the key is all, all keys at the path are removed.   If --force is specified, permanently remove all keys at the path including history, otherwise an empty path will still exist.\n\n$pathUsage"; }

rmArgs() { getCredentialArg "$@"; }
rmCommand() { rmDo "$path" "$key"; }

rmDo()
{
	local path="$1" key="$2"; operationInit "rm" "$path" "$key" || return

	# remove a single credential or Vault credentials
	[[ "$key" != "all" || "$manager" == "vault" ]] && { rmWorker; return; }

	# remove all credentials
	local key keys onlyKeys="true"; IFS=$'\n' ArrayMake keys "$(lsCommand)"
	for key in "${keys[@]}"; do 
		operationInit "rm" "$path" "$key" || return
		rmWorker || return
	done
}

rmWorker()
{
	local result return; result="$(RunFunction "rm" "$manager")"; return="$?"
	log1 "rm '$path' '$key': return=$return result='$result'";
	(( return != 0 )) && { ScriptErrQuiet "unable to remove '$path' '$key'"; return 1; }
	return 0
}

rmMac() { RunLog security delete-generic-password -a $USER -s "$managerPathKey"; }
rmOp() { RunLog op item delete "$managerPathKey"; }
rmPass() { RunLog pass rm --force "$managerPathKey"; }
rmWin() { RunLog RunWin wincred.exe delete "$managerPathKey"; }
rmGk() { RunLog secret-tool clear "$managerPath" "$key"; }

rmVault()
{ 
	local path="$managerPath"
	[[ "$key" == "all" ]] && { key="all" rmVaultLeaf; return; } || rmVaultKey
}

rmVaultKey()
{
	! vaultKeyExists "$path" "$key" && return
	vault kv get -format=json -mount="$store" "$path" | jq ".data.data|del(.$key)" | vault kv put -mount="$store" "$path" -
}

rmVaultLeaf()
{
	! vaultIsLeaf "$path" && return

	# permanently remove all keys at the leaf node (including history)
	# If force is not used, an empty leaf node will remain.
	[[ $force ]] && { RunLog vault kv metadata delete -mount="$store" "$path"; return; }

	# if the leaf node has data remove it
	vaultLeafHasData "$path" && { RunLog vault kv delete -mount="$store" "$path"; return; }
}
#
# set command
#

setUsage() { echot "Usage: $(ScriptName) set PATH [KEY](default) [VALUE|-]\nSet a credential.  If the value is - read it from the standard input.

	--password|-p				prompt for a password
	--value|-V=VALUE		the value to set, useful if the value begins with a -"; }

setArgStart() { unset value; key="default"; }

setOpt() 
{
	case "$1" in
		-) value="$(cat)";;
		--password|-p) value="$(PasswordGet)";;
		--value|--value=*|-V|-V=*) ScriptOptGet value "$@";;
		*) return 1
	esac
}

setArgs() 
{
	# path
	ScriptArgGet "path" -- "$@" || return; shift	

	# see if we need to get the key argument
	local needKey
	[[ $value ]] && (( $# == 1 )) && needKey="true"
	[[ ! $value ]] && (( $# > 1 )) && needKey="true"

	# key and value
	[[ $needKey ]] && { ScriptArgGet "key" -- "$@" || return; shift; }
	[[ ! $value ]] && { ScriptArgGet "value" -- "$@" || return; shift; }

	return 0
}

setCommand() { setDo "$path" "$key" "$value"; }

setDo()
{ 
	local path="$1" key="$2" value="$3"; operationInit "set" "$path" "$key" || return
	local result return; result="$(RunFunction "set" "$manager")"; return="$?"
	log1 "set '$path' '$key': return=$return result='$result'"
	(( return != 0 )) && { ScriptErrQuiet "unable to set '$path' '$key'"; return 1; }
	return 0
}

setMac() { security add-generic-password -U -a $USER -s "$managerPathKey" -X "$(echo "$value" | xxd -ps -c 0)"; }
setPass() { echo -n "$value" | pass insert -m --force "$managerPathKey"; }
setGk() { echo -n "$value" | secret-tool store --label "$managerPathKey" "$managerPath" "$key"; }
setVault() { vaultSet "$managerPath" "$key" "$value"; }
setWin() { RunWin wincred.exe set "$managerPathKey" "$value"; }

setOp()
{
	existsOp && { RunLog op item edit "$managerPathKey" password="$value" --cache; return; }
	RunLog op item create --category="Password" --title="$managerPathKey" password="$value" --tags="credential-$store" --cache
}

#
# store commands
#

storeUsage() { EchoWrap "Usage: $(ScriptName) store add|ls|name
Manage credential stores for the credential manager.  \
Credential managers support more than one physical storage container.  \
Each container holds distinct credentials."; }

storeCommand() { storeLsCommand; }

storeAddUsage() { EchoWrap "Usage: $(ScriptName) store add NAME"; }
storeAddArgs() { ScriptArgGet "name" -- "$@"; }
storeAddCommand() { RunFunction "storeAdd" "$manager"; }
storeAddVault() { vault secrets enable -path="$name" kv-v2; }

storeNameCommand() { echo "$store"; }

storeLsCommand() { RunFunction "storeLs" "$manager"; }
storeLsVault() {	vault secrets list; }

#
# sync command
#

syncUsage()
{
		echot "Usage: $(ScriptName) sync PATH [KEY](default)
Syncronize keys betwen the specified credential managers.
Both credential managers are modified to ensure they are the same
at the at the specified PATH and KEY.

	-m1,	--manager1							first credential manager, defaults to local
	-m1pp, --m1-path-prefix=PATH	first path prefix, defaults to none
	-m1s, --m1-tore=STORE					first credential store name, defaults to secret

	-m2,	--manager2							second credential manager, defaults to remote
	-m2pp, --m2-path-prefix=PATH	second path prefix, defaults to none
	-m2s, --m2-store=STORE				second credential store name, defaults to secret"
}

syncArgStart()
{
	unset -v ignoreEmpty key path recursive
	m1="local" m2="remote" cred1Args=() cred2Args=() credBothArgs=()
}

syncOpt() 
{
	case "$1" in
		-r|--recursive) recursive="--recursive";;

		-m1|--manager1|-m1=*|--manager1=*) ScriptOptGet m1 "$@" && aliasValidate "$m1";;
		--m1-path-prefix|--m1-path-prefix=*|-m1pp|-m1pp=*) ScriptOptGet "o" "$@" && cred1Args+=(--path-prefix="$o") credBothArgs+=(--m1-path-prefix="$o");;
		--m1-store|--m1-store=*|-m1s|-m1s=*) ScriptOptGet "o" "$@" && cred1Args+=(--store="$o") credBothArgs+=(--m1-store="$o");;

		-m2|--manager2|-m2=*|--manager2=*) ScriptOptGet m2 "$@" && aliasValidate "$m2";;
		--m2-path-prefix|--m2-path-prefix=*|-m2pp|-m2pp=*) ScriptOptGet "o" "$@" && cred2Args+=(--path-prefix="$o") credBothArgs+=(--m2-path-prefix="$o");;
		--m2-store|--m2-store=*|-m2s|-m2s=*) ScriptOptGet "o" "$@" && cred2Args+=(--store="$o") credBothArgs+=(--m2-store="$o");;

		*) return 1
	esac
}

syncArgs()
{
	ScriptArgGet "path" -- "$@" || return; shift
	(( ! $# )) && return; ScriptArgGet "key" -- "$@"; shift
}

syncArgEnd()
{
	cred1Args+=(--manager=$m1) credBothArgs+=(--manager1=$m1)
	cred2Args+=(--manager=$m2) credBothArgs+=(--manager2=$m2)
}

syncCommand()
{
	log1 "syncing $path from $m1 to $m2"

	[[ $key ]] && { syncKey; return; }
	
	# get all keys at path
	local key keys; IFS=$'\n' ArrayMake keys "$({ cred1 ls --keys "$path"; cred2 ls --keys "$path"; } | sort | uniq)"
	[[ $verbose ]] && { PrintErr "all keys: "; ArrayShow keys; }

	for key in "${keys[@]}"; do
		[[ ! $quiet ]] && header "$path $key"
		credBoth sync "$path" "$key" || return
	done
}

syncKey()
{
	# key does not exist in m1
	if ! cred1 exists "$path" "$key"; then
		echo "Creating '$path $key' in $m1..."
		local value; value="$(cred2 get "$path" "$key")" || return
		cred1 set "$path" "$key" "$value" || return
		return
	fi

	# key does not exist in m2
	if ! cred2 exists "$path" "$key"; then
		echo "Creating '$path $key' in $m2..."
		local value; value="$(cred1 get "$path" "$key")" || return
		cred2 set "$path" "$key" "$value" || return
		return
	fi

	# compare values
	local value1; value1="$(cred1 get "$path" "$key")" || return
	local value2; value2="$(cred2 get "$path" "$key")" || return

	if [[ "$value1" == "$value2" ]]; then
		echo "$path $key is the same in $m1 and $m2"
		return
	fi

	# compare time
	local time1; time1="$(cred1 get time "$path" "$key" | GetSeconds -)" || return
	local time2; time2="$(cred2 get time "$path" "$key" | GetSeconds -)" || return

	if [[ $verbose ]]; then
		log1 "$m1 modifification time is $(cred1 get time "$path" "$key") ($time1 seconds)"
		log1 "$m2 modifification time is $(cred2 get time "$path" "$key") ($time2 seconds)"
	fi

	if (( $(echo "$time1 > $time2" | bc -l) )); then
		echo "Updating $m2 ($m1 value is newer)..."
		cred2 set "$path" "$key" "$value1" || return
	else
		echo "Updating $m1 ($m2 value is newer)..."
		cred1 set "$path" "$key" "$value2" || return
	fi
}

#
# test commands
#

testUsage() { EchoWrap "Usage: $(ScriptName) test all|path|get|set\nTest the credential manager."; }
testCommand() { usage; }

testAllUsage() { EchoWrap "Usage: $(ScriptName) test path\nTest the credential manager get and set."; }
testAllCommand() { testSetCommand && testGetCommand; }

testPathUsage() { EchoWrap "Usage: $(ScriptName) test path\nThe path for the credential manager test."; }
testPathCommand() { testPath; }

testGetUsage() { EchoWrap "Usage: $(ScriptName) test get\nTest credential manager get."; }
testGetCommand() { local path key; pathToKey "$(testPath)" && get "$path" "$key" > /dev/null; }

testSetUsage() { EchoWrap "Usage: $(ScriptName) test set\nTest credential manager set."; }
testSetCommand() { local path key; pathToKey "$(testPath)" && setDo "$path" "$key" "$manager-success"; }

testPath() { echo "/test/check"; }

#
# helper - arguments
#

getCredentialArg() # PATH [KEY](default)
{
	ScriptArgGet "path" -- "$@" || return; shift
	(( ! $# )) && key="default" || ScriptArgGet "key" -- "$@"
}

getExcludeManagersOpt()
{
	ScriptOptGet "excludeManagers" "exclude-managers" "$@" || return
	excludeManagersArg=( --exclude-managers "$excludeManagers" )
	StringToArray "${excludeManagers,,}" "," excludeManagers

	# validate the managers
	local manager; for manager in "${excludeManagers[@]}"; do
		! isManager "$manager" && { managerInvalid "$manager"; return 1; }
	done

	return 0
}

#
# helper - GNOME Keyring
#

gnomeKeyringDaemonIsHealthy()
{
	gnomeKeyringDaemonEnvironment || return

	# check running
	if ! IsProcessRunning --full "gnome-keyring-daemon"; then
		log1 "gnome-keyring-daemon is not running"
		return 1
	fi

	# check sockets
	log2 "GNOME_KEYRING_CONTROL=$GNOME_KEYRING_CONTROL"
	for socket in "$GNOME_KEYRING_CONTROL/control" "$GNOME_KEYRING_CONTROL/pkcs11"; do
		gnomeKeyringCheckSocket "$socket" || return
	done

	return 0
}

gnomeKeyringCheckSocket()
{
	local socket="$1"
	log2 "checking keyring socket '$socket'"
	! [[ -e "$socket" ]] && { log1 "keyring socket '$socket' missing"; return 1; }
	! [[ -S "$socket" ]] && { log1 "keyring socket '$socket' is not a socket"; return 1; }
	return 0
}

gnomeKeyringDaemonEnvironment()
{
	[[ $GNOME_KEYRING_CONTROL && ! $forceEnvironment ]] && return

	export XDG_RUNTIME_DIR="/run/user/$(${G}id -u)"
	export GNOME_KEYRING_CONTROL="$XDG_RUNTIME_DIR/keyring"
	SystemdConf || return
}

# gnomeKeyringDaemonStart - start the gnome-keyring-daemon and return export variables
gnomeKeyringDaemonStart()
{	
	# load the environment
	gnomeKeyringDaemonEnvironment || return

	# start the gnome-keyring-daemon
	# - do not use the SSH component as it interferes with existing SSH agents
	# - use setsid to ensure the process stays running when the current shell ends
	if [[ "$@" || $forceEnvironment ]] || ! gnomeKeyringDaemonIsHealthy; then
		
		local var="$(RunQuiet setsid --fork --wait -- gnome-keyring-daemon --components=secrets,pkcs11 --replace "$@")"
		[[ $var ]] && eval "export $var"
	fi

	# check if healthy
	! gnomeKeyringDaemonIsHealthy && { ScriptErrQuiet "unable to start the gnome-keyring-daemon"; return 1; }

	# healthy
	log2 "gnomeKeyringDaemonStart: started successfully (arguments='$@')"
	return 0
}

#
# helper - vault
#

# vaultGet PATH [KEY] - get value of KEY at PATH.  If key is not specified all of the data at 
#
# Return values:
# 0 - key exists, show value
# 1 - path exists, key does not
# 2 - path does not exist
# 3 - error getting key
vaultGet()
{
	local path="$1" key="$2"

	# get
	log3 "vaultGet: vault kv get -field=\"$key\" -mount=\"$store\" \"$path\""
	local result return ; result="$(vault kv get -field="$key" -mount="$store" "$path" 2>&1)"; return="$?"

	# exists, return 0
	if (( return == 0 )); then
		echo "$result"
		return 0
	fi

	# path exists, key does not, return 1
	if echo "$result" | grep --quiet "^Field \"$key\" not present in secret$"; then
		log3 "vaultGet: key '$key' does not exist at '$path'"
		return 1
	fi	

	# path does not exist, return 2
	if echo "$result" | grep --quiet "^No value found at"; then
		log3 "vaultGet: path '$path' does not exist"
		return 2
	fi
	
	# other error
	ScriptErrQuiet "unexpected Vault error getting '$path $key'"; EchoErr "$result"
	return 3
}

# vaultLs PATH - list folders and keys at PATH, one per line.  Folders end in /.
#
# Return values:
# 0 - path exists, show folders and keys
# 1 - path does exist
# 2 - error getting path
vaultLs()
{
	local path="$1" key="$2"

	# list
	log3 "command: vault kv list ${args[@]} -mount=\"$store\" \"$path\""
	local result return; result="$(vault kv list "${args[@]}" -mount="$store" "$path" 2>&1)"; return="$?"

	# exists, return 0
	if (( return == 0 )); then
		echo "$result" | ${G}tail --lines=+3
		return 0
	fi

	# path does not exist, return 1
	if echo "$result" | grep --quiet "^No value found at"; then
		log3 "vaultLs: path '$path' does not exist"
		return 1
	fi
	
	# other error
	ScriptErrQuiet "unexpected Vault error listing '$path'"; EchoErr "$result"
	return 2
}

# vaultSet PATH KEY VALUE
vaultSet()
{	
	local path="$1" key="$2" value="$3" return

	local return; vaultLeafHasData "$path"; return="$?"
	(( return == 3 )) && return "$return"

	if (( return == 0 )); then
		log3 "vaultSet: vault kv patch -mount=\"$store\" \"$path\" \"$key\"=\"$value\""
		vault kv patch -mount="$store" "$path" "$key"="$value"
	else
		log3 "vaultSet: vault kv put -mount=\"$store\" \"$path\" \"$key\"=\"$value\""
		vault kv put -mount="$store" "$path" "$key"="$value"
	fi
}

# vaultIsLeaf PATH - return 0 if the path is a leaf node with values
vaultIsLeaf() { vaultGet "$1" > /dev/null; }

# vaultKeyExists PATH KEY - return 0 if the key exists at path, 1 if it does not
vaultKeyExists() { vaultGet "$1" "$2" > /dev/null; }

# vaultLeafHasData PATH - leaf node contains data (contains non-deleted keys)
vaultLeafHasData() { vaultGet "$1" | ${G}grep --quiet --extended-regexp "^(=)+ Data (=)+$"; }

# vaultPathHasChildren PATH - return 0 if the path has children
vaultPathHasChildren() { vaultLs "$1" > /dev/null; }

#
# helper
#

aliasValidate() { listManagers "$1" > /dev/null; }
canFallbackRemote() { ! isManagerRemote "$1" && [[ $fallback ]] && isAvailable "remote"; }
askPassword() { ask password "Enter the $(description) credential store password"; }
credDo() { RunLog credential --unlock "${excludeManagersArg[@]}" $fallback "${globalArgs[@]}" "$@"; }
cred() { credDo "${storeArg[@]}" "${pathPrefixArg[@]}" "$@"; }
cred1() { credDo "${cred1Args[@]}" "$@"; }
cred2() { credDo "${cred2Args[@]}" "$@"; }
credBoth() { credDo "${credBothArgs[@]}" "$@"; }
isExcluded() { ! IsInArray "${1,,}" excludeManagers && return 1; log1 "$1 is excluded"; return 0; }
isManager() { IsInArray "${1,,}" allManagers; } 
isManagerRemote() { local manager="$1" a=( $(listManagers "remote") ); IsInArray "$manager" a; }
lockedStatus() { isUnlocked "$1" && echo "unlocked" || echo "locked"; }
pathToKey() { path="$1"; key="$(GetFileName "$path")" path="$(GetFilePath "$path")"; }

# description [MANAGER] - return the description of the credential manager 
description()
{
	local manager="${1:-$manager}"
	case "${manager,,}" in
		gk) printf "GNOME Keyring";;
		mac) printf "Macintosh";;
		op) printf "1Password";;
		pass) printf "pass";;
		vault) printf "HashiCorp Vault";;
		win) 	printf "Windows";;
		*) printf "$manager";;
	esac
}

# excludeManagers [manager]... - return the --manager-exclude option with the existing plus new excluded managers
excludeManagers()
{
	local excludes=( "${excludeManagers[@]}" "$@" )
	echo -n "--exclude-managers=$(ArrayDelimit excludes)"	
}

keyNotFound()
{ 
	canFallbackRemote "$manager" && return 1
	ScriptErrQuiet "'$1 $2' does not exist in the '$(description)' credential store"
	return 1
}

# managerPath PATH - return the manager specific path, i.e. : /a/b/ -> $store-$pathPrefix-a-b	
managerPath()
{
	local path="$1"

	# cleanup path - //a////b/c/ -> a/b/c
	path="$(echo "$path" | sed 's/\/\///g' | RemoveTrim "/")"

	# manager custom path
	RunFunctionExists "managerPath" "$manager" && { RunFunction "managerPath" "$manager" -- "$path"; return; }

	# default path - a/b -> $store-$pathPrefix-a-b	 
	local prefix=""
	[[ $store ]] && prefix+="$store-"
	[[ $pathPrefix ]] && prefix+="${pathPrefix//\//-}-"
	echo "$prefix$(RemoveTrim "${path//\//-}" "-")"
}

# managerPathVault PATH: /a/b/ -> /$pathPrefix/a/b/
managerPathVault()
{
	local prefix=""
	[[ $pathPrefix ]] && prefix+="/$(RemoveTrim "$pathPrefix" "/")"
	echo "${prefix}/$1"
}

# managerPathPass PATH: /a/b/ -> /$store/$pathPrefix/a/b
managerPathPass()
{
	local prefix=""
	[[ $store ]] && prefix+="/$store"
	[[ $pathPrefix ]] && prefix+="/$(RemoveTrim "$pathPrefix" "/")"
	echo "${prefix}/$1"
}

# operationInit OPERATION PATH KEY - set managerPathKey and managerKey to the manager specific values for the operation
operationInit()
{
	local operation="$1" path="$2" key="$3"; 

	managerPath="$(managerPath "$path")" || return
	managerPathKey="$(managerPath "$path/$key")" || return

	log1 "$operation: manager='${manager,,}' store='$store' path='$path' key='$key' managerPath='$managerPath' managerPathKey='$managerPathKey'"
}

ScriptRun "$@"

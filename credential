#!/usr/bin/env bash
. script.sh || exit

run() {	init && args "$@" && findManager && initManager && "${command}Command"; }

init()
{
	pathUsage="\
	path		credential location, i.e. folder or /folder1/folder2"
}

usage()
{
	ScriptUsage "$1" "\
Usage: credential
Interact with a credential store.

Common commands:
	get[s]	get a credential
	set			set a credential

Other commands:
	check		check if a credential manager is installed
	delete  delete a credential
	engine	manage credential engines
	exists 	check if a credential exists
	list 		list credentials
	manager	show the the GUI manager
	status	show the credential manager status
	sync		synronize a credential
	type		show the type of the credential manager in use		

Options:
	-e, --engine=ENGINE 	physical storage engine for credentials
	-x, --exclude-managers=MANAGERS	exclude the comma separated list of managers
	-m, --manager					force the use of a specific credential manager
	-f, --force  					force the operation
	-q, --quiet 					minimize informational messages

Environment variables:
	CREDENTIAL_MANAGER		if set use the specified credential manager (see below)
	CREDENTIAL_ENGINE			if set, specify the secret engine to use (Vault)

Credential managers: 
	local|l|remote|r			find a local or remote (network) credential manager
	platform							find a credential manager for the current platform (default)
	none									do not use a credential manager

	mac|win 							use the native credential manager for the platform
	pass|SecretTool				use the pass or SecretTool credential managers
	vault|v		 						use HashiCorp Vault"
}

args()
{
	local args=()
	unset -v force quiet type
	unset -v path key
	excludeManagers=()

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in
			-e|--engine) ScriptArg engine "$@";;
			-f|--force) force="true";;
			-h|--help) usage 0;;
			-m|--manager|-m*|--manager=*) ScriptArg "type" "manager" "$@";;
			-x|--exclude-managers|-x*|--exclude-managers=*) ScriptArg "excludeManagers" "exclude-managers" "$@"; StringToArray "${excludeManagers,,}" "," excludeManagers;;
			-q|--quiet) quiet="true";;
			*) ScriptOption "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# other arguments
	ScriptArgs "$@" || return; shift "$shift"

	# initialize
	[[ ! $type && $CREDENTIAL_MANAGER ]] && IsFunction "findManager${CREDENTIAL_MANAGER}" && type="$CREDENTIAL_MANAGER"
 	[[ ! $engine && $CREDENTIAL_ENGINE ]] && engine="$CREDENTIAL_ENGINE" || engine="secret"

	(( $# == 0 )) && return || usage
}

getCredentialArg() # PATH [KEY](default)
{
	ScriptGetArg "path" -- "$@"; shift
	[[ $1 ]] && { ScriptGetArg "key" -- "$@"; shift; } || key="default"
}

#
# Commands
#

checkCommand() { return 0; }
typeCommand() { echo "$type"; }

managerCommand()
{
	if IsPlatform win; then 
		control.exe /name Microsoft.CredentialManager
	elif IsPlatform debian; then
		start seahorse
	fi
}

statusCommand()
{
	echo "Credential store is $type"
	
	if [[ "$type" == "vault" ]]; then
		echo; vault status 
	elif findManagerVault; then
		echo "Vault is available"
	fi
		
	return 0
}

#
# Delete Command
#

deleteUsage() { echot "Usage: $(ScriptName) delete PATH [KEY|all](default)
Delete a credential.

If the key is all, all keys at the path are deleted.   If --force is specified,
permanently delete all keys at the path.\n\n$pathUsage"; }

deleteGetArgs() { getCredentialArg "$@"; }

deleteCommand() { RunFunction "delete" "$type" -- "$@"; }
deleteMac() { security delete-generic-password -gwa $USER -s "$path-$key"; }
deletePass() { pass rm "$path-$key"; }
deleteSecretTool() { deleteGeneric; }
deleteWin() { deleteGeneric; }

deleteVault()
{ 
	# delete a key
	if [[ "$key" != "all" ]]; then
		! vaultKeyExists "$path" "$key" && return
		vault kv get -format=json "$path" | jq ".data.data|del(.$key)" | vault kv put "$path" -
	
	# permanently delete all keys
	elif [[ $force ]]; then
		! vaultPathExists "$path" && return
		vault kv metadata delete "$path"

	# delete all keys
	else
		! vaultDataExists "$path" && return
		vault kv delete "$path"
		
	fi
}

deleteGeneric()
{
	if [[ "$key" != "all" ]]; then
		RunFunction "deleteDo" "$type" || return

	else
		local key keys; IFS=$'\n' keys=( $(listCommand) )
		for key in "${keys[@]}"; do deleteWin || return; done
	fi
}

deleteDoWin() { wincred.exe delete "$path-$key"; }
deleteDoSecretTool() { secret-tool clear "$path" "$key"; }

#
# Engine Commands
#

engineUsage() { echot "Usage: $(ScriptName) engine add|list
Manage credential engines."; }

engineCommand() { engineListCommand; }

engineListCommand() { RunFunction "engineList" "$type" -- "$@"; }
engineListVault() {	vault secrets list; }

engineAddUsage() { echot "Usage: $(ScriptName) engine add NAME"; }
engineAddGetArgs() { ScriptGetArg "name" -- "$@"; shift; }
engineAddCommand() { RunFunction "engineAdd" "$type" -- "$@"; }
engineAddVault() { vault secrets enable -path="$name" kv-v2; }

#
# Exist Command
#

existsUsage() { echot "Usage: $(ScriptName) exists PATH [KEY](default)
Return 0 if the specified credential exists.\n\n$pathUsage"; }

existsGetArgs() { getCredentialArg "$@"; }

existsCommand() { RunFunction "exists" "$type" -- "$@"; }
existsMac() { security find-generic-password -gwa $USER -s "$path-$key" >& /dev/null; }
existsPass() { [[ -f "$HOME/.password-store/$path-$key.gpg" ]]; }
existsSecretTool() { secret-tool search $path $key |& grep label >& /dev/null; }
existsVault() { vaultKeyExists "$path" "$key"; }
existsWin() { wincred.exe exists "$path-$key"; }

#
# Get Command
#

getUsage() { echot "Usage: $(ScriptName) get PATH [KEY](default)
Get a credential.\n\n$pathUsage"; }

getGetArgs() { getCredentialArg "$@"; }

getCommand() { RunFunction "get" "$type" -- "$@"; }
getMac() { security find-generic-password -gwa $USER -s "$path-$key" 2> /dev/null; }
getPass() { pass show "$path-$key"; }
getSecretTool() { secret-tool lookup "$path" "$key"; }
getVault() { vault kv get -field="$key" "$path"; }
getWin() { wincred.exe get "$path-$key"; }

#
# Gets Command
#

getsUsage() { echot "Usage: $(ScriptName) gets PATH [KEY](default)
Get a credential silently (without showing an error).
This is useful if the key does not exist.\n\n$pathUsage"; }

getsGetArgs() { getCredentialArg "$@"; }
getsCommand() { RunFunction "get" "$type" -- "$@" 2> /dev/null; return 0; }

#
# List Command
#

listUsage() { echot "Usage: $(ScriptName) list [path]
List all the paths or all keys at the specified path.\n\n$pathUsage"; }

listGetArgs()
{
	[[ $1 ]] && ScriptGetArg "path" -- "$@"; shift
	return 0
}

listCommand() { RunFunction "list" "$type" -- "$@"; }
listPass() { pass show; } 

listSecretTool()
{	
	local filter="$(RemoveTrim "$path" "-")-"
	local levels="$(CharCount "$filter" "-")"
	lssecret | grep "^Item:" | cut -d$'\t' -f2 | grep "^$filter" | cut -d- -f$(( levels+1 )) | sort | uniq
}

listVault()
{	
	# path with data
	if vaultDataExists "$path"; then
		vault kv get -format=json "$path" | jq '.data.data|keys|.[]' -r

	# folder
	elif ! vaultPathExists "$path"; then
		vault kv list "$path" | tail +3
		(( ${PIPESTATUS[0]} == 0 ))

	fi
	
}

listWin()
{
	local filter="$(RemoveTrim "$path" "-")-*"
	local levels="$(CharCount "$filter" "-")"
	wincred.exe list "$filter" | RemoveCarriageReturn | cut -d- -f$(( levels+1 )) | sort | uniq
}

#
# Set Command
#

setUsage() { echot "Usage: $(ScriptName) set PATH [KEY](default) value
Set a credential."; }

setGetArgs()
{
	ScriptGetArg "path" -- "$@"; shift
	(( $# > 1 )) && { ScriptGetArg "key" -- "$@"; shift; } || key="default"
	ScriptGetArg "value" -- "$@"; shift
}

setCommand() { RunFunction "set" "$type" -- "$@"; }
setMac() { security add-generic-password -U -a $USER -s "$path-$key" -w "$value"; }
setPass() { pass insert -m --force "$path-$key"<<< "success" 2> /dev/null; }
setSecretTool() { echo "$value" | secret-tool store --label "$path-$key" "$path" "$key"; }
setWin() { wincred.exe set "$path-$key" "$value"; }

setVault()
{	
	if ! vaultDataExists "$path"; then
		vault kv put "$path" "$key"="$value"
	else
		vault kv patch "$path" "$key"="$value"
	fi
}

#
# Sync Command
#

syncUsage()
{
		echot "Usage: $(ScriptName) sync PATH [KEY](default)
Synronize a credential betwen the local and remote credential store.

	-ro,	--remote-older	assume destination credential is older
	-lo,	--local-older		assume local credential is older"
}

syncArgStart() { unset -v localOlder remoteOlder; }

syncGetOption() 
{
	case "$1" in
		-lo|--local-older) localOlder="true";;
		-ro|--remote-older) remoteOlder="true";;
		*) return 1
	esac
}

syncGetArgs() { getCredentialArg "$@"; }

syncArgEnd()
{
	[[ $localOlder && $remoteOlder ]] && { ScriptErr "only one of --local-older or --remote-older may be specified"; return 1; }
	[[ ! $localOlder && ! $remoteOlder ]] && { ScriptErr "one of --local-older or --remote-older must be specified"; return 1; }
	return 0
}

# credential get --local-or-remote
# credential sync --dest-older -do --source-older -so

syncCommand()
{

	local p="$1" key="$2" value="$3" m managers=( local remote )

	for m in "${managers[@]}"; do

		if ! credential exists "$p" "$key" --quiet --manager="$m"; then
			echo "Creating \`$p $key\` ($m)..."
			credential set "$@" --manager="$m" || return

		elif [[ "$(credential get "$p" "$key" --manager="$m")" != "$value" ]]; then
			echo "Updating \`$p $key\` ($m)..."
			credential set "$@" --manager="$m" || return

		fi

	done

}

#
# Find a Credential Manager
#

findManager()
{
	type="${type,,}"

	# no credential manager was found
	[[ "$type" == "none" ]] && { noCredentialManager; return; }

	# use the specified credential manager
	if [[ $type && "$type" != @(l|local|platform) ]]; then

		# aliases
		[[ "$type" == @(remote|r|v) ]] && type="vault"

 		# ensure correct case
		if [[ "$type" == "secrettool" ]]; then type="SecretTool"
		else type="$(ProperCase "$type")"
		fi

		# see if the specified credential manage is valid
		if ! IsFunction "findManager${type}"; then
			[[ ! $quiet ]] && EchoErr "credential: \`$type\` is not a valid credential manager"
			return 1
		fi

		# ensure the specified credential manager is available
		"findManager${type^}" || noCredentialManager "$type"
		return
	fi

	# find a credential manager based on the platform
	RunPlatform findManagerPlatform || noCredentialManager
}

findManagerPlatformLinux() { findManagerSecretTool || findManagerPass || findManagerVault; }
findManagerPlatformMac() { findManagerMac || findManagerPass || findManagerVault; }
findManagerPlatformWin() { findManagerWin || findManagerSecretTool || findManagerPass || findManagerVault; }

findManagerMac() # MacOS Keychain
{
	{ IsInArray "mac" excludeManagers || ! IsPlatform mac || ! Inpath security; } && return 1	
	type="mac"
}

findManagerPass() 
{
	{ IsInArray "secrettool" excludeManagers || ! InPath pass; } && return 1
	pass insert -m --force test-default<<< "success" >& /dev/null && type="pass"
}

findManagerSecretTool()
{
	# ensure SecretTool is installed and we are using an X display
	{ IsInArray "secrettool" excludeManagers || [[ ! $DISPLAY ]] || ! InPath secret-tool; } && return 1

	# ensure DBUS can be configured correctly over SSH (so we get the Ubuntu Gnome keyring password prompt)
	if IsSsh && InPath dbus-launch dbus-update-activation-environment; then
		local result; result="$(dbus-update-activation-environment --systemd DISPLAY 2>&1)" || return
		[[ "$result" != "" ]] && return 1 # returns error text if there is an issue
	fi 

	echo "success" | secret-tool store --label "test" test default >& /dev/null && type="SecretTool"
}

findManagerVault()
{
	{ IsInArray "vault" excludeManagers || ! InPath vault; } && return 1
	[[ ! $VAULT_ADDR || ! $VAULT_TOKEN ]] && { eval "$(hashi vault config)" || return; }
	[[ $VAULT_ADDR && $VAULT_TOKEN ]] && type="vault"
}

findManagerWin() # Windows Credential Manager
{
	{ IsInArray "win" excludeManagers || ! IsPlatform win || ! InPath "wincred.exe"; } && return 1	
	type="win"
}

#
# Initialize the Credential Manager
#

initManager() { [[ ! $type ]] && return; RunFunction "initManager" "$type"; }
initManagerGeneric() { path="$engine-$(RemoveTrim "${path//\//-}" "-")"; }			# /a/b/ -> $engine-a-b
initManagerSecretTool() { initManagerGeneric; }
initManagerVault() { path="/$engine/$(RemoveTrim "$path" "/")"; } 							# /a/b/ -> /$engine/a/b
initManagerWin() { initManagerGeneric; }

noCredentialManager()
{
	local desc="a"; [[ $1 ]] && desc="the $1"
	[[ ! "$quiet" ]] && ScriptErr "$desc credential manager is not available"
	[[ "$command" == "type" ]] && echo "none"
	return 1
}

#
# Vault Helper
#

# vaultKeyExists PATH KEY - return 0 if the key exists at path, 1 if it does not
vaultKeyExists() { vaultPathSpecified "$1" && vault kv get -field="$2" "$1" >& /dev/null; }

# vaultDataExists PATH - return 0 if the path contains data
vaultDataExists() { vaultPathSpecified "$1" && vault kv get "$1" |& grep -q -E "(=)+ Data (=)+"; }

# vaultPathExists PATH - return 0 if the path exists
vaultPathExists() { vaultPathSpecified "$1" && vault kv get "$1" >& /dev/null; }

# vaultPathSpecified PATH - return 0 if a path has been specified
vaultPathSpecified() { [[ $path && "$(RemoveTrim "$path" "/")" != "$engine" ]]; }


run "$@"
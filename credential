#!/usr/bin/env bash
. function.sh

run() {	init && args "$@"; findManager && initManager && "${command}Command"; }

init() { :; }

usage()
{
	echot "\
usage: credential manager|status
	check															check if a credential manager is installed
	delete path [key|all](default)		delete the key
		If all is specified all, all keys at the path are deleted.  
		If all and --force are specified, permanently delete all keys at the path (all metadata and versions). 
	exists path [key](default)				check if a key exists
	list [path]												list all the paths, or all keys at the specified path
	get path [key](default)						get a key 
	set path [key](default) value			set a key

	path						a grouping of credentials key/value paris.   
									For vault the path prefix defaults to $vaultDefaultEngine/.

	-e, --engine ENGINE 	specify the secret engine, defaults to secret (Vault only)
	-f, --force  					force the operation
	-q, --quiet 					minimize informational messages
	-v, --vault						force the use of vault even if another credential manager exists

	Environment variables:
	CREDENTIAL_VAULT			if set use vault
	CREDENTIAL_ENGINE			if set, specifies the secret engine to use (Vault only)"
	exit 1
}

args()
{
	unset command force key path value quiet vault
	args=() key="default"

	# options
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-e|--engine) [[ ! $2 ]] && usage; engine="$2"; shift;;
			-f|--force) force="true";;
			-h|--help) usage 0;;
			-q|--quiet) quiet="true";;
			-v|--vault) vault="true";;
			*) args+=( "$1" )
		esac
		shift
	done

	set -- "${args[@]}"

	# environment variables
	[[ $CREDENTIAL_VAULT ]] && vault="true"

	# command
	{ [[ $# == 0 ]] || ! IsFunction ${1}Command; } && usage
	command="$1"; shift

	# command arguments
	if [[ "$command" == @(delete|exists|get|list|set) ]]; then
	
		# path
		(( $# == 0 )) && [[ "$command" != @(list) ]] && usage;
		(( $# > 0 )) && { path="$1"; shift; }

		# key
		case "$command" in
			delete|exists|get) [[ $# == 1 ]] && { key="$1"; shift; };;
			set) [[ $# == 2 ]] && { key="$1"; shift; }; ;;
		esac
		
	fi

	# value
	[[ "$command" == "set" && $# == 1 ]] && { value="$1"; shift; };

	[[ $# != 0 ]] && usage;
}

#
# Commands
#

checkCommand() { return 0; }
typeCommand() { echo "$type"; }

managerCommand()
{
	if IsPlatform win; then 
		control.exe /name Microsoft.CredentialManager
	elif IsPlatform debian; then
		start seahorse
	fi
}

statusCommand()
{
	echo "Credential store is $type"
	
	if [[ "$type" == "vault" ]]; then
		echo; vault status 
	elif checkVault; then
		echo "Vault is available"
	fi
		
	return 0
}

#
# Delete Command
#

deleteCommand() { RunFunction "delete$type" -- "$@"; }

deleteMac() { security delete-generic-password -gwa $USER -s "$path-$key"; }
deletePass() { pass rm "$path-$key"; }
deleteSecretTool() { secret-tool clear "$path" "$key"; }
deleteWinCred() { wincred.exe set "$path-$key" "$USER" "" 2> /dev/null; }

deleteVault()
{ 
	# return if already deleted
	if [[ "$key" == "all" ]]; then
		! vaultPathExists "$path" && return
	else
		! vaultKeyExists "$path" "$key" && return
	fi

	# delete a single key by setting it's value to the empty string
	[[ "$key" != "all" ]] && { vault kv patch "$path" "$key"=""; return; }

	# delete all of the keys permanently
	[[ $force ]] && { vault kv metadata delete "$path"; return; }

	# delete latest version of all keys
	vault kv delete "$path"
}

#
# Exist Command
#

existsCommand() { RunFunction "exists$type" -- "$@"; }

existsMac() { security find-generic-password -gwa $USER -s "$path-$key" >& /dev/null; }
existsPass() { [[ -f "$HOME/.password-store/$path-$key.gpg" ]]; }
existsSecretTool() { secret-tool search $path $key |& grep label >& /dev/null; }
existsVault() { vault kv get -field="$key" "$path" >& /dev/null; }
existsWinCred() { wincred.exe get "$path-$key" 2> /dev/null >& /dev/null; }

#
# Get Command
#

getCommand()
{
	local pass="$(RunFunction "get$type" -- "$@")"
	[[ $pass ]] && echo "$pass" || return 1
}

getMac() { security find-generic-password -gwa $USER -s "$path-$key" 2> /dev/null; }
getPass() { pass show "$path-$key"; }
getSecretTool() { secret-tool lookup "$path" "$key"; }
getVault() { vault kv get -field="$key" "$path"; }
getWinCred() { wincred.exe get "$path-$key" 2> /dev/null; }

#
# List Command
#

listCommand() { RunFunction "list$type" -- "$@"; }

listVault()
{	
	# list keys at path
	if [[ $(GetWord "$path" 2 /) ]]; then
		vaultPathValidate "$path" || return
		vault kv get "$path"
	fi

	# list available paths
	local paths result
	paths="$(vault kv list "$path" |& tail +3)"; result="$?"

	[[ "$paths" =~ ^"No value found at" ]] && return

	if [[ "$result" != 0 ]]; then
		[[ ! $quiet ]] && EchoErr "$paths"
		return "$result"
	fi

	printf "$paths\n"
}

#
# Set Command
#

setCommand() { RunFunction "set$type" -- "$@"; }

setMac() { security add-generic-password -U -a $USER -s "$path-$key" -w "$value"; }
setPass() { passSet; }
setSecretTool() { echo "$value" | secret-tool store --label "credential for $path $key" "$path" "$key"; }
setWinCred() { wincred.exe set "$path-$key" "$USER" "$value" 2> /dev/null; }

setVault()
{
	if ! vaultPathExists "$path"; then
		vault kv put "$path" "$key"="$value"
	else
		vault kv patch "$path" "$key"="$value"
	fi
}

#
# Find a Credential Manager
#

findManager()
{
	# check for vault if it was called for explicitly
	if [[ $vault ]]; then
		findManagerVault && return
		noCredentialManager "vault"
	fi

	# check for a platform specific credential manager
	RunPlatform findManager && return
	noCredentialManager
}

findManagerMac() { type="Mac"; }
findManagerWin() { ! InPath "wincred.exe" && return 1; type="WinCred"; }

findManagerLinux()
{
	[[ $DISPLAY ]] && InPath secret-tool && echo "success" | secret-tool store --label "test" test default >& /dev/null && { type="SecretTool"; return; }
	passCheck && { type="Pass"; return; }	
}

findManagerVault()
{
	{ ! InPath vault || [[ ! $VAULT_TOKEN ]]; } && return 1
	type="Vault"
}

#
# Initialize the Credential Manager
#

initManager() { RunFunction "initManager$type"; }

initManagerVault()
{
	# get engine
	[[ ! $engine && $CREDENTIAL_ENGINE ]] && engine="$CREDENTIAL_ENGINE"
	[[ ! $engine ]] && engine="secret"

	# validate engine - it must be a key value (kv) secret engine
	if ! vault secrets list |& grep "^$engine/[ ]*kv[ ]" >& /dev/null; then
		[[ ! $quiet ]] && EchoErr "\`$engine\` is not a valid key value secrets engine"
		return 1
	fi

	# add engine to path
	path="$engine/$path"
}

noCredentialManager()
{
	local desc="${1:-A credential manager}"
	[[ ! "$quiet" ]] && ScriptErr "$desc is not available"
	return 1
}

#
# Vault Helper
#

# vaultKeyExists PATH KEY - return 0 if the key exists at path, 1 if it does not
vaultKeyExists() { vault kv get -field="$2" "$1" >& /dev/null; }

# vaultPathExists PATH - return 0 if the path is valid
vaultPathExists() { vault kv get "$1" >& /dev/null; }

# vaultPathValidate PATH - if the path does not exist return an error
vaultPathValidate()
{ 
	vaultPathExists "$path" && return
	[[ ! "$quiet" ]] && ScriptErr "the path ``$path`` does not exist"
	return 1
}

# 
# pass helper - put last, causes issues with sublime hilighting
#

passCheck() { InPath pass && pass insert -m --force test-default<<<"success" >& /dev/null; }
passSet() { pass insert -m --force "$path-$key"<<<"success" 2> /dev/null; }

run "$@"


#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName)
Interact with a credential store.

Common commands:
	exists 		check if a credential exists
	get[s]		get a credential
	ls 				list credentials
	manager		manage credetnial managers
	rm  			remove a credential
	set				set a credential

Common options:
	-F, --fallback			 							fallback to a remote credential manager if possible
	-em, --exclude-managers=MANAGERS	comma separated list of managers to exclude
	-m, --manager											force the use of a specific credential manager
	-ul, --unlock											force unlocking of the credential manager"
}

usageVerbose()
{ 
	ScriptUsageEcho "
Copy commands:
	copy		copy credentials from one path to another
	mirror	mirror credentials from one credential manager to another
	sync		synronize credentials from one credential manager to another

Other commands:
	environment			return environment variables
	gui							show the the GUI manager
	store						manage credential stores

Other options:
	-e, --engine=ENGINE 			physical storage engine for credentials, defaults to secret
	-g, --gui									force a GUI prompt for the password
	-p, --password=PASSWORD 	password to unlock the credential manager

Environment variables:
	CREDENTIAL_MANAGER		if set use the specified credential manager (see below)
	CREDENTIAL_ENGINE			if set, specify the secret engine to use (Vault)

Credential managers: 
	all										find all credential managers (default)
	local|l|remote|r			find local or remote (network) credential managers
	platform							find a credential manager for the current platform
	none									do not use a credential manager

	mac|win 							native credential manager for the platform (MacOS Keychain, Windows Credential Manager)
	op|pass|SecretTool	  1Password, pass, or SecretTool credential managers
	vault|v		 						HashiCorp Vault credential manager"
}

init()
{
	unset -v path key # getCredentialArg
	allManagers=(mac op pass SecretTool vault win)
	sep="-"
	pathUsage="	path		credential location, i.e. folder or /folder1/folder2"
}

argStart() { unset -v engine fallback gui manager passwordArg unlock; engineArg=() excludeManagers=() excludeManagersArg=(); }

opt()
{
	case "$1" in
		-e|--engine|-e=*|--engine=*) ScriptOptGet engine "$@"; engineArg=( --engine "$engine" );;
		-em|--exclude-managers|-em=*|--exclude-managers=*) getExcludeManagerOpt "$@";;
		-F|--fallback) fallback="--fallback";;
		-g|--gui) gui="--gui";;
		-m|--manager|-m=*|--manager=*) ScriptOptGet "manager" "$@"; manager="$(managerNameValidate "$manager")";;
		-p|--password|-p=*|--password=*) ScriptOptGet passwordArg password "$@";;
		-ul|--unlock) unlock="--unlock";;
		*) return 1;;
	esac
}

argEnd()
{
	# set the credential engine
 	[[ ! $engine ]] && { [[ $CREDENTIAL_ENGINE ]] && engine="$CREDENTIAL_ENGINE" || engine="secret"; }

	# unlock the manager if we are running a command the requires us to be unlocked
 	[[ "$command" != @(environment|managerAvailable|managerDescription|managerName|lock|unlock|status|manager) ]] && unlock="--unlock";

 	# find and initialize a credential manager
 	managerFind || return
}

getCredentialArg() # PATH [KEY](default)
{
	ScriptArgGet "path" -- "$@"; shift
	[[ $1 ]] && { ScriptArgGet "key" -- "$@"; shift; } || key="default"
}

getExcludeManagerOpt()
{
	ScriptOptGet "excludeManagers" "exclude-managers" "$@"
	excludeManagersArg=( --exclude-managers "$excludeManagers" )
	StringToArray "${excludeManagers,,}" "," excludeManagers
}

#
# commands
#

environmentCommand()
{
	CREDENTIAL_MANAGER="$manager" CREDENTIAL_ENGINE="$engine" CREDENTIAL_MANAGER_CHECKED="true" 
	ScriptReturn --export "CREDENTIAL_MANAGER" "CREDENTIAL_ENGINE" "CREDENTIAL_MANAGER_CHECKED" || return
	RunFunction "environment" "$manager" || return
}
	
environmentSecretTool() { gnomeKeyringDaemonEnvironment; }
environmentOp() { 1PasswordHelper environment; }

guiCommand() { RunFunction "gui" "$manager"; }
guiOp() { 1PasswordHelper start; }
guiSecretTool() { start seahorse; }
guiWin() { start control.exe /name Microsoft.CredentialManager; }

#
# copy command
#

copyUsage() { echot "Usage: $(ScriptName) copy SRC DEST
Copy credentials from one path to another."; }

copyArgStart() { unset -v src dest; }

copyArgs()
{
	ScriptArgGet "src" -- "$@"; shift
	ScriptArgGet "dest" -- "$@"; shift
}

copyCommand()
{
	log1 "copying path $src to $dest..."
	initPath "$src" || return

	local key keys value; IFS=$'\n' keys=( $(lsCommand) )
	for key in "${keys[@]}"; do
		value="$(getCommand)" || return
		RunLog cred set "$dest" "$key" "$value" || return
	done

}

#
# exist command
#

existsUsage() { echot "Usage: $(ScriptName) exists PATH [KEY](default)
Return 0 if the specified credential exists.\n\n$pathUsage"; }

existsArgs() { getCredentialArg "$@"; }
existsCommand() { exists "$path" "$key" || existsFallbackRemote "$path" "$key"; }

existsFallbackRemote()
{
	local path="$1" key="$2"; ! canFallbackRemote && return 1
	log1 "credential '$path $key' does not exist in the local store, falling back to remote store"
	cred exists "$path" "$key" --manager=remote
}

exists() { local path="$1" key="$2"; managerPathInit "$path" "$key" && RunFunction "exists" "$manager"; }
existsMac() { security find-generic-password -gwa $USER -s "$managerPathKey" >& /dev/null; }
existsPass() { [[ -f "$HOME/.password-store/$managerPathKey.gpg" ]]; }
existsSecretTool() { secret-tool search "$managerPath" "$key" |& ${G}grep label > /dev/null; }
existsVault() { vaultKeyExists "$managerPath" "$key"; }
existsWin() { wincred.exe exists "$managerPathKey"; }

#
# get command
#

getUsage() { echot "Usage: $(ScriptName) get [time] PATH [KEY](default)
Get a credential.

$pathUsage
	time					return the UTC time the specified credential was last modified

	-p, --prompt	prompt for the credential if not found"; }

getArgStart() { unset prompt; }
getArgs()  { getCredentialArg "$@"; }

getOpt() 
{
	case "$1" in
		-p|--prompt) prompt="true";;
		*) return 1
	esac
}

getCommand() { get "$path" "$key" || getFallbackRemote "$path" "$key" || getPrompt "$path" "$key"; }

getFallbackRemote()
{
	local path="$1" key="$2"; ! canFallbackRemote && return 1		
	log1 "credential '$path $key' does not exist in the local store, falling back to remote store"
	cred get "$path" "$key" --manager=remote || return
}

getPrompt()
{
	local path="$1" key="$2"

	[[ ! $prompt ]] && return 1

	# prompt for the credential
	local prompt="${1:-Enter the new credential for $path $key: }"
	read -s -p "$prompt" value; echo
	[[ ! $value ]] && { ScriptErr "no credential specified"; return 1; }

	# set the credential
	log1 "setting credential '$path $key' to '$value'"
	setCommand || return

	# set the credential in the remote credential store if needed
	{ isManagerRemote || [[ ! $fallback ]] || ! isManagerAvailableRemote; } && return
	log1 "setting credential '$path $key' to '$value' in the remote credential store"
	cred set "$path" "$key" "$value" --manager=remote || return

	echo "$value"
}

get() { local path="$1" key="$2"; log1 "running get: path=$path key=$key"; managerPathInit "$path" "$key" && RunFunction "get" "$manager"; }
getMac() { security find-generic-password -gwa $USER -s "$managerPathKey" 2> /dev/null && return; keyNotFound "$path" "$key"; }
getOp() { op get item "$managerPath" | jq '.details.fields[] | select(.designation == "'$key'").value' | RemoveQuotes; }
getPass() { pass show "$managerPathKey"; }
getSecretTool() {	secret-tool lookup "$managerPath" "$key" | RemoveNewline; [[ "${PIPESTATUS[0]}" == 0 ]] && return; keyNotFound "$path" "$key"; }
getVault() { vault kv get -field="$key" "$managerPath" | RemoveNewline; return "${PIPESTATUS[0]}"; }
getWin() { wincred.exe get "$managerPathKey"; }

#
# get time Command
#

getTimeCommand() { getTime "$path" "$key"; }

getTime()
{
	local path="$1" key="$2"; managerPathInit "$path" "$key" || return
	local time="$(RunFunction "getTime" "$manager")"
	[[ ! $time ]] && { ScriptErr "unable to determine '$path $key' modifification time"; return 1; }
	printf "$time"
}

getTimeVault() { vault kv get --format=json "$managerPath" | jq -r .data.metadata.created_time; }
getTimeWin() { wincred.exe detail "$managerPathKey" | jq -r .[0].LastWriteTimeUtc; }

getTimeMac()
{
	local date; date="$(security find-generic-password -a $USER -s "$managerPathKey" | tgrep "\"mdat\"<timedate>=" | tr -s " " | cut -d" " -f3 | RemoveQuotes | RemoveEnd 'Z\\000')" || return
	[[ ! $date ]] && return
	date -j -f "%Y%m%d%H%M%S%z" "${date}-0000"
}

getTimeSecretTool()
{
	local date; date="$(secret-tool search "$managerPath" "$key" |& tgrep '^modified =' | GetAfter "=" | RemoveSpaceTrim)" || return
	[[ ! $date ]] && return
	date -u --date="$date"
}

#
# gets command - get silent
#

getsUsage() { echot "Usage: $(ScriptName) gets PATH [KEY](default)
Get a credential silently (without showing an error).
This is useful if the key does not exist.\n\n$pathUsage"; }

getsArgs() { getCredentialArg "$@"; }
getsCommand() { getCommand 2> /dev/null; return 0; }

#
# ls command
#

lsUsage() { echot "Usage: $(ScriptName) ls [path]
List all the paths or all keys at the specified path.\n\n$pathUsage

	-p, --paths		list paths at specified path and below
	-k, --keys		list only keys at specified path"; }

lsArgStart() { unset onlyPaths onlyKeys; }

lsOpt() 
{
	case "$1" in
		-p|--paths) onlyPaths="true";;
		-k|--keys) onlyKeys="true";;
		*) return 1
	esac
}

lsArgs() 
{
	[[ $1 ]] && ScriptArgGet "path" -- "$@"; shift
	return 0
}

lsCommand() { lsDo "$path"; }

lsDo() { local path="$1"; log1 "running ls: path=$path"; managerPathInit "$path" && RunFunction "ls" "$manager"; }
lsMac() { lsWorker "lsMacFilter"; }
lsPass() { pass show; } 
lsSecretTool() { lsWorker "lsSecretToolFilter"; }
lsWin() {	lsWorker "lsWinFilter"; }

lsMacFilter() { security dump-keychain -r login.keychain | tgrep '0x00000007 <blob>=' | cut -d= -f2 | RemoveQuotes | tgrep "^$path$sep" | sort | uniq; }
lsSecretToolFilter() { lssecret | tgrep "^Item:" | cut -d$'\t' -f2 | tgrep "^$path$sep" | sort; }
lsWinFilter() { wincred.exe list "$path$sep*" | RemoveCarriageReturn | sort; }

lsVault()
{	
	local path="$(RemoveTrim "$managerPath" "/")"

	# paths
	if [[ ! $onlyKeys ]] && vaultPathHasChildren "$path"; then

		if [[ $onlyPaths ]]; then
			local p paths; IFS=$'\n' paths=( $(vault kv list "$path" | tail +3 | sort | sed 's/\/$//' | sed 's/$/\//' | uniq) )
			local origPath="$path"
			local prefix="$origPath/$p"; prefix="${prefix/$engine\//}"
			for p in "${paths[@]}"; do echo "$prefix$p"; path="$origPath/$p"; lsVault; done
			return
		fi

		vault kv list "$path" | tail +3 | sort | sed 's/\/$//' | sed 's/$/\//' | uniq # add / suffix
		(( ${PIPESTATUS[0]} != 0 )) && return 1
	fi

	# keys
	if [[ ! $onlyPaths ]] && vaultLeafHasData "$path"; then
		vault kv get -format=json "$path" | jq '.data.data|keys|.[]' -r
		(( ${PIPESTATUS[0]} != 0 )) && return 1
	fi
	
}

lsWorker()
{
	local filter="$1"
	local path="$(RemoveTrim "$managerPath" "$sep")"

	if [[ $onlyPaths ]]; then lsPathsRecursive
	elif [[ $onlyKeys ]]; then lsKeys
	else lsPaths && lsKeys
	fi
}

lsKeys()
{
	$filter |
		sed "s/^$path$sep//" | 		# remove path prefix
		tgrep -v "$sep" |					# remove child paths 
		sort
}

lsPaths()
{
	$filter |
		tgrep "$sep" |					# include paths
		sed "s/^$path$sep//" | 	# remove path prefix
		tgrep "$sep"	|					# remove keys
		sed "s/$sep.*$//" |			# remove child paths
		sed 's/$/\//'	|					# add / suffix
		uniq
}

lsPathsRecursive()
{	
	$filter |
		sed "s/$sep[^$sep]*$//" | 	# remove leaves
		tgrep -v "^${path}$" |			# remove exact path
		sed "s/^$engine$sep//" | 		# remove engine prefix
		sed "s/$sep/\//g" |					# replace sepator with /
		uniq
}

#
# manager commands
#

managerUsage() { echot "Usage: $(ScriptName) manager all|available|description|lock|name|status|test|unlock\nManage credential engines."; }
managerCommand() { managerDescriptionCommand; }
managerAllUsage() { echot "Usage: $(ScriptName) available\nShow all credential managers."; }
managerAllCommand() { echo -n "${allManagers[@]}"; }
managerDescriptionUsage() { echot "Usage: $(ScriptName) description\nShow a description of the selected credential manager."; }
managerDescriptionCommand() { echo "Using the $(managerDescription) credential store ($(managerStatusCommand))"; }
managerNameUsage() { echot "Usage: $(ScriptName) name\nShow the name of the credential manager."; }
managerNameCommand() { echo "${manager:-none}"; }
managerStatusUsage() { echot "Usage: $(ScriptName) status\nShow the credential manager status (locked or unlocked)."; }
managerStatusCommand() { isUnlocked && echo "unlocked" || echo "locked"; }
managerTestUsage() { echot "Usage: $(ScriptName) available\nShow the available credential managers."; }
managerTestCommand() { setDo "test" "check" "$manager-success"; }

isManagerRemote() { [[ "$manager" == @(op|vault) ]]; }

isLocked() { ! isUnlocked; }
isUnlocked() { RunFunction "isUnlocked" "$manager"; }
isUnlockedOp() { 1PasswordHelper IsSignedIn; }
isUnlockedSecretTool() { [[ "$(secret-check)" == "unlocked" ]]; }
isUnlockedVault() { [[ $VAULT_TOKEN ]]; }

#
# manager find
#

# managerFind - find ana initialize and optionally unlock a credential manager
managerFind()
{
	# use the CREDENTIAL_MANAGER variable if set
	[[ ! $manager && $CREDENTIAL_MANAGER ]] && { manager="$CREDENTIAL_MANAGER"; manager="$(managerNameValidate "$manager")" || unset manager; }

	# if manager is excluded do not use it
	if isManagerExcluded "$manager"; then
		log3 "managerFind: the '$manager' credential manager is excluded"
		unset manager
	fi

	# if no credetial manager was found last time don't try again
	if [[ "$manager" == "None" ]]; then
		 if [[ ! $force ]]; then
		 	[[ ! $quiet ]] && ScriptErr "no credential manager is available"
		 	return 1;
		 fi
	 	unset manager
	fi

 	# log the default credential manager
	[[ $manager ]] && log3 "managerFind: defaulting to the '$manager' credential manager"

	# if a credential manager was not specified, default to searching for all credential managers
 	if [[ ! $manager ]]; then
 		log3 "managerFind: no credential manager specified, finding any credential manager"
 		manager="All" 	
 	fi

 	# find the specified credential manager
	managerFindDo && { return; }

 	# widen the credential manager search if possible
 	[[ "$manager" != "All" ]] && manager="All" && { managerFindDo && return; }

 	# credential manager is not available message
 	manager="None"
 	[[ ! $quiet ]] && ScriptErr "no credential manager is available"

	return 1
}

managerFindDo()
{
	if managerFind_${manager^}; then
		log2 "using the '$manager' credential manager"
		return 0
	fi
	log3 "managerFind: no credential manager is available"
	return 1
}

# managerFind_* - these function names are valid for the name of the credential manager to find

managerFind_All() { log2 "managerFind: all"; managerFind_Local || managerFind_Remote; }
managerFind_Local() { log2 "managerFind: local"; managerFind_Mac || managerFind_Win || managerFind_SecretTool || managerFind_Pass; }
managerFind_Remote() { log2 "managerFind: remote"; managerFind_Vault || managerFind_Op; }
managerFind_None() { log2 "managerFind: none"; return 1; }

managerFind_Op() { log2 "managerFind: op"; isManagerAvailableOp && managerFindUnlock && manager="op"; }
managerFind_Mac() { IsPlatform mac || return; log2 "managerFind: mac"; isManagerAvailableMac && managerFindUnlock && manager="mac"; }
managerFind_Pass() { log2 "managerFind: pass"; isManagerAvailablePass && managerFindUnlock && manager="pass"; }
managerFind_SecretTool() { IsPlatform debian || return; log2 "managerFind: SecretTool"; isManagerAvailableSecretTool && managerFindUnlock && manager="SecretTool"; }
managerFind_Vault() { log2 "managerFind: Vault"; isManagerAvailableVault && managerFindUnlock && manager="vault"; }
managerFind_Win() { IsPlatform win || return; log2 "managerFind: win"; isManagerAvailableWin && managerFindUnlock && manager="win"; }

managerFindUnlock()
{
	[[ ! $unlock ]] && return
	quiet="--quiet" unlock
}

# managerPathInit PATH KEY - set managerPathKey and managerKey to the manager specific values
managerPathInit()
{
	local path="$1" key="$2"
	managerPath="$(managerPath "$path")"
	managerPathKey="$(managerPath "$path/$key")"
}

# managerPath PATH - return the manager specific path
managerPath() { RunFunction "managerPath" "$manager" -- "$1"; }
managerPathMac()  { managerPathGeneric "$1"; }
managerPathSecretTool() { managerPathGeneric "$1"; }
managerPathWin() { managerPathGeneric "$1"; }

# managerPathGeneric PATH: /a/b/ -> $engine-a-b	
managerPathGeneric()
{
	local prefix; [[ $engine ]] && prefix="$engine-"
	echo "$prefix$(RemoveTrim "${1//\//-}" "-")"
}

# managerPathVault PATH: /a/b/ -> /$engine/a/b
managerPathVault()
{
	echo "/$engine/$(RemoveTrim "$1" "/")"
}


# managerNameAlias ALIAS - return the a credential manager name for an alias
managerNameAlias()
{
	case "${1,,}" in
		l) echo "local";;
		r) echo "remote";;
		v) echo "vault";;
		st|secrettool) echo "SecretTool";;
		*) echo "${1,,}";;
	esac
}

# managerDescription - return the description of the credential manager 
managerDescription()
{
	case "${manager,,}" in
		mac) printf "Macintosh";;
		op) printf "1Password";;
		pass) printf "Pass";;
		secrettool) printf "GNOME Keyring";;
		vault) printf "HashiCorp Vault";;
		win) printf "Windows";;
	esac
}

# managerNameValidate (NAME)[local] - validate that the credential manager name is valid and resolve manager alias names
managerNameValidate()
{
	local name="$1"
	[[ $name ]] && name="$(managerNameAlias "$name")" || name="local"

	# ensure correct case
	if [[ "${name,,}" == "secrettool" ]]; then name="SecretTool"
	else name="$(ProperCase "$name")"
	fi

	# check if the specified credential manager is valid
	if ! IsFunction "managerFind_${name}"; then
		[[ ! $quiet ]] && ScriptErr "'$manager' is not a valid credential manager"
		return 1
	fi

	echo "$name"
}

#
# manager available command
#

managerAvailableUsage() { echot "Usage: $(ScriptName) available\nShow the available credential managers."; }
managerAvailableCommand() { managerAvailable; }

managerAvailable()
{
	local manager available=()
	for manager in "${allManagers[@]}"; do
		 isManagerAvailable "$manager" && available+=($manager)
	done
	echo -n "${available[@]}"
}

isManagerAvailable() { RunFunction "isManagerAvailable" "${1:-$manager}";  }
isManagerAvailableMac() { ! isManagerExcluded mac && IsPlatform mac && InPath security && ! IsSsh; }
isManagerAvailableOp() { ! isManagerExcluded op && InPath op; }
isManagerAvailablePass() { ! isManagerExcluded pass && InPath pass; }
isManagerAvailableSecretTool() { ! isManagerExcluded secrettool && [[ $DISPLAY ]] && InPath gnome-keyring-daemon lssecret secret-tool secret-check; }
isManagerAvailableWin() { ! isManagerExcluded win && IsPlatform win &&  InPath "wincred.exe"; }
isManagerAvailableVault() { ! isManagerExcluded vault && InPath vault; }

isManagerAvailableRemote() { isManagerAvailableOp || isManagerAvailableVault; }
isManagerAvailableLocal() { isManagerAvailableMac || isManagerAvailableWin || isManagerAvailableSecretTool || isManagerAvailablePass; }

#
# manager lock/unlock command
#

managerLockCommand()
{
	isLocked && return
	lock || { [[ ! $quiet ]] && EchoErr "Unable to lock the $(managerDescription) credential manager."; return 1; }
	[[ ! $quiet ]] && EchoErr "The $(managerDescription) credential manager was locked."
	return 0
}

lock() { RunFunction "lock" "${1:-$manager}"; }
lockSecretTool() { RunSilent secret-lock; }
lockOp() { op signout; }

managerUnlockCommand()
{
	isUnlocked && return
	unlock || { [[ ! $quiet ]] && EchoErr "Unable to unlock the $(managerDescription) credential manager."; return 1; }
	[[ ! $quiet ]] && EchoErr "The $(managerDescription) credential manager was unlocked."
	return 0
}

unlock() { RunFunction "unlock" "${1:-$manager}"; }
unlockOp() { eval "$(1PasswordHelper signin $quiet $verbose)"; }

unlockSecretTool()
{
	# return if already unlocked
	isUnlocked && return

	# start the gnome-keyring-daemon
	gnomeKeyringDaemonStart || return

	# unlock with password argument
  if [[ $passwordArg ]]; then
		eval "export $(echo -n "$password" | gnomeKeyringDaemonRun --unlock)"

	# unlock with password from console prompt
  elif [[ ! $gui ]] && IsStdIn; then # TODO: disable CLI password for now

  	local i password
		for (( i=1; i<=3; ++i )); do
	  	password="$(ask password "Enter the $(managerDescription) credential store password")" || return		
			eval "export $(echo -n "$password" | gnomeKeyringDaemonRun --unlock)"
			isUnlocked && break
		done

	# unlock with an X Windows dialog, which retries if the password is not correct
	elif [[ $DISPLAY ]]; then
		[[ ! $DISPLAY ]] && { ! [[ $quiet ]] && ScriptErr "a display is required to read the $(managerDescription) password"; return 1; }
		RunSilent secret-unlock
		managerTestCommand || return

	# unable to get a password
	else	
		[[ ! $quiet ]] && ScriptErr "a terminal is required to read the $(managerDescription) password."
		return 1

	fi

	# return true if we are now unlocked
	isUnlocked
}
 
unlockVault()
{
	# ensure the vault configuration is set
	[[ ! $VAULT_ADDR || ! $VAULT_TOKEN ]] && { log2 "configuring vault environment"; eval "$(hashi vault environment $quiet $verbose)" || return; }
	[[ ! $VAULT_ADDR ]] && { log2 "vault server address not found"; return 1; }
	[[ ! $VAULT_TOKEN ]] && { log2 "vault authentication token not found"; return 1; }

	# check if the Vault verver is available
	local server="$(GetUriServer "$VAULT_ADDR")" port="$(GetUriPort "$VAULT_ADDR")"
	if ! IsAvailablePort "$server" "$port"; then
		ScriptErr "the Vault server $server is not responding on port $port"
		return 1
	fi

	(( verboseLevel > 1 )) && vault status >& /dev/stderr
	vault status >& /dev/null
}

gnomeKeyringDaemonRun() {	RunQuiet gnome-keyring-daemon --replace "$@"; }

gnomeKeyringDaemonIsHealthy()
{	
	# check running
	if ! IsTaskRunning "gnome-keyring-daemon" --unix --user; then
		[[ $verbose ]] && log1 "gnome-keyring-daemon is not running"
		return 1
	fi

	# check sockets
	log2 "GNOME_KEYRING_CONTROL=$GNOME_KEYRING_CONTROL SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
	for socket in "$GNOME_KEYRING_CONTROL/control" "$SSH_AUTH_SOCK" "$GNOME_KEYRING_CONTROL/pkcs11"; do
		gnomeKeyringCheckSocket "$socket" || return
	done

	return 0
}

gnomeKeyringCheckSocket()
{
	local socket="$1"
	log2 "checking keyring socket '$socket'"
	! [[ -e "$socket" ]] && { log1 "keyring socket '$socket' missing"; return 1; }
	! [[ -S "$socket" ]] && { log1 "keyring socket '$socket' is not a socket"; return 1; }
	return 0
}

gnomeKeyringDaemonEnvironment()
{
	[[ $GNOME_KEYRING_CONTROL && $SSH_AUTH_SOCK ]] && return

	case "$PLATFORM" in
		linux) export GNOME_KEYRING_CONTROL="/run/user/$(id --user)/keyring";;
		win) export GNOME_KEYRING_CONTROL="/mnt/wslg/runtime-dir/keyring";;
	esac

	export SSH_AUTH_SOCK="$GNOME_KEYRING_CONTROL/ssh"
}

# gnomeKeyringDaemonStart - start the gnome-keyring-daemon and return export variables
gnomeKeyringDaemonStart()
{	
	gnomeKeyringDaemonEnvironment || return

	# start the gnome-keyring-daemon
	{ [[ $force ]] || ! gnomeKeyringDaemonIsHealthy; } && eval "export $(gnomeKeyringDaemonRun)"

	# failed to start 
	! gnomeKeyringDaemonIsHealthy && { [[ ! $quiet ]] && ScriptErr "unable to start the gnome-keyring-daemon"; return 1; }

	# healthy
	return 0
}

#
# manager unlocked
#

managerUnlockedUsage() { echot "Usage: $(ScriptName) unlocked\nShow the unlocked credential managers."; }
managerUnlockedCommand() { managerUnlocked; }

managerUnlocked()
{
	local manager unlocked=()
	for manager in "${allManagers[@]}"; do
		isManagerAvailable "$manager" && isUnlocked "$manager" && unlocked+=($manager)
	done
	echo -n "${unlocked[@]}"
}

#
# mirror command
#

mirrorUsage()
{
		echot "Usage: $(ScriptName) mirror PATH [KEY]
Mirror keys from one credential manager to another.
This will ensure the 'to' credential manager is identical to 
the 'from' credential manager at the specified PATH and KEY.

	-F,	--from MANAGER	first secret manager, defaults to local
	-T,	--to MANAGER		second secret manager, defaults to remote"
}

mirrorArgStart() { syncArgStart "$@"; }

mirrorOpt() 
{
	case "$1" in
		-F|--from|-F=*|--from=*) ScriptOptGet m1 "$@"; m1="$(managerNameAlias "$m1")";;
		-T|--to|-T=*|--to=*) ScriptOptGet m2 "$@"; m2="$(managerNameAlias "$m2")";;
		*) return 1
	esac
}

mirrorArgs() { syncArgs "$@"; }

mirrorCommand()
{
	log1 "mirroring $path from $m1 to $m2..."

	[[ $key ]] && { mirrorKey; return; }

	[[ ! $force ]] && { ScriptErr "to overwrite all values at '$path' in $m2 --force must be specified."; return 1; }

	# get m1 keys at path
	local key keys; IFS=$'\n' keys=( $(cred1 ls --keys "$path") )
	[[ ! $keys ]] && { ScriptErr "no permission or no keys at '$path' in $m1"; return 1; }
	[[ $verbose ]] && { PrintErr "$m1 keys: "; ArrayShow keys; }

	echo "Deleting all keys at '$path' in $m2..."
	RunLog cred2 rm "$path" all || return

	for key in "${keys[@]}"; do
		echo "Adding '$path $key' to $m2..."
		local value; value="$(cred1 get "$path" "$key")" || return
		RunLog cred2 set "$path" "$key" "$value" || return
	done
}

cred1() { cred "--manager=$m1" "$@"; }
cred2() { cred "--manager=$m2" "$@"; }

mirrorKey()
{
	! cred1 exists "$path" "$key" && { ScriptErr "'$path $key' does not exist in $m1"; return; }
	local value; value="$(cred1 get "$path" "$key")" || return
	cred2 set "$path" "$key" "$value"
}

#
# rm command
#

rmUsage() { echot "Usage: $(ScriptName) rm PATH [KEY|all](default)
Remove a credential.

If the key is all, all keys at the path are removed.   If --force is specified,
permanently remove all keys at the path.\n\n$pathUsage"; }

rmArgs() { getCredentialArg "$@"; }
rmCommand() { rmDo "$path" "$key" && rmFallbackRemote "$path" "$key"; }

rmFallbackRemote()
{
	local path="$1" key="$2"; ! canFallbackRemote && return
	log1 "removing credential '$path $key' from the remote store"
	cred rm "$path" "$key" --manager=remote || return
}

rmDo()
{
	local path="$1" key="$2"; managerPathInit "$path" "$key" || return

	# remove a single credential or Vault credentials
	[[ "$key" != "all" || "$manager" == "vault" ]] && { RunFunction "rm" "$manager"; return; }

	# remove all credentials
	local key keys onlyKeys="true"; IFS=$'\n' keys=( $(lsCommand) )
	for key in "${keys[@]}"; do RunFunction "rm" "$manager" || return; done
}

rmMac() { security delete-generic-password -a $USER -s "$managerPathKey"; }
rmPass() { pass rm "$managerPathKey"; }
rmWin() { wincred.exe delete "$managerPathKey"; }
rmSecretTool() { secret-tool clear "$managerPath" "$key"; }

rmVault()
{ 
	local path="$managerPath"

	# remove a single key
	if [[ "$key" != "all" ]]; then
		! vaultKeyExists "$path" "$key" && return
		vault kv get -format=json "$path" | jq ".data.data|del(.$key)" | vault kv put "$path" -
		return
	fi

	# remove all keys at a leaf node
	! vaultIsLeaf "$path" && return

	# permanently remove all keys at the leaf node
	[[ $force ]] && { vault kv metadata delete "$path"; return; }

	# if the leaf node has data remove it
	vaultLeafHasData "$path" && { vault kv delete "$path"; return; }
		
	return 0
}

#
# set command
#

setUsage() { echot "Usage: $(ScriptName) set PATH [KEY](default) value\nSet a credential."; }

setArgs() 
{
	ScriptArgGet "path" -- "$@"; shift
	(( $# > 1 )) && { ScriptArgGet "key" -- "$@"; shift; } || key="default"
	ScriptArgGet "value" -- "$@"; shift
}

setCommand() { setDo "$path" "$key" "$value"; }
setDo() { local path="$1" key="$2" value="$3"; log1 "running set: path=$path key=$key"; managerPathInit "$path" "$key" && RunFunction "set" "$manager"; }
setMac() { security add-generic-password -U -a $USER -s "$managerPathKey" -w "$value"; }
setPass() { echo -n "$value" | pass insert -m --force "$managerPathKey"; }
setSecretTool() { echo -n "$value" | secret-tool store --label "$managerPathKey" "$managerPath" "$key"; }
setWin() { wincred.exe set "$managerPathKey" "$value"; }

setVault()
{	
	local path="$managerPath"

	if ! vaultLeafHasData "$path"; then
		vault kv put "$path" "$key"="$value"
	else
		vault kv patch "$path" "$key"="$value"
	fi
}

#
# store commands
#

storeUsage() { echot "Usage: $(ScriptName) store add|ls
Manage credential stores."; }

storeCommand() { storeLsCommand; }

storeLsCommand() { RunFunction "storeLs" "$manager"; }
storeLsVault() {	vault secrets list; }

storeAddUsage() { echot "Usage: $(ScriptName) store add NAME"; }
storeAddArgs() { ScriptArgGet "name" -- "$@"; shift; }
storeAddCommand() { RunFunction "storeAdd" "$manager"; }
storeAddVault() { vault secrets enable -path="$name" kv-v2; }

#
# sync command
#

syncUsage()
{
		echot "Usage: $(ScriptName) sync PATH [KEY](default)
Syncronize keys betwen the specified credential managers.

	-m1,	--manager1			first secret manager, defaults to local
	-m2,	--manager2			second secret manager, defaults to remote"
}

syncArgStart()
{
	unset -v key path
	m1="local" m2="remote"
}

syncOpt() 
{
	case "$1" in
		-m1|--manager1|-m1=*|--manager1=*) ScriptOptGet m1 "$@"; m1="$(managerNameAlias "$m1")";;
		-m2|--manager2|-m2=*|--manager2=*) ScriptOptGet m2 "$@"; m2="$(managerNameAlias "$m2")";;
		*) return 1
	esac
}

syncArgs()
{
	ScriptArgGet "path" -- "$@"; shift
	[[ $1 ]] && { ScriptArgGet "key" -- "$@"; shift; }
	return 0
}

syncCommand()
{
	log1 "syncing $path from $m1 to $m2"

	[[ $key ]] && { syncKey; return; }
	
	# get all keys at path
	local key keys; IFS=$'\n' keys=( $({ cred1 ls --keys "$path"; cred2 ls --keys "$path"; } | sort | uniq) )
	[[ $verbose ]] && { PrintErr "all keys: "; ArrayShow keys; }

	for key in "${keys[@]}"; do
		header "$path $key"
		cred sync "$path" "$key" "-m1=$m1" "-m2=$m2" || return
	done
}

syncKey()
{
	# key does not exist in m1
	if ! cred1 exists "$path" "$key"; then
		echo "Creating '$path $key' in $m1..."
		local value; value="$(cred2 get "$path" "$key")" || return
		cred1 set "$path" "$key" "$value" || return
		return
	fi

	# key does not exist in m2
	if ! cred2 exists "$path" "$key"; then
		echo "Creating '$path $key' in $m2..."
		local value; value="$(cred1 get "$path" "$key")" || return
		cred2 set "$path" "$key" "$value" || return
		return
	fi

	# compare values
	local value1; value1="$(cred1 get "$path" "$key")" || return
	local value2; value2="$(cred2 get "$path" "$key")" || return

	if [[ "$value1" == "$value2" ]]; then
		echo "$path $key is the same in $m1 and $m2"
		return
	fi

	# compare time
	local time1; time1="$(cred1 get time "$path" "$key" | GetSeconds -)" || return
	local time2; time2="$(cred2 get time "$path" "$key" | GetSeconds -)" || return

	if [[ $verbose ]]; then
		log1 "$m1 modifification time is $(cred1 get time "$path" "$key") ($time1 seconds)"
		log1 "$m2 modifification time is $(cred2 get time "$path" "$key") ($time2 seconds)"
	fi

	if (( $(echo "$time1 > $time2" | bc -l) )); then
		echo "Updating $m2 ($m1 value is newer)..."
		cred2 set "$path" "$key" "$value1" || return
	else
		echo "Updating $m1 ($m2 value is newer)..."
		cred1 set "$path" "$key" "$value2" || return
	fi
}

#
# helper - vault
#

vaultIsLeaf() { vault kv get "$1" >& /dev/null; } 														# vaultIsLeaf PATH - return 0 if the path is a leaf node
vaultKeyExists() { vault kv get -field="$2" "$1" >& /dev/null; }							# vaultKeyExists PATH KEY - return 0 if the key exists at path, 1 if it does not
vaultLeafHasData() { vault kv get "$1" |& ${G}grep -q -E "(=)+ Data (=)+"; } 	# vaultLeafHasData PATH - leaf node contains data (contains non-deleted keys)
vaultPathHasChildren() { vault kv list "$1" >& /dev/null; } 									# vaultPathHasChildren PATH - return 0 if the path has children

#
# helper
#

canFallbackRemote() { ! isManagerRemote && [[ $fallback ]] && isManagerAvailableRemote; }
cred() { RunLog credential --unlock "${engineArg[@]}" "${excludeManagersArg[@]}" $fallback $force $quiet $verbose "$@"; }
isManagerExcluded() { IsInArray "${1,,}" excludeManagers; }

keyNotFound()
{ 
	canFallbackRemote && return 1
	ScriptErr "key '$1 $2' does not exist in the $(managerDescription) credential store"; return 1
}

ScriptRun "$@"

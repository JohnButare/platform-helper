#!/usr/bin/env bash
. script.sh || exit

run() {	init && args "$@" && findManager && initManager && "${command}Command"; }

init()
{
	sep="-"
	pathUsage="\
	path		credential location, i.e. folder or /folder1/folder2"
}

usage()
{
	ScriptUsage "$1" "\
Usage: credential
Interact with a credential store.

Common commands:
	get[s]		get a credential
	set				set a credential

Other commands:
	check		check if a credential manager is installed
	delete  delete a credential
	engine	manage credential engines
	exists 	check if a credential exists
	list 		list credentials
	manager	show the the GUI manager
	status	show the credential manager status
	sync		synronize a credential
	type		show the type of the credential manager in use

Options:
	-e, --engine=ENGINE 	physical storage engine for credentials
	-f, --fallback			 	fallback to a remote credential manager if possible
	-x, --exclude-managers=MANAGERS	exclude the comma separated list of managers
	-m, --manager					force the use of a specific credential manager
	-f, --force  					force the operation
	-q, --quiet 					minimize informational messages
	-v,  --verbose				show additional status

Environment variables:
	CREDENTIAL_MANAGER		if set use the specified credential manager (see below)
	CREDENTIAL_ENGINE			if set, specify the secret engine to use (Vault)

Credential managers: 
	local|l|remote|r			find a local or remote (network) credential manager
	platform							find a credential manager for the current platform (default)
	none									do not use a credential manager

	mac|win 							use the native credential manager for the platform
	pass|SecretTool				use the pass or SecretTool credential managers
	vault|v		 						use HashiCorp Vault"
}

args()
{
	local args=()
	unset -v engine fallback force quiet type verbose
	unset -v path key
	excludeManagers=() excludeManagersArg=() engineArg=()

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in
			-e|--engine|-e=*|--engine=*) ScriptOptGet engine "$@"; engineArg=( --engine "$engine" );;
			-F|--fallback) fallback="--fallback";;
			-f|--force) force="--force";;
			-h|--help) usage 0;;
			-m|--manager|-m=*|--manager=*) ScriptOptGet "type" "manager" "$@"; validateManager || return;;
			-x|--exclude-managers|-x=*|--exclude-managers=*) getExcludeManagerOpt "$@" || return;;
			-q|--quiet) quiet="--quiet";;
			-v|--verbose) verbose="--verbose";;
			*) ScriptOpt "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# other arguments
	ScriptArgs "$@" || return; shift "$shift"

	# initialize
	[[ ! $type && $CREDENTIAL_MANAGER ]] && { type="$CREDENTIAL_MANAGER"; validateManager || type="local"; }
 	[[ -z ${engine+x} ]] && { [[ $CREDENTIAL_ENGINE ]] && engine="$CREDENTIAL_ENGINE" || engine="secret"; }

	(( $# == 0 )) && return || usage
}

getCredentialArg() # PATH [KEY](default)
{
	ScriptArgGet "path" -- "$@"; shift
	[[ $1 ]] && { ScriptArgGet "key" -- "$@"; shift; } || key="default"
}

getExcludeManagerOpt()
{
	ScriptOptGet "excludeManagers" "exclude-managers" "$@"
	excludeManagersArg=( --exclude-managers "$excludeManagers" )
	StringToArray "${excludeManagers,,}" "," excludeManagers
}

#
# Commands
#

checkCommand() { return 0; }
typeCommand() { echo "$type"; }

managerCommand()
{
	if IsPlatform win; then 
		control.exe /name Microsoft.CredentialManager
	elif IsPlatform debian; then
		start seahorse
	fi
}

statusCommand()
{
	echo "Credential store is $type"
	
	if [[ "$type" == "vault" ]]; then
		echo; vault status 
	elif findManagerVault; then
		echo "Vault is available"
	fi
		
	return 0
}

#
# Delete Command
#

deleteUsage() { echot "Usage: $(ScriptName) delete PATH [KEY|all](default)
Delete a credential.

If the key is all, all keys at the path are deleted.   If --force is specified,
permanently delete all keys at the path.\n\n$pathUsage"; }

deleteArgs() { getCredentialArg "$@"; }

deleteCommand() { RunFunction "delete" "$type"; }
deleteMac() { security delete-generic-password -gwa $USER -s "$path-$key"; }
deletePass() { pass rm "$path-$key"; }
deleteSecretTool() { deleteGeneric; }
deleteWin() { deleteGeneric; }

deleteVault()
{ 
	# delete a single key
	if [[ "$key" != "all" ]]; then
		! vaultKeyExists "$path" "$key" && return
		vault kv get -format=json "$path" | jq ".data.data|del(.$key)" | vault kv put "$path" -
		return
	fi

	# delete all keys at a leaf node
	! vaultIsLeaf "$path" && return

	# permanently delete all keys at the leaf node
	[[ $force ]] && { vault kv metadata delete "$path"; return; }

	# if the leaf node has data delete it
	vaultLeafHasData "$path" && { vault kv delete "$path"; return; }
		
	return 0
}

deleteGeneric()
{
	[[ "$key" != "all" ]] && { RunFunction "deleteDo" "$type" || return; }

	local key keys onlyKeys="true"; IFS=$'\n' keys=( $(listCommand) )
	for key in "${keys[@]}"; do deleteGeneric || return; done
}

deleteDoWin() { wincred.exe delete "$path-$key"; }
deleteDoSecretTool() { secret-tool clear "$path" "$key"; }

#
# Engine Commands
#

engineUsage() { echot "Usage: $(ScriptName) engine add|list
Manage credential engines."; }

engineCommand() { engineListCommand; }

engineListCommand() { RunFunction "engineList" "$type"; }
engineListVault() {	vault secrets list; }

engineAddUsage() { echot "Usage: $(ScriptName) engine add NAME"; }
engineAddArgs() { ScriptArgGet "name" -- "$@"; shift; }
engineAddCommand() { RunFunction "engineAdd" "$type"; }
engineAddVault() { vault secrets enable -path="$name" kv-v2; }

#
# Exist Command
#

existsUsage() { echot "Usage: $(ScriptName) exists PATH [KEY](default)
Return 0 if the specified credential exists.\n\n$pathUsage"; }

existsArgs() { getCredentialArg "$@"; }

existsCommand()
{
	RunFunction "exists" "$type" && return
	! canFallback && return 1
	[[ $verbose ]] && EchoErr "credential \`$originalPath $key\` does not exist in the local store, falling back to remote store"
	cred exists "$originalPath" "$key" --manager=remote
}

existsMac() { security find-generic-password -gwa $USER -s "$path-$key" > /dev/null; }
existsPass() { [[ -f "$HOME/.password-store/$path-$key.gpg" ]]; }
existsSecretTool() { secret-tool search $path $key |& grep label > /dev/null; }
existsVault() { vaultKeyExists "$path" "$key"; }
existsWin() { wincred.exe exists "$path-$key"; }

canFallback() { ! isManagerRemote && [[ $fallback ]] && checkManagerRemote; }

#
# Get Command
#

getUsage() { echot "Usage: $(ScriptName) get [time] PATH [KEY](default)
Get a credential.

$pathUsage
	time		return the UTC time the specified credential was last modified"; }

getArgs()  { getCredentialArg "$@"; }

getCommand()
{
	RunFunction "get" "$type" && return
	! canFallback && return 1		
	[[ $verbose ]] && EchoErr "credential \`$originalPath $key\` does not exist in the local store, falling back to remote store"
	cred get "$originalPath" "$key" --manager=remote
}

getMac() { security find-generic-password -gwa $USER -s "$path-$key" 2> /dev/null; }
getPass() { pass show "$path-$key"; }
getSecretTool() { secret-tool lookup "$path" "$key" | RemoveNewline; return "${PIPESTATUS[0]}"; }
getVault() { vault kv get -field="$key" "$path" | RemoveNewline; return "${PIPESTATUS[0]}"; }
getWin() { wincred.exe get "$path-$key"; }

getTimeCommand()
{
	local time="$(RunFunction "getTime" "$type")"; 
	[[ ! $time ]] && { ScriptErr "unable to determine \`$originalPath $key\` modifification time"; return 1; }
	printf "$time"
}

getTimeSecretTool() { date -u --date="$(secret-tool search secret-test other |& grep '^modified =' | GetAfter "=" | RemoveSpaceTrim)"; }
getTimeVault() { vault kv get --format=json "$path" | jq -r .data.metadata.created_time; }
getTimeWin() { wincred.exe detail "$path-$key" | jq -r .[0].LastWriteTimeUtc; }

#
# Gets Command - get silent
#

getsUsage() { echot "Usage: $(ScriptName) gets PATH [KEY](default)
Get a credential silently (without showing an error).
This is useful if the key does not exist.\n\n$pathUsage"; }

getsArgs() { getCredentialArg "$@"; }
getsCommand() { getCommand 2> /dev/null; return 0; }

#
# List Command
#

listUsage() { echot "Usage: $(ScriptName) list [path]
List all the paths or all keys at the specified path.\n\n$pathUsage

	-p, --paths		list paths at specified path and below
	-k, --keys		list only keys at specified path"; }

listArgStart() { unset onlyPaths onlyKeys; }

listOpt() 
{
	case "$1" in
		-p|--paths) onlyPaths="true";;
		-k|--keys) onlyKeys="true";;
		*) return 1
	esac
}

listArgs() 
{
	[[ $1 ]] && ScriptArgGet "path" -- "$@"; shift
	return 0
}

listCommand() { RunFunction "list" "$type"; }
listPass() { pass show; } 
listWin() {	listDo "listWinFilter"; }
listSecretTool() { listDo "listSecretToolFilter"; }

listWinFilter() { wincred.exe list "$path$sep*" | RemoveCarriageReturn | sort; }
listSecretToolFilter() { lssecret | grep "^Item:" | cut -d$'\t' -f2 | grep "^$path$sep" | sort; }

listVault()
{	
	local path="$(RemoveTrim "$path" "/")"
	# vaultIsLeaf
	# vaultPathHasChildren
	# vaultLeafHasData

	# paths
	if [[ ! $onlyKeys ]] && vaultPathHasChildren "$path"; then

		if [[ $onlyPaths ]]; then
			local p paths; IFS=$'\n' paths=( $(vault kv list "$path" | tail +3 | sort | sed 's/\/$//' | sed 's/$/\//' | uniq) )
			local origPath="$path"
			local prefix="$origPath/$p"; prefix="${prefix/$engine\//}"
			for p in "${paths[@]}"; do echo "$prefix$p"; path="$origPath/$p"; listVault; done
			return
		fi

		vault kv list "$path" | tail +3 | sort | sed 's/\/$//' | sed 's/$/\//' | uniq # add / suffix
	fi

	# keys
	if [[ ! $onlyPaths ]] && vaultLeafHasData "$path"; then
		vault kv get -format=json "$path" | jq '.data.data|keys|.[]' -r
	fi
	
}

listDo()
{
	local filter="$1"
	local path="$(RemoveTrim "$path" "$sep")"

	if [[ $onlyPaths ]]; then listPathsRecursive
	elif [[ $onlyKeys ]]; then listKeys
	else listPaths && listKeys
	fi
}

listKeys()
{
	$filter |
		sed "s/^$path$sep//" | 		# remove path prefix
		grep -v "$sep" |					# remove child paths 
		sort
}

listPaths()
{
	$filter |
		grep "$sep"	|						# include paths
		sed "s/^$path$sep//" | 	# remove path prefix
		grep "$sep"	|						# remove keys
		sed "s/$sep.*$//" |			# remove child paths
		sed 's/$/\//'	|					# add / suffix
		uniq
}

listPathsRecursive()
{	
	$filter |
		sed "s/$sep[^$sep]*$//" | 	# remove leaves
		grep -v "^${path}$" |				# remove exact path
		sed "s/^$engine$sep//" | 		# remove engine prefix
		sed "s/$sep/\//g" |					# replace sepator with /
		uniq
}

#
# Set Command
#

setUsage() { echot "Usage: $(ScriptName) set PATH [KEY](default) value
Set a credential."; }

setArgs() 
{
	ScriptArgGet "path" -- "$@"; shift
	(( $# > 1 )) && { ScriptArgGet "key" -- "$@"; shift; } || key="default"
	ScriptArgGet "value" -- "$@"; shift
}

setCommand() { RunFunction "set" "$type"; }
setMac() { security add-generic-password -U -a $USER -s "$path-$key" -w "$value"; }
setPass() { pass insert -m --force "$path-$key"<<< "success" 2> /dev/null; }
setSecretTool() { echo "$value" | secret-tool store --label "$path-$key" "$path" "$key"; }
setWin() { wincred.exe set "$path-$key" "$value"; }

setVault()
{	
	if ! vaultLeafHasData "$path"; then
		vault kv put "$path" "$key"="$value"
	else
		vault kv patch "$path" "$key"="$value"
	fi
}

#
# Sync Command
#

syncUsage()
{
		echot "Usage: $(ScriptName) sync PATH [KEY](default)
Synronize keys betwen the specified credential managers.

	-m1,	--manager1			first secret manager, defaults to local
	-m2,	--manager2			second secret manager, defaults to remote"
}

syncArgStart()
{
	unset -v key path
	m1="local" m2="remote"
}

syncOpt() 
{
	case "$1" in
		-m1|--manager1|-m1=*|--manager1=*) ScriptOptGet m1 "$@";;
		-m2|--manager2|-m2=*|--manager2=*) ScriptOptGet m2 "$@";;
		*) return 1
	esac
}

syncArgs()
{
	ScriptArgGet "path" -- "$@"; shift
	[[ $1 ]] && { ScriptArgGet "key" -- "$@"; shift; }
	return 0
}

syncCommand()
{
	local path="$originalPath"

	[[ $verbose ]] && echo "Syncing $path from $m1 to $m2"

	[[ $key ]] && { syncKey; return; }
	
	# get all keys at path
	local key keys; IFS=$'\n' keys=( $({ cred1 list --keys "$path"; cred2 list --keys "$path"; } | sort | uniq) )
	[[ $verbose ]] && { printf "all keys: "; ArrayShow keys; }

	for key in "${keys[@]}"; do
		header "$path $key"
		cred sync "$path" "$key" "-m1=$m1" "-m2=$m2" || return
	done
}

syncKey()
{
	# key does not exist in m1
	if ! cred1 exists "$path" "$key"; then
		echo "Creating \`$path $key\` in $m1..."
		local value; value="$(cred2 get "$path" "$key")" || return
		cred1 set "$path" "$key" "$value" || return
		return
	fi

	# key does not exist in m2
	if ! cred2 exists "$path" "$key"; then
		echo "Creating \`$path $key\` in $m2..."
		local value; value="$(cred1 get "$path" "$key")" || return
		cred2 set "$path" "$key" "$value" || return
		return
	fi

	# compare values
	local value1; value1="$(cred1 get "$path" "$key")" || return
	local value2; value2="$(cred2 get "$path" "$key")" || return

	if [[ "$value1" == "$value2" ]]; then
		echo "$path $key is the same in $m1 and $m2"
		return
	fi

	# compare time
	local time1; time1="$(cred1 get time "$path" "$key" | GetSeconds -)" || return
	local time2; time2="$(cred2 get time "$path" "$key" | GetSeconds -)" || return

	if [[ $verbose ]]; then
		echo "$m1 modifification time is $(cred1 get time "$path" "$key") ($time1 seconds)"
		echo "$m2 modifification time is $(cred2 get time "$path" "$key") ($time2 seconds)"
	fi

	if (( $(echo "$time1 > $time2" | bc -l) )); then
		echo "Updating $m2 ($m1 value is newer)..."
		cred2 set "$path" "$key" "$value1" || return
	else
		echo "Updating $m1 ($m2 value is newer)..."
		cred1 set "$path" "$key" "$value2" || return
	fi
}

#
# Mirror Command
#

mirrorUsage()
{
		echot "Usage: $(ScriptName) mirror PATH [KEY](default)
Mirror keys from one credential manager to another.
This will ensure the \`to\` credential manager is identical to 
the \`from\` credential manager at the specified PATH and KEY.

	-f,	--from MANAGER	first secret manager, defaults to local
	-t,	--to MANAGER		second secret manager, defaults to remote"
}

mirrorArgStart() { syncArgStart "$@"; }

mirrorOpt() 
{
	case "$1" in
		-f|--to|-f=*|--from=*) ScriptOptGet m1 "$@";;
		-t|--to|-t=*|--to=*) ScriptOptGet m2 "$@";;
		*) return 1
	esac
}

mirrorArgs() { syncArgs "$@"; }

mirrorCommand()
{
	local path="$originalPath"

	[[ $verbose ]] && echo "Mirroring $path from $m1 to $m2"

	[[ $key ]] && { mirrorKey; return; }

	[[ ! $force ]] && { ScriptErr "to overwrite all values at \`$path\` in $m2 --force must be specified."; return 1; }

	# get m1 keys at path
	local key keys; IFS=$'\n' keys=( $(cred1 list --keys "$path") )
	[[ ! $keys ]] && { ScriptErr "there are no keys at \`$path\` in $m1"; return 1; }
	[[ $verbose ]] && { printf "$m1 keys: "; ArrayShow keys; }

	echo "Deleting all keys at \`$path\` in $m2..."
	cred2 delete "$path" all || return

	for key in "${keys[@]}"; do
		echo "Adding \`$path $key\` to $m2..."
		local value; value="$(cred1 get "$path" "$key")" || return
		cred2 set "$path" "$key" "$value" || return
	done
}

cred1() { cred "--manager=$m1" "$@"; }
cred2() { cred "--manager=$m2" "$@"; }

mirrorKey()
{
	! cred1 exists "$path" "$key" && { ScriptErr "\`$path $key\` does not exist in $m1"; return; }
	local value; value="$(cred1 get "$path" "$key")" || return
	cred2 set "$path" "$key" "$value"
}

#
# Find a Credential Manager
#

validateManager()
{
	[[ $type ]] && type="${type,,}" || type="local"

	# aliases
	[[ "$type" == @(l) ]] && type="local"
	[[ "$type" == @(r) ]] && type="remote"
	[[ "$type" == @(v) ]] && type="vault"
	[[ "$type" == @(st) ]] && type="secrettool"

	# ensure correct case
	if [[ "$type" == "secrettool" ]]; then type="SecretTool"
	else type="$(ProperCase "$type")"
	fi

	# check if the credential manage is valid
	if ! IsFunction "findManager${type}"; then
		[[ ! $quiet ]] && EchoErr "credential: \`$type\` is not a valid credential manager"
		return 1
	fi

	return 0
}

findManager()
{
	[[ ! $type ]] && type="local"
	"findManager${type^}" || { noCredentialManager "$type"; return; }
	[[ $verbose ]] && HilightErr "credential: using $type credential manager"
	return 0
}

isManagerRemote() { [[ "$type" == @(vault) ]]; }

findManagerLocal() { findManagerPlatform; }
findManagerRemote() { findManagerVault; }

findManagerPlatform() { RunPlatform "findManagerPlatform"; }
findManagerPlatformLinux() { findManagerSecretTool || findManagerPass || findManagerVault; }
findManagerPlatformMac() { findManagerMac || findManagerPass || findManagerVault; }
findManagerPlatformWin() { findManagerWin || findManagerSecretTool || findManagerPass || findManagerVault; }

findManagerMac() { checkManagerMac && type="mac"; }
findManagerNone() { return 1; }
findManagerPass() { checkManagerPass && type="pass"; }
findManagerSecretTool() { checkManagerSecretTool && type="SecretTool"; }
findManagerVault() { checkManagerVault && type="vault"; }
findManagerWin() { checkManagerWin && type="win"; }

checkManagerRemote() { checkManagerVault; }
checkManagerMac() { ! IsInArray "mac" excludeManagers && IsPlatform mac && InPath security; } 			# MacOS Keychain
checkManagerWin() { ! IsInArray "win" excludeManagers && IsPlatform win &&  InPath "wincred.exe"; } # Windows Credential Manager

checkManagerPass() 
{
	{ IsInArray "secrettool" excludeManagers || ! InPath pass; } && return 1
	pass insert -m --force test-default<<< "success" >& /dev/null
}

checkManagerSecretTool()
{
	# ensure SecretTool is installed and we are using an X display
	{ IsInArray "secrettool" excludeManagers || [[ ! $DISPLAY ]] || ! InPath secret-tool; } && return 1

	# ensure DBUS can be configured correctly over SSH (so we get the Ubuntu Gnome keyring password prompt)
	if IsSsh && InPath dbus-launch dbus-update-activation-environment; then
		local result; result="$(dbus-update-activation-environment --systemd DISPLAY 2>&1)" || return
		[[ "$result" != "" ]] && return 1 # returns error text if there is an issue
	fi 

	echo "success" | secret-tool store --label "test" test default >& /dev/null
}

checkManagerVault()
{
	{ IsInArray "vault" excludeManagers || ! InPath vault; } && return 1
	[[ ! $VAULT_ADDR || ! $VAULT_TOKEN ]] && { eval "$(hashi vault environment)" || return; }
	local server="$(GetUriServer "$VAULT_ADDR")" port="$(GetUriPort "$VAULT_ADDR")"
	IsAvailablePort "$server" "$port" && [[ $VAULT_ADDR && $VAULT_TOKEN ]]
}

#
# Initialize the Credential Manager
#

initManager() { [[ ! $type ]] && return; RunFunction "initManager" "$type"; }
initManagerSecretTool() { initManagerGeneric; }
initManagerWin() { initManagerGeneric; }

initManagerGeneric()
{
	# update path: /a/b/ -> $engine-a-b	
	originalPath="$path"
	local prefix; [[ $engine ]] && prefix="$engine-"
	path="$prefix$(RemoveTrim "${path//\//-}" "-")"
} 

initManagerVault()
{
	# update path: /a/b/ -> /$engine/a/b
	originalPath="$path"
	path="/$engine/$(RemoveTrim "$path" "/")"
}

#
# Vault Helper
#

vaultIsLeaf() { vault kv get "$1" >& /dev/null; } 												# vaultIsLeaf PATH - return 0 if the path is a leaf node
vaultKeyExists() { vault kv get -field="$2" "$1" >& /dev/null; }					# vaultKeyExists PATH KEY - return 0 if the key exists at path, 1 if it does not
vaultLeafHasData() { vault kv get "$1" |& grep -q -E "(=)+ Data (=)+"; } 	# vaultLeafHasData PATH - leaf node contains data (contains non-deleted keys)
vaultPathHasChildren() { vault kv list "$1" >& /dev/null; } 							# vaultPathHasChildren PATH - return 0 if the path has children

#
# helper
#

cred() { credential "${engineArg[@]}" "${excludeManagersArg[@]}" $fallback $force $quiet $verbose "$@"; }

noCredentialManager()
{
	local desc="a"; [[ $1 ]] && desc="the $1"
	[[ ! $quiet ]] && ScriptErr "$desc credential manager is not available"
	[[ "$command" == "type" ]] && echo "none"
	return 1
}

run "$@"

#!/usr/bin/env bash
. script.sh || return
. color.sh || return

usage()
{
	ScriptUsage "$1" "Usage: $(ScriptName) [cleanup|gui](cleanup)
Cleanup files and configuration on the host.

	-w, --what LIST	comma seperated list of items to update
	-s, --skip LIST	comma seperated list of items to skip

items: $(echo "${defaultItems[@]}")"
	exit $1
}

init()
{	
	defaultCommand="cleanup"	
	defaultItems=( apt borg brew docker files journal ruby volumes )
	otherItems=( interactive )
	allItems=( "${defaultItems[@]}" "${otherItems[@]}" )
}

argStart() { unset -v skipArg whatArg; skip=() what=() ; }

opt()
{
	case "$1" in
		-s|--skip|-s=*|--skip=*) ScriptArgItems "skip" "allItems" "$@" || return;;
		-w|--what|-w=*|--what=*) ScriptArgItems "what" "allItems" "$@" || return;;
		*) return 1;;
	esac
}

#
# commands
#

guiCommand()
{
	IsPlatform mac && { start "CleanMyMac X.app"; return; }
	IsPlatform win && { start "$P/CleanMyPC/CleanMyPC.exe"; return; }
	return 0
}

#
# cleanup command
#

cleanupCommand()
{
	local errors=0 item

	[[ ! $what ]] && what=( "${defaultItems[@]}" )

	for item in "${what[@]}"; do
		IsInArray "$item" skip && continue
		"cleanup${item^}" || { log1 "error cleaning $item"; (( ++errors )); }
	done

	return "$errors"
}

cleanupBorg() { ! InPath borg && return; hilight "cleaning Borg..." && BorgHelper compact all;  }
cleanupBrew() { ! IsPlatform brew && return; hilight "cleaning Homebrew..." && brew cleanup; }
cleanupRuby() { ! which gem >& /dev/null && return; hilight "cleaning Ruby..." && sudoc gem cleanup; }
cleanupVolumes() { hilight "cleaning volumes..."; unc unmount all || return;  [[ -d "$(drive dir user)" ]] && rmdir "$(drive dir user)/"* >& /dev/null; return 0; }

cleanupApt()
{
	! IsPlatform apt && return
	hilight "cleaning apt..."
	sudoc apt-get clean -y || return 	# cleanup downloaded package files in /var/cache/apt/archives
	sudoc apt autoremove -y || return
	InPath wajig && { wajig purgeremoved || return; }
	return 0
}

cleanupDocker()
{
	! InPath docker && return

	# get dangling images
	local images; images="$(docker images -f "dangling=true" -q)"
	[[ ! $images ]] && return

	# cleanup dangling images	
	hilight "cleaning Docker..."
	docker rmi "$images"
}

cleanupJournal()
{
	! IsPlatform systemd && return
	hilight "cleaning systemd journal..."
	sudo journalctl --rotate && sudo journalctl --vacuum-time=2d
}

# files
cleanupFiles() { echo -n "${GREEN}cleaning files...${RESET}" && cleanupFilesTmp && RunPlatform cleanupFiles && echo "done"; }
cleanupFilesTmp() { ! IsPlatform mac && [[ -d "$TMP" ]] && rm -fr "$TMP/"*; echo -n "."; }

cleanupFilesWin()
{
	[[ -d "$UADATA/Temp" ]] && { log1 "$UADATA/Temp..."; rm -fr "$UADATA/Temp/"* >& /dev/null; echo -n "."; }
	[[ -d "$WIN_ROOT/temp" ]] && { log1 "$WIN_ROOT/temp..."; rm -fr "$WIN_ROOT/temp/"* >& /dev/null; echo -n "."; }
	[[ -d "$WINDIR/Temp" ]] && { log1 "$WINDIR/Temp"; rm -fr "$WINDIR/Temp/"* >& /dev/null; echo -n "."; }
	return 0
}

# interactive
cleanupInteractive() { RunPlatform cleanupInteractive; }

cleanupInteractiveWin()
{
	ask 'Cleanup old windows versions' && { elevate CleanMgr.exe /AUTOCLEAN || return; }
	ask 'Cleanup path' && { os path || return; }
	ask 'Cleanup startup programs' && { start --elevate autoruns || return; }
	ask 'Cleanup scheduled tasks' && { start --elevate task scheduler || return; }
	ask 'Cleanup remaining files' && { elevate CleanMgr.exe /VERYLOWDISK || return; }
	return 0
}

ScriptRun "$@"
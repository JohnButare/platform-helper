#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
usage: $(ScriptName) [sync|IsAvailable](sync)
Sync local files.

	-p, --protocol  $(ScriptOptNetworkProtocolUsage)"
}

init() 
{
	defaultCommand="sync"
	excludeDir=("Document Themes")
	exclude=(".*_sync.txt" "desktop.ini" ".git" ".DS_Store" "@eaDir" "thumbs.db" "*.TMP" "*.jcorig" )
	SshAgentConf "${globalArgs[@]}" || return
}

argStart() { unset -v protocol; }

opt()
{
	case "$1" in
		-p|--protocol|-p*|--protocol=*) ScriptOptNetworkProtocol "$@";;
		*) return 1;;
	esac
}

#
# IsAvailable Command
#

isAvailableUsage() { echo "\
Usage: $(ScriptName) IsAvailable
Return true if the default file server is available for syncronization."; }

isAvailableCommand() { local host; host="$(GetServer "file")" && unc IsAvailable "$host" "${protocolArg[@]}" "${globalArgs[@]}"; }

#
# Sync Command
#

syncUsage()
{
	echo "\
usage: $(ScriptName) sync [HOST](default)
Sync local files with the specified host.

Destination can be one of HOST|UNC|DIR|host|public|home.
- if the destination is \"host\", find a mounted host (i.e. VM host).
- if the destination is public or home, find the public or home directories
  specified in configuration

	-do,	--dest-older	assume destination files are than the local source files
	-so,	--src-older		assume local files are older than the destination files
	-nb,	--no-bak			do not backup files to the bak directory
	-ng,	--no-git			do not synchronize git repositories
	-u,	--unison	perform synronization using Unison"
}

syncArgStart() { unset -v hosts method noBak noGit unison; syncProgram="SyncDir";}

syncOpt() 
{
	case "$1" in
		--dest-older|--destination-older|-do) method="--dest-older";;
		--no-bak|-nb) noBak="--no-bak";;
		--no-git|-ng) noGit="--no-git";;
		--src-older|--source-older|-so) method="--src-older";;
		--unison|-u) unison="--unison" syncProgram="Unison";;
		*) return 1
	esac
}

syncArgs() { hosts=( "$@" ); (( shift+=$# )); true; }

syncCommand()
{	

	# initialize the source host
	local srcHost srcId; syncInitSrc || return

	# arguments
	set -- "${hosts[@]}"

	# default file server
	if [[ ! $1 ]]; then
		local host; host="$(GetServer "file")" || return
		set -- "$host"
	fi

	# sync destinations
	local destHost destId
	for destHost in "$@"; do			
		TimerOn
		syncInitDest || return		
		syncStart || return
		syncShared || return
		syncUser || return	
		syncFinish || return
	done
}

sync()
{
	local suffix="$1"; shift
	syncGit "$srcDir/$suffix" && sync$syncProgram "$srcDir/$suffix" "$destDir/$suffix" "$@" 
}

syncSyncDir()
{
	local srcDir="$1" destDir="$2"; shift 2
	local args=($method $noBak --srcid "$srcId" --destid "$destId" -x "${exclude[@]}" "${excludeDir[@]}" "${globalArgs[@]}")
	RunLog2 SyncDir "$srcDir" "$destDir" "${args[@]}" "$@" || return
}

syncUnison()
{
	local srcDir="$1" destDir="ssh://$destHost/$2"; shift 2
	local args=(-confirmbigdel); [[ $noPrompt ]] && args+=(-batch)

	# set server command - mac does not have /usr/local/bin in the path
	args+=( -servercmd=/usr/local/bin/unison -times )

	# options
	local recursive x=( "${exclude[@]}" )

	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-r|--recursive) recursive="true";;
			-x|--exclude) while [[ $2 ]] && ! IsOption "$2"; do x+=("$2"); shift; done;;
			*)
		esac
		shift
	done

	# excludes
	args+=(-ignore "Name {$(ArrayDelimit x ",")}")
	args+=(-ignore "Path {$(ArrayDelimit excludeDir ",")}")
	[[ "$suffix" == "platform" ]] && args+=(-ignore "Path {win,win_arm}")

	# force
	args+=(-ignorearchives)
	
	# permissions
	EchoErr "$srcDir"
	if drive IsWin "$srcDir"; then
		args+=(-perms=0 -dontchmod)
	elif ! IsPlatform mac && IsPlatform mac --host; then # mac does not have the user as a group as in Linux
		args+=(-owner=true)
	else
		args+=(-owner=true -group=true)
	fi

	# syncronization direction
	[[ "$method" == "--src-older" ]] && args+=(-force "$destDir")
	[[ "$method" == "--dest-older" ]] && args+=(-force "$srcDir")

	# sync
	echo; hilight "Synronizing $srcDir..."
	RunLog2 sudor unison "$srcDir" "$destDir" "${args[@]}" || return
}

syncGit()
{
	local dir="$1"

	# return if not a git directory
	[[ $noGit || ! -d "$dir/.git" ]] && return

	# setup
	log2 "git: sync git for '$dir'"
	cd "$dir" || return

	# fetch upstream updates	
	log2 "git: fetching"
	git fetch --quiet || return

	log2 "git: upstream status"
	local status="$(GitHelper upstream)"
	local changes; [[ "$(git status --porcelain)" != "" ]] && changes="true"

	# check upstream status
	case "$status" in
		ahead|up-to-date) return 0;;
		diverged) ScriptErr "'$dir' has diverged from the upstream branch"; return 1;;
	esac

	# stash local changes
	[[ $changes ]] && { log2 "git: stash"; git stash push --include-untracked || return; }

	# pull changes from upstream
	log2 "git: pull"; 
	git pull --quiet || return

	# restore local changes
	[[ $changes ]] && { log2 "git: stash pop"; git stash pop || return; }
	
	return 0
}

syncInitDest()
{
	local what
	unset destData destHome

	# Unison
	if [[ "$syncProgram" == "Unison" ]]; then
		destId="$(os name "$destHost" | RemoveDnsSuffix)"
		hostGetInfo "$destHost" || return
		destData="/$(GetUncDirs "$_data")" destHome="/$(GetUncDirs "$_home")"
		
	# host
	elif [[ "$destHost" == "host" ]]; then
		ScriptEval HostGetInfo host || return
		destHost="$_root" destId="host" destData="$_data" destHome="$_home"
		
	# UNC|public|home
	elif IsUncPath "$destHost" || [[ "$destHost" == @(public|home) ]]; then
		destHost="$(unc mount "$destHost" "${globalArgs[@]}")" || return		
		destId="$(unc get unc "$destHost" "${globalArgs[@]}" | GetUncServer | RemoveDnsSuffix)"

	# DIR
	elif [[ -d "$destHost" ]]; then 
		destId="$(drive label "$destHost" --quiet)" || destId="$(drive device "$destHost" --quiet)" || destId="$(GetFileName "$destHost")"

	# HOST
	else
		destId="$(os name "$destHost" | RemoveDnsSuffix)"

	fi

	# do not sync to ourself
	if IsLocalHostIp "$destHost" || [[ "$destHost" == "/" ]]; then
		[[ ! $quiet ]] && ScriptErr "cannot sync to the local computer"
		return 1
	fi

	# logging
	log2 "syncInitDest: destHost=$destHost destId=$destId"

	# return if destData and destHome are set
	[[ $destData && $destHome ]] && return

	# mount destData and destHome
	hostGetInfo "$destHost" || return
	destData="$(RunLog2 unc mount "$_data" --protocol=$_protocol "${globalArgs[@]}")" || return
	destHome="$(RunLog2 unc mount "$_home" --protocol=$_protocol "${globalArgs[@]}")" || return
}

syncInitSrc()
{
	srcHost="${HOSTNAME,,}"
	srcId="$srcHost"
	ScriptEval HostGetInfo || return
	srcData="$_data" srcHome="$_home"
}

syncShared()
{
	[[ ! $destData ]] && return

	local srcDir="$srcData" destDir="$destData"
	sync "bin" || return 
	sync "platform" -r || return
	[[ $unison ]] && { sync "platform/win" -r || return; }
	[[ $unison ]] && { sync "platform/win_arm" -r || return; }
	sync "doc" || return
	sync "icons" || return
	sync "lib" || return
	sync "man" -r || return
	sync "setup" || return
}

syncStart()
{
	# source
	local message="$(RemoveDnsSuffix "$srcId")"

	# sync direction
	case "$method" in
		--dest-older) message+="->";;
		--src-older) message+="<-";;
		*) message+="<->";;
	esac

	# destination
	message+="$destId"

	# show the message
	[[ $verbose ]] && { header "Synronizing $message"; return; }
	[[ $unison ]] && header "$message" || printf "$message..."
}

syncFinish()
{
	[[ ! $unison ]] && { TimerOff; return; }
	hilight "\nSynronization finished in $(TimerOff)"
}

syncUser()
{	
	[[ ! $destHome ]] && return

	local srcDir="$srcHome/data" destDir="$destHome/data"
	sync "bin" -r || return
	sync "certificate/public" || return
	sync "certificate/private" || return
	sync "profile/default" || return
	sync "replicate" || return

	srcDir="$srcHome" destDir="$destHome"
	syncSshPrep; sync ".ssh" -x "authorized_keys.jcorig" "environment" "log" || return
}

# syncSshPrep - if .ssh has 1 file we are bootstrapping.  This file will be the known_hosts file.
# Remove the .ssh directory to force a full copy.  This prevents intermitant hangs when bootstraping 
# seen with Windows 11 build 22593.
syncSshPrep () { [[ "$(DirCount ~/.ssh)" != "1" ]] && return; rm -fr ~/.ssh; }

#
# helper
#

# hostGetInfo HOST
hostGetInfo()
{
	local host="$1"
	RunLog2 ScriptEval HostGetInfo "$1" "${protocolArg[@]}" --quiet && return
	[[ ! $quiet ]] && ScriptErr "unable to get '$host' information"; return 1
}

ScriptRun "$@"

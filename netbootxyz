#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" app script color || exit

usage()
{
	init; ScriptUsage "$1" "\
usage: netbootxyz dir|docker|edit|info|setup|test|vars
$(ScriptName) commands.

	update|deploy|both			update and deploy netboot.xyz"
}

init() 
{
	# netboot.xyz application
	app="netbootxyz"
	dockerImageName="$app"

	# locations
	confDir="$HOME/$(ConfigGet confDir)/netboot.xyz" || return
	appDir="/opt/netboot.xyz"
	appConfig="$confDir/user_overrides.yml"
	downloadDir="$HOME/Downloads"
	menu="$confDir/menu/custom.ipxe.j2"
	webDirApp="/var/www/html/"
	winScriptDir="$confDir/web/custom/windows/scripts"

	# other
	winReleases=(release release-preview dev beta canary)
}

#
# commands
#

bothUsage() { ScriptUsageEcho "Usage: $(ScriptName) all\nUpdate and deploy netboot.xyz."; }
bothCommand() { updateAllCommand && deployAllCommand; }
isInstalledCommand() { [[ -d "$appDir" ]]; }
varsCommand() { local webDirTarget="$(getWebDirTarget)" && ScriptReturn appDir confDir webDirApp webDirTarget; }

#
# deploy commands
#

deployUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) deploy [all|app|assets|public|web](all)
Deploy netboot.xyz."
}

deployCommand() { deployAllCommand; }
deployPublicUsage() { ScriptUsageEcho "Usage: $(ScriptName) deploy public\Synchronize public installation files."; }
deployPublicCommand() { wiggin sync public "${globalArgs[@]}"; }

deployAllUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) deploy all
Deploy web, assets, and the public installation files.  \
The application is not deployed since the web site indicates when menus are out of date." 
}

deployAllCommand() { local noPrompt="--no-prompt"; unset -v unset hostArg hostOpt hosts; deployWebCommand && deployAssetsCommand && deployPublicCommand; }

deployAppUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) deploy app
Deploy the netboot.xyz application by upgrading the menus."
}

deployAppCommand()
{
	HeaderBig "Deploying Application"

 	local versionLatest; versionLatest="$(versionLatest)" || return
 	log1 "versionLatest=$versionLatest"

	local host hosts; getHosts || return
	for host in "${hosts[@]}"; do
		local h="$(RemoveDnsSuffix "$host")" versionHost; versionHost="$(versionApp "$host")" || return		
		log1 "host=$host versionHost=$versionHost versionLatest=$versionLatest"
		[[ "$versionHost" == "$versionLatest" ]] && continue
		open "http://$host:3000" || return
		pause "Click Update Menus then press any key to continue..."
	done
}

deployAssetsUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) deploy assets
Deploy menus, assets, custom assets, and installers to the custom assets directory."
}

deployAssetsCommand()
{
	header "Deploying Assets"

	hilight "Deploying custom assets..."
	local server; server="$(GetServer "netbootxyz" "${globalArgs[@]}")" || return
	UnisonHelper sync "$winScriptDir" "$server" "$ADATA/netbootxyz/assets-custom/windows/scripts" --root --no-props "${globalArgs[@]}" || return

	hilight "Syncronizing netboot.xyz assets..."
	wiggin sync netbootxyz || return
}

deployWebUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) deploy web
Copy the netboot.xys web site from $(FileToDesc "$webDirApp") to $(FileToDesc "$webDirTarget"), \
then uploads the content to all active Apache web servers."
}

deployWebArgStart() { unset hostArg hostOpt hosts; }
deployWebOpt() { ScriptOptHost "$@"; }

deployWebCommand()
{
	HeaderBig "Deploying Web"
	local webDirTarget; webDirTarget="$(getWebDirTarget)" || return

	hilight "Copying files.."
	sudoc quietPlatformConf="true" CopyDir --recursive --delete --rsync "$webDirApp" "$webDirTarget" "${globalArgs[@]}" || return

	hilight "Copying custom files..."
	sudo quietPlatformConf="true" CopyDir --recursive --rsync --no-metadata "$confDir/web/netboot.xyz/" "$webDirTarget" "${globalArgs[@]}" || return

	hilight "Copying custom menus..."
	sudo cp "$menu" "$webDirTarget/custom/custom.ipxe"  || return # assumes Jinja2 templates are not used (no {{ }})

	hilight "Syncronizing web sites..."	
	apache sync "${hostOpt[@]}" "${globalArgs[@]}"
}

#
# dir command
#

dirUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) dir [all|app|conf|web-app|web-target|win-install|win-installers](all)
Return the path to a netboot.xyz directory.

- app: netboot.xyz application (the Git repository)
- conf: custom configuration
- web-app: netboot.xyz website
- web-target: target website
- win-install: Windows ISO images
- win-installers: Windows extracted ISO images"
}

dirCommand() { dirAllCommand; }
dirAppCommand() { echo "$appDir"; }
dirConfCommand() { echo "$confDir"; }
dirWeb-appCommand() { echo "$webDirApp"; }
dirWeb-targetCommand() { echo "$(getWebDirTarget)"; }
dirWin-installCommand() { getWinInstallDir; }

dirWin-installersCommand()
{
	local server; server="$(GetServers "netbootxyz" "${globalArgs[@]}" | head -1)" || return # use GetServers so the server is more predictable (result is sorted)
	local dir; dir="$(unc mount "//$server/root/srv/netbootxyz/installers/windows")/$buildDir" || return
	echo "$dir"
}

dirAllCommand()
{
	cat <<-EOF
		app='$(dirAppCommand)'
		conf='$(dirConfCommand)'
		webApp='$(dirWeb-appCommand)'
		webTarget='$(dirWeb-targetCommand)'
		winInstall='$(dirWin-installCommand)'
		winInstallers='$(dirWin-installersCommand)'
		EOF
}

#
# docker commands
#

dockerUsage() { ScriptUsageEcho "Usage: $(ScriptName) docker IsInstalled|IsRunning|shell|start|stop\nControl the '$dockerImageName' Docker image."; }
dockerCommand() { usage; }
dockerIsInstalledCommand() { InPath docker || return; docker container list |& grep "$dockerImageName" >& /dev/null; }
dockerIsRunningCommand() { docker ps | grep --quiet "$dockerImageName"; }
dockerShellCommand() { docker exec -it "$dockerImageName" /bin/bash; } 
dockertStartCommand() { docker start "$(getContainerId)"; } 
dockerStopCommand() { docker stop "$(getContainerId)"; } 

#
# edit commands
#

editUsage() { ScriptUsageEcho "Usage: $(ScriptName) edit conf|menu|win\nEdit the netboot.xyz configuration or menus."; }
editCommand() { usage; }
editConfUsage() { ScriptUsageEcho "Usage: $(ScriptName) edit conf\nEdit the netboot.xyz configuration ($(FileToDesc "$appConfig"))."; }
editConfCommand() { TextEdit "$appConfig"; }
editMenuUsage() { ScriptUsageEcho "Usage: $(ScriptName) edit conf\nEdit the netboot.xyz configuration ($(FileToDesc "$menu"))."; }
editMenuCommand() { TextEdit "$menu"; }
editWinUsage() { ScriptUsageEcho "Usage: $(ScriptName) edit conf\nEdit the netboot.xyz configuration ($(FileToDesc "$menu"))."; }
editWinCommand() { TextEdit "$winScriptDir"; }

#
# info commands
#

infoUsage() { ScriptUsageEcho "Usage: $(ScriptName) info [locations|sites|servers|win](all)\nShow information."; }
infoCommand() { infoAllCommand; }
infoAllCommand() { infoLocationsCommand && echo && infoSitesCommand && echo && infoServersCommand && echo && infoWinCommand; }

infoLocationsCommand()
{
	local webDirTarget="$(getWebDirTarget)" || return

	echot "\
Locations:
- application: netboot.xyz Git repository  : $appDir ($(checkDir "$appDir"))
- configuration: custom configuration      : $confDir ($(checkDir "$confDir"))
- web app: netboot.xyz website             : $webDirApp ($(checkDir "$webDirApp"))
- web target: local website source         : $webDirTarget ($(checkDir "$webDirTarget"))"
}

infoSitesCommand()
{
	local applicationUrl="$(GetServer "netbootxyz" --quiet)"
	[[ $applicationUrl ]] && applicationUrl="http://$applicationUrl:3000" || applicationUrl="${RED}no netbootxyz application servers${RESET}"

	local menuUrl="$(GetServer "apache-web" --quiet)"
	[[ $menuUrl ]] && menuUrl="https://$menuUrl:1443/netbootxyz http://$menuUrl:180/netbootxyz" || menuUrl="${RED}no web menu servers${RESET}"

	local assetUrl="$(GetServer "apache-web" --quiet)"
	[[ $assetUrl ]] && assetUrl="https://$assetUrl:1443/boot-assets http://$assetUrl:180/boot-assets" || menunUrl="${RED}no web asset servers${RESET}"

	echot "\
Sites:
- application: https://netboot.butare.net
	- direct: $applicationUrl
- bootloaders/menus: https://boot.butare.net http://boot.butare.net/menu.ipxe
	- direct: $menuUrl
- assets: http://boot-assets.butare.net
  - direct: $assetUrl"
}

infoServersCommand()
{
	echo "Servers:"

	# web asset
	local webAssetServers="$(GetServers "apache-web" --quiet | NewlineToSpace | RemoveSpaceTrim)"
	[[ ! $webAssetServers ]] && webAssetServers="${RED}no web asset servers${RESET}"

	echot "\
- web-asset: $webAssetServers
  - directory: 'cd \$(apache dir cd)/boot-assets'"

  # web menu
	local webMenuServers="$(GetServers "apache-web" --quiet | NewlineToSpace | RemoveSpaceTrim)"
	[[ ! $webMenuServers ]] && webMenuServers="${RED}no web menu servers${RESET}"

	echot "\
- web-menu: $webMenuServers
  - directory: 'cd \$(apache dir cd)/netbootxyz"

  # TFTP
	local tftpServers="$(GetServers "tftp" --quiet | NewlineToSpace | RemoveSpaceTrim)"
	[[ ! $tftpServers ]] && tftpServers="${RED}no tftp servers${RESET}"

	local tftpServer="$(GetServer "tftp" --quiet)"
	[[ ! $tftpServer ]] && tftpServer="${RED}no tftp servers${RESET}"

	echot "\
- tftp: $tftpServers
  - configuration: /etc/default/tftpd-hpa
	- example: 'tftp $tftpServer -c get menu.ipxe'	"
}

infoWinUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) info win [detail]
Show Windows release information from UUP dump.

	-a, --alternate		use alternate source for release information (Microsoft)"
}

infoWinArgStart() { unset -v alternate; }

infoWinOpt()
{
	case "$1" in
		--alternate|-a) alternate="--alternate";;
		*) return 1;;
	esac
}

infoWinCommand()
{
	echot "Windows:"
	
	local release
	for release in "${winReleases[@]}"; do
		echo "  $release: $(infoWinBuild "$release")"		
	done
}

infoWinDetailCommand()
{
	local release term="$TERM"; [[ ! $term ]] && term="xterm-256color"
	{
		echo  "${GREEN}release#build#notes${RESET}"

		for release in "${winReleases[@]}"; do
			echo "${RESET}${RESET}$release#$(infoWinBuild "$release")#$(infoWinUrl "$release")"
		done

	} | ${G}column -c $(tput cols -T "$term") -t -s#
}

# infoWinBuild release|release-preview|beta|dev|canary
infoWinBuild()
{
	local release="$1" url
	local cacheSuffix=""; [[ $alternate ]] && cacheSuffix="-alternate"
	local cache="win-build-$release${cacheSuffix}"; UpdateGet "$cache" && return
	local src="Uup"; [[ $alternate ]] && src="Microsoft"
	local build="$(infoWinBuild${src} "$release")" || return
	! IsNumeric "$build" && { ScriptErr "Windows '$release' release build '$build' is not numeric"; return 1; }
	UpdateSet "$cache" "$build" && echo "$build"
}

infoWinBuildMicrosoft()
{
	local release="$1"

	# get release URL
	local url="$(infoWinUrl "$release")" || return
	log1 "infoWinBuildMicrosft: url=$url"

	# Microsoft does not have an apparent source for release build version
	[[ "$release" == "release" ]] && { alternate="" infoWinBuild "$release"; return; }

	# get build
	local result; result="$(curl -L --silent "$url")" || return
	local build="$(echo "$result" | grep "Build " | grep "strong" | head -1 | sed 's/.*Build //' | cut -d" " -f1 | cut -d")" -f1)"
	[[ "$build" =~ \. ]] && { echo "$build"; return; } # major.minor

	# minor version - release preview only has major version, find the minor version
	local major="$build"
	local minor; minor="$(echo "$result" | grep "$major\." | head -1 | sed "s/.*$major//" | cut -d" " -f1 | cut -d"." -f2)" || return
	echo "$major.$minor"
}

infoWinBuildUup()
{
	local release="$1"

	# get release URL
	local url="$(infoWinUrl "$release")" || return
	log1 "infoWinBuildUup: url=$url"
	local sleep=1
	for (( i = 0; i < 10; i++ )); do
		sleep "$sleep"
		local result; result="$(curl -L --silent "$url")" || return
		! echo "$result" | qgrep "rate limited" && break
		(( sleep+=sleep ))
		SleepStatus "UUP dump rate is limited, sleeping $sleep seconds..." 1>&2 || return
	done
		
	echo "$result" | ${G}grep "Build number:" | tail -1 | ${G}cut -d: -f2 | RemoveSpaceTrim | ${G}cut -d" " -f1
}

# infoWinUrl release|release-preview|beta|dev|canary - get Windows version URL from UUPdump.net or Windows Insider blogs (alternate)
# - both sources to validate, UUP dump may rate limit
infoWinUrl()
{
	local release="$1"
	src="Uup"; [[ $alternate ]] && src="Microsoft"
	infoWinUrl${src} "$release"
}

infoWinUrlMicrosoft()
{
	local name release="$1"
	case "${release,,}" in
		canary) name="canarychannellatest";;
		dev) name="DevLatest";;
		beta) name="BetaLatest";;
		release-preview) name="ReleasePreviewWindows11";;
		release) infoWinUrlUup "$release"; return;;
		*) ScriptErr "'$1' is not a valid Windows release"; return 1;;
	esac
	echo "https://aka.ms/$name"
}

infoWinUrlUup()
{
	local name release="$1"
	case "${release,,}" in
		canary) name="canary";;
		dev) name="wif";;
		beta) name="wis";;
		release-preview) name="rp";;
		release) name="retail";;
		*) ScriptErr "'$1' is not a valid Windows release"; return 1;;
	esac
	echo "https://uupdump.net/fetchupd.php?arch=amd64&ring=$name"
}

#
# setup command
#

setupUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup [app|config|test|web](all)\nSetup the netboot.xyz build environment including the application and web source files."; }
setupCommand() { setupAll; }
setupAllCommand() { setupAll; }
setupAll() { setupAppCommand && echo && setupConfigCommand && echo && setupTestCommand && echo && setupWebCommand; }
setupTestUsage() { ScriptUsageEcho "Usage: $(ScriptName) setup test\nSetup the netboot.xyz test programs."; }
setupTestCommand() { inst install TftpClient --no-header; }

setupAppUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) setup app
Install and update the netboot.xyz application in '$appDir'."
}

setupAppCommand()
{
	[[ ! $force && -d "$appDir" ]] && return	
	hilight "Setting up the netboot.xyz application ($appDir)..."

	# install packages
	package ansible git apache2 || return
	IsPlatform debian && { package python-is-python3 || return; }

	# install /opt/netboot.xyz application
	sudov || return
	[[ -d "$appDir" ]] && { sudo rm -fr "$appDir" || return; }
	sudo git clone "https://github.com/netbootxyz/netboot.xyz.git" "$appDir" || return
	sudo ${G}chown --recursive "$USER" "$appDir" || return
	! IsPlatform mac && { sudo ${G}chgrp -R "$USER" "$appDir" || return; }

	# update and build the application (checks out the latest tag)
	echo; updateAppCodeCommand || return
}

setupConfigUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) setup config
Setup the netboot.xyz configuration directory '$(FileToDesc "$configDir")'."
}

setupConfigCommand()
{
	(( $(${G}stat -c%b "$confDir/user_overrides.yml") > 0 )) && [[ ! $force ]] && return
	hilight "Setting up the configuration directory '$(FileToDesc "$confDir")'..."
	CloudGet "$confDir"
}

setupWebUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) setup web
Setup the netboot.xyz web directories '$webDirApp' and '$(getWebDirTarget)'."
}

setupWebCommand()
{
	local webDirTarget; webDirTarget="$(getWebDirTarget)" || return
	sudov || return

	# target web directory
	if [[ $force || ! -d "$webDirTarget" ]]; then
		hilight "Setting up the target web directory '$(FileToDesc "$webDirTarget")'..."
		apache sync "${globalArgs[@]}" || return
		sudo ${G}mkdir --parents "$webDirTarget" || return
	fi

	# netboot.xyz web directory (/var/www/html) - will be updated when the application is deployed
	if [[ $force || ! -d "$webDirApp" ]] || (( $(DirCount "$webDirApp") == 0 )); then
		hilight "Setting up the netboot.xyz web directory '$(FileToDesc "$webDirApp")'..."
		sudo quietPlatformConf="true" CopyDir --recursive --delete "$webDirTarget/" "$webDirApp"  "${globalArgs[@]}" || return
	fi

	return 0
}

#
# test command
#

testUsage() { ScriptUsageEcho "Usage: $(ScriptName) test [menu|ui|version|assets|tftp](all)\nTest the netboot.xyz configuration."; }
testArgStart() { result="0"; }

testCommand() { testAllCommand; }
testAllCommand() { header "Menu Test" && testMenu && header "UI Test" && testUi && header "Version Test" && testVersion && header "Asset Test" && testAssets && header "TFTP Test" && testTftp && return $result; }
testMenuCommand() { testMenu && return $result; }
testUiCommand() { testUi && return $result; }
testVersionUsage() { ScriptUsageEcho "Usage: $(ScriptName) test app\nTest the netboot.xyz application versions."; }
testVersionCommand() { testVersion && return $result; }
testAssetsCommand() { testAssets && return $result; }
testTftpCommand() { testTftp && return $result; }

testMenu() { printf "menus: "; curl --silent "https://boot.butare.net" | grep -q "iPXE Bootloaders" && echo "OK" || testFail "FAIL"; }
testUi() { printf "UI: "; curl --silent "https://netboot.butare.net" | grep -q "Web Application for customizing netboot.xyz" && echo "OK" || testFail "FAIL"; }

testVersion()
{
 	local versionCurrent; versionCurrent="$(versionCurrent)" || { testFail "could not get netbootxyz current version"; return; }
 	local versionLatest; versionLatest="$(versionLatest)" || { testFail  "could not get netbootxyz latest version"; return; }
 	printf "application source version: "; [[ "$versionCurrent" == "$versionLatest" ]] && echo "OK" || testFail "out of date (current v$versionCurrent, latest v$versionLatest)"

	local host hosts; getHosts || { testFail; return; }

	for host in "${hosts[@]}"; do
		local h="$(RemoveDnsSuffix "$host")" versionHost; versionHost="$(versionApp "$host")" || { testFail "unable to get the netboot.xyz version of host '$host'"; return; }
		printf "application $h version: "; [[ "$versionHost" == "$versionLatest" ]] && echo "OK" || testFail "out of date ($h v$versionHost, latest v$versionLatest)"
	done
}

testAssets()
{
	testWeb "boot-assets" "http://boot-assets.butare.net"
	testWeb "boot-assets-custom" "http://boot-assets.butare.net/custom/"

	local host hosts; GetHostsApp "apache-web" active || return 
	for host in "${hosts[@]}"; do
		host="$(RemoveDnsSuffix "$host")"
		testWeb "assets-$host" "http://$host.butare.net:180/boot-assets"
	done
}

testTftp()
{
	# determine tftp program
	local run tftp="${G}tftp"
	if ! InPath $tftp; then
		tftp="tftp"
		run="ssh $(GetServer "apache-web")" || { testFail "could not get a server to test TFTP"; return; }
	fi

	local file="about.ipxe"
	local server servers; servers="$(GetServers "tftp")" || { testFail "could not get TFTP servers"; return; }

	for server in $servers; do
		local desc="$(RemoveDnsSuffix "$server")"
		printf "TFTP $desc: "
		printf "server..."; IsAvailable "$server" || { testFail "not available"; continue; }
		printf "port..."; IsAvailablePortUdp "$server" 69 || { testFail "not responding (port 69)"; continue; }
		printf "IPv4..."; RunLog $run $tftp -4 $server -c get "$file" > /dev/null || { testFail "failed"; $run rm -f "$file"; continue; }
		printf "IPv6..."; RunLog $run $tftp -6 $server -c get "$file" > /dev/null || { testFail "failed"; $run rm -f "$file"; continue; }
		echo "OK"
		$run rm -f "$file"
	done
}

# testFail MESSAGE - display a failure message and increase the failure count in the result variable
testFail() { (( ++result )); [[ $1 ]] && HilightErrEnd "$1"; return 0; }

# testWeb DESCRIPTION URL
testWeb()
{
	local description="$1" url="$2"
	local server="$(GetUriServer "$url")" port="$(GetUriPort "$url")"

	printf "$description: "

	# check server
	printf "server..."; IsAvailable "$server" || { testFail "not available ($(RemoveDnsSuffix "$server"))"; return; }
	
	# check port
	if [[ $port ]]; then
		printf "port..."; IsAvailablePort "$server" "$port" || { testFail "not responding ($(RemoveDnsSuffix "$server") port $port)"; return; }
	fi
	
	# check HTTP response
	printf "url..."; RunLog curl -sL "$url" | qgrep "Index of /" || { testFail "not available ($url)"; return; }

	echo "OK"
}

#
# update commands
#

updateUsage() { ScriptUsageEcho "Usage: $(ScriptName) update [all|app|win](all)\nUpdate netboot.xyz."; }
updateCommand() { usage; }
updateAllCommand() { updateAppCommand && updateWinCommand; }

#
# update app commands
#

updateAppUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) update app [all|code|build](all)
Update the netboot.xyz application."
}

updateAppCommand() { updateAppAllCommand; }
updateAppAllCommand() { updateAppCodeCommand && updateAppBuildCommand; }

updateAppCodeUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) update app code
Update the netboot.xyz application code in $(FileToDesc "$appDir") to the latest tag in the repository."
}

# updateAppCodeCommand - 
updateAppCodeCommand()
{
	cd "$appDir" || return	
	git fetch || return

	# return if at the latest
	local latestTag; latestTag="$(versionLatest)" || return
	local currentTag; currentTag="$(versionCurrent)" || return
	log1 "updateAppCode: currentTag=$currentTag latestTag=$latestTag"
	[[ ! $force && "$currentTag" == "$latestTag" ]] && return

	# update
	hilight "Updating the netboot.xyz application to v${latestTag}..."
	git reset --hard  "$latestTag" || return
}

updateAppBuildUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) update app build
Build the netboot.xyz application by running the Ansible playbook.  \
The build integrates new netboot.xyz code and menus to '$(FileToDesc "$webDirApp")'."
}

updateAppBuildCommand()
{
	cp "$confDir/user_overrides.yml" "$appDir" || return
	cd "$appDir" && sudoc ansible-playbook -i "inventory" "site.yml"
}

#
# update win commands
#

updateWinUsage()
{
	echot "\
Usage: $(ScriptName) app update win [all|build|download|select](select)
Update Windows setup images.  ISO images are built using the 'uup build all' command.

	all 				download and build the current Windows builds 
	build				build compressed UUP download files and ISO directories in $(FileToDesc "$downloadDir")
	download  	download current Windows UUP files to $(FileToDesc "$downloadDir")
	select 			select a Windows build from the UUP web site and build it"
}

updateWinCommand() { updateWinSelectCommand; }

updateWinBuildUsage() { ScriptUsageEcho "Usage: $(ScriptName) update win build\Build any compressed UUP download files in $(FileToDesc "$downloadDir")."; }
updateWinBuildCommand() { uupBuild; }

updateWinDownloadUsage() { ScriptUsageEcho "Usage: $(ScriptName) update win download\Download current Windows UUP files to $(FileToDesc "$downloadDir")."; }
updateWinDownloadCommand() { uupDownload; }

updateWinAllUsage() { ScriptUsageEcho "Usage: $(ScriptName) update win all auto\Download and build the current Windows builds."; }

updateWinAllCommand()
{
	HeaderBig "Download UUP Files"
	uupDownload || return
	(( $(getUupFileCount) == 0 )) && return
	uupBuild || return
}

updateWinSelectUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) update win select [auto]
Select a specific Windows build."
}

updateWinSelectCommand()
{
	infoWinCommand || return

	echot "\
- Select Latest Public|Release Preview|Beta|Dev|Canary build, x64|arm64
- Select Windows 11, version NNNN (ni_release)
- Next, Next, Create download package"
	open "https://uupdump.net/"; pause
	uupBuild || return
}

# uupBuild - build the UUP files in $downloadDir
uupBuild() { cd "$downloadDir" && uupBuildIso && uupBuildInstall; }

uupBuildIso()
{
	# return if no UUP files
	local fileCount="$(getUupFileCount)"
	if (( fileCount == 0 )); then
		log1 "uupBuildIso: no UUP build files in $(FileToDesc "$downloadDir")"; return
	fi

	# build
	log1 "uupBuildInstall: processing $fileCount UUP build files"
	local file; for file in *.*.zip; do
		HeaderBig "Building ISO from $(FileToDesc "$file")"
		uup build iso "$file" "${globalArgs[@]}" || return
	done
}

uupBuildInstall()
{
	# find ISO directories in the format MAJOR.MINOR
	local dirs; IFS=$'\n' ArrayMake dirs "$(find . -maxdepth 1 -regextype posix-extended -regex '.*/[0-9]+\.[0-9]+-(amd64|arm64)' -type d -printf '%f\n')"
	(( ${#dirs[@]} == 0 )) && { log1 "uupBuildInstall: no Windows ISO directories in $(FileToDesc "$downloadDir")"; return; }

	# build
	log1 "uupBuildInstall: processing ${#dirs[@]} ISO directories"
	local dir; for dir in "${dirs[@]}"; do
		HeaderBig "Installing ISO $(FileToDesc "$dir")"

		# copy ISO to install directory
		uup build install "$dir" "${globalArgs[@]}" || return

		# extract ISO to installers directory
		uup build installers "$dir" "${globalArgs[@]}" || return

		# update installation scripts
		ScriptEval uup build vars "$dir" || return
		local file="$winScriptDir/install/$buildDir.bat"
		hilight "Creating script '$(FileToDesc "$file")'..."
		if [[ $force || ! -f "$file" ]]; then
			log1 "uupBuildInstall: creating '$(FileToDesc "$file")' "
			echo "@setup.bat $buildDir" > "$file" || return
		else
			log1 "uupBuildInstall: file '$(FileToDesc "$file")' already exists"
		fi

		# update install README.txt
		local dir; dir="$(getWinInstallDir)" || return
		local file="$dir/README.txt"
		hilight "Updating '$(FileToDesc "$file")'..."
		local line="$buildDir"
		local label="$(infoWinCommand | grep "${build}$" | cut -d":" -f1 | RemoveNewline | RemoveSpaceTrim | tr -s " ")" || return # build may match multiple release types
		[[ $label ]] && line+=" ($label)"
		if ! qgrep "$line" "$file"; then
			log1 "uupBuildInstall: adding '$line' to '$(FileToDesc "$file")'"
			echo "$line" >> "$file" || return
		else
			log1 "uupBuildInstall: file '$(FileToDesc "$file")' already has line '$line'"
		fi

	done
}

# uupDownload - download current UUP files to $downloadDir
uupDownload()
{
	hilight "Downloading current releases..."
	local setupDir; setupDir="$(getWinInstallDir)" || return
	infoWinDetailCommand | tee "$setupDir/releases.txt" || return

	hilight "Downloading UUP build files..."
	local file; file="$(mktemp -t "UupBuilds.XXXXXXXXXX.json")" || return
	curl --silent "https://api.uupdump.net/listid.php" > "$file" || return
	log2 "downloaded UUP build JSON file to '$file'"

	# download the UUP files for each current windows build
	local release
	for release in "${winReleases[@]}"; do
		local build; build="$(infoWinBuild "$release")" || return
		local arch="amd64" # amd64|arm64
		local uuid; uuid="$(cat "$file" | jq '.response.builds | map(select(.build | contains("'$build'"))) | map(select(.arch == "amd64"))[0] | .uuid' | RemoveQuotes)"
		local uup="$downloadDir/${build}.${arch}.zip"
		log2 "release=$release build=$build uuid=$uuid uup='$uup'"

		# UUP zip file is already downloaded
		[[ -f "$uup" ]] && { log1 "the UUP build file for the current $release release is already in '$uup'"; continue; }

		# check if this release is already downloaded
		[[ ! $force && -d "$setupDir/$build" ]] && { [[ ! $quiet ]] && echo "The setup for the current $release release (build $build) exists in $(FileToDesc "$setupDir/$build")."; continue; }

		# download UUP zip file
		hilight "Downloading UUP file for Windows $release build $build $arch..."
		log1 "uuid=$uuid uup=$uup"

		while true; do
			curl --location -X POST "https://uupdump.net/get.php?id=${uuid}&pack=en-us&edition=core;professional" --data 'autodl=2&updates=1' --output "$uup" || return
			file "$uup" | qgrep "Zip" && break # rapid downloads are text files not zip files
			SleepStatus "Download failed, waiting for UUP site to stabilize..." 5
		done

	done

	# display status
	let uupFileCount; uupFileCount="$(getUupFileCount)" || return
	(( uupFileCount > 0 )) && { echo "$uupFileCount UUP build file(s) in $(FileToDesc "$(GetFilePath "$uup") need processing")."; }

	rm "$file" || return
}

#
# version command
#

versionUsage() { ScriptUsageEcho "Usage: $(ScriptName) version [all|app|current|latest|local](local)\nShow netboot.xyz versions."; }
versionCommand() { versionLocalCommand; }

versionAllCommand()
{
	echo "local: v$(versionLocal)"
	echo "source current: v$(versionCurrent)"
	echo "source latest: v$(versionLatest)"

	local host hosts; getHosts || return
	for host in "${hosts[@]}"; do
		echo "application $(RemoveDnsSuffix "$host"): v$(versionApp "$host")"
	done
}

versionAppUsage() { ScriptUsageEcho "Usage: $(ScriptName) version menus\nShow netboot.xyz application version."; }
versionAppCommand() { local host; host="$(GetServer "netbootxyz" "${globalArgs[@]}")" && versionApp "$host"; }

versionCurrentUsage() { ScriptUsageEcho "Usage: $(ScriptName) version current\nShow netboot.xyz application source current version."; }
versionCurrentCommand() { versionCurrent; }

versionLatestUsage() { ScriptUsageEcho "Usage: $(ScriptName) version latest\nShow netboot.xyz application source latest version."; }
versionLatestCommand() { versionLatest; }

versionLocalUsage() { ScriptUsageEcho "Usage: $(ScriptName) version local\nShow netboot.xyz local application version."; }
versionLocalCommand() { versionLocal; }

versionApp() { SshHelper connect "$1" -- cat "$ACONF/netbootxyz/config/menuversion.txt 2> /dev/null"; } # versionApp HOST
versionCurrent() { ( appCd && git describe --tags; ); }
versionLatest() { ( appCd && git tag | sort -V | grep -v '\-RC' | ${G}tail --lines=-1; ); }
versionLocal() { isInstalledCommand && cat "$appDir/version.txt"; }

#
# helper functions
#

appCd() { AppInstallCheck && cd "$appDir"; }
checkDir() {  [[ -d "$1" ]] && echo "present" || echo "${RED}missing${RESET}";  }
getContainerId() { docker ps --all | grep "$dockerImageName" | cut -d" " -f1; }
getHosts() { GetHostsService "netbootxyz"; }
getUupFileCount() { command ls -1 "$downloadDir/"*.*".zip" 2> /dev/null | wc -l; }
getWinInstallDir() { FindInstallFile "other/Microsoft/Windows/setup"; }
getWebDirTarget() { local dir; dir="$(apache dir sync)" || return; echo "$dir/htdocs/netbootxyz"; }

ScriptRun "$@"
#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Helper commands for HashiCorp consul, nomad, and vault products.

Common commands:
	cleanup|install|remove|update
	cert							create certificates
	config						configure all products
	resolve						resolve a service
	PRODUCT|all				commands for a product or all products
	status						show status for all products
	ui								start the hashi-ui server and launch it

Common options:
	-cf, --config-file			configuration file to use in place og bootstrap-config.sh
	-cp, --config-prefix		configuration prefix to use, i.e. test
	-H,  --host HOST				comma separated list of hosts for the command or one of the
													following aliases: first|second|third|fourth
			 --product-server		server for product communication"
}

init()
{
	products=( consul nomad vault )
	productUsage="consul|nomad|vault"
	binDir="/usr/local/bin"; IsPlatform entware && binDir="/opt/bin"
	certVolume=""
	certOptUsage="-e, --encrypt [DIR]		directory for PKI certificates, if specified TLS will be enabled"

	configWhat="consul-vault-data local-certs local-credentials private-certs public-certs"
}

argStart() { unset -v configFile configFileArg configPrefix configPrefixArg hostArg hostArgOrig productServer; }

opt()
{
	case "$1" in
		-cf|--config-file|-cf=*|--config-file=*) ScriptOptGet "configFile" "config-file" "$@" && ScriptCheckFile "$configFile" && configFileArg=(--config-file "$configFile");;
		-cp|--config-prefix|-cp=*|--config-prefix=*) ScriptOptGet "configPrefix" "config-prefix" "$@" && configPrefixArg=(--config-prefix "$configPrefix");;
		-H|--host|-H=*|--host=*) ScriptOptGet hostArg host "$@"; hostArgOrig="$hostArg";;
		--product-server|--product-server=*) ScriptOptGet productServer product-server "$@";;
		*) return 1;;
	esac
}

argEnd()
{
	# basic configuration
	datacenter="$(ConfigGet "workgroup")"
	baseDomain="$(ConfigGet "baseDomain")"
	domain="$(ConfigGet "domain")"
	
	# port configuration
	consulHttpPort="8500" consulHttpsPort="8501"
	nomadHttpPort="4646" nomadHttpsPort="$nomadHttpPort"
	vaultHttpPort="8200" vaultHttpsPort="$vaultHttpPort"

	# product configuration - set product from command if possible
	product=""
	if IsInArray "${commandNames[0]}" products; then
		product="${commandNames[0]}"
		productInit || return
	else
		initConfig || return
	fi
}

#
# Commands
#

cleanupCommand()
{
	local hosts; getHosts "localhost" || return

	for host in "${hosts[@]}"; do
		header "Cleanup ($host)"
		hostCleanup "$host" || return
	done
}

statusCommand()
{
	local product term="$TERM"; [[ ! $term ]] && term="xterm-256color"

	{
		#(productVarGet "CACERT" | GetFilePath | FileToDesc
		hilight "product-ui-certificate-token-config-domain"

		for product in "${products[@]}"; do			
			! productIsInstalled && continue

			suppressErrors="true" productInit || return
			local ui="$(productVarGet "ADDR")"
			local cert="false"; [[ -f "$(productVarGet "CACERT")" ]] && cert="true"
			local token="false"; [[ $(productVarGet "TOKEN") ]] && token="true"
			local prefix="$(productVarGet "CONFIG")"; prefix="${prefix:-prod}"
			local domain="$(productVarGet "DOMAIN")"
			echo "${RESET}${RESET}$product-$ui-$cert-$token-$prefix-$domain" # add resets to line up the columns

		done

	} | column -c $(tput cols -T "$term") -t -s-
}

uiCommand()
{
	local product

	for product in "consul" "nomad"; do
		productInit || return
		export ${product}_ENABLE="true"
		export ${product}_ADDR="$(productVarGet "ADDR")"
		export ${product}_ACL_TOKEN="$(productVarGet "TOKEN")"	
		unset ${product}_HTTP_SSL; [[ "$(GetUriProtocol "${product}_ADDR")" == "https" ]] && export ${product}_HTTP_SSL="true"
	done

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# Certificate Commands
#

certUsage()
{
	echot "Usage: $(ScriptName) cert copy|info|make

	copy		copy public certificates
	make		make certificates
	status	show certificate status

	$certOptUsage"
}

certArgStart() { unset encrypt; }

certOpt()
{
	case "$1" in
		-e|--encrypt|-e=*|--encrypt=*) encryptOptGet "$@";;
		*) return 1;;
	esac
}

certCommand() { usage; }

#
# Certificate Copy Command
#

certCopyUsage() { echot "\
Usage: $(ScriptName) cert copy [all|consul|nomad](all)
Copy public certificates to the public installation location.

	-e, --encrypt DIR			directory for PKI certificates"; }

certCopyCommand() { certCopyAllCommand; }
certCopyAllCommand() { certCopyPublic "consul" && certCopyPublic "nomad" && certDirUnmountPrivate; }
certCopyConsulCommand() { certCopyPublic "consul" && certDirUnmountPrivate; }
certCopyNomadCommand() { certCopyPublic "nomad" && certDirUnmountPrivate; }

certCopyPublic()
{
	local product="${1:-$product}"

	# initialization
	initConfig || return
	certInit || return

	# source directory (private certificates)
	local src; src="$(certDirMountPrivate)" || return
	local cert certs=( "$ca" "$certCli" "$certCliKey" ); [[ $caAuto ]] && certs+=( "$caAuto" )

	certValidate "$src" "${certs[@]}" || return

	# destination directory (public certificates)
	local dest; dest="$(certDirPublic)" || return
	${G}mkdir --parents "$dest" || return

	# return if the source and destination locations are the same
	[[ "$src" == "$dest" ]] && return

	# return if the certificates exist in the destination location
	[[ ! $force ]] && certExists "$dest" "${certs[@]}" && return

	# copy the certificates
	log1 "copying $product public certificates to '$(FileToDesc "$dest")'..."
	for cert in "${certs[@]}"; do
		copyFile "$src/$cert" "$dest" || return
	done
}

#
# Certificate Make Command
#

certMakeUsage() { echot "\
Usage: $(ScriptName) cert make all|consul|nomad
Create certificates required for HashiCorp products.

	-e, --encrypt DIR			directory for PKI certificates"; }

certMakeArgEnd() { [[ ! $encrypt ]] && MissingOption "encrypt"; return 0; }
certMakeCommand() { usage; }
certMakeAllCommand() { certMake "consul" && certMake "nomad" && certMakeCleanup; }
certMakeConsulCommand() { certMake "consul" && certMakeCleanup; }
certMakeNomadCommand() { certMake "nomad" && certMakeCleanup; }

certMake()
{
	local product="$1"; 

	# certificate initialization - mount the private certifcate directory and create subfolders
	certInit || return
	certDir="$(certDirMountPrivate)" || return
	sudoc ${G}mkdir --parents "$certDir" || return
	useHttps="true"

	# create the certificates
	RunFunction "cert" "Make${product^}" || return
}

certMakeCleanup() { certDirUnmountPrivate || return; }

certMakeStart() { hilight "$1"; cd "$certDir"; }

# Make Consul certificates

certMakeConsul()
{
	# install consul to create certificates
	! InPath "consul" && { inst "consul" || return; }

	# create the certificates
	certMakeConsulCa || return
	certMakeConsulCli || return
}

certMakeConsulCa()
{
	certExists "$certDir" "$ca" "$caKey" && return
	certMakeStart "Creating the certificate authority for $baseDomain..." || return

	# create the cert
	consul tls ca create \
		-domain="$baseDomain" \
		-name-constraint || return # name constraint required for HTTPS GUI

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

# certMakeConsulCaAuto - get the auto generated Consul certficate authority.   This CA
# is used on Consul clients and is needed on the Consul client to access the Consul API
# from other programs like Nomad, curl, or wget.
certMakeConsulCaAuto()
{
	certValidate "$certDir" "$ca" || return
	certExists "$certDir" "$caAuto" && return

	header "Get Consul Certificates"
	certMakeStart "Getting the automatic certificate authority..." || return

	! InPath "consul-k8s" && { inst "consul-k8s" || return; }

	consul-k8s get-consul-client-ca \
		--server-addr "$(productGetServer "consul")" \
		--server-port "$consulHttpsPort" \
		--ca-file="$ca" \
		--output-file "$caAuto" || return
}

certMakeConsulCli()
{
	certValidate "$certDir" "$ca" "$caKey" || return
	certExists "$certDir" "$certCli" "$certCliKey" && return
	certMakeStart "Creating the CLI certificates..." || return

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

certMakeConsulServer()
{
	local cert="$1" key="$2" host="$3"

	certValidate "$certDir" "$ca" "$caKey" || return
	certExists "$certDir" "$cert" "$key" && return
	certMakeStart "Creating the $host server certificate..." || return

	# remove any existing temporary certs
	rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

	# create the cert
	local ip; ip="$(GetIpAddress "$host")" || return
	local osName; osName="$(os name "$host")" || return
	consul tls cert create -server \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-additional-ipaddress="$ip" \
		-additional-dnsname="$osName" \
		-node="$host" || return

	# rename the temporary cert
	mv "$datacenter-server-$baseDomain-0.pem" "$cert" || return
	mv "$datacenter-server-$baseDomain-0-key.pem" "$key" || return
}

# Make Nomad certificates

certMakeNomad()
{
	# install cfssl to create certificates
	! InPath "cfssl" && { inst "cfssl" || return; }

	# create certificates
	certMakeNomadCa || return
	certMakeNomadServer || return
	certMakeNomadClient || return
	certMakeNomadCli || return
}

certMakeNomadCa()
{
	certExists "$certDir" "$ca" "$caKey" && return
	certMakeStart "Creating the Nomad certificate authority..." || return
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca
}

certMakeNomadCli()
{
	certValidate "$certDir" "$ca" "$caKey" || return
	certExists "$certDir" "$certCli" "$certCliKey" && return
	certMakeStart "Creating the Nomad CLI certificate..." || return
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-cli
}

certMakeNomadClient()
{
	certValidate "$certDir" "$ca" "$caKey" || return
	certExists "$certDir" "$certClient" "$certClientKey" && return
	certMakeStart "Creating the Nomad client certificate..." || return
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-client
}

certMakeNomadServer()
{
	certValidate "$certDir" "$ca" "$caKey" || return
	certExists "$certDir" "$certServer" "$certServerKey" && return
	certMakeStart "Creating the Nomad server certificate..." || return

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > "cfssl.json" || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(ArrayDelimit joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -config="cfssl.json" -hostname="$hosts" - | cfssljson -bare "nomad-server"
}

#
# Certificate Status Command
#

certStatusUsage() 
{ 
	echot "\
Usage: $(ScriptName) cert copy [all|consul|nomad](all)
Show certificate status.

	-m, --make																		make the certificate directory
	-t, --type local|private|public|any](any)			type of certificate directory"
}

certStatusCommand() { certStatusAllCommand; }
certStatusAllCommand() { certStatusConsulCommand && certStatusNomadCommand; }
certStatusConsulCommand() { certStatus "consul"; }
certStatusNomadCommand() { certStatus "nomad"; }

certStatus()
{
	local dir product="$1"; initConfig || return

	# initialize certificates
	certInit || return; 
	[[ "$encrypt" ]] && dir="$(certDirPrivate | certDirSuffix)" || dir="$(certDirLocal)"
	certDirValidate "$dir" || return

	# show results
	echo "${product^} certificates are located in '$dir'"; echo
	{
		hilight "type:file:present"
		echo "CA:$ca:$(certStatusPresent "$ca")"
		[[ $caAuto ]] && echo "Auto CA:$caAuto:$(certStatusPresent "$caAuto")"
		echo "CA Key:$caKey:$(certStatusPresent "$caKey")"
		echo "CLI:$certCli:$(certStatusPresent "$certCli")"
		echo "CLI Key:$caKey:$(certStatusPresent "$certCliKey")"

		# in the prive certifice directory consul uses client and server certificates specific to the host
		if [[ "$product" != "consul" || ! $encrypt ]]; then
			echo "Client:$certClient:$(certStatusPresent "$certClient")"
			echo "Client Key:$certClientKey:$(certStatusPresent "$certClientKey")"
			echo "Server:$certServer:$(certStatusPresent "$certServer")"
			echo "Server Key:$certServerKey:$(certStatusPresent "$certServerKey")"
		fi

	} | column -c $(tput cols) -t -s: -n

	echo
}

certStatusPresent() { [[ -f "$dir/$1" ]] && echo "true" || echo ""; }

#
# Install Command
#

installUsage() { echot "\
Usage: $(ScriptName) install all|cli|$productUsage
Install a HashiCorp product.

	-c, --clients	HOSTS		comma separated list of clients to install
	-s, --server HOSTS		comma separated list of servers to install
	-j, --join HOSTS			comma separated list of hosts to join to, defaults to servers
	$certOptUsage
	-w, --what=C1[,C2...] components to install: acl cert program service NomadVaultIntegration"; }

installArgStart() { clients=() servers=() join=() encrypt="" force=""; }

installOpt()
{
	case "$1" in
		-c|--clients|-c=*|--clients=*) ScriptOptGet "clients" "$@"; StringToArray "$clients" "," clients;;
		-s|--servers|-s=*|--servers=*) ScriptOptGet "servers" "$@"; StringToArray "$1" "," servers;;
		-j|--join|-j=*|--join=*) ScriptOptGet "join" "$@"; StringToArray "$1" "," join;;
		-e|--encrypt|-e=*|--encrypt=*) encryptOptGet "$@";;
		-w|--what|-w=*|--what=*) ScriptOptGet "what" "$@"; StringToArray "${what,,}" "," what;;
		*) return 1;;
	esac
}

installCommand() { installAllCommand; }
installAllCommand() { installConsulDo && installVaultDo && installNomadDo && certMakeCleanup; }

#
# Install CLI Command
#

installCliUsage() {	echot "\
Usage: $(ScriptName) install cli all|$productUsage
Install a HashiCorp program and certificates for command line access.

-w, --what=C1[,C2...] components to install: cert cred program"; }

installCliCommand() { local product; for product in vault consul nomad; do installCli "$product" || return; done; }
installCliConsulCommand() { installCli "consul"; }
installCliNomadCommand() { installCli "nomad"; }
installCliVaultCommand() { installCli "vault"; }

installCli()
{
	local product="$1"; initConfig || return

	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be installed locally"; return 1; }
	
	whatCheck "program" && { productInstall "$product" "localhost" || return; }
	whatCheck "cert" && certPublicExists && { productInstallCerts "$product" || return; }
	whatCheck "cred" && InPath vault && { configSetLocal "$product" || return; }
	return 0
}

#
# Install Consul Command
#

installConsulCommand() { installConsulDo && certMakeCleanup; }

installConsulDo()
{ 
	local product="consul"; installCommon || return
	local -A options serverOptions guiOptions 
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	options=(
		[domain]="$baseDomain"
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[client_addr]="0.0.0.0"
		[bind_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[retry_join]="[ $(ArrayShow join ", ") ]"
		[leave_on_terminate]="true"
		[telemetry]="{ disable_compat_1.9 = true }"
		[acl]="$(cat <<-EOF
			{ 
			  enabled = true
			  default_policy = "allow"
			  enable_token_persistence=true
			}
			EOF
		)"
	)

	serverOptions=(
		[server]="true"
		[bootstrap_expect]="${#join[@]}"
		[advertise_addr]='{{ GetInterfaceIP \"eth0\" }}'
	)

	commonEncryptOptions=(
		[addresses]='{ https = "0.0.0.0" }'
		[ports]="{ http = -1, https = $consulHttpsPort }"
		[verify_incoming]="false"
		[verify_incoming_rpc]="true"
		[verify_outgoing]="true"
		[verify_server_hostname]="true"
	)

	clientEncryptOptions=(
		[ca_file]="$certDirService/$ca"
		[auto_encrypt]="{ tls = true }"
	)

	serverEncryptOptions=(
		[ca_file]="$certDirService/$ca"
		[cert_file]="$certDirService/$certServer"
		[key_file]="$certDirService/$certServerKey"
		[auto_encrypt]="{ allow_tls = true }"
	)

	guiOptions=( [ui_config]="{ enabled = true }" )

	installDo || return
}

installConsulCommon()
{
	# service
	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$program agent -config-dir=$productConfigDir"
	serviceKillSignal="SIGTERM"
}

installConsulClient() 
{
	certs && { cp "$certDir/$caAuto" "$tmpDir/cert" || return; }
	return 0
}

installConsulServer() 
{ 
	certs && { installConsulCertServer || return; }
	ArrayAppend o serverOptions guiOptions || return
}

installConsulCertServer()
{
	local cert="consul-server-$host.pem"
	local key="consul-server-$host-key.pem"

	certMakeConsulServer "$cert" "$key" "$host" || return

	cp "$certDir/$cert" "$tmpDir/cert/$certServer" || return
	cp "$certDir/$key" "$tmpDir/cert/$certServerKey" || return
}

installConsulServerFinal()
{
	certs && { certMakeConsulCaAuto || return; }
	installAcl || return
}

installConsulFinal() { installConsulAgentAcl; }

installConsulAgentAcl()
{
	! whatCheck "acl" && return

	header "Add Tokens"
	productInit "consul" || return

	# create the default policy and token (for DNS resolution)	
	local name="dns-requests"
	local defaultToken policy="$(cat <<-EOF
		node_prefix "" {
		  policy = "read"
		}
		service_prefix "" {
		  policy = "read"
		}
		EOF
	)"
	consulAclCreate "dns-requests" "$policy" || return
	defaultToken="$(consulAclTokenGet "$name")" || return

	# create the host specific policies
	for host in server "${servers[@]}" client "${clients[@]}"; do
		[[ "$host" == @(client|server) ]] && { type="$host"; continue; }

		# continue if the default policy is already deny
		[[ "$(installConsulConfigGet "default_policy")" == "deny" ]] && continue

		# initialize certificates - updates caLocal based on type
		certInit || return

		# create the ACL policy for the host
		local token policy="$(cat <<-EOF
			node "$host" {
			  policy = "write"
			}		
			EOF
		)"
		name="agent-$host"
		consulAclCreate "$name" "$policy" || return
		token="$(consulAclTokenGet "$name")" || return

		# update the token on the agent
		hilight "Updating the ACL configuration on $host..."

		local args; args="-http-addr=$(productGetAddress "$product" "127.0.0.1")" || return	
		certs && args+=" -ca-file=\"$certDirService/$caLocal\" -client-cert=\"$certDirService/$certCli\" -client-key=\"$certDirService/$certCliKey\""
		
		scriptRun "$(cat <<-EOF
			export CONSUL_HTTP_TOKEN=$CONSUL_HTTP_TOKEN
			consul acl set-agent-token $args agent "$token" || exit
			consul acl set-agent-token $args default "$defaultToken" || exit
			EOF
		)" || return

	done

	# update default ACL policy
	for host in "${servers[@]}" "${clients[@]}"; do
		
		# continue if the default policy is already deny
		[[ "$(installConsulConfigGet "default_policy")" == "deny" ]] && continue

		hilight "Updating the default ACL policy on $host..."

		scriptRun "$(cat <<-EOF
			sudo sed -i 's/default_policy = "allow"/default_policy = "deny"/' "$productConfigFile" || return
			sudo systemctl restart "$product" --no-block || exit
			EOF
		)"

	done

}

# installConsulConfigGet VAR - get a variable from the Consul configuration file
installConsulConfigGet() 
{
	scriptRun "grep \"$1[ ]*=[ ]*\" \"$productConfigFile\"" | tr -s " " | cut -d"=" -f2 | RemoveCarriageReturn | RemoveSpace | RemoveQuotes
}

#
# Install Nomad Command
#

installNomadCommand() { installNomadDo && certMakeCleanup; }

installNomadDo()
{
	local product="nomad"; installCommon || return
	local -A options clientOptions serverOptions guiOptions
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 
	local token; token="$(product="consul" credGetIfExists "token")"; [[ ! $token ]] && { ScriptErr "unable to get a Consul token for Nomad"; return 1; }
	local port; port="$(productGetPort "consul")" || return

	options=( 
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[acl]="{ enabled = true }"
		[consul]="$(cat <<-EOF
			{
			  token = "$token"
			  address = "127.0.0.1:$port"
			}
			EOF
		)"
	)
	
	serverOptions=(
		[server]="$(cat <<-EOF
			{
			  enabled = true
			  bootstrap_expect = "${#join[@]}"
			  raft_protocol = 3
			}
			EOF
		)"
	)

	commonEncryptOptions=()

	clientOptions=(
		[client]="$(cat <<-EOF
			{
			  enabled = true 
			}
			EOF
		)"
	)

	clientEncryptOptions=(
		[tls]="$(cat <<-EOF
			{ 
			  http = true
			  rpc = true
			  ca_file = "$certDirService/$ca"
			  cert_file = "$certDirService/$certClient"
			  key_file = "$certDirService/$certClientKey"
			  verify_server_hostname = false
			  verify_https_client = false
			}
			EOF
		)"
	)

	serverEncryptOptions=(
		[tls]="$(cat <<-EOF
			{
			  http = true
			  rpc = true
			  ca_file = "$certDirService/$ca"
			  cert_file = "$certDirService/$certServer"
			  key_file = "$certDirService/$certServerKey"
			  verify_server_hostname = false
			  verify_https_client = false
			}
			EOF
		)"
	)

	installDo || return
}

installNomadCommon()
{
	# encryption
	if certs; then
		certInit "consul" || return 
	
		cat > "$tmpDir/$product.env" <<-EOF
			CONSUL_HTTP_SSL=true
			CONSUL_CACERT=$certDirService/$caLocal
			CONSUL_CLIENT_CERT=$certDirService/$certServer
			CONSUL_CLIENT_KEY=$certDirService/$certServerKey
		EOF

		certInit "nomad" || return
	fi

	return 0
}

installNomadClient()
{
	certs && { cp "$certDir/$ca" "$certDir/$certClient" "$certDir/$certClientKey" "$tmpDir/cert" || return; }
	ArrayAppend o clientOptions || return
}

installNomadServer()
{
	certs && { cp "$certDir/$ca" "$certDir/$certServer" "$certDir/$certServerKey" "$tmpDir/cert" || return; }
	ArrayAppend o serverOptions clientOptions || return
}

installNomadServerFinal() { installAcl; }

installNomadFinal() { initNomadVaultIntegration; }

initNomadVaultIntegration()
{
	! whatCheck "nomadvaultintegration" && return	

	header "Install Nomad Vault Integration"
	! InPath vault && { echo "Vault is not installed, skipping nomad vault integration"; return; }

	local policy; productInit "vault" || return

	# nomad-cluster policy - policy for jobs (specifiy in job configuration)
	if ! vault policy list | grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster policy to Vault..."
		local policy="$(cat <<-EOF
			path "secret/*" {
			  capabilities = ["read"]
			}
			EOF
		)"
		echo "$policy" | vault policy write nomad-cluster - || return
	fi

	# nomad-cluster role - role Nomad uses to create tokens for jobs (specifies which policies jobs can request)
	if ! vault list "/auth/token/roles" |& grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster role to Vault..."
		policy="$(policyDownload "https://nomadproject.io/data/vault/nomad-cluster-role.json")" || return
		vault write /auth/token/roles/nomad-cluster @"$policy" || return
	fi

	# nomad-server policy - policy for the token Nomad uses to access Vault
	if ! vault policy list | grep -q "^nomad-server$"; then
		hilight "Adding the nomad-server policy to Vault..."
		policy="$(policyDownload "https://nomadproject.io/data/vault/nomad-server-policy.hcl")" || return
		vault policy write nomad-server "$policy" || return
	fi

	# create token for Nomad to access vault - Nomad will renew the token every 72h
	local token="$(vault token create -display-name nomad-server -policy nomad-server -period 72h -orphan -format=json | jq '.auth.client_token' | RemoveQuotes)" || return

	# create and copy the vault configuration files
	for host in server "${servers[@]}" client "${clients[@]}"; do
		[[ "$host" == @(client|server) ]] && { type="$host"; continue; }

		# certificate configuration
		local certConfig
		if certs; then
			certInit "consul" || return
			certConfig="$(cat <<-EOF

			  ca_file          = "$certDirService/$caLocal"
			  cert_file        = "$certDirService/$certCli"
			  key_file         = "$certDirService/$certCliKey"
				EOF
			)"
			certInit "nomad" || return
		fi

		# configuration	
		local file="$tmpDir/02_vault.hcl"
		cat > "$file" <<-EOF
			vault {
			  enabled          = true
			  address          = "$(productGetAddress vault $(vaultHostGetLocal "$host"))"
			  create_from_role = "nomad-cluster"
			  token            = "$token"$certConfig
			}
			EOF

		if [[ $test ]]; then
			header "$(ProperCase "$product") Configuration ($(GetFileName "$file"))"
			cat "$file" || return
		else
			hostCopy "$file" "$productConfigDir" || return
			productServiceRestart || return
		fi

	done

	# install vault client for nomad jobs
	for host in "${servers[@]}" "${clients[@]}"; do
		productInstall "vault" "$host" || return
	done

	return 0
}

#
# Install Vault Command
#

installVaultCommand() { installVaultDo && certMakeCleanup; }

installVaultDo()
{
	local product="vault"; installCommon || return
	local -A options clientOptions serverOptions guiOptions

	local token; token="$(product="consul" credGetIfExists "token")" || return
	[[ ! $token ]] && { ScriptErr "unable to get a Consul token for Vault integration"; return 1; }

	# certificate configuration
	local certConfig certCliConfig
	if certs; then

		certConfig="$(cat <<-EOF

		  tls_cert_file = "$certDirService/$certServer"
		  tls_key_file = "$certDirService/$certServerKey"
			EOF
		)"

		certCliConfig="$(cat <<-EOF

		  tls_ca_file = "$certDirService/$ca"
		  tls_cert_file = "$certDirService/$certCli"
		  tls_key_file = "$certDirService/$certCliKey"
			EOF
		)"

	fi

	# configuration

	options=(
		[listener]="\"tcp\" $(cat <<-EOF
			{
			  address = "0.0.0.0:$(productGetPort)"$certConfig
			}
			EOF
		)"

		[storage]="\"consul\" $(cat <<-EOF
			{
			  token = "$token"
			  path = "vault/"
			  address = "127.0.0.1:$(productGetPort "consul")"
			  scheme = "$(productGetProtocol)"$certCliConfig
			}
			EOF
		)"

		[service_registration]="\"consul\" $(cat <<-EOF
				{
				  token = "$token"
				  address="127.0.0.1:$(productGetPort "consul")"
				  scheme="$(productGetProtocol)"$certCliConfig
				}
			EOF
		)"
	)

	guiOptions=( [ui]="true" )

	installDo || return
}

installVaultCommon()
{
	# options
	o[api_addr]="https://$hostFqdn:$vaultHttpsPort"

	# service
	execStart="$program server -config=$productConfigDir"
	serviceLimit+=$'\n'"LimitMEMLOCK=infinity"
}

installVaultServer() { ArrayAppend o guiOptions || return; }

installVaultServerFinal()
{
	installVaultAcl || return; 

	# store the initial vault key on the first vault servers local credential manager
	vaultTokenSetRemote || return

	# unseal the vault
	vaultUnsealCommand || return

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | grep -q "^secret"; then
		header "Vault Configuration"
		vault secrets enable -path=secret kv-v2 || return
	fi

	return 0
}

installVaultAcl()
{
	! whatCheck "acl" && return

	header "Install Vault ACL"
	productInit "vault" || return

	# generate the unseal keys
	local n key result s seals; seals="$(vault operator init 2>&1)"; result="$?"
	echo "$seals" | grep -q "Vault is already initialized" && return
	(( result != 0 )) && { EchoErr "$seals"; return 1; }

	# show the seal keys
	hilight "Store the following vault unseal keys in a secure location:"
	echo "$seals"

	# store the root token
	declare token; token="$(echo "$seals" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credSet "token" "$token" || return
	export VAULT_TOKEN="$token"

	# store the seal keys
	IFS=$'\n' seals=( $(echo "$seals" | grep "Unseal Key") )
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credSet "key$n" "$key" || return
	done
}

#
# Remove Command
#

removeUsage() { echot "\
Usage: $(ScriptName) remove all|cli|$productUsage
Remove a HashiCorp product configuration and data.

	-w, --what=C1[,C2...] components to remove: program service
		$configWhat"; }

removeArgStart() { unset what yes; }

removeOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) ScriptOptGet "what" "$@"; StringToArray "${what,,}" "," what;;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

removeOptArgEnd()
{
	[[ ! $what ]] && MissingOption "what"

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

removeCommand() { removeAllCommand; }
removeAllCommand() { removeDo "vault" && removeDo "nomad" && removeDo "consul"; }
removeConsulCommand() { removeDo "consul"; }
removeNomadCommand() { removeDo "nomad"; }
removeVaultCommand() { removeDo "vault"; }

removeDo()
{
	local product="$1"
	whatCheckConfig && { removeConfig "$product" || return; }
	whatCheck "service" && { removeService || return; }
	return 0
}

removeService()
{
	local removeProgram; whatCheck "program" && removeProgram="true"

	local host hosts; getHosts "all" || return
	for host in "${hosts[@]}"; do
		header "Remove $(ProperCase "$product") Service ($host)"
		productServiceRemove "$product" "$host" || return
	done
}

#
# Remove CLI Command
#

removeCliUsage() { echot "\
Usage: $(ScriptName) remove cli all|$productUsage
Remove a HashiCorp program and certificates used for command line access."; }

removeCliCommand() { local product; for product in "${products[@]}"; do removeCli "$product" || return; done; }
removeCliConsulCommand() { removeCli "consul"; }
removeCliNomadCommand() { removeCli "nomad"; }
removeCliVaultCommand() { removeCli "vault"; }

removeCli() 
{ 
	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be removed locally"; return 1; }
	whatCheck "config" && { certInit "$1" && removeDir "$(certDirLocal)"; }
	whatCheck "program" && { $testEcho sudo rm -f "/usr/local/bin/$1" || return; }
	return 0
}

#
# Resolve Command
#

resolveUsage()
{
	echot "Usage: $(ScriptName) resolve SERVICE
Return the first available server for the specified service.

	-a, --all							return all available servers instead of the just the first
	-m, --method=api|dig|dns|list|nslookup
		api					use the API to return available servers as JSON
		dig					use dig to return available servers
		dns					use DNS to return available servers
		nslookup		use nslookup to return available servers
		list				use the API to return a list of available servers"
}

resolveArgStart() { unset -v all method name; }

resolveOpt()
{
	case "$1" in
		-a|--all) all="true";;
		-m|--method|-m=*|--method=*) ScriptOptGet "method" "$@";;
		*) return 1;;
	esac
}

resolveArgs() { ScriptArgGet "name" -- "$@"; shift; }

resolveCommand()
{
	productInit "consul" || return

	case "$method" in
		"") short="true" resolveDns "$name";;
		api) resolveApi "$name";;
		dig) resolveDig "$name";;
		dns) resolveDns "$name";;
		nslookup) resolveNslookup "$name";;
		list) resolveApi "$name" | jq ".[].Node" | RemoveQuotes | sort | uniq;;
		*) ScriptErr "unknown method '$method'"; return 1;;
	esac
}

resolve() { all="" short="true" resolveAddress "$1"; }

resolveApi()
{
	local name="$1"
	log1 "using API to resolve service '$name'"
	local product="consul"; productInit --no-token || return

	RunLog curl --silent --show-error "$(productVarGet "ADDR")/v1/catalog/service/$name"
}

resolveDig()
{
	local name="$1" name+=".service.$domain"

	log1 "using dig to resolve '$name'"
	local server; server="$(getConsulServer)" || return

	# resolve
	[[ ! $short ]] && { RunLog dig "@$server" -p 8600 "$name" SRV; return; }

	# resolve short - only return IP
	local ip; ip="$(RunLog dig "@$server" -p 8600 "$name" A +short)"
	[[ ! $ip ]] && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }
	log1 "dig resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

resolveDns()
{
	local name="$1"
	local filter=(head -1); [[ $all ]] && { filter=(cat); }

	if InPath dig; then
		resolveDig "$name" | "${filter[@]}"
	elif ! IsBusyBox "nslookup"; then
		resolveNslookup "$name" | "${filter[@]}"
	else
		EchoErr "unable to resolve '$name'"
	fi
}

resolveNslookup()
{
	local name="$1"; name+=".service.$domain"

	log1 "using nslookup to resolve '$name'"
	local server; server="$(getConsulServer)" || return

	# resolve
	[[ ! $short ]] && { RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server"; return; }

	# resolve short - only return IP
	local result; result="$(RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server")"
	(( $? != 0 )) && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }

	local ip
	if [[ "$result" =~ .*canonical\ name.* ]]; then
		ip="$(printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//')"
	else
		ip="$(printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace)"
	fi
	
	log1 "nslooklup resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

# getConsulServer - get a consul server that is available for DNS queries on port 8600
getConsulServer()
{
	local server="$(productGetServer "consul")"
	log1 "found consul consul server '$server'"
	[[ ! $server ]] && { [[ ! $quiet ]] && ScriptErr "no consul server found"; return 1; }
	! IsAvailablePort "$server" 8600 && { [[ ! $quiet ]] && ScriptErr "consul server $server port 8600 is not available"; return 1; }
	echo "$server"
}

#
# Update Command
#

updateUsage() { echot "usage: $(ScriptName) program all|$productUsage"; }
updateCommand() { usage; }
updateAllCommand() { updateDo "vault" && updateDo "nomad" && updateDo "consul"; }
updateConsulCommand() { updateDo "consul"; }
updateNomadCommand() { updateDo "nomad"; }
updateVaultCommand() { updateDo "vault"; }

updateDo()
{
	local product="$1" host hosts; getHosts "all" || return
	
	for host in "${hosts[@]}"; do
		header "Update $(ProperCase "$product") ($host)"
		productInstall "$product" "$host" || return
	done
}

#
# Install Helper
#

installCommon()
{
	productServiceVars || return

	# certificates
	certs && useHttps="true"

	# variables
	declare -Ag commonOptions=( [log_level]="Info" )
	tmpDirTemplate="hashi.XXXXXXXXXX"

	# add clients and servers from hostArg
	if [[ $hostArg ]]; then
		local host hosts; StringToArray "$hostArg" "," hosts
		local defaultServers; configGetArray "servers" "defaultServers"
		for host in "${hosts[@]}"; do
				IsInArray "$host" defaultServers && servers+=( "$host" ) || clients+=( "$host" )
		done
		unset hostArg
	fi

	# use default clients and servers if needed
	if [[ ! $clients && ! $servers ]]; then
		if [[ "$product" == "vault" ]]; then
			clients=( )
			configGetArray "VaultServers" servers
		else
			configGetArray "clients"
			configGetArray "servers"
		fi
	fi

	# set join servers	
	[[ ! $join ]] && configGetArray "servers" "join"
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(os name "$h")" ); done

	if [[ $verbose ]]; then
		PrintErr "clients: "; ArrayShow clients
		PrintErr "servers: "; ArrayShow servers
		PrintErr "join: "; ArrayShow join
	fi
	
	return 0
}
	
installDo()
{
	local certDir useHttps tmpDir="$(tmpDirCreate)" || return
	(( verboseLevel > 2 )) && EchoWrap "Using temporary directory $tmpDir"

	installCertMake || return
	installProgram || return
	installServiceServers || return
	installCertLocal || return
	installServerFinal || return
	installServiceClients || return
	installFinal || return
	installCertPublic || return

	# cleanup
	unset servers clients; hostArg="$hostArgOrig"
	rm -fr "$tmpDir"
}

installCerts() { certs && whatCheck "cert"; }
installCertLocal() { header "Install Local Certificates"; ! installCerts && return; productInstallCerts "$product"; }
installCertMake() { header "Create Certificates"; ! certs && return; certMake "$product"; }
installCertPublic() { header "Copy Public Certificates"; ! installCerts && return; certCopyPublic "$product"; }
installFinal() { RunFunction "install" "${product}Final" || return; }
installServerFinal() { RunFunction "install" "${product}ServerFinal"; }

installAcl()
{
	! whatCheck "acl" && return

	header "Install $(ProperCase "$product") ACL"
	productInit || return

	# generate the bootstrap token
	local header text
	local alreadyCreated="ACL bootstrap already done"; [[ "$product" == "consul" ]] && alreadyCreated="ACL bootstrap no longer allowed"
	local waitingForNodes="The ACL system is currently in legacy mode."
	
	# try up to 30 times to get the bootstrap text
	for (( i = 0; i < 30; i++ )); do
		text="$($product acl bootstrap 2>&1)" && break
		echo "$text" | grep -q "$alreadyCreated" && return
		echo "$text" | grep -q "$waitingForNodes" &&
			{ [[ $header ]] && printf "." || printf "bootstrap..."; header="true"; sleep 1; continue; }
		EchoErr "$text"; return 1
	done
	[[ $header ]] && echo
	echo "$text" | grep -q "$waitingForNodes" && { EchoErr "$text"; return 1; }
	
	# show the full bootstrap text
	hilight "Store the following bootstrap token in a secure location:"
	echo "$text"

	# get and store the token
	local secretId="Secret ID"; [[ "$product" == "consul" ]] && secretId="SecretID"
	local sep="="; [[ "$product" == "consul" ]] && sep=":"
	local token="$(echo "$text" | grep "$secretId" | cut -d$sep -f 2 | RemoveSpace)"
	[[ ! $token ]] && { ScriptErr "unable to determine the bootstrap token"; return 1; }
	credSet "token" "$token" || return

	productVarSet "TOKEN" "$token" || return
	log1 "updated environment variable $(productVar "TOKEN") to $(productVarGet "TOKEN")..."

	return 0
}

installProgram()
{
	! whatCheck "program" && return

	for host in localhost "${servers[@]}" "${clients[@]}"; do
		productInstall "$product" "$host" || return
	done
}

# installProductConfig - turn the passed array variables into an HCL script
installProductConfig()
{
	local key var

	for var in "$@"; do
		local -n config="$var"

		for key in "${!config[@]}"; do

			local equal=" =" quote="true" v="${config[$key]}"
			local fc="${v:0:1}" sc="${v:1:1}" # first and second characters

			# example: addresses { https = "0.0.0.0" }
			[[ "$fc" == "{" && "$sc" != "{" ]] && quote="" equal=""

			# example: retry_join = [ "pi3", "pi4" ]
			[[ "$fc" == "[" ]] && quote=""

			# listener "tcp" { address = "0.0.0.0:8200", tls_disable = 1 }
			[[ "$fc" == "\"" ]] && quote="" equal=""

			# boolean, example: server = true			
			[[ "$v" == @(true|false) ]] && quote=""

			# integer, example: bootstrap_expect = 2
			IsInteger "$v" && quote=""

			[[ $quote ]] && echo "$key$equal \"${config[$key]}\"" || echo "$key$equal ${config[$key]}"

		done

	done
}

installService()
{
	local type="$1" host="$2"; productServiceVars || return
	local f hostFqdn scriptFinal
	local -A o
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local serviceLimit="LimitNOFILE=infinity"$'\n'"LimitNPROC=infinity"
	local execStart="$program agent -config=$productConfigDir"
	local execReload="/bin/kill --signal HUP \$MAINPID"
	local exectStop=""
	local serviceKillSignal="SIGINT"

	# host information
	hostFqdn="$(os name "$host")" || return
	host="$(RemoveDnsSuffix "$hostFqdn")"

	# header
	header "Install $(ProperCase "$product") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	DelDir --contents "$tmpDir" || return
	${G}mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return		

	# copy certificates
	certs && { FileCommand cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$tmpDir/cert" || return; }

	# service
	printf "" > "$tmpDir/$product.env"

	# options - other options added in installPRODUCTServer or installPRODUCTClient
	o=( ); ArrayAppend o commonOptions options || return

	certs && IsDeclared commonEncryptOptions && { ArrayAppend o "commonEncryptOptions" || return; }
	certs && IsDeclared ${type}EncryptOptions && { ArrayAppend o "${type}EncryptOptions" || return; }

	RunFunction "install" "${product}Common"
	RunFunction "install" "${product}$(ProperCase "$type")" || return

	# create the configuration files
	installProductConfig o > "$tmpDir/config/$productConfigFileBase" || return
	installServiceConfig > "$tmpDir/$product.service" || return

	# copy the files to the remote host
	if ! IsLocalHost "$host"; then
		hilight "Copying files to $host..."
		scp -r "$tmpDir" "$host:/$tmpDir" || return
	fi

	# run the installation script - do notuse only standard commands
	hilight "Running installation..."
	scriptRun "$(cat <<-EOF

		# user
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudo useradd --system --home-dir "$productConfigDir" --shell "/bin/false" "$user" || exit
		fi

		# directories
		if ! [[ -d "$certDirService" && -d "$productConfigDir" && -d "$productDataDir" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudo install -o "$user" -g "$user" -m 755 -d "$certDirService" "$productConfigDir" "$productDataDir" || exit
		fi

		# files

		if [[ \$(sudo ls -A "$tmpDir/data") ]] && [[ ! \$(sudo ls -A "$productDataDir") || "$force" ]]; then
		  echo "Copying data files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$productDataDir" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/config") ]] && [[ ! -f "$productConfigDir/$productConfigFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$productConfigDir" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/cert") ]] && [[ ! \$(sudo ls -A "$certDirService") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$certDirService" "$tmpDir/cert/"* || exit
		fi

		if [[ -f "$certDirService/$ca" ]] && [[ ! -f "$certStoreCa" || "$force" ]]; then
			echo "Installing CA certificate..."
			sudo cp "$certDirService/$ca" "$certStoreCa" || exit
			sudo update-ca-certificates || exit
		fi

		if [[ "$caAuto" && -f "$certDirService/$caAuto" ]] && [[ ! -f "$certStoreCaAuto" || "$force" ]]; then
			echo "Installing automatic CA certificate..."
			sudo cp "$certDirService/$caAuto" "$certStoreCaAuto" || exit
			sudo update-ca-certificates || exit
		fi

		# service		

		if [[ -f "$productServiceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudo systemctl stop "$product" || exit
		fi

		if [[ ! -f "$productServiceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudo cp "$tmpDir/$product.service" "$tmpDir/$product.env" "/etc/systemd/system" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl enable "$product" || exit
			sudo systemctl start "$product" --no-block || exit
		fi

		$scriptFinal

		# cleanup
		printf "Cleaning up..."; rm -fr "$tmpDir"; echo done

		exit 0

		EOF
	)" || return

	if [[ $test ]] || (( verboseLevel > 1 )); then

		header "$(ProperCase "$product") Configuration ($(GetFileName "$productConfigFileBase"))"
		cat "$tmpDir/config/$productConfigFileBase" || return

		header "Service Configuration ($product.service)"
		cat "$tmpDir/$product.service" || return

		header "Service Environment ($product.env)"
		cat "$tmpDir/$product.env" || return

	fi

	return 0
}

installServiceClients()
{
	! whatCheck "service" && return

	for host in "${clients[@]}"; do
		installService "client" "$host" || return
	done
}

installServiceConfig()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$product")
		Documentation=https://www.hashicorp.com/products/$product
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$productConfigFile
		StartLimitIntervalSec=10
		StartLimitBurst=3

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$productServiceEnvFile
		KillMode=process
		KillSignal=$serviceKillSignal
		Restart=on-failure
		RestartSec=2
		TasksMax=infinity
		$serviceLimit

		[Install]
		WantedBy=multi-user.target
	EOF
}

installServiceServers()
{
	! whatCheck "service" && return

	for host in "${servers[@]}"; do
		installService "server" "$host" || return
	done
}

#
# All Commands
#

allUsage() { echot "\
Usage: $(ScriptName) all environment|status
Commands for all products."; }

allCommand() { usage; }

allEnvironmentCommand() { configEnvironmentAll; }

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# Config Commands
#

configUsage() { echot "\
Usage: $(ScriptName) config [deploy|get|remove|set|show](show)
Configure products.

	get VAR			get configuration variable
	remove			remove all local and remote configuration
	set 				set configuration
	environment	set environment variables"; }

configCommand() { usage; }

# Config Deploy Command

configDeployUsage() { echot "\
Usage: $(ScriptName) config deploy $productUsage FILE
Deploy a configuration file."; }

configDeployArgStart() { unset file; }
configDeployArgs() { ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift; }

configDeployCommand() { usage; }
configDeployConsulCommand() { configDeploy "consul" "$file"; }
configDeployNomadCommand() { configDeploy "nomad" "$file"; }
configDeployVaultCommand() { configDeploy "vault" "$file"; }

configDeploy()
{
	local product="$1" file="$2"; productServiceVars || return

	# copy the vault configuration files
	local host hosts; getHosts || return
	for host in "${hosts[@]}"; do
		header "Config Deploy $(GetFileName "$file") ($host)"
		hostCopy "$file" "$productConfigDir" || return
		productServiceRestart || return
	done

}

# Config Environment Commands

configEnvironmentUsage() { echot "\
Usage: $(ScriptName) config environment [all|$productUsage|test|reset](all)
Show the product environment variables.  This command is typically called 
with ScriptEval to update current environment.

	-se, --suppress-errors			supress certificate not found errors"; }

configEnvironmentArgStart() { unset -v suppressErrors; }

configEnvironmentOpt()
{
	case "$1" in
		-se|--suppress-errors) suppressErrors="true";;
		*) return 1;;
	esac
}

configEnvironmentCommand() { configEnvironmentAll; }
configEnvironmentAllCommand() { configEnvironmentAll; }
configEnvironmentResetCommand() { echo "unset CONSUL_HTTP_TOKEN VAULT_TOKEN NOMAD_TOKEN"; }

configEnvironmentConsulCommand() { productEnvironment "consul"; }
configEnvironmentNomadCommand() { productEnvironment "nomad"; }
configEnvironmentVaultCommand() { productEnvironment "vault"; }

# environment aliases commands
configEnvironmentProdCommand() { configPrefix="" configEnvironmentCommand; }
configEnvironmentTestCommand() { configPrefix="test" configEnvironmentCommand; }

configEnvironmentAll()
{
	# initialize consul for product lookups
	productIsInstalled "consul" && { productInit "consul" || return; }

	local product
	for product in "${products[@]}"; do		
		! productIsInstalled && continue
		productEnvironment || return; echo
	done
}

# Config Get Command

configGetUsage() { echot "\
Usage: $(ScriptName) config get VAR
Get a configuration variable."; }

configGetArgStart() { unset varName; }
configGetArgs() { ScriptArgGet "varName" "var" -- "$@"; shift; }
configGetCommand() { configGet "$varName"; }

# configExists VAR
configExists() { [[ $(configGet "$var") ]]; }

# configGet VAR
configGet()
{
	local var="hashi$(UpperCaseFirst "$configPrefix")$(UpperCaseFirst "$1")"
	ConfigInit "$configFile" && ConfigExists "$var" && ConfigGet "$var"
}

# configGetArray VAR [ARRAY_NAME](VAR)
configGetArray()
{
	local var="$1" 
	local arrayName="${2:-$var}"
	StringToArray "$(configGet "$var")" "," "$arrayName"
}

# configGetList VAR
configGetList()
{
	local var="$1" a
	StringToArray "$(configGet "$var")" "," "a"
}

# configServer - return the first server for the current product
configServer()
{
	local var="servers"; [[ "$product" == "vault" ]] && var="VaultServers"
	configGet "$var" | GetWord - "1" ","
}

# configServers - return a comma separated list of all of the servers in the configuration
configServers()
{
	local server; configGetArray "servers"
	local client; configGetArray "clients"
	local vaultServers; configGetArray "VaultServers" "vaultServers"
	local hosts=(); ArrayAppend --remove-dups hosts servers clients vaultServers
	ArrayDelimit hosts	
}

# Config Remove Commands

configRemoveUsage() { echot "\
Usage: $(ScriptName) config remove all|$productUsage
Delete configuration.

	-w, --what=C1[,C2...] configuration to remove: $configWhat"; }

configRemoveArgStart() { unset what yes; }

configRemoveOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) ScriptOptGet "what" "$@"; StringToArray "${what,,}" "," what;;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

configRemoveOptArgEnd()
{
	[[ ! $what ]] && MissingOption "what"

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' configuration from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

configRemoveCommand() { usage; }
configRemoveAllCommand() { removeConfig "vault" && removeConfig "nomad" && removeConfig "consul"; }
configRemoveConsulCommand() { removeConfig "consul"; }
configRemoveNomadCommand() { removeConfig "nomad"; }
configRemoveVaultCommand() { removeConfig "vault"; }

removeConfig()
{
	local product="${1:-$product}"; certInit || return; ConfigInit || return

	if [[ ! $force || ! $yes ]]; then
		ScriptErr "To permanently deletes all local and remote configuration and certificates for $baseDomain $configDesc, --force and --yes are required"
		return 1
	fi

	header "Remove $(ProperCase "$product") Configuration"

	# Vault data
	if [[ "$product" == "vault" ]] && whatCheck "consul-vault-data" && quiet="--quiet" productInit "consul"; then
		hilight "Removing Vault data from Consul..."
		$testEcho consul kv delete -recurse "vault/"
	fi

	# certificates (local, private, and public)	
	if [[ "$product" != "vault" ]]; then # Vault uses Consul certificates
		local dir
		whatCheck "local-certs" && { hilight "Removing local certificates..."; removeLocalCerts || return; }
		whatCheck "private-certs" && { hilight "Removing private credentials..."; dir="$(certDirMountPrivate)" || return; removeDir "$dir" && certDirUnmountPrivate; }
		whatCheck "public-certs" && { hilight "Removing public credentials..."; dir="$(certDirPublic)" || return; removeDir "$dir"; }
	fi

	# credentials (local)
	whatCheck "local-credentials" && { hilight "Removing local credentials..."; credDelete "all" || return; }

	# delete host certificates
	local host hosts; getHosts "all" || return
	for host in "${hosts[@]}"; do
		hilight "Removing $host certificates and credentials..."
		ssh -q -t "$host" bash -i "credential delete \"$(credPath)\" all $verbose && rm -fr \"$(certDirSuffix "/opt/hashi")\"" || return
	done

	return 0
}

removeLocalCerts()
{
	local product="${1:-$product}"; certInit || return

	removeDir "$(certDirLocal)" || return

	if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
		$testEcho sudoc rm -f "$certStoreCa" "$certStoreCaAuto" || return
		$testEcho sudo update-ca-certificates || return
	fi

	return 0
}


# config set command

configSetUsage() { echot "\
Usage: $(ScriptName) config local|remote
Set configuration.

	local			set the local configuration in the local credential store
	remote		set the remote configuration in Vault"; }

configSetCommand() { usage; }

# config set local command

configSetLocalUsage()
{
	echot "\
Usage: $(ScriptName) config set local [all|$productUsage](all)
Set the local configuration in the local credential store."
}

configSetLocalCommand() { configSetLocalAllCommand; }

configSetLocalAllCommand() { configSetLocalConsulCommand && configSetLocalNomadCommand && configSetLocalVaultCommand; }
configSetLocalConsulCommand() { configSetLocal "consul"; }
configSetLocalNomadCommand() { configSetLocal "nomad"; }
configSetLocalVaultCommand() { configSetLocal "vault"; }

configSetLocal()
{	
	local p="${1:-$product}" product="vault";	productInit || return; credManagerCheck "local" || return

	# ensure we have a Vault token
	vaultTokenSetLocal || return	

	# copy the product configuration from Vault to the local credential store
	configMirror "vault" "local" "$p" || return
}

# config set remote command

configSetRemoteUsage()
{
	echot "\
Usage: $(ScriptName) config set remote [all|$productUsage](all)
Set the remote configuration in Vault."
}

configSetRemoteCommand() { configSetRemoteAllCommand; }

configSetRemoteAllCommand() { configSetRemoteConsulCommand && configSetRemoteNomadCommand && configSetRemoteVaultCommand; }
configSetRemoteConsulCommand() { configSetRemote "consul"; }
configSetRemoteNomadCommand() { configSetRemote "nomad"; }
configSetRemoteVaultCommand() { configSetRemote "vault" && vaultTokenSetRemote; }

configSetRemote()
{
	local p="${1:-$product}" product="vault"; productInit || return; credManagerCheck "local" "vault" || return
	configMirror "local" "vault" "$p" || return
}

# config helper

configMirror()
{
	local from="$1" to="$2" product="${3:-$product}"
	[[ ! $force ]] && credential exists "$(credPath)" token --manager="$to" && return
	hilight "Mirroring ${product^} credentials to ${to^}..."
	credential mirror --from="$from" --to="$to" "$(credPath)" --force $verbose || return
}

#
# Consul Command
#

consulUsage() { echot "\
Usage: $(ScriptName) consul acl|backup|environment|restore|service|status
Consul commands."; }

consulCommand() { usage; }
consulBackupCommand() { consul snapshot save "$(GetDateStampNext "consul.$domain" "snap")"; }
consulEnvironmentCommand() { productEnvironment "$product"; }
consulStatusCommand() { consul members; }

# Consul ACL Command

consulAclUsage() { echot "\
Usage: $(ScriptName) consul acl create
Consul ACL commands."; }

consulAclCommand() { usage; }

# Consul ACL Create Command

consulAclCreateUsage() { echot "\
Usage: $(ScriptName) consul acl create [NAME] [DEFINITION]
Create a Consul ACL."; }

consulAclCreateArgStart() { unset name def; }

consulAclCreateArgs()
{
	ScriptArgGet "name" -- "$@"; shift
	ScriptArgGet "def" -- "$@"; shift
}

consulAclCreateCommand() { consulAclCreate "$name" "$def"; }

# Consul ACL Token Command

consulAclTokenUsage() { echot "\
Usage: $(ScriptName) consul acl token [get|delete] [NAME]
Manage Consul ACL tokens."; }

consulAclTokenArgStart() { unset name; }
consulAclTokenArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclTokenCommand() { consulAclTokenGetCommand; }
consulAclTokenGetCommand() { consulAclTokenGet "$name"; }
consulAclTokenDeleteCommand() { consulAclTokenGet "$name"; }

# Consul ACL Helper

# consulAclCreate NAME DEF - create an ACL with the specified name and definition.   Return a token for the policy.
consulAclCreate()
{
	local name="$1" def="$2"
	consulAclPolicyCreate "$name" "$def" || return
	consulAclTokenCreate "$name" || return
}

# consulAclPolicyExists NAME - return true if the specified policy exists
consulAclPolicyExists()
{
	local name="$1"
	[[ "$(consul acl policy list -format=json | jq ".[] | select(.Name == \"$1\").Name" | RemoveQuotes)" == "$name" ]]
}

# consulAclPolicyCreate NAME DEF - create a policy with the specified name and definition
consulAclPolicyCreate()
{
	local name="$1" def="$2"
	[[ ! $force ]] && consulAclPolicyExists "$name" && return
	consulAclPolicyDelete "$name" || return

	hilight "Creatning ACL policy $name..."
	[[ $test ]] && { printf "${GREEN}create policy $name:${RESET}\n%s\n" "$(cat)"; return; }
	echo "$def" | consul acl policy create -name "$name" -rules -
}

# consulAclPolicyDelete NAME - delete the specified policy
consulAclPolicyDelete()
{
	local name="$1"
	! consulAclPolicyExists "$name" && return

	hilight "Deleting ACL policy $name..."
	[[ $test ]] && { hilight "delete policy $name"; return; }
	consul acl policy delete -name "$name"
}

# consulAclTokenGet DESC - get the token Secret ID with the specified description
consulAclTokenGet()
{
	local desc="$1"
	! consulAclTokenExists "$1" && { ScriptErr "token '$desc' does not exists"; return 1; }
	consul acl token read -id "$(consulAclTokenId "$desc")" | grep "SecretID" | cut -d: -f 2 | RemoveSpace
}

# cosulTokenExists NAME - return true if the tokenexists
consulAclTokenExists()
{
	local name="$1"
	[[ "$(consul acl token list -format=json | jq ".[] | select(.Description == \"$name\").Description" | RemoveQuotes)" == "$desc" ]]
}

# consulAclTokenId NAME - get the token ID
consulAclTokenId()
{
	local name="$1"
	consul acl token list -format=json | jq ".[] | select(.Description == \"$name\").AccessorID" | RemoveQuotes
}

# consulAclTokenCreate DESC POLICY - create a token with the specified description that has the permission to the specified policy
consulAclTokenCreate()
{
	local desc="$1" policy="${2:-$1}"
	[[ ! $force ]] && consulAclTokenExists "$desc" && return	
	consulAclTokenDelete "$desc" || return

	hilight "Creating ACL token $desc for policy $policy..."
	[[ $test ]] && { hilight "create token $desc for policy $policy"; return; }
	consul acl token create -description "$1" -policy-name "$policy"
}

# consulAclTokenDelete DESC - delete the token with the specified description
consulAclTokenDelete()
{
	local desc="$1"
	! consulAclTokenExists "$desc" && return

	hilight "Deleting ACL token $desc..."
	[[ $test ]] && { hilight "delete token $desc"; return; }
	consul acl token delete -id "$(consulAclTokenId "$desc")"
}

#
# Consul Service
#

consulServiceInit() { unset file; }

consulServiceUsage() { echot "\
Usage: $(ScriptName) consul service register|deregister FILE
Consul service commands."; }

consulServiceArgs() { ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift; }

consulServiceCommand() { usage; }

consulServiceRegisterCommand()
{
	# get the service ID
	local id type; type="$(validateConfigFile "$file")" || return
	if [[ "$type" == "json" ]]; then
		id="$(cat "$file" | jq ".service.name" | RemoveQuotes)"
	else
		id="$(cat "$file" | grep "name =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
	fi
	[[ ! $id ]] && { ScriptErr "Unable to determine the service id in '$file'"; return 1; }

	# create the service ACL policy
	local name="service-$id"
	local policy="$(cat <<-EOF
		service "$id" {
		  policy = "write"
		}
		EOF
	)"	
	consulAclCreate "$name" "$policy" || return

	# register the service
	local token="$(consulAclTokenGet "$name")" || return
	local f; f="$(${G}mktemp -t "hashi.service.XXXX.hcl")" || return
	if [[ "$type" == "json" ]]; then
		cat "$file" | sed "s/\"token\": \".*\"/\"token\" = \"$token\"/" > "$f" || return
	else
		cat "$file" | sed "s/token = \".*\"/token = \"$token\"/" > "$f" || return
	fi
	[[ $test ]] && { cat "$f"; return; }
	consul services register "$f" || return

	# cleanup
	rm -f "$f"	

	return 0
}


# -id|FILE
consulServiceDeregisterCommand() { consul services deregister "$file"; }

#
# Nomad Commands
#

nomadUsage() { echot "\
Usage: $(ScriptName) nomad environment|job|status
Nomad commands."; }

nomadCommand() { usage; }
nomadEnvironmentCommand() { productEnvironment "$product"; }
nomadStatusCommand() { nomad node status; }

#
# Nomad Job Commands
#

nomadJobUsage() { echot "\
Usage: $(ScriptName) nomad job NAME
Nomad job commands.

	force	NAME		force a periodic job to start
	log	NAME			show the log for a periodic job
	run NAME			run or update a job
	status [NAME]	status of all running jobs or the specified job"; }

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() { nomadJobStatusCommand; }

# nomad job run
nomadJobRunCommand()
{
	[[ -f "$CLOUD/network/system/hashi/job/$job.hcl" ]] && job="$CLOUD/network/system/hashi/job/$job.hcl"
	ScriptCheckFile "$job" || return
	nomad run "$job" "${otherArgs[@]}" || return
}

# nomad job status 
nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | grep -v dead
	fi
}

# nomnd job force

nomadJobForceUsage() { echot "\
Usage: $(ScriptName) nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"; }

nomadJobForceArgStart() { log=""; }

nomadJobForceOpt() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogUsage() { echot "\
Usage: $(ScriptName) nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"; }

nomadJobLogArgStart() { follow=""; }

nomadJobLogOpt() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId" "${otherArgs[@]}"
		header "Standard Error"; nomad alloc logs -stderr "$allocId" "${otherArgs[@]}"
	fi		
}

# nomad helper

nomadGetJobId()
{ 
	jobId="$(nomad job status "$job" |& tail -1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job '$job'"; exit 1
}

nomadGetAllocId()
{
	[[ ! $jobId ]] && { nomadGetJobId || return; }
	allocId="$(nomad job status "$jobId" |& tail -1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job '$job'"; exit 1
}

#
# Vault Commands
#

vaultUsage() { echot "\
Usage: $(ScriptName) vault environment|status|token|unseal
Vault commands.

	unseal			unseal the vault using keys from the credential store"; }

vaultCommand() { usage; }
vaultEnvironmentCommand() { productEnvironment "$product"; }

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	echo "Active Node            $(resolve active.vault)"
	echo "Standby Node           $(resolve standby.vault)"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac

}

vaultSealCommand()
{
	local active="$(resolve active.vault)"
	local standby="$(resolve standby.vault)"
	
	header "Vault Seal"
	vaultSeal "$active" && vaultSeal "$standby"
}

vaultSeal()
{
	local host="$1"

	[[ ! $host ]] && return
	echo "Sealing Vault host $host..."
	productInit "vault" "$host" || return
	$testEcho vault operator seal || return
}

vaultTokenCommand()
{
	for accessor in $(vault list auth/token/accessors | tail +3); do
		header "$accessor"
		vault token lookup -accessor "$accessor"
	done
}

vaultUnsealCommand()
{
	local host hosts key; vaultHostsGet || return

	for host in "${hosts[@]}"; do
		header "Vault Unseal ($host)"
		productInit "vault" "$host" || return

		vaultIsUnsealed && { echo "Vault on $host is already unsealed"; continue; }

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credGet "key$n")" || return
			$testEcho vault operator unseal "$key" || return
		done

	done
}

# vaultHostsGetLocal - return the first Vault host, or 127.0.0.1 if Vault is running locally
vaultHostGetLocal()
{
	local localHost="$1" host hosts; getHosts "VaultServers" || return	

	for host in "${hosts[@]}"; do
		[[ "${host,,}" == "${localHost,,}" ]] && { echo "127.0.0.1"; return; }
	done

	DnsResolve "${hosts[0]}" || echo "${hosts[0]}"
}

# vaultHostsGet - set the hosts array to all the Vault hosts
vaultHostsGet()
{
	local json

	# get the hosts from Consul if possible
	if productIsInstalled "consul" && json="$(resolveApi "vault")"; then
		IFS=$'\n' hosts=( $( echo "$json" | jq -r '.[].ServiceAddress') )
	fi
	
	# get the hosts from configuration 
	[[ ! $hosts ]] && { getHosts "VaultServers" || return; }

	# no hosts found
	[[ "${#hosts[@]}" == "0" ]] && { ScriptErr "no Vault hosts found"; return 1; }

	return 0
}

vaultIsUnsealed() { vault status | grep -q '^Sealed[ ]*false$'; }

# vaultTokenSetRemote - set the Vault token in the remote credential store 
vaultTokenSetRemote()
{	
	local product="vault"
	local token="$(productVarGet "token")"; [[ ! $token ]] && { ScriptErr "unable to get the Vault token from the environment"; return 1; }
	local server="$(configServer)"; [[ ! $server ]] && { ScriptErr "unable to get the Vault configuration server"; return 1; }
	local serverToken="$(ssh -q -t "$server" bash -i credential gets "$(credPath)" token $verbose)"

	[[ ! $force && "$token" == "$serverToken" ]] && return

	ssh -q -t "$server" bash -i credential set "$(credPath)" token "$token" $verbose
}

# vaultTokenSetLocal - set the Vault token in the local credential store.  
vaultTokenSetLocal()
{
	local product="vault"

	[[ $VAULT_TOKEN && ! $force && "$(credGets "token" --quiet)" == "$VAULT_TOKEN" ]] && return

	local host="$(configServer)"; IsLocalHost "$host" && return

	echo "Getting the Vault token from $host..."

	local token; token="$(ssh -4 -q -t "$host" bash -i credential get "$(credPath)" token $verbose)"
	if [[ ! $token ]]; then
		ScriptErr "The Vault token does not exist in the local credential manager on $(configServer) at path $(credPath)"
		return 1
	fi

	echo "Updating the Vault token in the local credential store..."
	export VAULT_TOKEN="$token"
	credSet "token" "$token" || return
}

#
# Certificate Helper
#

# locations:
# - certDirLocal() - certificate directory for command line clients (i.e. /opt/hashi/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT or /opt/PRODUCT/cert)
# - certDirPublic() - public certificate directory on the installation share
# - certDirPrivate() - the root private certificate directory from the --encrypt option or certificateDir configuration
# - certDirService() - certificate directory for services (i.e. /opt/PRODUCT/cert/)
# - certDirMountPrivate() - mount the root private certificate directory and return it
# - certDirUnmountPrivate() - unmount the private certificate directory
#
# usages:
# - certMake - makes certificates, creates the private certificate directory
# - certCopyPublic - copies public certificates from the private certificate directory to the public certificate directory
# - productEnvironment - sets product environment variables for local or service certificates by calling certDirLocal()
# - productInstallCerts - copies certificates locally for command line use, creates certDirLocal

# certs - true if certificates are being used
certs() { [[ $encrypt ]]; }

# certInit - initialize certificate variables for the specified product
certInit()
{
	local product="$(certProduct ${1:-$product})"

	(( verboseLevel > 1 )) && EchoErr "Initializing $product certificates..."

	# certificates
	ca="$product-ca.pem"
	caLocal="$ca" # CA to use for access to the local server
	caKey="$product-ca-key.pem"	
	certCli=$product-cli.pem
	certCliKey=$product-cli-key.pem
	certClient=$product-client.pem
	certClientKey=$product-client-key.pem
	certServer=$product-server.pem
	certServerKey=$product-server-key.pem

	# other variables
	certDirService="$(certDirService)"
	certDirStore="/usr/local/share/ca-certificates"
	certStoreCa="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$ca").crt"

	# consul clients use an automatic CA
	unset caAuto certStoreCaAuto	
	if [[ "$product" == "consul" ]]; then
		caAuto="$product-ca-auto.pem"
		certStoreCaAuto="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$caAuto").crt"
		[[ "$type" == "client" ]] && caLocal="$caAuto"
	fi

	return 0
}

certDirLocal()
{
	local dir="$(certDirSuffix "/opt/hashi")"

	if [[ -d "$dir" ]]; then echo "$dir"
	elif [[ -d "$(certDirService)" ]]; then echo "$(certDirService)"
	else return 1;
	fi
}

# certDirMountPrivate - mount the private certificate directory
certDirMountPrivate()
{
	local device="$(configGet "CertificateDevice")"
	local dir="$(configGet "CertificateDir")"

	# mount the device
	if [[ $device ]]; then
		case "$(GetFileExtension "$device")" in
			hc) certDirVolume="$(VeraCrypt mount "$device" p --dir "$dir")";;
			*) ScriptErr "unable to mount certificate device '$device'"; return 1;;
		esac
	fi

	# validate the private certificate directory and set certDir
	certDirValidate "$(certDirPrivate)" && certDirPrivate | certDirSuffix
}

certDirPrivate()
{	
	if [[ -d "$encrypt" ]]; then echo "$encrypt"
	elif [[ -d "$certDirVolume" ]]; then echo "$certDirVolume"
	elif [[ ! $(configGet "certificateDevice") && $(configGet "certificateDir") ]]; then configGet "certificateDir"
	else return 1;
	fi 
}

certDirPublic()
{ 
	findInstallFile --quiet "other/HashiCorp" | certDirSuffix && return "${PIPESTATUS[0]}"
	[[ ! $quiet ]] && ScriptErr "unable to locate the public certificate directory"
	return 1
}

certDirService()
{
	local product="${1:-$product}"
	echo "/opt/$(certProduct "$product")/cert"
}

# certDirSuffix DIR - add certificate suffix to DIR: DIR/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT
certDirSuffix()
{ 
	GetArgs; [[ ! $1 ]] && return 1
	echo "$(RemoveTrailingSlash "$1")/certificate/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$(certProduct "$product")"
}

certDirUnmountPrivate()
{
	[[ ! $certDirVolume ]] && return
	unset -v certDirVolume
	VeraCrypt unmount p
}

certDirValidate()
{
	[[ ! $1 ]] && { MissingOperand "encrypt"; return 1; }
	[[ ! -d "$1" ]] && { EchoErr "Certificate directory '$1' does not exist"; return 1; }
	return 0
}

# certExists DIR FILES - return 0 if all certificate files exist in the certificate directory
certExists()
{ 
	local file dir="$1"; shift

	for file in "$@"; do
		[[ ! -f "$dir/$file" ]] && return 1
	done

	return 0
}

# certProduct - Vault uses consul certificates
certProduct() { [[ "$1" == "vault" ]] && echo "consul" || echo "$1"; }

certPublicExists() { quiet="true" certPublicFind > /dev/null; }

# certPublicFind - find public certificates
certPublicFind()
{
	local product="${1:-$product}"; certInit || return

	local dir="$(certDirPrivate | certDirSuffix)"
	[[ ! -d "$dir" ]] && { dir="$(certDirPublic)" || return; }
	certValidate "$dir" "$ca" "$certCli" "$certCliKey" || return
	echo "$dir"
}

certStoreInstall()
{
	local src="$1" dest="$2"

	[[ ! -d "$(GetFilePath "$dest")" ]] && return
	[[ -f "$dest" && ! $force ]] && return

	hilight "Installing $(FileToDesc "$src") in the certificate store..."
	sudo cp "$src" "$dest" || return
	sudo update-ca-certificates || return
}

certStoreMacInstall()
{
	! IsPlatform mac && return
	sudoc security add-trusted-cert -d -r trustRoot -k "/Library/Keychains/System.keychain" "$1"
}

certStoreWinInstall()
{
	local src="$1"

	! IsPlatform win && return
	
	hilight "Installing $(FileToDesc "$src") in the Windows certificate store..."
	local file="$(PlatformTmp)/$(GetFileName "$src")"
	cp "$src" "$file" || return
	RunScript --elevate "$verbose" -- certutil.exe -addstore root "$(utw "$file")" || return
	rm "$file" || return
}

# certValidate DIR FILES - show an error if a certificate does not exist in the certificate directory
certValidate()
{
	local file dir="$1"; shift

	for file in "$@"; do 
		if [[ ! -f "$dir/$file" ]]; then
			[[ ! $quiet ]] && EchoErr "$(ProperCase "$product") certificate $file does not exist in '$(FileToDesc "$dir")'"
			return 1
		fi
	done

	return 0
}

#
# Credential Helper
#

credPath()
{
	local path="$(configGet "credentialPath")" product="${1:-$product}"

	if [[ "$path" ]]; then
		echo "$(RemoveTrailingSlash "$path")/$product"
	else
		echo "/hashi/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
	fi
}

credDelete() { $testEcho credential delete "$(credPath)" "$@" $verbose; }
credExists() { credential exists "$(credPath)" "$@" $verbose; }
credGet() { credential get "$(credPath)" "$@" $verbose; }
credGets() { credential gets "$(credPath)" "$@" $verbose; }
credGetIfExists() { credExists "$@" --quiet && credGet "$@" --quiet; }

# credSet KEY VALUE
credSet()
{
	log1 "Setting $(credPath) $1 credential to $2..."
	$testEcho credential set "$(credPath)" "$@" $verbose || return
}

# credManagerCheck MANAGER...  - check if the credential managers are available
credManagerCheck()
{
	local manager

	for manager in "$@"; do
		log1 "checking the '$manager' credential manager..."
		credential --manager="$manager" check $verbose && continue
		EchoErr "The '$manager' credential manager is not available"
		return 1
	done
}

#
# Host Helper
#

hostCheck()
{
	local host="$1"
	[[ ! $host ]] && MissingOperand "host"
	! IsAvailable "$host" && { EchoErr "$host is not available"; return 1; }
	return 0
}

hostCleanup()
{
	local host="$1"; hostCheck "$host" || return 0

	scriptRun "$(cat <<-EOF
			printf "cleaning..."
			[[ \$(find "$TEMP" -maxdepth 1 -name "hashi.*") ]] && printf "." && sudo rm -fr "$TEMP/hashi."*
			[[ -d "$TEMP/consul-test" ]] && printf "." && rmdir "$TEMP/consul-test"
			printf "." && rm -f "$TEMP/hashi.service."*
			echo "done"
			EOF
	)"
}

# hostCopy "FILE" "DEST" - copy file to the host destination directory withthe correct permissions
hostCopy()
{
	local file="$1" dest="$2"
	local name="$(GetFileName "$file")"

	hilight "Copying files to $host..."
	scp "$file" "$host:/tmp" || return

	scriptRun "$(cat <<-EOF
		sudo mv "/tmp/$name" "$dest" || exit
		sudo chmod 755 "$dest/$name" || exit
		sudo chown "$user" "$dest/$name" || exit
		sudo chgrp "$user" "$dest/$name" || exit
		EOF
	)"
}

#
# Product Helper
#

# productInit [PRODUCT] [HOST] - enable product for use  on host in this script
productInit()
{
	local noToken; [[ "$1" == "--no-token" ]] && { shift; noToken="--no-token"; }
	local product="${1:-$product}" host="$2"

	! productIsInstalled "$1" && { EchoErr "$product is not installed"; return 1; }

	initConfig || return 
	certInit || return

	ScriptEval productEnvironment $noToken "$product" "$host" || return

	if [[ $verbose ]]; then
		local token="$(productVarGet "TOKEN")" desc="no token"; [[ $token ]] && desc="token"
		log1 "using $product server at $(productVarGet "ADDR") with $desc"
		(( verboseLevel > 1 )) && productEnvironment "$product" "$host"
	fi

	return 0
}

# productEnvironment [PRODUCT] [HOST] - show the environment variables for the specified product
productEnvironment()
{
	local noToken; [[ "$1" == "--no-token" ]] && { shift; noToken="--no-token"; }
	local product="${1:-$product}" host="$2" force="$force"; certInit || return; 	

	# force the environment change if the configuration has changed
	if [[ "$configPrefix" != "$(productVarGet "CONFIG")" || "$baseDomain" != "$(productVarGet "DOMAIN")" ]] && [[ ! $force ]]; then
		log1 "$product environment check will be forced (configPrefix=$configPrefix $(productVar "CONFIG")=$(productVarGet "CONFIG")  baseDomain=$baseDomain $(productVar "DOMAIN")=$(productVarGet "DOMAIN")"
		force="--force"
	fi

	# variables
	local certDir="$(certDirLocal)"
	local server; server="$(productGetServer "$product" "$host")" || return
	local useHttps; [[ -d "$certDir" ]] && useHttps="true"
	local url; url="$(productGetAddress "$product" "$server")" || return	

	# logging
	if [[ $verbose ]]; then
		if [[ $useHttps ]]; then
			log1 "certificate directory '$certDir' exists, HTTPS will be used"
		else
			log1 "certificate directory no present, HTTP will be used"
		fi
	fi

	# local hosts use the automatic certificate authority
	IsLocalHost "$server" && [[ -f "$certDirService/$caAuto" ]] && ca="$caAuto"
	
	# validate certificates
	[[ $useHttps && ! $suppressErrors ]] && { certValidate "$certDir" "$ca" "$certCli" "$certCliKey" || return; }

	# arguments
	local args="-http-addr=$url"
	[[ $useHttps ]] && args+=" -ca-file=$certDir/$ca -client-cert=$certDir/$certCli -client-key=$certDir/$certCliKey"

	# standard configuration
	cat <<-EOF
		export $(productVar "CONFIG")="$configPrefix"
		export $(productVar "DOMAIN")="$baseDomain"
		export $(productVar "SERVER")="$server"
		export $(productVar "ADDR")="$url"
		export $(productVar "ARGS")="$args"
	EOF

	# certificate configuration
	if [[ $useHttps ]]; then
		cat <<-EOF
			export $(productVar "CACERT")="$certDir/$ca"
			export $(productVar "CLIENT_CERT")="$certDir/$certCli"
			export $(productVar "CLIENT_KEY")="$certDir/$certCliKey"
		EOF
	else
		cat <<-EOF
			export $(productVar "CACERT")=""
			export $(productVar "CLIENT_CERT")=""
			export $(productVar "CLIENT_KEY")=""
		EOF
	fi

	# token configuration - set if not already set, i.e. nomad can set the VAULT_TOKEN
	local token tokenVar tokenVal
	tokenVar="$(productVar "TOKEN")"
	tokenVal="$(productVarGet "TOKEN")"
	if [[ $force || ! $tokenVal ]] && [[ ! $noToken ]]; then
		local exclude=(); [[ "$product" == "vault" ]] && exclude=( "--exclude-managers=vault" ) # prevent recursion	
		[[ "$CREDENTIAL_MANAGER" == @(remote|v|vault) ]] && export CREDENTIAL_MANAGER="local"
		tokenVal="$(credGets "token" "${exclude[@]}" --quiet)" || tokenVal=""
	fi
	[[ $tokenVal ]] && echo "export $tokenVar=\"$tokenVal\""

	return 0
}

# productGetAddress [PRODUCT] [SERVER] [PORT] - get the communication URL for the product
productGetAddress()
{
	local product="$1"
	local server="$2"; [[ ! $server ]] && server="$(productGetServer)"
	local port="$3"; [[ ! $port ]] && port="$(productGetPort "$product")"
	[[ $useHttps ]] && echo "https://$server:$port" || echo "http://$server:$port"
}

# productGetPort [PRODUCT] - get the primary port for the specified product
productGetPort()
{
	local p="${1:-$product}"
	declare -n port; [[ $useHttps ]] && port="${p}HttpsPort" || port="${p}HttpPort"
	echo "$port"
}

productGetProtocol() { [[ $useHttps ]] && echo "https" || echo "http"; }

# productGetServer [PRODUCT] - get the server for the product
productGetServer()
{
	local product="${1:-$product}" host="$2"
	local server; server="$(productGetServerDo)" || return

	[[ ! $server ]] && { ScriptErr "unable to find a $product server for the '$configDesc' configuration"; return 1; }

	# return server - use 127.0.0.1 or the fully qualified DNS name (to match the certificate)
	IsLocalHost "$server" && echo "127.0.0.1" || DnsResolve "$server"
}

productGetServerDo()
{
	# use the passed host
	[[ $host ]] && { echo "$host"; return; }

	# use the --product-server argument
	[[ $productServer ]] && { echo "$productServer"; return; }

	# use the first host specified by the --host or --servers arguments
	if [[ $hostArg || $servers ]]; then
		local hosts; getHosts "${servers[@]}" || return
		echo "${hosts[0]}"; return
	fi

	# use the <product>_SERVER environment variable if it is valid
	if [[ ! $force && $(productVarGet "SERVER") ]]; then
		server="$(productVarGet "SERVER")"
		DnsResolve --quiet "$server" >& /dev/null && { echo "$server"; return; }
	fi

	# use the local host for the server if the product service is running
	if [[ "$product" != @(nomad) ]] && [[ -f "/etc/systemd/system/$product.service" ]] && IsProcessRunning "$product" && service running "$product"; then
		echo "127.0.0.1"; return
	fi

	# use DNS to resolve the service	
	if server="$(GetServer "$product.service" --quiet)"; then
		echo $server; return
	fi

	# use consul to resolve the server for the product
	if [[ "$product" != "consul" ]] && server="$(productResolve)"; then
		echo $server; return
	fi

	# use the first server specified in bootstrap-config.sh
	echo "$(configServer)"
}

productInstall()
{
	local product="$1"
	local host="$2"; hostCheck "$host" || return
	local installDir="$(findInstallFile "other/HashiCorp/$product")" || return		

	# local install
	if IsLocalHost "$host"; then

		header "Install $(ProperCase "$product") Program (local)"

		# return if up to date
		local file="$(os executable find "$installDir")" || return
		InPath "$product" && [[ ! $force && "$(productVersion "$product")" == "$(productVersion "$product" "$file")" ]] && return	
		
		# install
		hilight "Installing $product..."
		local user="root" group="root"
		IsPlatform mac && group="wheel"
		IsPlatform qnap && { user="admin"; group="administrators"; }
		sudoc ${G}install -o "$user" -g "$group" -m 755 -T "$file" "$binDir/$product" || exit
 
		return 0
	fi

	local dest="$binDir/$product"

	# header
	header "Install $(ProperCase "$product") Program ($host)"

	# version check
	[[ ! $force ]] && ssh "$host" "[[ -f \"$dest\" ]]" && [[ "$(productVersion "$product")" == "$(productVersion "$product" "$host")" ]] && return

	# determine the host architecture
	printf "$host architecture..."
	local machine="$(ssh "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm"; [[ "$product" == "consul" ]] && machine="armhfv6";;
		*) machine="amd64";; 
	esac
	printf "$machine..."

	# find the program
	printf "program..."
	local file="$(find "$installDir" -maxdepth 1 -type f  -name "$product*_linux_$machine" | tail -1)"
	[[ ! -f "$file" ]] && { echo; ScriptErr "unable to find the $product program"; return 1; };
	echo "$(GetFileName "$file")"

	# copy the program to the host
	scp "$file" "$host:/tmp/$product" || return

	# update the program on the host
	local productServiceFile="/etc/systemd/system/$product.service"

	scriptRun "$(cat <<-EOF
		[[ -f "$productServiceFile" ]] && { printf "stopping service..."; sudo systemctl stop "$product" || exit; echo "done"; }
		sudo cp "/tmp/$product" "$binDir" || exit
		[[ -f "$productServiceFile" ]] && { printf "starting service..."; sudo systemctl start "$product" --no-block || exit; echo "done";  }
		exit 0
		EOF
	)" || return

}

productInstallCerts()
{
	local product="${1:-$product}"; certInit || return
	local src; src="$certDir"; [[ ! -d "$src" ]] && { src="$(certPublicFind)" || return; }
	local dest="$(certDirSuffix "/opt/hashi")" # always install certificates to /opt/hashi 

	[[ -f "$dest/$ca" && ! $force ]] && return	

	printf "${GREEN}Installing $product certificates...${RESET}"
	sudoc ${G}mkdir --parents "$dest" || return
	sudo cp "$src/$ca" "$src/$certCli" "$src/$certCliKey" "$dest" || return
	[[ -f "$src/$caAuto" ]] && { sudo cp "$src/$caAuto" "$dest" || return; }
	sudo chmod +r "$dest/"* || return
	hilight "done"

	certStoreMacInstall "$src/$ca" || return
	certStoreWinInstall "$src/$ca" || return
	certStoreInstall "$src/$ca" "$certStoreCa" || return
	[[ -f "$src/$caAuto" ]] && { certStoreInstall "$src/$caAuto" "$certStoreCaAuto" || return; }
		
	return 0
}

productIsInstalled() { [[ $(FindInPath "${1:-$product}") ]]; }

# productResolve PRODUCT - resolve the host name for the specified product
productResolve()
{
	local product="${1:-$product}"
	local name="$product"; [[ "$product" == "vault" ]] && name="active.vault"
	resolve "$name"
}

productServiceRemove()
{
	local product="$1"; productServiceVars || return
	local host="$2"; hostCheck "$host" || return 0
	
	scriptRun "$(cat <<-EOF

		# delete service
		if [[ -f "$productServiceFile" ]]; then
			echo "Deleting the service..."
			sudo systemctl stop "$product" || exit
			sudo systemctl disable "$product" || exit
			sudo rm -f "$productServiceFile" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl reset-failed || exit
		fi

		# remove certificates
		if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
			echo "Removing automatic CA certificate..."
			sudo rm -f "$certStoreCa" "$certStoreCaAuto" || exit
			sudo update-ca-certificates || return
		fi

		printf "cleaning..."
		getent passwd "$product" >&/dev/null && { printf "user..."; sudo userdel "$product" >& /dev/null; }
		getent group "$product" >&/dev/null && { printf "group..."; sudo groupdel "$product" >& /dev/null; }
		[[ -d "/etc/$product.d" ]] && { printf "configuration..."; sudo rm -fr "/etc/$product.d"; }
		[[ -d "/opt/$product" ]] && { printf "data..."; sudo rm -fr "/opt/$product"; }
		[[ "$removeProgram" && -f "$binDir/$product" ]] && { printf "program..."; sudo rm -f "$binDir/$product"; }

		[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && { printf "tempory files..."; sudo rm -fr "/tmp/hashi."*; }
		[[ -d "/tmp/consul-test" ]] && sudo rmdir "/tmp/consul-test"

		echo "done"

		EOF
	)"
}

productServiceRestart() { scriptRun "sudo systemctl restart "$product" --no-block || exit"; }

productServiceVars()
{
	local product="${1:-$product}"; certInit || return
	
	# variables
	program="$(FindInPath "$product")" || return
	user="$product"; [[ "$product" == "nomad" ]] && user="root"; # many Nomad jobs require running as root

	# directories	
	productConfigDir="/etc/$product.d" 
	productDataDir="/opt/$product"

	# configuration
	productConfigFileBase="01_$product.hcl"
	productConfigFile="$productConfigDir/$productConfigFileBase"
	productServiceFile="/etc/systemd/system/$product.service"
	productServiceEnvFile="/etc/systemd/system/$product.env"
}

# productVar VAR - get the environment variable name
productVar()
{
	local var="${1^^}"
	local http; [[ "$product" == "consul" && "$var" == @(ADDR|TOKEN) ]] && http="HTTP_";
	echo "${product^^}_${http}${var}"; 
}

# productVarGet VAR - get a product variable from the environment
productVarGet()
{
	local var="$1"
	local -n v="$(productVar "$var")"
	echo "$v"
}

# productVarSet VAR VALUE - set a product environent variable 
productVarSet()
{
	local var="$1" value="$2"
	local -n v="$(productVar "$var")"
	v="$value"
}

# productVersion PRODUCT WHAT - show the versionof the specified product
productVersion()
{
	local product="$1" what="${2:-$HOSTNAME}" desc version

	if [[ -f "$what" ]]; then
		# use the standard download file format (PRODUCT_VERSION_PLATFORM_ARCHITECURE) if possible as running Go programs on network shares from Windows can fail
		local file="$(GetFileName "$what")"
		[[ "$(GetWord "$file" 1 _)" == "$product" ]] && version="$(GetWord "$file" 2 _)" || version="$("$what" --version)" 
		desc="$(FileToDesc "$what")"

	elif IsLocalHost "$what"; then
		version="$($product --version | productVersionFilter)"
		desc="local"

	else
		version="$(ssh $host -- $product --version | productVersionFilter)"
		desc="$what"
	fi
	
	log1 "$product version ($desc) is $version"
	echo "$version"
}

productVersionFilter() { head -1 | cut -d" " -f 2 | RemoveFront v; }
	
#
# helper
#

doHashi() { hashi "$@" $force $test $verbose "${configFileArg[@]}" "${configPrefixArg[@]}" "${otherArgs[@]}"; }
tmpDirCreate() { ${G}mktemp -d -t "$tmpDirTemplate"; }
whatCheck() { [[ ! $what ]] && return 0; IsInArray "$1" what; }
whatCheckConfig() { local c; for c in $configWhat; do whatCheck "$c" && return; done; return 1; }

copyFile()
{
	local file="$1" dest="$2"
	
	# return if the file exists
	[[ -f "$dest/$file" && ! $force ]] && return	

	# copy the file
	echo "Copying $(GetFileName "$file")..."
	$testEcho cp "$file" "$dest"
}

encryptOptGet() { ScriptOptGet --check "encrypt" "$@" && ScriptCheckDir "$encrypt" || encrypt="true"; }

findInstallFile()
{
	i check || return # cache the installation directory
	FindInstallFile "$@"
}

getHosts() 
{
	local h="${hostArg,,}"

	# use the hostArg if specified
	if [[ $h ]]; then

		if [[ "$h" == "all" ]]; then # all hosts
			StringToArray "$(configServers)" "," "hosts"
		elif [[ "$h" == @(1|2|3|4|5|first|second|third|fourth|fifth) ]]; then # aliases
			configGetArray "servers" "hosts"
			[[ "$h" == @(1|first) ]] && hosts=( "${hosts[0]}" )
			[[ "$h" == @(2|second) ]] && hosts=( "${hosts[1]}" )
			[[ "$h" == @(3|third) ]] && hosts=( "${hosts[2]}" )
			[[ "$h" == @(4|fourth) ]] && hosts=( "${hosts[3]}" )
			[[ "$h" == @(5|fifth) ]] && hosts=( "${hosts[4]}" )
		else # comma separated lists of hosts
			StringToArray "$hostArg" "," hosts
		fi

	# use all hosts from configuration
	elif [[ $# == 1 && "$1" == "all" ]]; then
		StringToArray "$(configServers)" "," "hosts"
		
	# use the specicified configuration variable
	elif [[ $# == 1 && $(configGet "$1") ]] ; then
		configGetArray "$1" "hosts"
	
	# use the passed servers	
	else
		hosts=( "${@}" )
	fi

	[[ ! $hosts ]] && MissingOperand "host"

	return 0
}

initConfig()
{
	# set the configuration prefix from the environment variable if it has not been set
	! IsVar configPrefix && [[ $product ]] && { configPrefix="$(productVarGet "CONFIG")"; } 

	# set configuration prefix aliases
	[[ "${configPrefix,,}" == "prod" ]] && configPrefix=""

	# set configuration description
	configDesc="${configPrefix:-prod}"

	return 0
}

policyDownload()
{
	local url="$1"	
	local install; install="$(FindInstallFile other/HashiCorp/acl)" || return
	local dest="$install/$(GetFileName "$url")"

	[[ ! -f "$dest" ]] && { curl "$url" --silent --show-error --location --output "$dest" || return; }
	echo "$dest"
}

removeDir()
{
	local dir="$1"
	[[ ! $dir || ! -d "$dir" || "$(DirCount "$dir")" == 0 ]] && return
	echo "Deleting '$(FileToDesc "$dir")'..."
	$testEcho sudoc DelDir --contents "$dir"
}

# scriptRun SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local functions="$(FindInPath function.sh | GetFullPath)" script="$1"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		  sudo() { sudoc "\$@"; }
		fi

		$script
		EOF
	)"

	{ [[ $test ]] || (( verboseLevel > 1 )); } && { printf "%s\n" "$script"; }
	[[ $test ]] && return

	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		DISPLAY="" ssh -q -X -t "$host" "$script"
	fi
}

# validateConfigFile FILE - return false if the specified file is not a valid HashiCorp configuration file.
validateConfigFile()
{
	local type="$(GetFileExtension "$file")"
	[[ ! "$type" == @(hcl|json) ]] && { ScriptErr "Specified file /`$file/` is not a valid HashiCorp configuration file"; return 1; }
	echo "$type"
}

ScriptRun "$@"

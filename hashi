#!/usr/bin/env bash
. script.sh || exit
. bootstrap-config.sh || exit

run() {	init && args "$@" && initFinal && "${command}Command" "${args[@]}"; }

usage()
{
	ScriptUsage "$1" "\
Usage: hashi [OPTION]... [COMMAND]...
Helper commands for HashiCorp consul, nomad, and vault products.

	PRODUCT|all				commands for a product or all products
	config						show configure variables for all products
	install|remove 		install or remove a product
	lookup|resolve		lookup or resolve a service
	ui								start the hashi-ui server and launch it
	status						show status for all products

	-H, --host HOST		host for the command"
}

args()
{
	unset hostArg

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-h|--help) usage 0;;
			-H|--host|-H*|--host=*) ScriptArg hostArg host "$@";;
			*) ScriptOption "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	[[ $@ ]] && usage

	return 0
}

#
# configuration
#

init()
{
	products=( consul vault nomad )
	datacenter="$workgroup"

	# ports
	consulHttpPort="8500" consulHttpsPort="8501"
	declare -g {nomadHttpPort,nomadHttpsPort}="4646"
	declare -g {vaultHttpPort,vaultHttpsPort}="8200"
}

initFinal()
{
	IsInArray "${commandNames[0]}" products && { productInit "${commandNames[0]}" || return; }
	return 0
}

configCommon()
{
	local name="$1"

	# directories	
	config="/etc/$name.d" 
	data="/opt/$name"

	# configuration files
	configFileBase="01_$name.hcl"
	configFile="$config/$configFileBase"
	serviceFile="/etc/systemd/system/$name.service"
	serviceEnvFile="/etc/systemd/system/$name.env"
}

configCert()
{
	local name="$1"; [[ "$name" == "vault" ]] && name="consul" # vault uses consul certificates

	certDir="$encrypt/$name"	# source (private) certificate directory
	cert="/opt/$name/cert" 		# public (program) certificate directory

	ca="$name-ca.pem"
	caKey="$name-ca-key.pem"
	certCli=$name-cli.pem
	certCliKey=$name-cli-key.pem
	certClient=$name-client.pem
	certClientKey=$name-client-key.pem
	certServer=$name-server.pem
	certServerKey=$name-server-key.pem
}

configHashi()
{
	local server="$(GetWord "$servers" 1)"; [[ ! $server ]] && server="${hashiServers[0]}"
	eval "$(hashi config --host "$server")"
}

configInstall()
{
	local name="$1"

	# ensure the CLI program exists locally
	! InPath "$name" && { inst "$name" || return; }

	# general
	tmpDirTemplate="hashi.XXXXXXXXXX"
	program="$(FindInPath "$name")" || return
	user="$name"
	commonOptions=( [log_level]="Info" )

	# clients and server defaults
	[[ "$name" == "vault" && ! $servers ]] && { servers=( "${vaultServers[@]}" ); }
	[[ ! $clients && ! $servers ]] && { clients=( "${hashiClients[@]}" ) servers=( "${hashiServers[@]}" ); }

	# join servers
	[[ ! $join ]] && join=( "${servers[@]}" )
	[[ ! $join ]] && join=( "${hashiServers[@]}" )
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(os name "$h")" ); done
	
	return 0
}

#
# Commands
#

configCommand() { allConfigCommand; }

statusCommand()
{
	{
		hilight "product-ui-token"
		for name in "${products[@]}"; do	

			! InPath "$name" && continue

			local http; httpVar "$name";
			local -n addr="${name^^}_${http}ADDR"
			local -n token="${name^^}_${http}TOKEN"; [[ $token ]] && token="true" || token="false"

			echo "$name-${addr}-$token"
		done
	} | column -c $(tput cols) -t -s- -n
}

uiCommand()
{
	local product

	product="consul"
	configCommon "$product" || return
	configCert "$product" || return
	export CONSUL_ENABLE="true"
	export CONSUL_ADDR="$(productGetUrl "$product")"
	export CONSUL_ACL_TOKEN="$(credential get "$product" token)"
	export CONSUL_HTTP_SSL="true"
	export CONSUL_CACERT="$cert/$ca"
	export CONSUL_CLIENT_CERT="$cert/$certCli"
	export CONSUL_CLIENT_KEY="$cert/$certCliKey"

	product="nomad"
	configCommon "$product" || return
	configCert "$product" || return
	export NOMAD_ENABLE="true"
	export NOMAD_ADDR="$(productGetUrl "$product")"
	export NOMAD_ACL_TOKEN="$(credential get "$product" token)"
	export NOMAD_HTTP_SSL="true"
	export NOMAD_CACERT="$cert/$ca"
	export NOMAD_CLIENT_CERT="$cert/$certCli"
	export NOMAD_CLIENT_KEY="$cert/$certCliKey"

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# Install Command
#

installInit() { clients=() servers=() join=() encrypt="" force="" test=""; }

installUsage()
{
	echot "\
Usage: hashi install cli|consul|nomad|vault
Install a HashiCorp product.  If no hosts are specified use the hosts
specified	in bootstrap-config.sh.

	-c, --clients	HOSTS		comma separated list of clients to install
	-s, --server HOSTS		comma separated list of servers to install
	-j, --join HOSTS			comma separated list of hosts to join to, defaults to servers
	-e, --encrypt DIR			directory for PKI certificates, if specified TLS will be enabled
	-f, --force						force installation
	-t, --test						do not make changes
	-w, --what=C1[,C2...] components to install, valid components are: acl certficate program service
													Nomad: VaultIntegration
													Vault: seals"
}

installOption()
{
	case "$1" in "") : ;;
		-c|--clients|-c*|--clients=*) ScriptArg "clients" "$@"; StringToArray "$clients" "," clients;;
		-s|--servers|-s*|--servers=*) ScriptArg "servers" "$@"; StringToArray "$1" "," servers;;
		-j|--join|-j*|--join=*) ScriptArg "join" "$@"; StringToArray "$1" "," join;;
		-e|--encrypt|-e*|--encrypt=*) ScriptArg encrypt certificates "$@";;
		-f|--force) force="--force";;
		-t|--test) test="--test";;
		-w|--what|-w*|--what=*) ScriptArg "what" "$@"; StringToArray "${what,,}" "," what;;
		*) return 1;;
	esac
}

installCommand() { usage; }

installCliCommand()
{
	for name in "${products[@]}"; do
		installCliProgram || return
		installCliCert || return
	done

	return 0
}

installCliProgram()
{
	! installComponent "program" && return
	[[ ! $force ]] && InPath "$name" && return # return if already installed
	inst $force "$name" || return
}

installCliCert()
{
	configCert "$name" || return
	! installCert && return
	[[ ! $force && -f "$cert/$ca" ]] && return	# return if already installed

	printf "Installing $name certificates..."
	sudoc mkdir --parents "$cert" || return
	sudoc cp "$certDir/$ca" "$certDir/$name-cli"* "$cert" || return
	echo "done"
}

#
# Install Consul Command
#

installConsulCommand()
{ 
	installCommon || return

	# configuration
	local -A options serverOptions guiOptions 
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	options=(
		[domain]="$baseDomain"
		[datacenter]="$datacenter"
		[data_dir]="/opt/$name"
		[client_addr]="0.0.0.0"
		[bind_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[retry_join]="[ $(ShowArray join ", ") ]"
		[acl]="$(cat <<-EOF
			{ 
			  enabled = true
			  default_policy = "allow"
			  enable_token_persistence=true
			}
			EOF
		)"
	)

	serverOptions=(
		[server]="true"
		[bootstrap_expect]="${#join[@]}"
		[advertise_addr]='{{ GetInterfaceIP \"eth0\" }}'
	)

	commonEncryptOptions=(
		[addresses]='{ https = "0.0.0.0" }'
		[ports]="{ http = -1, https = $consulHttpsPort }"
		[verify_incoming]="false"
		[verify_incoming_rpc]="true"
		[verify_outgoing]="true"
		[verify_server_hostname]="true"
	)

	clientEncryptOptions=(
		[ca_file]="$cert/$ca"
		[auto_encrypt]="{ tls = true }"
	)

	serverEncryptOptions=(
		[ca_file]="$cert/$ca"
		[cert_file]="$cert/$certServer"
		[key_file]="$cert/$certServerKey"
		[auto_encrypt]="{ allow_tls = true }"
	)

	guiOptions=( [ui]="true" )

	# install
	installPerform || return
}

installConsulCommon()
{
	# service
	local cliArgs="$(cat <<-EOF
-http-addr="https://127.0.0.1:8501" \
-ca-file="$cert/$ca" \
-client-cert="$cert/$certCli" \
-client-key="$cert/$certCliKey"
	EOF
	)"

	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$program agent -config-dir=$config"
	execReload="$program reload $cliArgs"
	execStop="$program leave $cliArgs"
}

installConsulServer() 
{ 
	consulCertServerCopy || return
	AppendArray o serverOptions guiOptions
}

installConsulClient()
{
	consulCertClientCopy || return
}

consulCertInit()
{
	# certificates are created using consul
	! InPath "consul" && { inst "consul" || return; }

	pushd "$certDir" > /dev/null || return

	# create the CA and CLI certificates
	consulCertCaMake || return
	consulCertCliMake || return

	popd > /dev/null || return
}

consulCertCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the certificate authority for $baseDomain..."

	# create the cert
	consul tls ca create \
		-domain="$baseDomain" \
		-name-constraint || return # name constraint required for HTTPS GUI

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

# consulCertClientGet - get the auto generated consul client certficate authority
# which is needed by other clients like nomad
consulCertClientCopy()
{
	! installCert && return

	local f="$certDir/$certClient"

	if [[ ! -f "$f" ]]; then

		! InPath "consul-k8s" && { inst "consul-k8s" || return; }
	
		consul-k8s get-consul-client-ca \
			--server-addr "$(productGetServer "consul")" \
			--server-port "$consulHttpsPort" \
			--ca-file="$certDir/$ca" \
			--output-file "$f" || return

	fi
		
	cp "$certDir/$certClient" "$tmpDir/cert" || return
}

consulCertCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

consulCertServerCopy()
{	
	! installCert && return

	local c="consul-server-$host.pem"
	local k="consul-server-$host-key.pem"

	consulCertServerMake "$c" "$k" || return

	cp "$certDir/$c" "$tmpDir/cert/$certServer" || return
	cp "$certDir/$k" "$tmpDir/cert/$certServerKey" || return
}

consulCertServerMake()
{
	local c="$1" k="$2"

	certExist "$c" "$k" && return

	hilight "Creating the $host server certificate..."

	# move to the certificate directory
	pushd "$certDir" >& /dev/null || return

	# remove any existing temporary certs
	rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

	# create the cert
	consul tls cert create -server \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-additional-ipaddress="$(GetIpAddress "$host")" \
		-additional-dnsname="$hostFqdn" \
		-node="$host" || return

	# rename the temporary cert
	mv "$datacenter-server-$baseDomain-0.pem" "$c" || return
	mv "$datacenter-server-$baseDomain-0-key.pem" "$k" || return

	popd >& /dev/null || return
}

#
# Install Nomad Command
#

installNomadCommand()
{
	installCommon || return

	# configuration
	local -A options clientOptions serverOptions guiOptions
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	options=( 
		[datacenter]="$datacenter"
		[data_dir]="/opt/$name"
		[acl]="{ enabled = true }"
		[consul]="{$(getConsulTokenConfig)
        address = \"127.0.0.1:$(productGetPort "consul")\"
}"
	)

	serverOptions=(
		[server]="{
	enabled = true
	bootstrap_expect = "${#join[@]}"
}"
	)

	clientOptions=(
		[client]="{
	enabled = true 
}"
	)

	clientEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certClient\"
	key_file = \"$cert/$certClientKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	serverEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certServer\"
	key_file = \"$cert/$certServerKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	# install
	installPerform || return
}

installNomadCommon()
{ 
	! installCert && return

	# set the certificate configuration to consul
	configCert "consul" || return

	local caCert="$ca"

	# get the auto generated consul client certificate
	[[ "$type" == "client" ]] && caCert="$certClient"
	
	# create the service environment file
	cat > "$tmpDir/$name.env" <<-EOF
		CONSUL_HTTP_SSL=true
		CONSUL_CACERT=$cert/$caCert
		CONSUL_CLIENT_CERT=$cert/$certServer
		CONSUL_CLIENT_KEY=$cert/$certServerKey
	EOF

	# return the nomad certificate configuration
	configCert "nomad" || return
}

installNomadServer()
{
	certServerCopy || return
	AppendArray o serverOptions clientOptions
}

installNomadClient()
{
	certClientCopy || return
	AppendArray o clientOptions
}

installNomadFinal()
{
	initNomadVaultIntegration || return
}

initNomadVaultIntegration()
{
	! installComponent "vaultintegration" && return	
	! InPath vault && { echo "Vault is not installed, skipping nomad vault integration"; return; }

	productConfigSet "vault" || return

	local tmpDir="$(tmpDirCreate)" || return
	pushd "$tmpDir" >& /dev/null || return

	# add the nomad-cluster policy to Vault
	if ! vault policy list | grep "^nomad-server$" >& /dev/null; then
		hilight "Adding the nomad-cluster policy to Vault..."
		curl https://nomadproject.io/data/vault/nomad-server-policy.hcl -O -s -L || return
		vault policy write nomad-server nomad-server-policy.hcl || return
	fi

	# add the nomad-cluster role to Vault
	if ! vault list "/auth/token/roles" | grep "^nomad-cluster$" >& /dev/null; then
		hilight "Adding the nomad-cluster role to Vault..."
		curl https://nomadproject.io/data/vault/nomad-cluster-role.json -O -s -L || return
		vault write /auth/token/roles/nomad-cluster @nomad-cluster-role.json || return
	fi

	popd >& /dev/null || return
	rm -fr "$tmpDir"

	# grant the nomad-cluster role permission to required secrets
	if ! vault policy list | grep "^nomad-cluster$" >& /dev/null; then
		hilight "Granting the nomad-cluster role permission in Vault..."
		cat | vault policy write nomad-cluster - <<-EOF
			path "secret/*" {
			  capabilities = ["read"]
			}
		EOF
	fi

	# create a token for nomad to access vault
	local token="$(vault token create -policy nomad-server -orphan -format=json | jq '.auth.client_token')" || return

	# add vault integration configuration to nomad
	local file="$tmpDir/02_vault.hcl"

	configCert "consul" || return
	cat > "$file" <<-EOF
		vault {
		  enabled          = true
		  ca_file          = "$cert/$ca"
		  cert_file        = "$cert/$certCli"
		  key_file         = "$cert/$certCliKey"
		  address          = "https://127.0.0.1:$vaultHttpsPort"
		  token            = "$token"
			create_from_role = "nomad-cluster"
		}
	EOF

	#for host in "${servers[@]}" "${clients[@]}"; do
	# here here
}

nomadCertInit()
{
	# certificates are created using consul
	! InPath "cfssl" && { inst "cfssl" || return; }

	pushd "$certDir" >& /dev/null || return

	# create the CA and CLI certificates
	nomadCertCaMake || return
	nomadCertServerMake || return
	nomadCertClientMake || return
	nomadCertCliMake || return

	popd >& /dev/null || return
}

nomadCertCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the nomad certificate authority..."
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca || return
}

nomadCertServerMake()
{
	certExist "$certServer" "$certServerKey" && return

	hilight "Creating the server certificate..."

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > cfssl.json || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(DelimitArray "," joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -config=cfssl.json -hostname="$hosts" - | \
		cfssljson -bare nomad-server || return
}

nomadCertClientMake()
{
	certExist "$certClient" "$certClientKey" && return

	hilight "Creating the client certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-client || return
}

nomadCertCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the CLI certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-cli
}

#
# Install Vault
#

installVaultCommand()
{
	installCommon || return

	# configuration
	local -A options clientOptions serverOptions guiOptions

	# configuration
	options=(
		[listener]="\"tcp\" $(cat <<-EOF
			{ 
			  address = "0.0.0.0:8200"
			  tls_cert_file = "$cert/$certServer"
			  tls_key_file = "$cert/$certServerKey"
			}
			EOF
		)"

		[storage]="\"consul\" $(cat <<-EOF
			{$(getConsulTokenConfig)
			  path = "vault/"
			  address = "127.0.0.1:8501"
			  scheme = "https"
			  tls_ca_file = "$cert/$ca"
			  tls_cert_file = "$cert/$certCli"
			  tls_key_file = "$cert/$certCliKey"
			}
			EOF
		)"

		[service_registration]="\"consul\" $(cat <<-EOF
				{$token
				  address="127.0.0.1:8501"
				  scheme="https"
				  tls_ca_file = "$cert/$ca"
				  tls_cert_file = "$cert/$certCli"
				  tls_key_file = "$cert/$certCliKey"
				}
			EOF
		)"
	)

	guiOptions=( [ui]="true" )

	# install
	installPerform || return
}

installVaultCommon()
{
	# options
	o[api_addr]="https://$hostFqdn:8200"

	# service
	execStart="$program server -config=$config"

	# script
	scriptFinal="$(cat <<-EOF
		echo "Configuring vault..."

		# allow memory locking without elevation (so don't need to run as root)
		sudo setcap cap_ipc_lock=+ep "$program" || return
		EOF
	)"
}

installVaultServer() { AppendArray o guiOptions; }

installVaultFinal() { installVaultSeals; }

installVaultSeals()
{
	vaultConfig || return

	# generate the unseal keys, returning if already generated
	local n key s seals; seals="$(vault operator init 2>&1)" || return 0

	IFS=$'\n' seals=( $(echo "$seals" | grep "Unseal Key") )
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credential set vault "key$n" "$key"
	done

	declare token; token="$(cat "/tmp/a.txt" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credential set vault token "$token"

	# show the full seal text
	header "Vault Seal"
	hilight "Store the following Vault seals in a secure location:"
	echo "$seals"

	# check if the seals were stored correctly
	if [[ "$(credential get vault token)" != "$token" ]]; then
		EchoErr "unable to store the Vault root token and possibly the Vault seals in the credential store"
		return 1
	fi

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | grep "^secret" > /dev/null; then
		vault secrets enable -path=secret kv-v2 || return
	fi

	return 0
}

#
# Remove Command
#

removeUsage()
{
	echot "usage: $(ScriptName) remove consul|nomad|vault"
	exit ${1:-1}
}

removeCommand() { usage; }

removeConsulCommand() { removePerform; }
removeNomadCommand() { removePerform; }
removeVaultCommand() { removePerform; }

removePerform()
{
	local command="" hosts=() name
	local name="${commandNames[1]}" # name of the product to remove

	# default to localhost
	[[ ! $hosts ]] && hosts=( "localhost" )

	# configuration variables
	configCommon "$name" || return

	# remove
	removeProduct "${hosts[@]}" || return
}

removeProduct()
{
	for host in "$@"; do
		header "Remove $(ProperCase "$name") ($host)"
		removeCommon || return
		$command "$@" || return
	done
}

removeCommon()
{
	scriptRun "$(cat <<-EOF

		# delete service
		if [[ -f "$serviceFile" ]]; then
			echo "Deleting the service..."
			sudo systemctl stop "$name" || exit
			sudo systemctl disable "$name" || exit
			sudo rm -f "$serviceFile" || return
			sudo systemctl daemon-reload || return
			sudo systemctl reset-failed || return
		fi

		printf "cleaning..."

		printf "user..."
		sudo userdel "$name"
		sudo userdel "$name" >& /dev/null

		printf "configuration..."; 
		sudo rm -fr "/etc/$name.d" || return

		printf "data..."; 
		sudo rm -fr "/opt/$name" || return

		printf "program..."; 
		sudo rm -f "/usr/local/bin/$name" || return

		printf "temporary files..."; 
		sudo rm -f "/tmp/$name."* || return

		echo "done"

		EOF
	)"
}

#
# Certificate Helper
#

certExist() { [[ -f "$certDir/$1" && -f "$certDir/$2" ]]; }

certInit()
{
	! installCert && return

	# create the certificate directory
	[[ ! -d "$certDir" ]] && { mkdir --parents "$certDir" || return; }

	# product specific certificate initialization
	RunFunction "${name}CertInit"
}

certClientCopy()
{
	! installCert && return
	cp "$certDir/$certClient" "$certDir/$certClientKey" "$tmpDir/cert" || return
}

certServerCopy()
{
	! installCert && return
	cp "$certDir/$certServer" "$certDir/$certServerKey" "$tmpDir/cert" || return
}

#
# Install Helper
#

installComponent() { [[ ! $what ]] && return 0; IsInArray "$1" what; }
installCert() { [[ $cert ]] && installComponent "certificate"; }

installCommon()
{
	declare -g certDir 
	declare -g name="${commandNames[1]}"; [[ ! $name ]] && usage; # name of the product to install
	declare -Ag commonOptions

	configCommon "$name" || return
	configCert "$name" || return
	configInstall "$name" || return
}
	
installPerform()
{
	local result tmpDir="$(tmpDirCreate)" || return

	certInit || return
	installService || return
	installAcl || return
	installFinal || return

	# cleanup
	[[ ! $test ]] && { rm -fr "$tmpDir"; ssh "$host" rm -fr "$tmpDir"; }

	return 0
}

installService()
{
	! installComponent "service" && return

	local f hostFqdn hostIp type scriptFinal	
	local -A o
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local execStart="$program agent -config=$config"
	local execReload="/bin/kill -HUP"
	local exectStop=""

	# servers
	for host in "${servers[@]}"; do
		type="server"
		installServiceInit || return
		RunFunction "install$(ProperCase "$name")Server" || return
		installServiceDo || return
	done

	# clients
	for host in "${clients[@]}"; do
		type="client"
		installServiceInit || return
		RunFunction "install$(ProperCase "$name")Client" || return
		installServiceDo || return
	done
}

installServiceInit()
{
	scriptFinal=""

	# host information
	hostFqdn="$(os name "$host")" || return # host fully qualified domain name
	host="$(RemoveDnsSuffix "$hostFqdn")"
	hostIp="$(GetIpAddress "$hostFqdn")"

	# header
	header "Install $(ProperCase "$name") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	DelDir --contents "$tmpDir" || return
	mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return		

	# copy program
	! IsLocalHost "$host" && { installProgram || return; }

	# copy certificates
	installCert && { FileCommand cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$tmpDir/cert" || return; }

	# service
	printf "" > "$tmpDir/$name.env"

	# options - other options added in installPRODUCTServer or installPRODUCTClient
	o=( ); AppendArray o commonOptions options
	[[ "$encrypt" ]] && IsDeclared commonEncryptOptions && AppendArray o commonEncryptOptions
	[[ "$encrypt" ]] && IsDeclared ${type}EncryptOptions && AppendArray o ${type}EncryptOptions

	RunFunction "install$(ProperCase "$name")Common"
}

installServiceDo()
{
	# create the configuration files
	installConfigHcl o > "$tmpDir/config/$configFileBase" || return
	installConfigService > "$tmpDir/$name.service" || return

	# copy the files to the remote host
	if ! IsLocalHost "$host"; then
		hilight "Copying files to $host..."
		scp -r "$tmpDir" "$host:/$tmpDir" || return
	fi

	# run the installation script - use only standard commands
	hilight "Running installation..."
	scriptRun "$(cat <<-EOF

		# user
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudo useradd -r -d "$config" -s "/bin/false" "$user" || exit
		fi

		# stop the service
		if [[ -f "$serviceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudo systemctl stop "$name" || exit
		fi

		# program
		if [[ ! -f "$program" || "$force" ]]; then
		  echo "Copying program..."
		  sudo cp "$tmpDir/$name" "$program" || exit
		fi

		# directories
		if ! [[ -d "$cert" && -d "$config" && -d "$data" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudo install -o "$user" -g "$user" -m 755 -d "$cert" "$config" "$data" || exit
		fi

		# copy files
		if [[ \$(sudo ls -A "$tmpDir/data") ]] && [[ ! \$(sudo ls -A "$data") || "$force" ]]; then
		  echo "Copying data files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$data" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/config") ]] && [[ ! -f "$config/$configFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$config" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/cert") ]] && [[ ! \$(sudo ls -A "$cert") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$cert" "$tmpDir/cert/"* || exit
		fi

		# service		
		if [[ ! -f "$serviceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudo cp "$tmpDir/$name.service" "$tmpDir/$name.env" "/etc/systemd/system" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl enable "$name" || exit
			sudo systemctl start "$name" || exit
		fi

		$scriptFinal

		# cleanup
		echo "Cleaning up..."
		rm -fr "/tmp/$name.tmp"

		exit 0

		EOF
	)"

}

installAcl()
{
	! installComponent "acl" && return

	configHashi || return

	# generate the bootstrap token
	local token; token="$($name acl bootstrap 2>&1)" || return 0
	local secret="$(echo "$token" | grep "Secret ID" | cut -d= -f 2 | RemoveSpace)" 

	# store the bootstrap token in the credential store
	[[ $test ]] && return
	[[ $secret ]] && credential set "$name" token "$secret"

	# show the full bootstrap text
	header "$name Bootstrap Token"
	hilight "Store the following bootstrap token in a secure location:"
	echo "$token"

	# check if the bootstrap token was stored correctly
	if [[ ! $secret || "$(credential get "$name" token)" != "$secret" ]]; then
		EchoErr "unable to store the bootstrap token in the credential store"
		return 1
	fi

	return 0
}


# installConfigHcl - turn the passed array variables into an HCL script
installConfigHcl()
{
	local key var

	for var in "$@"; do
		local -n config="$var"

		for key in "${!config[@]}"; do

			local equal=" =" quote="true" v="${config[$key]}"
			local fc="${v:0:1}" sc="${v:1:1}" # first and second characters

			# example: addresses { https = "0.0.0.0" }
			[[ "$fc" == "{" && "$sc" != "{" ]] && quote="" equal=""

			# example: retry_join = [ "pi3", "pi4" ]
			[[ "$fc" == "[" ]] && quote=""

			# listener "tcp" { address = "0.0.0.0:8200", tls_disable = 1 }
			[[ "$fc" == "\"" ]] && quote="" equal=""

			# boolean, example: server = true			
			[[ "$v" == @(true|false) ]] && quote=""

			# integer, example: bootstrap_expect = 2
			IsInteger "$v" && quote=""

			[[ $quote ]] && echo "$key$equal \"${config[$key]}\"" || echo "$key$equal ${config[$key]}"

		done

	done
}

installConfigService()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$name")
		Documentation=https://www.hashicorp.com/products/$name
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$configFile

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$serviceEnvFile
		KillMode=process
		KillSignal=SIGINT
		Restart=on-failure
		RestartSec=2
		StartLimitBurst=3
		StartLimitIntervalSec=10
		LimitNOFILE=infinity
		LimitNPROC=infinity
		TasksMax=infinity

		[Install]
		WantedBy=multi-user.target
	EOF
}

installFinal() { RunFunction "install$(ProperCase "$name")Final"; }

installProgram()
{
	! installComponent "program" && return

	local file machine

	# check if the program is present on the host
	[[ ! $force ]] && ssh "$host" "[[ -f \"$program\" ]]" && return

	printf "Program..."	

	# find the installation directory
	file="$(FindInstallFile "other/HashiCorp/$name")" || return;
	printf "install..."

	# determine the host architecture
	machine="$(ssh "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm"; [[ "$name" == "consul" ]] && machine="armhfv6";;
		*) machine="amd64";; esac
	printf "$machine..."

	# find the program
	file="$(find "$file" -name "$name_*_linux_$machine" | tail -1)"
	[[ ! -f "$file" ]] && { ScriptErr "unable to find the $name program"; return 1; };
	printf "$(GetFileName "$file")..."

	# copy the program
	cp "$file" "$tmpDir/$name" || return
	echo "copied"
}

#
# Lookup Command
#

lookupInit() { name=""; }

lookupUsage() { echot "Usage: hashi lookup NAME[.service]
Lookup a service in consul.   All service endpoints are returned."; }

lookupArgs() { ScriptGetArg "name" "$1"; shift; }

lookupCommand()
{
	name+=".service.$domain"
	configCommon "consul" || return
	nslookup -port=8600 -type=a -norecurse "$name" "$(productGetServer "consul")"
}

#
# Resolve Command
#

resolveInit() { all=""; name=""; }

resolveUsage() { echot "Usage: hashi resolve [-a|all] NAME[.service]
resolve a service in consul to an IP address or canonical name.
If all is not specified the first IP address is returned."; }

resolveOption()
{
	case "$1" in "") : ;;
		-a|--all) all="true";;
		*) return 1;;
	esac
}

resolveArgs() { ScriptGetArg "name" "$1"; shift; }

resolveCommand()
{
	local filter="head -1"; [[ $all ]] && { filter="cat"; }

	local result; result="$(lookupCommand)" || return

	if [[ "$result" =~ .*canonical\ name.* ]]; then
		printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//' | $filter
	else
		printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace | $filter
	fi

	return "${PIPESTATUS[0]}"
}

#
# All Commands
#

allUsage()
{
	echot "\
Usage: hashi all config|status
Commands for all products."
}

allCommand() { usage; }

allConfigCommand()
{
	local product

	for product in "${products[@]}"; do
		productConfigShow "$product" || return
		echo
	done
}

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# Consul Commands
#

consulUsage()
{
	echot "\
Usage: hashi consul config|status
Consul commands."
}

consulCommand() { usage; }
consulConfigCommand() { productConfigShow "consul"; }
consulStatusCommand() { consul members; }

#
# Nomad Commands
#

nomadUsage()
{
	echot "\
Usage: hashi nomad config|job|status
Nomad commands."
}

nomadCommand() { usage; }
nomadConfigCommand() { productConfigShow "nomad"; }
nomadStatusCommand() { nomad node status; }

#
# Nomad Job Commands
#

nomadJobUsage()
{
	echot "\
Usage: hashi nomad job NAME
Nomad job commands.

	force	NAME		force a periodic job to start
	log	NAME			show the log for a periodic job
	status [NAME]	status of all running jobs or the specified job"
}

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() {	nomadJobStatusCommand; }

# nomad job status 

nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | grep -v dead
	fi
}

# nomnd job force

nomadJobForceInit() { log=""; }

nomadJobForceUsage()
{
	echot "\
Usage: hashi nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"
}

nomadJobForceOption() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogInit() { follow=""; }

nomadJobLogUsage()
{
	echot "\
Usage: hashi nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"
}

nomadJobLogOption() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId"
		header "Standard Error"; nomad alloc logs -stderr "$allocId"
	fi		
}

# nomad helper

nomadGetJobId()
{ 
	jobId="$(nomad job status "$job" |& tail -1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job \`$job\`"; exit 1
}

nomadGetAllocId()
{
	[[ ! $jobId ]] && { nomadGetJobId || return; }
	allocId="$(nomad job status "$jobId" |& tail -1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job \`$job\`"; exit 1
}

#
# Vault Commands
#

vaultUsage()
{
	echot "\
Usage: hashi vault config|status|unseal
Vault commands.

	unseal			unseal the vault using keys from the credential store"
}

vaultCommand() { usage; }
vaultConfigCommand() { productConfigShow "vault"; }

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac
}

vaultUnsealCommand()
{
	local host hosts=() key

	# unseal each host
	for host in "${hosts[@]}"; do
		header "$host"
		eval "$(hashi config --host "$host")"

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credential get vault key$n)"
			if [[ $key ]]; then
				vault operator unseal "$key" || return
			else
				echo "key $n does not exist in the credential store"
			fi
		done

	done
}

#
# Product Helper
#

# productInit PRODUCT - initialize a product command
productInit()
{
	product="$1"
	productConfigSet "$product"
}

# productConfigSet PRODUCT - set the configuration variables for the specified product, which enables use of
#   the the product in this script
productConfigSet()
{
	local product="$1" 
	local -n addr="${product^^}_ADDR"

	[[ ! $hostArg && $addr ]] && return
	eval "$(productConfigShow "$product")" || return
}

# productConfigShow PRODUCT - show the configuration variables for the specified product
productConfigShow()
{
	local product="$1"

	# configuration variables
	configCommon "$product" || return
	configCert "$product" || return

	local args="" 
	local server="$(productGetServer "$product")"
	local url="$(productGetUrl "$product" "$server")"
	local http; httpVar "$product";

	[[ -f "$cert/$certCli" ]] && args+=" -ca-file=$cert/$ca -client-cert=$cert/$certCli -client-key=$cert/$certCliKey"

	# standard configuration
	cat <<-EOF
		export ${product^^}_SERVER="$server"
		export ${product^^}_${http}ADDR="$url"
		export ${product^^}_ARGS="-http-addr=$url$args"
	EOF

	# certificate configuration
	if [[ -f "$cert/$certCli" ]]; then
		cat <<-EOF
			export ${product^^}_CACERT="$cert/$ca"
			export ${product^^}_CLIENT_CERT="$cert/$certCli"
			export ${product^^}_CLIENT_KEY="$cert/$certCliKey"
		EOF
	fi

	# token configuration - set if not already set, i.e. nomad can set the VAULT_TOKEN
	local token tokenVar tokenVal
	tokenVar="${product^^}_${http}TOKEN"
	tokenVal="$(eval echo "\$$tokenVar")"
	[[ ! $tokenVal ]] && token="$(productGetToken "$product" 2>&1)" && echo "export $tokenVar=\"$token\""

	return 0
}

# productGetServer PRODUCT - get the server for the product
productGetServer()
{
	local product="$1"

	# use the host specified by the --host argument
	if [[ $hostArg ]]; then
		IsLocalHost "$hostArg" && echo "127.0.0.1" || AddDnsSuffix "$hostArg" "$domain" 
		return
	fi

	# use the <product>_SERVER environment variable
	local -n val="${product^^}_SERVER"
	if [[ $val ]]; then
		echo "$val"
		return
	fi

	# use the local host for the server if the product service is running
	if [[ -f $serviceFile ]] && IsProcessRunning "$product" && service running "$product"; then
		echo "127.0.0.1"
		return
	fi

	# use consul to resolve the server for the product
	if [[ "$product" != "consul" ]]; then
		hashi resolve "$product"
		return
	fi
	
	# use the first server specified in bootstrap-config.sh
	local servers="$hashiServers"; [[ "$product" == "vault" ]] && servers="${vaultServers[@]}"
	AddDnsSuffix "$(GetWord "$hashiServers" 1)" "$domain"
}

# productGetPort PRODUCT - get the primary port for the specified product
productGetPort()
{
	local p="$1"
	declare -n port

	if [[ -d "$cert" ]]; then
		port="${p}HttpsPort"
		echo "$port"
	else
		port="${p}HttpPort"
		echo "$port"
	fi
}

# productGetToken PRODUCT - get the authentication token for the product
productGetToken()
{
	local excludeVault; [[ "$1" == "vault" ]] && excludeVault="--exclude-vault"
	credential "$excludeVault" get "$1" token	
}

# productGetUrl PRODUCT [SERVER] [PORT] - get the communication URL for the product
productGetUrl()
{
	local p="$1"
	local server="$2"; [[ ! $server ]] && server="$(productGetServer "$p")"
	local port="$3"; [[ ! $port ]] && port="$(productGetPort "$p")"

	[[ -d "$cert" ]] && echo "https://$server:$port" || echo "http://$server:$port"
}

#
# helper
#

httpVar() { http=""; [[ "$1" == "consul" ]] && http="HTTP_"; }

# getConsulTokenConfig - get the consul token configuration text
getConsulTokenConfig()
{
	local token; token="$(productGetToken "consul" 2>&1)" || return
	echo $'\n'"  token = \"$token\""
}

# scriptRun SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local functions="$(FindInPath function.sh | GetFullPath)" script="$1"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		  sudo() { sudoc "\$@"; }
		fi

		$script
		EOF
	)"

	[[ $test ]] && { printf "%s\n" "$script"; return; }

	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		DISPLAY="" ssh -X -t "$host" "$script"
	fi
}

tmpDirCreate() { mktemp -d -t "$tmpDirTemplate"; }

run "$@"

#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Helper commands for HashiCorp consul, nomad, and vault products.

Product commands: consul|nomad|vault

Common commands:  app|cert|config|install|remove|service|update
	resolve						resolve a service
	PRODUCT|all				commands for a product or all products
	status						show status for all products

Common options:
	-a,	 --api						server for API communication
	-cf, --config-file		configuration file to use in place og bootstrap-config.sh
	-cp, --config-prefix	configuration prefix to use, i.e. test
	-H,  --host HOST			comma separated list of hosts for the command
												aliases: active|all|clients|servers|1|2|3|4|5|6|first|second|third|fourth|fifth|sixth
	-is, --is-server			assume the hosts are servers"
}

usageVerbose()
{ 
	ScriptUsageEcho "
Other commands: cleanup
	ui								start the hashi-ui server and launch it

Other options:
	-nrs, --no-restart-service	do not restart services
	-nt, 	--no-token 						do not use a token for the command"
}

init()
{
	unset product
	products=( consul nomad vault )
	productUsage="consul|nomad|vault"
	binDir="/usr/local/bin"; IsPlatform entware && binDir="/opt/bin"
	certVolume="/mnt/p"; certVolumeWasMounted=""; [[ -e "$certVolume" ]] && certVolumeWasMount="true"
	certOptUsage="-e, --encrypt [DIR]		directory for PKI certificates\n	-ne, --no-encrypt		disable TLS encryption"
	configWhat="consul-vault-data local-certs local-credentials private-certs public-certs"
	unset sshAgentChecked
}

argStart() { unset -v api assumeServer configFile configFileArg configPrefix configPrefixArg hostArg noRestartService noToken; }

opt()
{
	case "$1" in
		--api|--api=*|-a|-a=*) ScriptOptGet api "$@";;
		--config-file|--config-file=*|-cf|-cf=*) ScriptOptGet "configFile" "config-file" "$@" && ScriptCheckFile "$configFile" && configFileArg=(--config-file "$configFile");;
		--config-prefix|--config-prefix=*|-cp|-cp=*) ScriptOptGet "configPrefix" "config-prefix" "$@" && configPrefixArg=(--config-prefix "$configPrefix");;
		--host|--host=*|-H|-H=*) ScriptOptGet hostArg host "$@";;
		--no-restart-service|-nrs) noRestartService="--no-restart-service";;
		--no-token|-nt) noToken="--no-token";;
		--is-server|-is) assumeServer="true";;
		*) return 1;;
	esac
}

argEnd()
{
	# basic configuration
	datacenter="$(ConfigGet "workgroup")"
	baseDomain="$(ConfigGet "baseDomain")"
	domain="$(ConfigGet "domain")"

	# port configuration
	consulHttpPort="8500" consulHttpsPort="8501"
	nomadHttpPort="4646" nomadHttpsPort="$nomadHttpPort"
	vaultHttpPort="8200" vaultHttpsPort="$vaultHttpPort"

	# product configuration - set product from command if possible
	if [[ $product ]]; then
		productInit "$product" || return
	else
		initConfig || return
	fi

	# set command specific forces
	unset forceEnvironment
	if [[ $force ]]; then
		if [[ "${commands[1]}" == @(configEnvironment) ]]; then forceEnvironment="true"
		fi
	fi

	return 0

}

cleanup()
{
	[[ ! $certVolumeWasMounted ]] && return
	certDirUnmountPrivate
}

#
# commands
#

cleanupCommand()
{
	local hosts; getHosts "localhost" || return

	for host in "${hosts[@]}"; do
		header "Cleanup ($host)"
		hostCleanup "$host" || return
	done
}

statusCommand()
{
	header "Consul"
	consul members || return
	echo

	header "Nomad"
 	nomad node status
 	echo
 	nomadVaultStatus
 	echo

 	header "Vault"
 	vault status
}

uiCommand()
{
	local product

	for product in "consul" "nomad"; do
		productInit "$product" || return
		export ${product}_ENABLE="true"
		export ${product}_ADDR="$(productVarGet "ADDR")"
		export ${product}_ACL_TOKEN="$(productVarGet "TOKEN")"	
		unset ${product}_HTTP_SSL; [[ "$(GetUriProtocol "${product}_ADDR")" == "https" ]] && export ${product}_HTTP_SSL="true"
	done

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# all commands
#

allUsage() { echot "\
Usage: $(ScriptName) all environment|status
Commands for all products."; }

allCommand() { usage; }
allEnvironmentCommand() { configEnvironmentAll; }

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# app commands
#

appUsage() { EchoWrap "Usage: $(ScriptName) app ls|node|server"; }
appArgStart() { unset app; product="consul"; }
appCommand() { usage; }

appLsUsage() { EchoWrap "Usage: $(ScriptName) app ls NAME\nList all applications."; }
appLsCommand() { consul kv get -recurse app | cut -d/ -f2 | sort | uniq; }

#
# app node commands
#

appNodeUsage()  { EchoWrap "Usage: $(ScriptName) app node [status|register|unregister](status)"; }
appNodeCommand() { appNodeStatusCommand; }

#
# app node status command 
#

appNodeStatusUsage()
{
	EchoWrap "Usage: $(ScriptName) app node status\nShow the applications that the specified host can run.

	-a,	--active		show active applications for the node"
}

appNodeStatusArgStart() { unset -v active; }

appNodeStatusOpt()
{
	case "$1" in
		--active|-a) active="--active";;
		*) return 1;;
	esac
}

appNodeStatusCommand() { ForAllHosts --brief appNodeStatus; }

appNodeStatus()
{
	local host="$(RemoveDnsSuffix "$1")"

	local app apps; IFS=$'\n' ArrayMake apps "$(verbose="--verbose" nomadNodeStatus "$host" | tgrep '^app\.' | cut -d" " -f1 | cut -d. -f2 | sort)" || return

	[[ ! $active ]] && { ArrayDelimit apps " "; return; }

	for app in "${apps[@]}"; do
		[[ "$app" == "apache-web" ]] && app="web"
		GetServers "$app" | ${G}grep --quiet "^$host." && printf "$app "
	done
	echo
}

#
# app node register commands
#

appNodeRegisterUsage() { EchoWrap "Usage: $(ScriptName) app register APP\nRegister an application with Consul and Nomad."; }
appNodeRegisterArgs() { ScriptArgGet "app" -- "$@"; shift; }

appNodeRegisterCommand()
{
	serviceVerify "nomad" || return
	
	hilight "Registering '$app' application in Consul..."
	consul kv put "app/$app/hosts/${HOSTNAME,,}" || return
	echo

	hilight "Registering '$app' application in Nomad..."
	
	local file="/etc/nomad.d/03_$app.hcl"
	[[ -f "$file" && ! $force ]] && return

 	cat <<-EOF | sudoc ${G}tee "$file" || return
		client {
		  meta { 
		    app.$app = "true" 
		  }
		}
	EOF

	serviceRestartLocal "nomad"
}

appNodeUnregisterUsage() { EchoWrap "Usage: $(ScriptName) app unregister APP\nUnregister an application in Consul and Nomad."; }
appNodeUnregisterArgs() { ScriptArgGet "app" -- "$@"; shift; }

appNodeUnregisterCommand()
{
	# Consul
	hilight "Unregistering '$app' application in Consul..."
	consul kv delete -recurse "apps/wire-guard/${HOSTNAME,,}" || return
	echo

	# Nomad
	local file="/etc/nomad.d/03_$app.hcl"; [[ ! -f "$file" ]] && return
	hilight "Unregistering '$app' application in Nomad..."
	sudoc rm "$file" && serviceVerify "nomad" && serviceRestartLocal "nomad"
}

#
# app server commands
#

appServerUsage() { EchoWrap "Usage: $(ScriptName) app server [not] [all|active|available](all) APP\nShow servers for an application."; }
appServerCommand() { appServerAllCommand; }
appServerArgs() { ScriptArgGet "app" -- "$@"; shift; }
appServerNotCommand() { usage; }

appServerActiveUsage() { EchoWrap "Usage: $(ScriptName) app server up APP\nShow servers where the application is actively running."; }
appServerActiveCommand() { appServerActive "$app" | sort -V; }

appServerAllUsage() { EchoWrap "Usage: $(ScriptName) app server all APP\nShow all servers that can host the application."; }
appServerAllCommand() { appServerAll "$app" | sort -V; }

appServerAvailableUsage() { EchoWrap "Usage: $(ScriptName) app server available APP\nShow available servers for the application.  These servers are accessible and may be running the applciation."; }
appServerAvailableCommand() { appServerAvailable "$app"; }

appServerNotActiveUsage() { EchoWrap "Usage: $(ScriptName) app server not active APP\nShow servers where the application is not currently running."; }
appServerNotActiveCommand() { appServerNotActive "$app"; }

appServerNotAvailableUsage() { EchoWrap "Usage: $(ScriptName) app server not available APP\nShow unavailable servers for the application.  These servers are down and are not available to run the applciation"; }
appServerNotAvailableCommand() { appServerNotAvailable "$app"; }

appServerActive() { resolveName "$1" --all; }
appServerAll() { local names; names="$(consul kv get -recurse "app/$1/hosts" | cut -d/ -f4 | cut -d: -f1)" && DnsResolveBatch $names; }
appServerAvailable() { local hosts; hosts="$(appServerAll "$1")" && IsAvailableBatch $hosts | sort -V; }
appServerNotAvailable() { local all available; available="$(appServerAvailable "$1")" && all=( $(appServerAll "$1") ) && ArrayRemove all "$available" && ArrayDelimit all "\n" | RemoveEmptyLines | sort -V; }
appServerNotActive() { local all active; active="$(appServerActive "$1")" && all=( $(appServerAll "$1") ) && ArrayRemove all "$active" && ArrayDelimit all "\n" | RemoveEmptyLines | sort -V; }

#
# certificate commands
#

certUsage()
{
	EchoWrap "Usage: $(ScriptName) cert copy|make|status

	copy		copy public certificates
	make		make certificates
	status	show certificate status

	$certOptUsage"
}

certArgStart() { encrypt="true"; }
certOpt() { encryptOpt "$@"; }
certCommand() { usage; }

#
# cert copy commands
#

certCopyUsage() { echot "\
Usage: $(ScriptName) cert copy all|$productUsage
Copy public certificates to the public installation location.\n\n  $certOptUsage"; }

certCopyCommand() { usage; }
certCopyAllCommand() { certCopyPublic "consul" && certCopyPublic "nomad" && certCopyPublic "vault"; }
certCopyConsulCommand() { certCopyPublic "consul"; }
certCopyNomadCommand() { certCopyPublic "nomad"; }
certCopyVaultCommand() { certCopyPublic "vault"; }

# certCopyPublic PRODUCT - copies public certificates from the private certificate directory to the public certificate directory
certCopyPublic()
{
	local product="$1"

	# initialization
	initConfig "$product" || return
	certInit "$product" || return

	# source directory (private certificates)
	local src; src="$(certDirPrivate | certDirSuffix "$product")" || return
	local cert certs=( "$ca" "$certCli" "$certCliKey" ); [[ $caAuto ]] && certs+=( "$caAuto" )

	certValidate "$src" "${certs[@]}" || return

	# destination directory (public certificates)
	local dest; dest="$(certDirPublic | certDirSuffix "$product")" || return
	${G}mkdir --parents "$dest" || return

	# return if the source (private) and destination (public) locations are the same
	[[ "$src" == "$dest" ]] && return

	# return if the certificates exist in the destination location
	[[ ! $force ]] && certExists "$dest" "${certs[@]}" && return

	# copy the certificates
	echo "Copying ${product^} public certificates to '$(FileToDesc "$dest")'..."
	for cert in "${certs[@]}"; do
		copyFile "$src/$cert" "$dest" || return
	done
}

#
# Certificate Make Command
#

certMakeUsage() { echot "\
Usage: $(ScriptName) cert make all|$productUsage [server]
Create certificates required for HashiCorp products.\n\n  $certOptUsage"; }

certMakeArgEnd() { [[ ! $encrypt ]] && MissingOption "encrypt"; return 0; }
certMakeCommand() { usage; }
certMakeAllCommand() { certMake "consul" && certMake "nomad" && certMake "vault"; }
certMakeConsulCommand() { certMake "consul"; }
certMakeNomadCommand() { certMake "nomad"; }
certMakeVaultCommand() { certMake "vault"; }
certMakeConsulServerCommand() { forAllHosts certMakeConsulServer; }
certMakeVaultServerCommand() { forAllHosts certMakeVaultServer; }

# certMakeCd PRODUCT - mount and change to the private certificate directory for the product
certMakeCd()
{
	local product="$1"; certInit "$product" || return
	local dir; dir="$(certDirPrivate | certDirSuffix "$product")" && sudoc ${G}mkdir --parents "$dir" && command cd "$dir"
}

# certMakeCp CERT... DEST - copy certificates to the destination directory
# - the certificates files are assumed to be relative, so change in to the private certifcate directory first
# - if a certificate file does not exist it is silently skipped
certMakeCp()
{
	! certs && return
	certMakeCd "$product" && FileCommand cp "$@"
}

# certMakeDnsArgs NAMES - return additional DNS name arguments for the comma separated list of names
certMakeDnsArgs()
{
	local args name names=(); StringToArray "$1" "," "names"

	for name in "${names[@]}"; do
		args+="--additional-dnsname=$(serviceDnsName "$name") --additional-dnsname=$(serviceDnsNameShort "$name") "
	done

	echo "$(RemoveSpaceTrim "$args")"	
}

# certMakeServer PRODUCT HOST [DEST] [CERT_ARGS...] - make server certificate for product.  Optionally copy it
#   to the destination directory.   CERT_ARGS allow for additional (alternate) names using -additional-ipaddress="IP"
#   or -additional-dnsname="DNS"
certMakeServer()
{
	local product="$1" host="$2"; shift 2; certMakeCd "$product" || return
	local dest; [[ -d "$1" ]] && { dest="$1"; shift; }
	local cert="$product-server-$host.pem"
	local key="$product-server-$host-key.pem"

	# initialzie
	certValidate "$ca" "$caKey" || return

	# create the certificate
	if ! certExists "$cert" "$key"; then
		hilight "Creating a ${product^} server certificate for $host..."

		# remove any existing temporary certs
		rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

		# create the cert
		local ip; ip="$(GetIpAddress "$host")" || return
		local fqdn; fqdn="$(hostFqdn "$host")" || return

		RunLog consul tls cert create -server \
			-dc="$datacenter" \
			-domain="$baseDomain" \
			-ca="$ca" \
			-key="$caKey" \
			-additional-ipaddress="$ip" \
			-additional-dnsname="$fqdn" \
			$@ \
			-node="$host" \
			-days="3650" || return

		# rename the temporary cert
		mv "$datacenter-server-$baseDomain-0.pem" "$cert" || return
		mv "$datacenter-server-$baseDomain-0-key.pem" "$key" || return
	fi

	# copy the certificates
	if [[ $dest ]]; then
		cp "$cert" "$dest/$certServer" || return
		cp "$key" "$dest/$certServerKey" || return
	fi
}

# certMakePRODUCTServer HOST [DIR] - make a server certificate
certMakeConsulServer() { certMakeServer "consul" "$@" "$(certMakeDnsArgs "consul")"; }
certMakeVaultServer() { certMakeServer "vault" "$@" "$(certMakeDnsArgs "vault,active.vault,standby.vault")"; }

certMakeNomadServer()
{
	local product="nomad" host="$1"; shift 1; certMakeCd "$product" || return
	local dest; [[ -d "$1" ]] && { dest="$1"; shift; }

	certValidate "$ca" "$caKey" || return
	certExists "$certServer" "$certServerKey" && return

	hilight "Creating the Nomad server certificates..."

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > "cfssl.json" || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(ArrayDelimit joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -config="cfssl.json" -hostname="$hosts" - | cfssljson -bare "nomad-server" || return

	# copy the certificates
	if [[ $dest ]]; then
		cp "$certServer" "$dest/$certServer" || return
		cp "$certServerKey" "$dest/$certServerKey" || return
	fi
}

# certMake PRODUCT - make certificates for the product.  All of the following certMake functions are should only be called from certMake.
certMake()
{	
	local product="$1"; certMakeCd "$product" || return
	RunFunction "cert" "Make${product^}" || return
}

certMakeCa()
{
	certExists "$ca" "$caKey" && return
	hilight "Creating the ${product^} certificate authority for $baseDomain..."

	# create the cert - name constraint required for HTTPS GUI
	consul tls ca create -domain="$baseDomain" -name-constraint || return

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

certMakeCli()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certCli" "$certCliKey" && return
	hilight "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-days="3650" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

# certMake - product specifics

certMakeConsul()
{
	# install consul to create certificates
	! InPath "consul" && { inst "consul" || return; }

	# create the certificates
	certMakeCa && certMakeCli && certMakeConsulCaAuto
}

# certMakeConsulCaAuto - get the auto generated Consul certficate authority.   This CA
# is used on Consul clients and is needed on the Consul client to access the Consul API
# from other programs like Nomad, curl, or wget.
certMakeConsulCaAuto()
{
	certValidate "$ca" || return
	certExists "$caAuto" && return

	header "Get Consul Certificates"
	hilight "Getting the automatic certificate authority..."

	! InPath "consul-k8s" && { inst "consul-k8s" || return; }

	consul-k8s get-consul-client-ca \
		--server-addr "$(productGetServer "consul")" \
		--server-port "$consulHttpsPort" \
		--ca-file="$ca" \
		--output-file "$caAuto" || return
}

certMakeNomad()
{
	# install cfssl to create certificates
	! InPath "cfssl" && { inst "cfssl" || return; }

	# create certificates
	certMakeNomadCa || return
	certMakeNomadServer || return
	certMakeNomadClient || return
	certMakeNomadCli || return
}

certMakeNomadCa()
{
	certExists "$ca" "$caKey" && return
	hilight "Creating the Nomad certificate authority..."
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca
}

certMakeNomadCli()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certCli" "$certCliKey" && return
	hilight "Creating the Nomad CLI certificate..."
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-cli
}

certMakeNomadClient()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certClient" "$certClientKey" && return

	hilight "Creating the Nomad client certificate..."
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -config=cfssl.json -hostname="client.global.nomad,localhost,127.0.0.1" - | cfssljson -bare nomad-client
}

certMakeVault()
{
	# install consul to create certificates
	! InPath "vault" && { inst "vault" || return; }

	# create the certificates
	certMakeCa && certMakeCli
}

#
# cert status command
#

certStatusUsage()
{
	EchoWrap "Usage: $(ScriptName) cert status
Show certificate status.

	-P,	--private		show private certificate status by mounting the private certificate directory
	-p,	--public		show public certificate status by mounting the public certificate directory

Certification locations:
  local - certificate directory for command line clients (i.e. /opt/hashi/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT or /opt/PRODUCT/cert)
  service - certificate directory for services (i.e. /opt/PRODUCT/cert/)
  private - the root private certificate directory from the --encrypt option or certificateDir configuration
  public - public certificate directory on the installation share"; }

certStatusArgStart() { unset private public; }

certStatusOpt()
{
	case "$1" in
		-P|--private) private="true";;
		-p|--public) public="true";;
		*) return 1;;
	esac
}

certStatusCommand() { certStatus; }

certStatus() { certStatusConsul && certStatusNomad && certStatusVault && certStatusPublic && certStatusPrivate; }
certStatusConsul() { certStatusProduct "consul"; }
certStatusNomad() { certStatusProduct "nomad"; }
certStatusVault() { certStatusProduct "vault"; }

certStatusShow()
{
	local desc="$1" dir="$2"
	header "$desc Certificates"
	hilight "location: $(FileToDesc "$dir")"
	command cd "$dir" && tree -L 2 --prune --noreport
	echo
}

certStatusProduct()
{
	local product="$1"

	# initialization
	initConfig "$product" || return
	certInit "$product" || return

	# service
	if [[ -d "$certDirService" ]]; then
		certStatusShow "$(UpperCaseFirst "$product") Service" "$certDirService" || return
	fi

	local certDirLocal="$(certDirLocal "$product")" || return
	if [[ "$certDirLocal" != "$certDirService" && -d "$certDirLocal" ]]; then
		certStatusShow "$(UpperCaseFirst "$product") CLI" "$certDirLocal" || return
	fi
}

# certStatusPublic - show status for the public certificate directory on the installation file server
certStatusPublic()
{
	[[ ! $public ]] && return
	local dir; dir="$(certDirPublic | certDirSuffix "")" && certStatusShow "Public" "$dir"
}

# certStatusPrivate - show status for the private certificate directory on the encrypted volume
certStatusPrivate()
{
	[[ ! $private ]] && return
	local dir; dir="$(certDirPrivate | certDirSuffix "")" && certStatusShow "Private" "$dir"
}

#
# config commands
#

configUsage() { echot "Usage: $(ScriptName) config deploy|get|hosts|remove|set\nConfigure products."; }
configCommand() { usage; }
configHostsUsage() { echot "Usage: $(ScriptName) config servers\nReturn the list of hosts."; }
configHostsCommand() { getHosts; ArrayDelimit hosts $'\n'; }

# config deploy commands

configDeployUsage() { echot "\
Usage: $(ScriptName) config deploy $productUsage FILE
Deploy a configuration file."; }

configDeployArgStart() { unset file; }
configDeployArgs() { ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift; }

configDeployCommand() { usage; }
configDeployConsulCommand() { forAllHosts configDeploy "consul" "$file"; }
configDeployNomadCommand() { forAllHosts configDeploy "nomad" "$file"; }
configDeployVaultCommand() { forAllHosts configDeploy "vault" "$file"; }

# configDeploy PRODUCT FILE HOST - deploy a product configuration file to a host
configDeploy()
{
	local product="$1" file="$2" host="$3"
	serviceConfigCopy "$product" "$host" "$file" && serviceRestart "$product" "$host"
}

# config environment commands

configEnvironmentUsage() { echot "\
Usage: $(ScriptName) config environment [all|$productUsage|test|reset](all)
Show the product environment variables.  This command is typically called 
with ScriptEval to update current environment.

	-se, --suppress-errors			supress certificate not found errors"; }

configEnvironmentArgStart() { unset -v suppressErrors; }

configEnvironmentOpt()
{
	case "$1" in
		-se|--suppress-errors) suppressErrors="true";;
		*) return 1;;
	esac
}

configEnvironmentCommand() { configEnvironmentAll; }
configEnvironmentAllCommand() { configEnvironmentAll; }
configEnvironmentResetCommand() { echo "unset CONSUL_HTTP_TOKEN VAULT_TOKEN NOMAD_TOKEN"; }

configEnvironmentConsulCommand() { productEnvironment "consul"; }
configEnvironmentNomadCommand() { productEnvironment "nomad"; }
configEnvironmentVaultCommand() { productEnvironment "vault"; }

# environment aliases commands
configEnvironmentProdCommand() { configPrefix="" configEnvironmentCommand; }
configEnvironmentTestCommand() { configPrefix="test" configEnvironmentCommand; }

configEnvironmentAll()
{
	# initialize consul for product lookups
	productIsInstalled "consul" && { productInit "consul" || return; }

	local product
	for product in "${products[@]}"; do		
		! productIsInstalled && continue
		productEnvironment || return; echo
	done
}

# config get command

configGetUsage() { echot "\
Usage: $(ScriptName) config get VAR
Get a configuration variable."; }

configGetArgStart() { unset varName; }
configGetArgs() { ScriptArgGet "varName" "var" -- "$@"; shift; }
configGetCommand() { configGet "$varName"; }

# configExists VAR
configExists() { [[ $(configGet "$var") ]]; }

# configGet VAR
configGet()
{
	local var="hashi$(UpperCaseFirst "$configPrefix")$(UpperCaseFirst "$1")"
	ConfigInit "$configFile" && ConfigExists "$var" && ConfigGet "$var"
}

# configGetArray VAR [ARRAY_NAME](VAR)
configGetArray()
{
	local var="$1" 
	local arrayName="${2:-$var}"
	StringToArray "$(configGet "$var")" "," "$arrayName"
}

# configGetList VAR
configGetList()
{
	local var="$1" a
	StringToArray "$(configGet "$var")" "," "a"
}

# configServer - return the first server for the current product
configServer()
{
	local var="servers"; [[ "$product" == "vault" ]] && var="VaultServers"
	local server="$(configGet "$var" | GetWord - "1" ",")";
	local domain="$(ConfigGet "domain")"
	AddDnsSuffix "$server" "$domain"
}

# configServers - set hosts to an array of all of the servers in the configuration
configServers()
{
	local servers; configGetArray "servers"
	local clients; configGetArray "clients"
	local vaultServers; configGetArray "VaultServers" "vaultServers"
	hosts=(); ArrayAppend --remove-dups hosts servers clients vaultServers
}

# Config Remove Commands

configRemoveUsage() { echot "\
Usage: $(ScriptName) config remove all|$productUsage
Remove all local and remote configuration.

	-w, --what=C1[,C2...] configuration to remove: $configWhat"; }

configRemoveArgStart() { unset whatArg yes; }

configRemoveOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

configRemoveOptArgEnd()
{
	[[ ! $what ]] && MissingOption "what"

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' configuration from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

configRemoveCommand() { usage; }
configRemoveAllCommand() { removeConfig "vault" && removeConfig "nomad" && removeConfig "consul"; }
configRemoveConsulCommand() { removeConfig "consul"; }
configRemoveNomadCommand() { removeConfig "nomad"; }
configRemoveVaultCommand() { removeConfig "vault"; }

# removeConfid PRODUCT - remove configuration for the product
removeConfig()
{
	local product="$1"; certInit "$product" || return; ConfigInit || return

	if [[ ! $force || ! $yes ]]; then
		ScriptErr "To permanently delete all $product local and remote configuration and certificates for $baseDomain $configDesc, --force and --yes are required"
		return 1
	fi

	header "Remove $(ProperCase "$product") Configuration"

	# Vault data
	if [[ "$product" == "vault" ]] && whatCheck "consul-vault-data" && quiet="--quiet" productInit "consul"; then
		hilight "Removing Vault data from Consul..."
		RunLog consul kv delete -recurse "vault/"
	fi

	# certificates (local, private, and public)	
	local dir
	whatCheck "local-certs" && { hilight "Removing local certificates..."; removeLocalCerts || return; }
	whatCheck "private-certs" && { hilight "Removing private credentials..."; dir="$(certDirPrivate | certDirSuffix "$product")" || return; removeDir "$dir"; }
	whatCheck "public-certs" && { hilight "Removing public credentials..."; dir="$(certDirPublic | certDirSuffix "$product")" || return; removeDir "$dir"; }

	# credentials (local)
	whatCheck "local-credentials" && { hilight "Removing local credentials..."; credDelete "all" || return; }

	# delete host certificates
	local host hosts; getHosts "all" || return
	for host in "${hosts[@]}"; do
		hilight "Removing $host certificates and credentials..."
		sshRun -q -t "$host" bash -i "credential rm \"$(credPath)\" all ${globalArgs[@]} && rm -fr \"$(certDirSuffix "$product" "/opt/hashi")\"" || return
	done
}

removeLocalCerts()
{
	local product="${1:-$product}"; certInit "$product" || return

	removeDir "$(certDirLocal "$product")" || return

	if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
		RunLog sudoc rm -f "$certStoreCa" "$certStoreCaAuto" || return
		RunLog sudoc update-ca-certificates || return
	fi
}

#
# config set command
#

configSetUsage() { echot "\
Usage: $(ScriptName) config local|remote [all|$productUsage](all)
Set local or remote credential configuration.

	-F,	--from MANAGER	first credential manager, defaults to local or remote
	-T,	--to MANAGER		second credential manager, defaults to local or remote"; }

configSetLocalArgStart() { from="remote" to="local"; }
configSetRemoveArgStart() { from="local" to="remote"; }

configSetOpt() 
{
	case "$1" in
		-F|--from|-F=*|--from=*) ScriptOptGet from "$@";;
		-T|--to|-T=*|--to=*) ScriptOptGet to "$@";;
		*) return 1
	esac
}

configSetCommand() { usage; }

configSetLocalCommand() { configSetLocalAllCommand; }
configSetLocalAllCommand() { configSetLocalConsulCommand && configSetLocalNomadCommand && configSetLocalVaultCommand; }
configSetLocalConsulCommand() { configSetLocal "consul"; }
configSetLocalNomadCommand() { configSetLocal "nomad"; }
configSetLocalVaultCommand() { configSetLocal "vault"; }

configSetRemoteCommand() { configSetRemoteAllCommand; }
configSetRemoteAllCommand() { configSetRemoteConsulCommand && configSetRemoteNomadCommand && configSetRemoteVaultCommand; }
configSetRemoteConsulCommand() { configSetRemote "consul"; }
configSetRemoteNomadCommand() { configSetRemote "nomad"; }
configSetRemoteVaultCommand() { configSetRemote "vault" && vaultTokenSetRemote; }

configSetLocal() { vaultTokenGetRemote && configMirror "$from" "$to" "$1"; }
configSetRemote() { configMirror "$from" "$to" "$1"; }

# configMirror FROM TO PRODUCT - mirror configuration credentials for a product
configMirror()
{
	local from="$1" to="$2" product="$3"

	# check if the configuration already exists in the TO credential store
	local check="token"; [[ "$product" == "vault" ]] && check="key5"
	[[ ! $force ]] && test="" RunLog credential exists "$(credPath)" "$check" --manager="$to" && return

	# get descriptions
	local fromDesc; fromDesc="$(credential manager name --manager="$from")"
	local toDesc; toDesc="$(credential manager name --manager="$to")"

	# mirror the credentials
	hilight "Mirroring ${product^} credentials from '$fromDesc' to '$toDesc'..."
	RunLog credential mirror --from="$from" --to="$to" "$(credPath)" --force "${globalArgs[@]}" || return
}

#
# config status command
#

configStatusCommand()
{
	local product term="$TERM"; [[ ! $term ]] && term="xterm-256color"

	{
		#(productVarGet "CACERT" | GetFilePath | FileToDesc
		hilight "product-ui-certificate-token-config-domain"

		for product in "${products[@]}"; do			
			! productIsInstalled && continue

			suppressErrors="true" productInit "$product" || return

			local ui="$(productVarGet "ADDR")"			
			local cert="false"; [[ -f "$(productVarGet "CACERT")" ]] && cert="true"
			local token="false"; [[ $(productVarGet "TOKEN") ]] && token="true"
			local prefix="$(productVarGet "CONFIG")"; prefix="${prefix:-prod}"
			local domain="$(productVarGet "DOMAIN")"

			[[ "$cert" == "true" && "$product" == "consul" ]] && { productVarGet "CACERT" | grep -q "auto" && cert="client" || cert="server"; }

			echo "${RESET}${RESET}$product-$ui-$cert-$token-$prefix-$domain" # add resets to line up the columns

		done

	} | column -c $(tput cols -T "$term") -t -s-
}

#
# consul command
#

consulUsage() { EchoWrap "Usage: $(ScriptName) consul acl|agent|api|backup|environment|reload|restore|service|status\nConsul commands."; }
consulArgStart() { product="consul"; }
consulCommand() { usage; }
consulEnvironmentCommand() { productEnvironment "$product"; }
consulReloadCommand() { forAllHosts consulReloadDo; }
consulStatusCommand() { consul members; }

consulBackupCommand()
{
	local file="$(GetDateStampNext "consul.$domain" "snap")"
	RunLog consul snapshot save "$TEMP/$file" || return # errors with operation not supported saving to SMB shares
	mv "$TEMP/$file" .  
}

consulReloadDo() { productInit "consul" "$1" && consul reload; }

#
# consul acl command
#

consulAclUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent|create|policy|token\nConsul ACL commands."; }
consulAclCommand() { usage; }

#
# consul acl agent command
#

consulAclAgentUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent allow|create|deny|deploy\nConfigure the agent ACL system."; }
consulAclAgentCommand() { usage; }

consulAclAgentAllowUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent allow\nChange the default ACL policy to allow."; }
consulAclAgentAllowCommand() { forAllHosts consulAclAgentAllow; }

consulAclAgentCreateUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent create\nCreate agent ACL policies and tokens.  \
If this is a new agent, use --api to specify the API server.  For example:\n
hashi consul acl agent create --api=pi1 --host=pi5"; }
consulAclAgentCreateCommand() { consulApiCheck && forAllHosts consulAclAgentCreate; }

consulAclAgentDenyUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent deny\nChange the default ACL policy to deny."; }
consulAclAgentDenyCommand() { forAllHosts consulAclAgentDeny; }

consulAclAgentDeployUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent deploy\nDeploy the agent ACL tokens to the 02_acl_tokens.hcl configuration file."; }
consulAclAgentDeployCommand() { forAllHosts consulAclAgentDeploy; }

# consul acl agent helper

# consulAclAgentDefault HOST - change the ACL mode on a host to allow
consulAclAgentAllow() { local host="$1"; consulAclAgentDefaultPolicy "allow"; }
consulAclAgentDeny() { local host="$1"; consulAclAgentDefaultPolicy "deny"; }

consulAclAgentDefaultPolicy()
{
	local newPolicy="$1"; serviceVars "consul" || return
	local currentPolicy; currentPolicy="$(serviceConfigVarGet "default_policy" "$product" "$host")" || return

	# return if we don't need to change the default ACL policy
	[[ ! $force && "$currentPolicy" == "$newPolicy" ]] && return

	# change the default ACL policy

	printf "Changing the default ACL policy on $host from $currentPolicy to $newPolicy..."

	scriptRun "$host" "$(cat <<-EOF
		sudoc sed -i "s/default_policy = \"$currentPolicy\"/default_policy = \"$newPolicy\"/" "$productConfigFile" || exit
		sudoc systemctl restart "$product" --no-block || exit
		EOF
	)" || return

	echo "done"
}

# consulAgentAclCreate HOST - create the policies and tokens for a consul agent
consulAclAgentCreate()
{
	local host="$1"

	# create default token for DNS requests
	if ! consulAclTokenExists "dns-requests"; then
		consulAclCreate "dns-requests" "$(cat <<-EOF
			node_prefix "" {
			  policy = "read"
			}
			service_prefix "" {
			  policy = "read"
			}
			EOF
		)" || return
	fi

	# create the ACL policy for the host
	if ! consulAclTokenExists "agent-$host"; then
		consulAclCreate "agent-$host" "$(cat <<-EOF
			node "$host" {
			  policy = "write"
			}		
			EOF
		)" || return
	fi

	return 0
}

# consulAclAgentDeploy HOST - deploy ACL tokens to a host
consulAclAgentDeploy()
{
	local host="$1"

	# create the agent ACL's
	consulAclAgentCreate "$host" || return
	local defaultToken; defaultToken="$(consulAclTokenGetSecret "dns-requests")" || return
	local agentToken; agentToken="$(consulAclTokenGetSecret "agent-$host")" || return
	
	# deploy the configuration file
	serviceConfigCopyText "consul" "$host" "02_acl_tokens.hcl" "$(cat <<-EOF
		acl {
		  tokens {
		    default = "$defaultToken"
		    agent = "$agentToken"
		  }
		}
		EOF
	)"
}

#
# consul acl create command
#

consulAclCreateUsage() { echot "\
Usage: $(ScriptName) consul acl create [NAME] [DEFINITION]
Create a Consul ACL."; }

consulAclCreateArgStart() { unset name def; }

consulAclCreateArgs()
{
	ScriptArgGet "name" -- "$@"; shift
	ScriptArgGet "def" -- "$@"; shift
}

consulAclCreateCommand() { consulAclCreate "$name" "$def"; }

#
# consul acl policy commands
#

consulAclPolicyUsage() { echot "\
Usage: $(ScriptName) consul acl policy [get|ls|rm](ls) [NAME]
Manage Consul ACL policies."; }

consulAclPolicyArgStart() { unset name; }
consulAclPolicyCommand() { consulAclPolicyLsCommand; }

consulAclPolicyGetArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclPolicyGetCommand() { consulAclPolicyGetId "$name"; }

consulAclPolicyLsUsage() { echot "Usage: $(ScriptName) consul acl list\nList all Consul ACL policy names."; }
consulAclPolicyLsCommand() { consulAclPolicyLs; }

consulAclPolicyRmArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclPolicyRmCommand() { consulAclPolicyRm "$name"; }

#
# Consul ACL Token Command
#

consulAclTokenUsage() { echot "\
Usage: $(ScriptName) consul acl token [get|ls|rm](ls)
Manage Consul ACL tokens."; }

consulAclTokenArgStart() { unset name; }
consulAclTokenCommand() { consulAclTokenLsCommand; }

consulAclTokenGetUsage() { echot "Usage: $(ScriptName) consul acl token get [secret]"; }
consulAclTokenGetArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclTokenGetCommand() { consulAclTokenGetId "$name"; }
consulAclTokenGetSecretCommand() { consulAclTokenGetSecret "$name"; }

consulAclTokenLsUsage() { echot "Usage: $(ScriptName) consul acl list\nList all Consul ACL token descriptions."; }
consulAclTokenLsCommand() { consulAclTokenLs; }

consulAclTokenRmArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclTokenRmCommand() { consulAclTokenRm "$name"; }

# Consul ACL Helper

consulAclPolicyLs() { consul acl policy list -format=json | jq '.[].Name' | RemoveQuotes | sort; }
consulAclTokenLs() { consul acl token list | grep "^Description:" | cut -d: -f2 | tr -s " " | cut -d" " -f2 | sort; }

# consulAclCreate NAME DEF - create an ACL with the specified name and definition.   Return the secret token for the policy.
consulAclCreate()
{
	local name="$1" def="$2"
	consulAclPolicyCreate "$name" "$def" && consulAclTokenCreate "$name"
}

# consulAclDelete NAME - delete the ACL policy and token
consulAclDelete() { local name="$1"; consulAclPolicyRm "$name" && consulAclTokenRm "$name"; }

# consulAclPolicyCreate NAME DEF - create a policy with the specified name and definition
consulAclPolicyCreate()
{
	local name="$1" def="$2"
	consulAclPolicyExists "$name" && { ScriptErr "the consul ACL policy '$name' already exists"; return 1; }
	echo "$def" | RunLog consul acl policy create -name "$name" -rules -
}

# consulAclPolicyExists NAME - return true if the specified policy exists
consulAclPolicyExists()
{
	local name="$1"
	[[ "$(consul acl policy list -format=json | jq ".[] | select(.Name == \"$1\").Name" | RemoveQuotes)" == "$name" ]]
}

# consulAclPolicyGetId NAME - get the policy ID for the specified policy name
consulAclPolicyGetId()
{
	local name="$1" id; id="$(consul acl policy list -format=json | jq '.[] | select(.Name == "'"$name"'").ID' | RemoveQuotes	)" || return
	consulValidateId "$id" "$name" "policy"
}

# consulAclPolicyRm NAME - delete the specified policy
consulAclPolicyRm()
{
	local name="$1"; ! consulAclPolicyExists "$name" && return

	hilight "Deleting ACL policy $name..."
	RunLog consul acl policy delete -name "$name"
}

# cosulTokenExists NAME - return true if the tokenexists
consulAclTokenExists()
{
	local name="$1"
	[[ "$(consul acl token list -format=json | jq ".[] | select(.Description == \"$name\").Description" | RemoveQuotes)" == "$name" ]]
}

# consulAclTokenGetSecret NAME - get the token Secret ID with the specified name
consulAclTokenGetSecret()
{
	local name="$1"
	! consulAclTokenExists "$1" && { ScriptErr "token '$name' does not exists"; return 1; }
	consul acl token read -accessor-id "$(consulAclTokenGetId "$name")" | grep "SecretID" | cut -d: -f 2 | RemoveSpace
}

# consulAclPolicyGetId NAME - get the token accessor ID for the specified token name
consulAclTokenGetId()
{
	local name="$1" id; id="$(consul acl token list -format=json | jq '.[] | select(.Description == "'"$name"'").AccessorID' | RemoveQuotes	)" || return
	consulValidateId "$id" "$name" "token"
}

# consulAclTokenCreate NAME [POLICY] - create a token with the specified description that has the permission to the specified policy
consulAclTokenCreate()
{
	local name="$1" policy="${2:-$1}"
	consulAclTokenExists "$name" && { ScriptErr "the consul ACL token '$name' already exists"; return 1; }
	RunLog consul acl token create -description "$name" -policy-name "$policy"
}

# consulAclTokenRm NAME - delete the token with the specified name
consulAclTokenRm()
{
	local name="$1"; ! consulAclTokenExists "$name" && return
	local id; id="$(consulAclTokenGetId "$name")" || return

	hilight "Deleting ACL token $name..."
	RunLog consul acl token delete -accessor-id "$id"
}

#
# consul api Command
#

consulApiUsage() { echot "Usage: $(ScriptName) consul api [check|put] PATH -- [curl arguments]\nCall the Consul API.  For example:\nhashi consul api /status/leader"; }
consulApiArgStart() { unset path; }
consulApiArgs() { [[ "$command" == "consulApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

consulApi() { RunLog curl --silent --show-error --header "X-Consul-Token: $CONSUL_HTTP_TOKEN" "$CONSUL_HTTP_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }
consulApiCommand() { consulApi "$path" "${otherArgs[@]}"; }

consulApiPutCommand() { consulApiPut "$path" "${otherArgs[@]}"; }
consulApiPut() { consulApi "$@" --request PUT; }

consulApiCheckCommand() { consulApiCheck; }
consulApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" && { [[ ! $quiet ]] && ScriptErr "consul server $host is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" && { [[ ! $quiet ]] && ScriptErr "consul server $host is not available on port $port"; return 1; }	

	# check api
	consulApi "/status/leader" 2> /dev/null | RemoveQuotes | RemovePort | IsIpAddress && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the consul API at $(productVarGet "ADDR") is not available"; consulApi "/status/leader"; return 1; }

	return 0
}

#
# consul agent command
#

consulAgentUsage() { echot "Usage: $(ScriptName) consul agent [checks](checks)"; }
consulAgentCommand() { consulAgentChecksCommand; }
consulAgentChecksUsage() { echot "Usage: $(ScriptName) consul agent checks\nShow all health checks on the agent."; }
consulAgentChecksCommand() { consulApi "/agent/checks" | jq '.[].CheckID' | RemoveQuotes | sort; }

#
# consul service commands
#

consulServiceInit() { unset file; }

consulServiceUsage() { echot "\
Usage: $(ScriptName) consul service [add|clean|ls|rm](ls)
Consul service commands."; }

consulServiceCommand() { consulServiceLsCommand; }
consulServiceLsCommand() { consulServiceLs; }

#
# consul service add command
#

consulServiceAddUsage() { echot "\
Usage: $(ScriptName) consul service add FILE
Add a Consul service using the service definition in FILE.

- FILE must be JSON or HCL
- if FILE is HCL, the CLI is used to perform the registeration, which allows HCL but does not allow script checks
- if FILE is JSON
  - curl is used to perform the registeration, which allows script checks
  - the JSON must contain a service attribute to provide future compatibility with CLI registration"; }

consulServiceAddArgs() { ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift; }

consulServiceAddCommand()
{
	local id; id="$(consulServiceFileGetId "$file")" || return
	local type; type="$(configFileValidate "$file")" || return

	# create the service ACL
	if ! consulAclTokenExists "service-$id"; then		
		consulAclCreate "service-$id" "$(cat <<-EOF
			service "$id" {
			  policy = "write"
			}
			EOF
		)" || return
	fi
	local token; token="$(consulAclTokenGetSecret "service-$id")" || return

	# add the service ACL token to the service file
	local f; f="$(${G}mktemp -t "hashi.service.XXXX.hcl")" || return
	if [[ "$type" == "json" ]]; then
		cat "$file" | jq '.[]' | sed "s/\"token\": \".*\"/\"token\": \"$token\"/" > "$f" || return
	else
		cat "$file" | sed "s/token = \".*\"/token = \"$token\"/" > "$f" || return
	fi

	# ensure the ACL token was added to the service file
	if ! grep --quiet "\"$token\"" "$f"; then
		ScriptErr "the token parameter was not found in the service file"
		return 1
	fi

	# register the service using curl for JSON as the CLI does not allow script checks (get Invalid check message)
	[[ $verbose ]] && cat "$f"
	if [[ "$type" == "json" ]]; then
		consulApiPut "/agent/service/register?replace-existing-checks=true" --data @"$f" || return
	else
		RunLog consul services register "$f" || return
	fi

	# cleanup the file
	rm -f "$f"	

	return 0
}

#
# consul service clean command
#

consulServiceCleanUsage() { echot "Usage: $(ScriptName) consul service clean\nCleanup orphaned service policies and tokens."; }

consulServiceCleanCommand()
{
	local name id policies tokens IFS=$'\n'

	# find orphan policies
	policies=(
		$(FileLeft \
			<(consulAclPolicyLs | grep "^service-" | sed 's/service-//') \
			<(consulServiceLs))
	)

	# delete orphan policies
	for name in "${policies[@]}"; do
		echo "Deleting orphan policy 'service-$name'..."
		id="$(consulAclPolicyGetId "service-$name")" || return
		RunLog consul acl policy delete -accessor-id "$id"
	done

	# find orphan tokens
	tokens=(
		$(FileLeft \
			<(consulAclTokenLs | grep "^service-" | sed 's/service-//') \
			<(consulServiceLs))
	)

	# delete orphan tokens
	for name in "${tokens[@]}"; do
		echo "Deleting orphan token 'service-$name'..."
		id="$(consulAclTokenGetId "service-$name")" || return
		RunLog consul acl token delete -accessor-id "$id"
	done
}

#
# consul service rm command
#

consulServiceRmUsage() { echot "Usage: $(ScriptName) consul service rm FILE|ID|NAME"; }
consulServiceRmArgs() { ScriptArgGet "service" -- "$@"; shift; }

consulServiceRmCommand()
{
	local id

	# get the service ID
	if [[ -f "$service" ]]; then # file
		id="$(consulServiceFileGetId "$service")" || return
	elif consulServiceIdExists "$service"; then # id
		id="$service"
	else # name
		id="$(consulServiceGetId "$service")" || return
	fi

	# deregister the service
	consulServiceIdExists "$id" && { consul services deregister -id "$id" || return; }

	# delete the service ACL
	consulAclDelete "service-$id" || return
}

# consul service helper commands

consulServiceLs() { consul catalog services; }

# consulServiceFileGetId FILE - return the service name from a service file
consulServiceFileGetId()
{
	local file="$1" type; type="$(consulServiceFileValidate "$file")" || return

	# get the service ID, which is the name if the ID attribute is not present
	local id
	if [[ "$type" == "json" ]]; then
		id="$(cat "$file" | jq ".service.id" | RemoveQuotes)"
		[[ ! $id || "$id" == "null" ]] && id="$(cat "$file" | jq ".service.name" | RemoveQuotes)"
	else
		id="$(cat "$file" | grep "id =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
		[[ ! $id ]] && id="$(cat "$file" | grep "name =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
	fi

	# check for a valid id
	[[ ! $id || "$id" == "null" ]] && { ScriptErr "unable to determine the service ID in '$file' (no name or id attribute)"; return 1; }

	# return the name
	echo "$id"
}

# consulServiceFileValidate FILE - return true and the configu file type if the file is a valid consul service file
consulServiceFileValidate()
{
	local type; type="$(configFileValidate "$file")" || return

	# check for the service attribute
	if [[ "$type" == "json" && "$(cat "$file" | jq ".service")" == "null" ]]; then
		ScriptErr "service attribute is required"
		return 1
	fi

	# return the type
	echo "$type"
}

# consulServiceGetId NAME - get the service ID for the specified service name
consulServiceGetId()
{
	local name="$1" id; id="$(consulApi "/agent/services" | jq '.[] | select(.Service == '"$name"').ID' | RemoveQuotes)" || return
	consulValidateId "$id" "$name" "service"
}

consulServiceIdExists()
{
	local id="$1"
	[[ "$(consulApi "/agent/services" | jq '.[] | select(.ID == "'"$id"'").ID' | RemoveQuotes)" == "$id" ]]; 
}

# consuleServiceIdValidate ID - return true if the ID is a consul service ID
consulServiceIdValidate()
{
	local id="$1"; consulServiceIdExists "$id" && return
	ScriptErr "a service with ID '$id' does not exist"
	return 1
}

# consul helper

# consulValidateId ID NAME WHAT - validate ID is correct for the given NAME.   WHAT is what we are validating.
consulValidateId()
{
	local id="$1" name="$2" what="$3"

	# check for a valid id
	[[ ! $id || "$id" == "null" ]] && { [[ ! $quiet ]] && ScriptErr "$what '$name' does not exist"; return 1; }

	# ensure there is only one WHAT with the specified name
	(( $(echo "$id" | wc -l) > 1 )) && { [[ ! $quiet ]] && ScriptErr "there is more than one $what with the name '$name'"; return 1; }

	# return the id
	echo "$id"
}

#
# install command
#

installUsage() { echot "\
Usage: $(ScriptName) install cli|service
Install a HashiCorp product."; }

installCommand() { usage; }

#
# install service command
#

installServiceUsage() { echot "\
Usage: $(ScriptName) install service all|cli|$productUsage
Install a HashiCorp product.

	-c, --clients	HOSTS						comma separated list of clients to install
	-if, --interface	INTERFACE		host interface adapter name, i.e. wlan0, defaults to hosts default interface
	-s, --server HOSTS						comma separated list of servers to install
	-j, --join HOSTS							comma separated list of hosts to join to, defaults to servers
	$certOptUsage
	-w, --what=C1[,C2...] components to install: acl program service config
	                        cert (cert-local cert-make cert-public cert-service)"; }

installServiceArgStart() { unset force interface whatArg; clients=() servers=() join=(); encrypt="true"; }

installServiceOpt()
{
	encryptCliOpt "$@" && return
	case "$1" in
		--clients|-c|--clients=*|-c=*) ScriptOptGet "clients" "$@"; StringToArray "$clients" "," clients;;
		--interface|-if|--interface=*|-if=*) ScriptOptGet "interface" "$@";;
		--servers|-s|--servers=*|-s=*) ScriptOptGet "servers" "$@"; StringToArray "$1" "," servers;;
		--join|-j|--join=*|-j=*) ScriptOptGet "join" "$@"; StringToArray "$1" "," join;;
		*) return 1;;
	esac
}

installServiceCommand() { usage; }
installServiceAllCommand() { installServiceConsulCommand && installServiceVaultCommand && installServiceNomadCommand; }
installServiceConsulCommand() { installService "consul"; }
installServiceNomadCommand() { installService "nomad"; }
installServiceVaultCommand() { installService "vault"; }

# install helper

installService()
{
	local product="$1" isServiceInstall="true"; serviceVars "$product" || return

	# common service options
	local commonOptions="$(cat <<-EOF
		log_level = "info"\n
		EOF
	)"

	# add clients and servers from hostArg if specified
	if [[ $hostArg ]]; then
		local host hosts; StringToArray "$hostArg" "," hosts
		local defaultServers; configGetArray "servers" "defaultServers"
		for host in "${hosts[@]}"; do
			IsInArray "$host" defaultServers && servers+=( "$host" ) || clients+=( "$host" )
		done
		unset hostArg
	fi

	# use default clients and servers if needed
	if [[ ! $clients && ! $servers ]]; then
		if [[ "$product" == "vault" ]]; then
			clients=( )
			configGetArray "VaultServers" servers
		else
			configGetArray "clients"
			configGetArray "servers"
		fi
	fi

	hosts=( "${servers[@]}" "${clients[@]}" )

	# set join servers	
	[[ ! $join ]] && configGetArray "servers" "join"
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(hostFqdn "$h")" ); done

	if [[ $verbose ]]; then
		PrintErr "clients: "; ArrayShow clients
		PrintErr "servers: "; ArrayShow servers
		PrintErr "join: "; ArrayShow join
	fi

	# install
	local certDir; certs && { certMakeCd "$product" || return; }
	local tmpDir; tmpDir="$(tmpDirCreate)" || return	
	installServiceCertMake || return # current directory will be the private certificate directory
	installServiceProgram || return
	installServiceHosts "server" "${servers[@]}" || return
	installServiceCertLocal || return
	installServiceServerFinal || return
	installServiceHosts "client" "${clients[@]}" || return
	installServiceFinal || return
	installServiceCertPublic || return

	# cleanup
	unset servers clients
	rm -fr "$tmpDir"
}

installServiceCertLocal() { ! whatCheck "cert" "cert-local" && return; header "Install Local Certificates" && certs && productInstallCerts "$product"; }
installServiceCertMake() { ! whatCheck "cert" "cert-make" && return; header "Create Certificates" && certMakeCd "$product" && certs && certMake "$product"; }
installServiceCertPublic() { ! whatCheck "cert" "cert-public" && return; header "Copy Public Certificates" && certs && certCopyPublic "$product"; }

installServiceAcl()
{
	{ ! whatCheck "acl" || isClient; } && return

	header "Install $(ProperCase "$product") ACL"
	productInit "$product" || return

	# generate the bootstrap token
	local header text
	local alreadyCreated="ACL bootstrap already done"; [[ "$product" == "consul" ]] && alreadyCreated="ACL bootstrap no longer allowed"
	local waitingForNodes="The ACL system is currently in legacy mode."
	
	# try up to 30 times to get the bootstrap text
	for (( i = 0; i < 30; i++ )); do
		text="$($product acl bootstrap 2>&1)" && break
		echo "$text" | grep -q "$alreadyCreated" && return
		echo "$text" | grep -q "$waitingForNodes" &&
			{ [[ $header ]] && printf "." || printf "bootstrap..."; header="true"; sleep 1; continue; }
		EchoErr "$text"; return 1
	done
	[[ $header ]] && echo
	echo "$text" | grep -q "$waitingForNodes" && { EchoErr "$text"; return 1; }
	
	# show the full bootstrap text
	hilight "Store the following bootstrap token in a secure location:"
	echo "$text"

	# get and store the token
	local secretId="Secret ID"; [[ "$product" == "consul" ]] && secretId="SecretID"
	local sep="="; [[ "$product" == "consul" ]] && sep=":"
	local token="$(echo "$text" | grep "$secretId" | cut -d$sep -f 2 | RemoveSpace)"
	[[ ! $token ]] && { ScriptErr "unable to determine the bootstrap token"; return 1; }
	credSet "token" "$token" || return

	productVarSet "TOKEN" "$token" || return
	log1 "updated environment variable $(productVar "TOKEN") to $(productVarGet "TOKEN")..."
}

installServiceConfig()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$product")
		Documentation=https://www.hashicorp.com/products/$product
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$productConfigFile
		StartLimitIntervalSec=10
		StartLimitBurst=3

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$productServiceEnvFile
		KillMode=process
		KillSignal=$serviceKillSignal
		Restart=on-failure
		RestartSec=2
		TasksMax=infinity
		$serviceLimit

		[Install]
		WantedBy=multi-user.target
	EOF
}

# installServiceHost client|server host - install the client or server version of the service 
installServiceHost()
{
	local type="$1" host="$2"
	local f hostFqdn hostIp
	local o="$commonOptions"
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local serviceLimit="LimitNOFILE=infinity"$'\n'"LimitNPROC=infinity"
	local execStart="$program agent -config=$productConfigDir"
	local execReload="/bin/kill --signal HUP \$MAINPID"
	local exectStop=""
	local serviceKillSignal="SIGINT"

	# host information
	hostFqdn="$(hostFqdn "$host")" || return
	hostIp="$(GetIpAddress "$hostFqdn")" || return
	host="$(RemoveDnsSuffix "$hostFqdn")"

	# header
	header "Install $(ProperCase "$product") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	${G}mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return

	# copy certificates
	certMakeCp "$ca" "$certCli" "$certCliKey" "$tmpDir/cert" || return

	# environment
	printf "" > "$tmpDir/$product.env"

	# interface
	if [[ ! $interface ]]; then
		interface="$(sshRun "$host" "route | grep \"^default\" | head -1 | tr -s \" \" | cut -d\" \" -f8")" || return
		log1 "installServiceHost: using default host interface '$interface'"
	fi

	# product specifics
	RunFunction "installServicePrep" "${product}" || return

	# create the configuration files
	echo -e "$o" > "$tmpDir/config/$productConfigFileBase" || return
	installServiceConfig > "$tmpDir/$product.service" || return
	LogFile3 "$tmpDir/$product.service"

	# copy the files to the remote host	
	copyDirRemote "$tmpDir" "$host" || return

	# run the installation script - do not assume /usr/local/data/bin scripts are present, use only standard commands
	hilight "Running installation..."
	scriptRun "$host" "$(cat <<-EOF

		$(installServiceTextUser)

		$(installServiceTextDirectories)

		# files

		if [[ \$(sudoc ls -A "$tmpDir/data") ]] && [[ ! \$(sudoc ls -A "$productDataDir") || "$force" ]]; then
		  echo "Copying data files..."
		  sudoc install -o "$user" -g "$user" -m 755 -t "$productDataDir" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudoc ls -A "$tmpDir/config") ]] && [[ ! -f "$productConfigDir/$productConfigFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudoc install -o "$user" -g "$user" -m 755 -t "$productConfigDir" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudoc ls -A "$tmpDir/cert") ]] && [[ ! \$(sudoc ls -A "$certDirService") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudoc install -o "$user" -g "$user" -m 755 -t "$certDirService" "$tmpDir/cert/"* || exit
		fi

		$(scriptCertStore "$certDirService")

		# service		

		if [[ -f "$productServiceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudoc systemctl stop "$product" || exit
		fi

		if [[ ! -f "$productServiceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudoc cp "$tmpDir/$product.service" "$tmpDir/$product.env" "/etc/systemd/system" || exit
			sudoc systemctl daemon-reload || exit
			sudoc systemctl enable "$product" || exit
			sudoc systemctl start "$product" --no-block || exit
		fi

		$(scriptCleanup)
		EOF
	)" || return
}

# installServiceHosts client|server [HOST...]- install the service on the specified hosts.
# - in Consul, use 'consul members' to view the servers and clients.
# - in Nomad, the clients are known as nodes, use 'nomad server members' to view the servers in the cluster, use 'nomad node status' to view the nodes in the cluster.
installServiceHosts()
{
	local type="$1"; shift

	! whatCheck "service" && return

	for host in "$@"; do
		installServiceHost "$type" "$host" || return
	done
}

installServiceProgram()
{
	! whatCheck "program" && return

	local hosts=("${servers[@]}" "${clients[@]}")
	! InPath "$product" && other+="localhost"

	for host in "${hosts[@]}"; do
		header "Install $product Program ($host)"
		productInstall "$product" "$host" || return
	done
}

installServiceFinal() { RunFunction "installServiceFinal" "${product}" || return; }

installServiceFinalConsul() { installServiceFinalConsulAgentAcl; }

installServiceFinalConsulAgentAcl()
{
	! whatCheck "acl" && return

	# setup
	header "Agent ACL"	

	# deploy agent ACL's
	for host in "${hosts[@]}"; do
		 consulAclAgentDeploy "$host" || return
	done

	# change the ACL policy to deny
	for host in "${hosts[@]}"; do
		consulAclAgentDeny "$host" || return
	done
}


installServiceFinalNomad() 
{
	! whatCheck "config" && return

	header "Nomad Configuration"
	installServiceForAllHosts "nomadConfigEnableVault" && \
		installServiceForAllHosts "nomadConfigEnableDocker" && \
		installServiceForAllHosts "nomadConfigEnableRawExec" && \
		installServiceForAllHosts "serviceRestart" "nomad"
}

installServiceForAllHosts()
{
	local host
	for host in "${hosts[@]}"; do
		"$@" "$host" || return
	done
}

installServicePrepConsul()
{ 
	# options
	o+="$(cat <<-EOF
		datacenter = "$datacenter"
		data_dir = "/opt/$product"
		domain = "$baseDomain"
		enable_script_checks = true
		leave_on_terminate = true
		retry_join = [ $(ArrayShow join ", ") ]

		# network
		advertise_addr = "{{ GetInterfaceIP \"$interface\" }}"
		advertise_addr_ipv6 = "{{ GetAllInterfaces | include \"name\" \"$interface\" | include \"type\" \"IPv6\" | sort \"address\" | limit 1 | join \"address\" \" \" }}"
		bind_addr = "{{ GetInterfaceIP \"$interface\" }}"
		client_addr = "0.0.0.0"

		# access control
		acl {
		  enabled = true
		  default_policy = "allow"
		  enable_token_persistence=true
		}\n
		EOF
	)"

	# server
	isServer && o+="$(cat <<-EOF

		# server
		server = true
		bootstrap_expect = ${#join[@]}
		ui_config { enabled = true }\n
		EOF
	)"

	# certificates
	if certs; then

		local serverDefaults; isServer && serverDefaults="$(cat <<-EOF

			    cert_file = "$certDirService/$certServer"
			    key_file = "$certDirService/$certServerKey"
			EOF
		)"

		o+="$(cat <<-EOF

			# encryption
			addresses { https = "0.0.0.0" }
			ports { http = -1, https = $consulHttpsPort }
			tls {
			  defaults {
			    ca_file = "$certDirService/$ca"$serverDefaults
			    verify_incoming = false
			    verify_outgoing = true
			  }
			  internal_rpc {
			    verify_server_hostname = true 
			  }
			}\n
			EOF
		)"		

		# client certificates
		if isClient; then
			o+="$(cat <<-EOF
				auto_encrypt = {
				  tls = true
				  dns_san = [ "$hostFqdn" ]
				  ip_san = [ "$hostIp" ]
				}\n
				EOF
			)"		
			cp "$caAuto" "$tmpDir/cert" || return
		fi
	
		# server certificates
		if isServer; then
			o+="auto_encrypt = { allow_tls = true }"
			certMakeConsulServer "$host" "$tmpDir/cert" || return
		fi

	fi

	# service options
	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$program agent -config-dir=$productConfigDir"
	serviceKillSignal="SIGTERM"
}

installServicePrepNomad()
{
	# options
	local token; token="$(product="consul" credGet "token" --quiet)"; [[ ! $token ]] && { ScriptErr "unable to get a Consul token for Nomad"; return 1; }
	local port; port="$(productGetPort "consul" "$(protocol)")" || return

	o+="$(cat <<-EOF
		datacenter = "$datacenter"
		data_dir = "/opt/$product"
		acl { enabled = true }
		client { enabled = true }
		consul {
		  token = "$token"
		  address = "127.0.0.1:$port"
		}\n
		EOF
	)"
	
	# server
	isServer && o+="$(cat <<-EOF

		# server
		server {
		  enabled = true
		  bootstrap_expect = "${#join[@]}"
		  raft_protocol = 3
		}\n
		EOF
	)"

	# certificates 
	if certs; then		
		local certFile="$(eval echo "\$cert${type^}")"		# certClient or certServer
		local keyFile="$(eval echo "\$cert${type^}Key")"	# certClientKey or certServerKey
		o+="$(cat <<-EOF

			# encryption
			tls { 
			  http = true
			  rpc = true
			  ca_file = "$certDirService/$ca"
			  cert_file = "$certDirService/$certFile"
			  key_file = "$certDirService/$keyFile"
			  verify_server_hostname = false
			  verify_https_client = false
			}\n
			EOF
		)"
		cp "$ca" "$certFile" "$keyFile" "$tmpDir/cert" || return
	fi

	# consul encryption environment variables
	if certs; then
		certInit "consul" || return 
	
		cat > "$tmpDir/$product.env" <<-EOF
			CONSUL_HTTP_SSL=true
			CONSUL_CACERT=$certDirService/$caLocal
			CONSUL_CLIENT_CERT=$certDirService/$certServer
			CONSUL_CLIENT_KEY=$certDirService/$certServerKey
		EOF

		certInit "nomad" || return
	fi
}

installServicePrepVault()
{
	# certificates
	local certListenerConfig certConsulConfig
	if certs; then

		# vault certificates
		certListenerConfig="$(cat <<-EOF

		  tls_client_ca_file = "$certDirService/$ca"
		  tls_cert_file = "$certDirService/$certServer"
		  tls_key_file = "$certDirService/$certServerKey"
			EOF
		)"
		certMakeVaultServer "$host" "$tmpDir/cert" || return

		# consul certificates
		certInit "consul" || return
		certConsulConfig="$(cat <<-EOF

		  tls_ca_file = "$certDirService/$ca"
		  tls_cert_file = "$certDirService/$certCli"
		  tls_key_file = "$certDirService/$certCliKey"
			EOF
		)"
		certInit "vault" || return

	fi

	# options
	local token; token="$(product="consul" credGet "token")" || return
	
	o+="$(cat <<-EOF
		listener "tcp" {
		  address = "0.0.0.0:$(productGetPort "$product" "$(protocol)")"$certListenerConfig
		}
		storage "consul" {
		  token = "$token"
		  path = "vault/"
		  address = "127.0.0.1:$(productGetPort "consul" "$(protocol)")"
		  scheme = "$(protocol)"$certConsulConfig
		}
		service_registration "consul" {
		  token = "$token"
		  address = "127.0.0.1:$(productGetPort "consul" "$(protocol)")"
		  scheme = "$(protocol)"$certConsulConfig
		}
		api_addr = "https://$hostFqdn:$vaultHttpsPort"\n
		EOF
	)"

	isServer && o+="$(cat <<-EOF
		ui = "true"\n
		EOF
	)"

	# service options
	execStart="$program server -config=$productConfigDir"
	serviceLimit+=$'\n'"LimitMEMLOCK=infinity"
}

installServiceServerFinal() { RunFunction "installServiceServerFinal" "${product}"; }

installServiceServerFinalConsul()
{
	certs && { certMakeConsulCaAuto || return; }
	installServiceAcl || return
}

installServiceServerFinalNomad() { installServiceAcl && installServiceServerFinalNomadVaultIntegration; }

installServiceServerFinalNomadVaultIntegration()
{	
	! whatCheck "config" && return

	header "Install Nomad Vault Integration"

	local policy; productInit "vault" || return

	# nomad-cluster policy - policy for jobs (specifiy in job configuration)
	if ! vault policy list | grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster policy to Vault..."
		local policy="$(cat <<-EOF
			path "secret/*" {
			  capabilities = ["read"]
			}
			EOF
		)"
		echo "$policy" | vault policy write nomad-cluster - || return
	fi

	# nomad-cluster role - role Nomad uses to create tokens for jobs (specifies which policies jobs can request)
	if ! vault list "/auth/token/roles" |& grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster role to Vault..."
		policy="$(policyDownload "https://nomadproject.io/data/vault/nomad-cluster-role.json")" || return
		vault write /auth/token/roles/nomad-cluster @"$policy" || return
	fi

	# nomad-server policy - policy for the token Nomad uses to access Vault
	if ! vault policy list | grep -q "^nomad-server$"; then
		hilight "Adding the nomad-server policy to Vault..."
		policy="$(policyDownload "https://nomadproject.io/data/vault/nomad-server-policy.hcl")" || return
		vault policy write nomad-server "$policy" || return
	fi
}


installServiceServerFinalVault()
{
	# generate the unseal keys
	local n key result s seals; seals="$(vault operator init 2>&1)"; result="$?"
	echo "$seals" | grep -q "Vault is already initialized" && return
	(( result != 0 )) && { EchoErr "$seals"; return 1; }

	# show the seal keys
	hilight "Store the following vault unseal keys in a secure location:"
	echo "$seals"

	# store the root token
	declare token; token="$(echo "$seals" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credSet "token" "$token" || return
	export VAULT_TOKEN="$token"

	# store the seal keys
	IFS=$'\n' ArrayMake seals "$(echo "$seals" | grep "Unseal Key")"
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credSet "key$n" "$key" || return
	done

	# store the Vault token on a remote server
	vaultTokenSetRemote || return

	# unseal vault
	vaultUnsealCommand || return

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | grep -q "^secret"; then
		header "Vault Configuration"
		vault secrets enable -path=secret kv-v2 || return
	fi
}

installServiceTextDirectories()
{
	cat <<-EOF
		if ! [[ -d "$certDirService" && -d "$productConfigDir" && -d "$productDataDir" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudoc install -o "$user" -g "$user" -m 755 -d "$certDirService" "$productConfigDir" "$productDataDir" || exit
		fi
	EOF
}

installServiceTextUser()
{
	cat <<-EOF
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudoc useradd --system --home-dir "$productConfigDir" --shell "/bin/false" "$user" || exit
		fi
	EOF
}

#
# install cli command
#

installCliUsage() {	echot "\
Usage: $(ScriptName) install cli all|$productUsage
Install a HashiCorp program and certificates for command line access.

	$certOptUsage
	-w, --what=C1[,C2...] components to install: cert cred program"; }

installCliArgStart() { unset encrypt whatArg yes; }
installCliOpt() { encryptCliOpt "$@"; }
installCliCommand() { usage; }
installCliAllCommand() { local product; for product in vault consul nomad; do installCli "$product" || return; done; }
installCliConsulCommand() { installCli "consul"; }
installCliNomadCommand() { installCli "nomad"; }
installCliVaultCommand() { installCli "vault"; }

installCli()
{
	local product="$1"; initConfig "$product" || return

	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be installed locally"; return 1; }
	
	whatCheck "program" && { productInstall "$product" "localhost" || return; }
	whatCheck "cert" && { productInstallCerts "$product" || return; }
	whatCheck "cred" && InPath vault && { doHashi config set local "$product" || return; }

	return 0
}

#
# nomad commands
#

nomadUsage() { echot "Usage: $(ScriptName) nomad api|config|environment|node|job|status\nNomad commands."; }
nomadArgStart() { product="nomad"; }
nomadCommand() { usage; }
nomadEnvironmentCommand() { productEnvironment "$product"; }
nomadStatusCommand() { nomad node status; }

#
# nomad api command
#

nomadApiUsage() { echot "Usage: $(ScriptName) nomad api [check|put] PATH -- [curl arguments]\nCall the Nomad API.  For example:\nhashi nomad api /nodes?resources=true"; }
nomadApiArgStart() { unset path; }
nomadApiArgs() { [[ "$command" == "nomadApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

nomadApiCommand() { nomadApi "$path" "${otherArgs[@]}"; }
nomadApi() { RunLog curl --silent --show-error --header "X-Nomad-Token: $NOMAD_TOKEN" "$NOMAD_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }

nomadApiPutCommand() { nomadApiPut "$path" "${otherArgs[@]}"; }
nomadApiPut() { nomadApi "$@" --request PUT; }

nomadApiCheckCommand() { nomadApiCheck; }
nomadApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" && { [[ ! $quiet ]] && ScriptErr "nomad server $host is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" && { [[ ! $quiet ]] && ScriptErr "nomad server $host is not available on port $port"; return 1; }	

	# check api
	nomadApi "/status/leader" 2> /dev/null | RemoveQuotes | RemovePort | IsIpAddress && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the nomad API at $(productVarGet "ADDR") is not available"; nomadApi "/status/leader"; return 1; }

	return 0
}

#
# nomad config commands
#

nomadConfigUsage() { echot "\
Usage: $(ScriptName) nomad config enable|disable docker|RawExec|vault
Enable or disable Nomad functionality."; }

nomadConfigCommand() { usage; }
nomadConfigEnableCommand() { usage; }
nomadConfigDisableCommand() { usage; }

nomadConfigEnableDockerCommand() { forAllHosts nomadConfigEnableDocker; }
nomadConfigDisableDockerCommand() { forAllHosts serviceConfigDelete "nomad" "10_docker.hcl"; }

nomadConfigEnableRawexecCommand() { forAllHosts nomadConfigEnableRawExec; }
nomadConfigDisableRawexecCommand() { forAllHosts serviceConfigDelete "nomad" "10_raw_exec.hcl"; }

nomadConfigEnableVaultCommand() { forAllHosts nomadConfigEnableVault; }
nomadConfigDisableVaultCommand() { forAllHosts serviceConfigDelete "nomad" "20_vault.hcl"; }

# nomadConfigEnablDocker HOST
nomadConfigEnableDocker()
{
	serviceConfigCopyText "nomad" "$1" "10_docker.hcl" "$(cat <<-EOF
		plugin "docker" {
		  config {
		    volumes {
		      enabled = true
		    }
		  }
		}
		EOF
	)"
}

# nomadConfigEnableRawExec HOST
nomadConfigEnableRawExec()
{
	serviceConfigCopyText "nomad" "$1" "10_raw_exec.hcl" "$(cat <<-EOF
		plugin "raw_exec" {
		  config {
		    enabled = true
		  }
		}
		EOF
	)"
}

# nomadConfigEnableVault HOST
nomadConfigEnableVault()
{
	local host="$1"

	# Vault integration requires vault executable and service certificates
	productInstall "vault" "$host" || return
	updateServiceCert "vault" "$host" || return

	# certificate configuration
	local certConfig
	if certs; then
		certInit "vault" || return
		certConfig="$(cat <<-EOF

		  ca_file = "$certDirService/$caLocal"
		  cert_file = "$certDirService/$certCli"
		  key_file = "$certDirService/$certCliKey"
			EOF
		)"
		certInit "nomad" || return
	fi

	# server configuration
	local server serverConfig; server="$(serviceIsServer "nomad" "$host")" || return
	if [[ "$server" == "true" ]]; then

		# create token for Nomad to access vault - Nomad will renew the token every 72h
		local token; token="$(vault token create -display-name nomad-server -policy nomad-server -period 72h -orphan -format=json | jq '.auth.client_token' | RemoveQuotes)" || return

		serverConfig="$(cat <<-EOF

		  create_from_role = "nomad-cluster"
		  token = "$token"
			EOF
		)"
	fi

	# configuration	
	serviceConfigCopyText "nomad" "$host" "02_vault.hcl" "$(cat <<-EOF
		vault {
		  enabled = true
		  address = "https://$(serviceDnsName "active.vault"):$(productGetPort "vault" "$(protocol)")"$certConfig$serverConfig
		}
		EOF
	)"
}

#
# nomad node commands
#

nomadNodeUsage() { echot "Usage: $(ScriptName) nomad node allocations|drain|exists|id|ls|status\nNomad node commands."; }
nomadNodeCommand() { usage; }
nomadNodeAllocationsCommand() { forAllHosts nomadNodeAllocations; }
nomadNodeExistsCommand() { local quiet="--quiet"; nomadNodeIdCommand > /dev/null; }
nomadNodeIdCommand() { forAllHosts nomadGetNodeId; }
nomadNodeLsCommand() { nomad node status -json | jq '.[] | .Name' | RemoveQuotes | sort --version-sort; }
nomadNodeStatusCommand() { ForAllHosts nomadNodeStatus --header "status"; }

nomadNodeAllocations()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	if [[ $verbose ]]; then
		header "$(RemoveDnsSuffix "$host")"; nomad status "$id" | sed '1,/Allocations/d' | tail -n +2 | grep " running "
	else
		printf "$(RemoveDnsSuffix "$host"): "; nomad status "$id" | sed '1,/Allocations/d' | tail -n +2 | grep " running " | wc -l
	fi
}

# nomadGetNodeId HOST
nomadGetNodeId()
{
	local host="$(RemoveDnsSuffix "$1")"
	local id; id="$(nomad node status -json | jq '.[] | select(.Name == "'"$host"'").ID' | RemoveQuotes)" || return
	[[ ! $id ]] && { ScriptErrQuiet "unable to get Nomad node ID for host '$host'"; return 1; }
	echo "$id"
}

nomadNodeStatus()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return	
	local args=(); [[ $verbose ]] && args+=(-verbose)
	nomad status "${args[@]}" "$id"
}

#
# nomad node drain commands
#

nomadNodeDrainUsage() { echot "Usage: $(ScriptName) nomad node drain enable|disable|status\nNomad node drain commands."; }
nomadNodeDrainCommand() { usage; }
nomadNodeDrainEnableCommand() { forAllHosts nomadNodeDrainEnable; }
nomadNodeDrainDisableCommand() { forAllHosts nomadNodeDrainDisable; }
nomadNodeDrainStatusUsage() { echot "Usage: $(ScriptName) nomad node drain status\nReturn true if all specified hosts are drained."; }
nomadNodeDrainStatusCommand() { forAllHosts nomadNodeDrainStatus; }

# nomadNodeDrainEnable HOST
nomadNodeDrainEnable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return
	local forceArg; [[ $force ]] && forceArg="-deadline 1m"

	# return if already enabled
	[[ ! $force ]] && nomadNodeDrainStatus "$host" && return

	# enable
	hilight "Draining Nomad on node $host..."
	RunLog nomad node drain -enable -yes $forceArg "$id" && echo
}

# nomadNodeDrainDisable HOST
nomadNodeDrainDisable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	# return if already disbaled
	[[ ! $force ]] && ! nomadNodeDrainStatus "$host" && return

	# disable
	hilight "Bringing Nomad node $host back online..."
	RunLog nomad node drain -disable -yes "$id" && echo
}

# nomadNodeDrainStatus HOST
nomadNodeDrainStatus()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	# node is not drained if it is elegible to get jobs
	local eleigible; eleigible="$(nomad node status -json "$id" | jq '.SchedulingEligibility' | RemoveQuotes	)" || return
	[[ "$eleigible" == "eligible" ]] && { log2 "host '$host' is elegible for jobs"; return 1; }
	
	# node is not drained if it has running allocations
	local hasAllocations; nomad status "$id" | sed '1,/Allocations/d' | tail -n +2 | grep --quiet " running " && hasAllocations="true"
	(( verboseLevel > 2 )) && nomad status "$id" | sed '1,/Allocations/d' | tail -n +2
	[[ $hasAllocations ]] && { log2 "host '$host' has running allocations"; return 1; }
	
	return 0	
}

#
# nomad node eligibility commands
#

nomadNodeEligibilityUsage() { echot "Usage: $(ScriptName) nomad node eligibility enable|disable|id\nNomad node eligibility commands."; }

nomadNodeEligibilityCommand() { usage; }
nomadNodeEligibilityEnableCommand() { forAllHosts nomadNodeEligibilityEnable; }
nomadNodeEligibilityDisableCommand() { forAllHosts nomadNodeEligibilityDisable; }

# nomadNodeEligibilityEnable HOST
nomadNodeEligibilityEnable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	hilight "Making Nomad node $host eligible..."
	RunLog nomad node eligibility -enable "$id"
}

# nomadNodeEligibilityDisable HOST
nomadNodeEligibilityDisable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	hilight "Making Nomad node $host ineligible..."
	RunLog nomad node eligibility -disable "$id"
}

#
# nomad job commands
#

nomadJobUsage() { echot "\
Usage: $(ScriptName) nomad job NAME
Nomad job commands.

	force	NAME		force a periodic job to start
	log	NAME			show the log for a periodic job
	run NAME			run or update a job
	status [NAME]	status of all running jobs or the specified job"; }

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() { nomadJobStatusCommand; }

# nomad job run
nomadJobRunCommand()
{
	local file; file="$(ConfigGet confDir)/hashi/job/$job.hcl"; [[ -f "$file" ]] && job="$file"
	ScriptCheckFile "$job" || return
	nomad run "$job" "${otherArgs[@]}" || return
}

# nomad job status 
nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | grep -v dead
	fi
}

# nomnd job force command

nomadJobForceUsage() { echot "\
Usage: $(ScriptName) nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"; }

nomadJobForceArgStart() { log=""; }

nomadJobForceOpt() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogUsage() { echot "\
Usage: $(ScriptName) nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"; }

nomadJobLogArgStart() { follow=""; }

nomadJobLogOpt() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId" "${otherArgs[@]}"
		header "Standard Error"; nomad alloc logs -stderr "$allocId" "${otherArgs[@]}"
	fi		
}

# nomad helper

# nomadClientName ID - return the name of the Nomad client with ID
nomadClientName() { nomad status "$1" | grep "^Name " | tr -s ' ' | cut -d"=" -f2 | RemoveSpace; }

# nomadClients - return all Nomad client ID's
nomadClients() { nomad node status | tail +2 | cut -d" " -f1; }

# nomadGetJobId - get the job ID for $job 
nomadGetJobId()
{ 
	jobId="$(nomad job status "$job" |& tail -1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job '$job'"; exit 1
}

# nomadGetAllocId - get the allocation ID for the $jobId or $job 
nomadGetAllocId()
{
	[[ ! $jobId ]] && { nomadGetJobId || return; }
	allocId="$(nomad job status "$jobId" |& tail -1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job '$job'"; exit 1
}

# nomadVaultStatus - show the status of the Vault integration for all Nomad clients
nomadVaultStatus()
{
	hilight "Nomad Vault integration status:"
	for id in $(nomadClients); do 
		echo "$(nomadClientName "$id"): $(nomad status -verbose "$id" | grep "^vault.accessible" | tr -s " " | cut -d"=" -f2 | RemoveSpace)"; 
	done
}

#
# remove command
#

removeUsage() { echot "\
Usage: $(ScriptName) remove all|cli|$productUsage
Remove a HashiCorp product configuration and data.

	-w, --what=C1[,C2...] components to remove: program service
		$configWhat"; }

removeArgStart() { unset whatArg yes; }

removeOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

removeOptArgEnd()
{
	[[ ! $what ]] && MissingOption "what"

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

removeCommand() { removeAllCommand; }
removeAllCommand() { removeDo "vault" && removeDo "nomad" && removeDo "consul"; }
removeConsulCommand() { removeDo "consul"; }
removeNomadCommand() { removeDo "nomad"; }
removeVaultCommand() { removeDo "vault"; }

removeDo()
{
	local product="$1"
	whatCheckConfig && { removeConfig "$product" || return; }
	whatCheck "service" && { removeService || return; }
	return 0
}

removeService()
{
	local removeProgram; whatCheck "program" && removeProgram="true"

	if [[ ! $force || ! $yes ]]; then
		ScriptErr "To permanently delete all $product services and programs for $baseDomain $configDesc, --force and --yes are required"
		return 1
	fi

	local host hosts; getHosts "all" || return
	for host in "${hosts[@]}"; do
		header "Remove $(ProperCase "$product") Service ($host)"
		serviceRemove "$product" "$host" || return
	done
}

#
# remove cli command
#

removeCliUsage() { echot "\
Usage: $(ScriptName) remove cli all|$productUsage
Remove a HashiCorp program and certificates used for command line access."; }

removeCliCommand() { local product; for product in "${products[@]}"; do removeCli "$product" || return; done; }
removeCliConsulCommand() { removeCli "consul"; }
removeCliNomadCommand() { removeCli "nomad"; }
removeCliVaultCommand() { removeCli "vault"; }

removeCli() 
{ 
	local product="$1"
	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be removed locally"; return 1; }
	whatCheck "config" && { certInit "$product" && removeDir "$(certDirLocal "$product")"; }
	whatCheck "program" && { RunLog sudoc rm -f "/usr/local/bin/$product" || return; }
	return 0
}

#
# resolve command
#

resolveUsage()
{
	echot "Usage: $(ScriptName) resolve [api|dig|name|nslookup|passing|list](passing) SERVICE
Resolve the nodes of a service.

	Resolve using Consul DNS servers:
	name				return passing service node DNS names
	passing			return passing service node IP addresses
	dig					use dig to return passing service nodes
	nslookup		use nslookup to return passing servers

	Resolve using the Consul API:
	api					use the API to return all service nodes detail as JSON
	list				return a list of passing service node names from the API

  -a, --all		return all passing service nodes instead of the first"
}

resolveArgStart() { unset -v all name; }
resolveArgs() { ScriptArgGet "name" -- "$@"; shift; }

resolveOpt()
{
	case "$1" in
		-a|--all) all="true";;
		*) return 1;;
	esac
}

resolveCommand() { resolvePassingCommand; }
resolvePassingCommand() { resolve "$name" "$all"; }
resolveApiCommand() { resolveApi "$name"; }
resolveNameCommand() { resolveName "$name" "$all" | sort --version-sort; }

resolveApi()
{
	local name="$1"
	log1 "using API to resolve the '$name' service"
	local product="consul"; noToken="true" productInit "$product" || return
	test="" RunLog curl --silent --show-error "$(productVarGet "ADDR")/v1/catalog/service/$name"
}

resolveDigCommand()
{
	log1 "using dig to resolve the '$name' service"
	name="$(serviceDnsName "$name")" || return
	local server; server="$(getDnsServer)" || return
	test="" RunLog dig "@$server" -p 8600 "$name" SRV
}

resolveListCommand()
{
	log1 "using API to resolve the '$name' service to a list of available nodes from the API"
	test="" resolveApi "$name" | jq ".[].Node" | RemoveQuotes
}

resolveNslookupCommand()
{
	log1 "using nslookup to resolve the '$name' service"
	name="$(serviceDnsName "$name")" || return
	local server; server="$(getDnsServer)" || return
	test="" RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server"
}

resolve()
{
	local name="$1" all="$2"
	local filter=(head -1); [[ $all ]] && { filter=(cat); }

	if InPath dig; then
		resolveDig "$name" | "${filter[@]}" || return
	elif InPath "nslookup" && ! IsBusyBox; then # nslookup does not work properly on BusyBox
		resolveNslookup "$name" | "${filter[@]}" || return
	else
		[[ ! $quiet ]] && HostUnresolved "$name"; return 1
	fi
}

resolveDig()
{
	local name; name="$(serviceDnsName "$1")" || return
	local server; server="$(getDnsServer)" || return
	local ip; ip="$(test="" RunLog dig "@$server" -p 8600 "$name" A +short)"
	[[ ! $ip ]] && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }
	log1 "dig resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

resolveNslookup()
{
	local name; name="$(serviceDnsName "$1")" || return
	local server; server="$(getDnsServer)" || return

	local result; result="$(test="" RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server")"
	(( $? != 0 )) && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }

	local ip
	if [[ "$result" =~ .*canonical\ name.* ]]; then
		ip="$(printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//')"
	else
		ip="$(printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace)"
	fi
	
	log1 "nslooklup resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

resolveName()
{
	local name="$1" all="$2"
	local ips; ips="$(resolve "$name" "$all")" && DnsResolveBatch $ips
}

#
# update command
#

updateUsage() { echot "usage: $(ScriptName) update cli|service"; }
updateCommand() { usage; }

# update cli command
updateCliUsage() { echot "usage: $(ScriptName) update cli cert|program\n\n	$certOptUsage"; }
updateCliArgStart() { encrypt="true"; }
updateCliOpt() { encryptOpt "$@"; }
updateCliCommand() { usage; }

# update cli cert command
updateCliCertUsage() { echot "usage: $(ScriptName) update cli cert all|$productUsage"; }
updateCliCertCommand() { usage; }
updateCliCertAllCommand() { updateCliCertConsulCommand && updateCliCertNomadCommand && updateCliCertVaultCommand; }
updateCliCertConsulCommand() { forAllHosts updateCliCert "consul"; }
updateCliCertNomadCommand() { forAllHosts updateCliCert "nomad"; }
updateCliCertVaultCommand() { forAllHosts updateCliCert "vault"; }

# updateCliCert PRODUCT HOST
updateCliCert()
{
	local product="$1" host="$2"; certInit "$product" || return
	local src; src="$(certPublicFind "$product")" || return
	local dest="$(certDirSuffix "$product" "/opt/hashi")" # always install certificates to /opt/hashi 

	# copy certificates to a temporary directory
	local tmpDir; tmpDir="$(tmpDirCreate)" || return
	certMakeCp "$src/$ca" "$src/$certCli" "$src/$certCliKey" "$tmpDir" || return
	[[ -f "$src/$caAuto" ]] && { certMakeCp "$src/$caAuto" "$tmpDir" || return; }

	# copy certificates to the host
	copyDirRemote "$tmpDir" "$host" || return

	# install the new certificates on the host
	scriptRun "$host" "$(cat <<-EOF
		
		echo "Installing ${product^} certificates..."
		sudoc install --backup=numbered -m 644 -t "$dest" "$tmpDir/"* || exit

		$(scriptCertStore "$dest")
		$(scriptCleanup)
		EOF
	)" || return

	# cleanup
	rm -fr "$tmpDir"
}

# update cli program command
updateCliProgramUsage() { echot "usage: $(ScriptName) update cli program all|$productUsage"; }
updateCliProgramCommand() { usage; }
updateCliProgramAllCommand() { updateCliProgramConsulCommand && updateCliProgramNomadCommand && updateCliProgramVaultCommand; }
updateCliProgramConsulCommand() { forAllHosts updateCliProgram "consul"; }
updateCliProgramNomadCommand() { forAllHosts updateCliProgram "nomad"; }
updateCliProgramVaultCommand() { forAllHosts updateCliProgram "vault"; }

# updateCliProgram PRODUCT HOST - assumes the host is not running the product service
updateCliProgram()
{
	local product="$1" host="$2"
	
	header "Update $(ProperCase "$product") CLI ($host)"

	# return if the product installation is not needed
	productInstallNeeded "$product" "$host" || return; [[ ! $installNeeded ]] && return

	# install the product
	productInstallDo "$product" "$host"
}

# update service command
updateServiceUsage() { echot "usage: $(ScriptName) update service cert|program\n\n	$certOptUsage"; }
updateServiceArgStart() { encrypt="true"; }
updateServiceOpt() { encryptOpt "$@"; }
updateServiceCommand() { usage; }

# update service cert command
updateServiceCertUsage() { echot "usage: $(ScriptName) update service cert all|$productUsage\n\n	$certOptUsage"; }
updateServiceCertCommand() { usage; }
updateServiceCertAllCommand() { updateServiceCertConsulCommand && updateServiceCertNomadCommand && updateServiceCertVaultCommand; }
updateServiceCertConsulCommand() { forAllHosts updateServiceCert "consul"; }
updateServiceCertNomadCommand() { forAllHosts updateServiceCert "nomad"; }
updateServiceCertVaultCommand() { forAllHosts updateServiceCert "vault"; }

# updateServiceCert PRODUCT HOST
updateServiceCert()
{
	local product="$1" host="$2"; serviceVars "$product" || return; certMakeCd "$product" || return
	
	# copy certificates to a temporary directory
	local tmpDir; tmpDir="$(tmpDirCreate)" || return
	certMakeCp "$ca" "$certCli" "$certCliKey" "$tmpDir" || return

	# only copy the server certifcates for servers
	local server; server="$(serviceIsServer "$product" "$host")" || return
	[[ "$server" == "true" ]] && { certMake${product^}Server "$host" "$tmpDir/cert" || return; }

	# copy certificates to the host
	copyDirRemote "$tmpDir" "$host" || return

	# install the new certificates on the host
	scriptRun "$host" "$(cat <<-EOF
		$(installServiceTextUser)
		$(installServiceTextDirectories)
		sudoc install --backup=numbered -o "$user" -g "$user" -m 755 -t "$certDirService" "$tmpDir/"* || exit
		$(scriptCleanup)
		EOF
	)" || return

	# restart the service on the host
	[[ "$server" == "true" ]] && { serviceRestart "$product" "$host" || return; }

	# cleanup
	rm -fr "$tmpDir"
}

# update service program command
updateServiceProgramUsage() { echot "usage: $(ScriptName) update service program all|$productUsage\n\n	$certOptUsage"; }
updateServiceProgramCommand() { usage; }
updateServiceProgramAllCommand() { updateServiceProgramConsulCommand && updateServiceProgramNomadCommand && updateServiceProgramVaultCommand; }
updateServiceProgramConsulCommand() { forAllHosts updateServiceProgram "consul"; }
updateServiceProgramNomadCommand() { forAllHosts updateServiceProgram "nomad"; }
updateServiceProgramVaultCommand() { forAllHosts updateServiceProgram "vault"; }

# updateServiceProgram PRODUCT HOST
updateServiceProgram()
{
	local product="$1" host="$2"
	
	header "Update $(ProperCase "$product") Service ($host)"

	# return if the product installation is not needed
	productInstallNeeded "$product" "$host" || return; [[ ! $installNeeded ]] && return

	# install the product
	RunFunction "updateStart" "$product" && productInstallDo "$product" "$host" && RunFunction "updateEnd" "$product"
}

updateStartNomad() { nomadNodeDrainEnable "$host"; }
updateEndNomad() { nomadNodeDrainDisable "$host"; }

#
# service commands
#

serviceUsage() { echot "Usage: $(ScriptName) service config|IsServer|monitor|restart|start|stop|verify $productUsage\nControl Hashi product services."; }

serviceCommand() { usage; }

serviceConfigUsage() { echot "Usage: $(ScriptName) service config $productUsage VAR\nReturn a service configuration variable."; }
serviceConfigCommand() { usage; }
serviceConfigArgs() { ScriptArgGet "varArg" "var" -- "$@"; }
serviceConfigConsulCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "consul"; }
serviceConfigNomadCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "nomad"; }
serviceConfigVaultCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "vault"; }

serviceIsServerCommand() { usage; }
serviceIsServerConsulCommand() { forAllHosts "serviceIsServer" "consul"; }
serviceIsServerNomadCommand() { forAllHosts "serviceIsServer" "nomad"; }
serviceIsServerVaultCommand() { forAllHosts "serviceIsServer" "vault"; }

serviceMonitorCommand() { usage; }
serviceMonitorConsulCommand() { serviceMonitorDo "consul"; }
serviceMonitorNomadCommand() { serviceMonitorDo "nomad"; }
serviceMonitorVaultCommand() { serviceMonitorDo "vault"; }
serviceMonitorDo() { productInit "$1" && "$1" monitor; }

serviceRestartCommand() { usage; }
serviceRestartConsulCommand() { forAllHosts serviceRestart "consul"; }
serviceRestartNomadCommand() { forAllHosts serviceRestart "nomad"; }
serviceRestartVaultCommand() { forAllHosts serviceRestart "vault"; }

serviceStartCommand() { usage; }
serviceStartConsulCommand() { forAllHosts serviceStart "consul"; }
serviceStartNomadCommand() { forAllHosts serviceStart "nomad"; }
serviceStartVaultCommand() { forAllHosts serviceStart "vault"; }

serviceStopCommand() { usage; }
serviceStopConsulCommand() { forAllHosts serviceStop "consul"; }
serviceStopNomadCommand() { forAllHosts serviceStop "nomad"; }
serviceStopVaultCommand() { forAllHosts serviceStop "vault"; }

serviceVerifyCommand() { usage; }
serviceVerifyConsulCommand() { forAllHosts serviceVerify "consul"; }
serviceVerifyNomadCommand() { forAllHosts serviceVerify "nomad"; }
serviceVerifyVaultCommand() { forAllHosts serviceVerify "vault"; }

# serviceVerify PRODUCT - return 1 and an error message if the service for a product is not installed
serviceVerify()
{
	local product="$1" host="$2"; [[ ! $product ]] && MissingOperand "product"

	productVerify "$product" && [[ -d "/etc/$product.d" ]] && service exists "$product" && return
	[[ ! $quiet ]] && ScriptErr "the $product service is not installed"
	return 1
}

# service helper

# hostCopy PRODUCT HOST FILE - copy a service configuration file to the host destination directory with the correct permissions
serviceConfigCopy()
{
	local product="$1" host="$2" file="$3"; serviceVars "$product" || return
	local name="$(GetFileName "$file")" exists; productServiceConfigReturn && return

	serviceConfigCopyStart && LogFile2 "$file" && RunLog scp "$file" "$host:/tmp" && serviceConfigCopyEnd 
}

# serviceConfigCopyText PRODUCT HOST NAME TEXT - copy text to a service configuration file on the host
serviceConfigCopyText()
{
	local product="$1" host="$2" name="$3" text="$4"; serviceVars "$product" || return
	local exists; productServiceConfigReturn && return

	serviceConfigCopyStart && sshRun "$host" "cat <<-EOF > /tmp/$name
		$text
		EOF" && serviceConfigCopyEnd
}

productServiceConfigReturn()
{
	hostFileExists "$host" "$productConfigDir/$name" && exists="true"
	[[ $isServiceInstall && ! $force && $exists ]]
}

# serviceConfigCopyStart - start copying a service configuration file
serviceConfigCopyStart()
{
	# check if the configuration file alreadys exists
	[[ ! $force && $exists ]] && { ScriptErr "configuration file '$name' already exists, use --force to overwrite"; return 1; }
	
	# logging
	hilight "Copying '$name' to $host:$productConfigDir..."
}

# serviceConfigCopyEnd - finish copying a service configuration file
serviceConfigCopyEnd()
{
	local dest="$productConfigDir/$name"

	# move and set permissions on the configuration file
	RunLog scriptRun "$host" "$(cat <<-EOF
		sudoc mv "/tmp/$name" "$dest" || exit
		sudoc chmod 600 "$dest" || exit
		sudoc chown "$user" "$dest" || exit
		sudoc chgrp "$user" "$dest" || exit
		EOF
	)"
}

# serviceConfigDelete PRODUCT FILE HOST - delete a service configuration file on the host
serviceConfigDelete()
{
	local product="$1" file="$2" host="$3"; serviceVars "$product" || return
	local dest="$productConfigDir/$file"

	RunLog scriptRun "$host" "$(cat <<-EOF
		[[ ! -f "$dest" ]] && exit 0
		sudoc rm "$dest"
		EOF
	)"
}

# serviceConfigVarGet VAR PRODUCT HOST - get a variable from the product configuration file, return error if the variable does not exist
serviceConfigVarGet() 
{
	local var="$1" product="$2" host="$3"; serviceVars "$product" || return;
	scriptRun "$host" "grep \"[ ]*$var[ ]*=[ ]*\" \"$productConfigFile\"" | tr -s " " | cut -d"=" -f2 | RemoveCarriageReturn | RemoveSpace | RemoveQuotes
}

# serviceIsServer PRODUCT HOST - return true if HOST is a PRODUCT server, otherwise return false
serviceIsServer()
{
	local product="$1" host="$2"; hostCheck "$host" || return
	local check="bootstrap_expect"; [[ "$product" == "vault" ]] && check="ui"
	serviceConfigVarGet "$check" "$product" "$host" > /dev/null && echo "true" || echo "false"
}

# serviceRemove PRODUCT HOST - remove the service from the host
serviceRemove()
{
	local product="$1"; serviceVars "$product" || return
	local host="$2"; hostCheck "$host" || return 0
	
	scriptRun "$host" "$(cat <<-EOF

		# delete service
		if [[ -f "$productServiceFile" ]]; then
			echo "Deleting the service..."
			sudoc systemctl stop "$product" || exit
			sudoc systemctl disable "$product" || exit
			sudoc rm -f "$productServiceFile" || exit
			sudoc systemctl daemon-reload || exit
			sudoc systemctl reset-failed || exit
		fi

		# remove certificates
		if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
			echoc "Removing automatic CA certificate..."
			sudoc rm -f "$certStoreCa" "$certStoreCaAuto" || exit
			sudoc update-ca-certificates || return
		fi

		printf "cleaning..."
		getent passwd "$product" >&/dev/null && { printf "user..."; sudoc userdel "$product" >& /dev/null; }
		getent group "$product" >&/dev/null && { printf "group..."; sudoc groupdel "$product" >& /dev/null; }
		[[ -d "/etc/$product.d" ]] && { printf "configuration..."; sudoc rm -fr "/etc/$product.d"; }
		[[ -d "/opt/$product" ]] && { printf "data..."; sudoc rm -fr "/opt/$product"; }
		[[ "$removeProgram" && -f "$binDir/$product" ]] && { printf "program..."; sudoc rm -f "$binDir/$product"; }

		[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && { printf "tempory files..."; sudoc rm -fr "/tmp/hashi."*; }
		[[ -d "/tmp/consul-test" ]] && sudoc rmdir "/tmp/consul-test"

		echo "done"

		EOF
	)"
}

# serviceCOMMAND PRODUCT HOST

serviceRestart() 
{
	[[ $noRestartService ]] && return
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudoc systemctl restart "$product" --no-block || exit"; 
}

serviceRestartLocal() 
{
	[[ $noRestartService ]] && return
	local product="$1"; service restart "$product" 
}

serviceStart() 
{
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudoc systemctl start "$product" --no-block || exit"; 
}

serviceStop() 
{
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudoc systemctl stop "$product" --no-block || exit"; 
}

serviceVars()
{
	local product="$1"; certInit "$product" || return
	
	# variables
	program="$(FindInPath "$product")" || return
	user="$product"; [[ "$product" == "nomad" ]] && user="root"; # many Nomad jobs require running as root

	# directories	
	productConfigDir="/etc/$product.d" 
	productDataDir="/opt/$product"

	# configuration
	productConfigFileBase="01_$product.hcl"
	productConfigFile="$productConfigDir/$productConfigFileBase"
	productServiceFile="/etc/systemd/system/$product.service"
	productServiceEnvFile="/etc/systemd/system/$product.env"
}

#
# vault commands
#

vaultUsage() { echot "Usage: $(ScriptName) vault api|environment|status|token|unseal\nVault commands."; }
vaultArgStart() { product="vault"; }
vaultCommand() { usage; }
vaultEnvironmentCommand() { productEnvironment "$product"; }

#
# vault api command
#

vaultApiUsage() { echot "Usage: $(ScriptName) vault api [check|list|put] PATH -- [curl arguments]\nCall the Consul API.  For example:\nhashi vault api /sys/health"; }
vaultApiArgStart() { unset path; }
vaultApiArgs() { [[ "$command" == "vaultApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

vaultApiCommand() { vaultApi "$path" "${otherArgs[@]}"; }
vaultApi() { RunLog curl --silent --show-error --header "X-Vault-Token: $VAULT_TOKEN" "$VAULT_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }

vaultApiListCommand() { vaultApiList "$path" "${otherArgs[@]}"; }
vaultApiList() { vaultApi "$@" --request LIST; }

vaultApiPutCommand() { vaultApiPut "$path" "${otherArgs[@]}"; }
vaultApiPut() { vaultApi "$@" --request PUT; }

vaultApiCheckCommand() { vaultApiCheck; }
vaultApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" && { [[ ! $quiet ]] && ScriptErr "vault server $host is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" && { [[ ! $quiet ]] && ScriptErr "vault server $host is not available on port $port"; return 1; }	

	# check api
	[[ "$(vaultApi "/sys/health" 2> /dev/null | jq '.initialized')" == "true" ]]  && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the vault API at $(productVarGet "ADDR") is not available"; vaultApi "/sys/health"; return 1; }

	return 0
}

#
# vault seal command
#

vaultSealCommand()
{
	local active="$(resolve active.vault)"
	local standby="$(resolve standby.vault)"
	
	header "Vault Seal"
	vaultSeal "$active" && vaultSeal "$standby"
}

vaultSeal()
{
	local host="$1"

	[[ ! $host ]] && return
	echo "Sealing Vault host $host..."
	productInit "vault" "$host" || return
	RunLog vault operator seal || return
}

#
# vault status command
#

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	echo "Active Node            $(resolve active.vault)"
	echo "Standby Node           $(resolve standby.vault)"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac

}

#
# vault token command
#

vaultTokenCommand()
{
	for accessor in $(vault list auth/token/accessors | tail +3); do
		header "$accessor"
		vault token lookup -accessor "$accessor"
	done
}

#
# vault unseal command
#

vaultUnsealUsage() { EchoWrap "Usage: $(ScriptName) vault unseal\nUnseal the vault using keys from the credential store."; }

vaultUnsealCommand()
{
	local host hosts key; vaultHostsGet || return

	for host in "${hosts[@]}"; do
		header "Vault Unseal ($host)"
		productInit "vault" "$host" || return
		vaultIsUnsealed && { echo "Vault on $host is already unsealed"; continue; }

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credGet "key$n")" || return
			RunLog vault operator unseal "$key" || return
		done

	done
}

# vault helper

# vaultHostsGet - set the hosts array to all the Vault hosts
vaultHostsGet()
{
	local json

	# get the hosts from Consul if possible
	if productIsInstalled "consul" && json="$(resolveApi "vault")"; then
		IFS=$'\n' ArrayMake hosts "$( echo "$json" | jq -r '.[].ServiceAddress')"
	fi
	
	# get the hosts from configuration 
	[[ ! $hosts ]] && { getHosts "VaultServers" || return; }

	# no hosts found
	[[ "${#hosts[@]}" == "0" ]] && { ScriptErr "no Vault hosts found"; return 1; }

	return 0
}

vaultIsUnsealed() { vault status | grep -q '^Sealed[ ]*false$'; }

# vaultTokenSetRemote - set the Vault token on a remote host
vaultTokenSetRemote()
{	
	local product="vault"; productInit "$product" || return

	# return if the Vault token is already set on the remote host
	local host; host="$(configServer)" || return
	local token; token="$(sshRunInteractive "$host" credential get "$(credPath)" token --queit "${globalArgs[@]}")" || return
	[[ "$token" == "$VAULT_TOKEN" ]] && return

	sshRunInteractive "$host" credential set "$(credPath)" token "$VAULT_TOKEN" "${globalArgs[@]}" || return
}

# vaultTokenGetRemote - get the Vault token from a remote host if needed
vaultTokenGetRemote()
{
	# return if we have a Vault token
	local product="vault"; { [[ $VAULT_TOKEN ]] || credExists "token"; } && return
	
	# get the token from the host
	local host token; host="$(configServer)" || return
	echo "Getting the Vault token from $host..."
	! IsLocalHost "$host" && token="$(sshRunInteractive "$host" credential get "$(credPath)" token "${globalArgs[@]}" | RemoveCarriageReturn)"
	
	# unable to get the token
	if [[ ! $token ]]; then
		ScriptErr "The Vault token does not exist in the local credential manager on $(configServer) at path $(credPath)"
		return 1
	fi

	# got a token
	export VAULT_TOKEN="$token"
}

#
# certificate helper
#

# certDirLocal PRODUCT - return the local certificate directory for CLI certificates, /opt/hashi/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT if present,
#   otherwise use /opt/PRODUCT/cert (when using the CLI on Hashi servers)
certDirLocal()
{
	local product="$1"
	local dir="$(certDirSuffix "$product" "/opt/hashi")"

	if [[ -d "$dir" ]]; then echo "$dir"
	elif [[ -d "$(certDirService "$product")" ]]; then echo "$(certDirService "$product")"
	else { [[ ! $quiet ]] && ScriptErr "unable to find the $product local certificate directory '/opt/hashi/certificate' or '/opt/$product/cert'"; return 1; }
	fi
}

# certDirPrivate - the root private certificate directory from the --encrypt option or certificateDir configuration
certDirPrivate()
{	
	# private encryption directory specified on command line
	[[ -d "$encrypt" ]] && { echo "$encrypt"; return; }

	# mount encrypted private certificate directory
	local device="$(configGet "CertificateDevice")"
	local dir="$(configGet "CertificateDir")"
	local fullDir="$certVolume/$dir"

	# return if not found
	if [[ ! $device || ! $dir ]]; then
		[[ ! $quiet ]] && ScriptErr "unable to locate the private certificate directory"
		return 1
	fi 

	# return if mounted
	if [[ -d "$fullDir" ]]; then
		echo "$fullDir"
		return
	fi

	# mount
	local ext="$(GetFileExtension "$device")"
	case "$ext" in

		hc) 
			! VeraCrypt IsInstalled && { [[ ! $quiet ]] && ScriptErr "unable to mount certificate device '$device' (VeraCrypt not installed)"; return 1; }
			fullDir="$(RunLog VeraCrypt mount "$device" p --dir "$dir")" || return 1
			;;

		*)
			[[ ! $quiet ]] && ScriptErr "unable to mount certificate device '$device' (type $ext not supported)"
			return 1
			;;

	esac

	[[ ! -d "$fullDir" ]] && { [[ ! $quiet ]] && ScriptErr "certificate directory '$dir' is missing on '$(FileToDesc "$device")'"; return 1; }

	echo "$fullDir"
}

# certDirPublic - return the public certificate directory from an installation file server
certDirPublic() { findInstallFile --quiet "other/HashiCorp" && return "${PIPESTATUS[0]}"; }

# certDirService PRODUCT - return the product service certificate directory
certDirService() { echo "/opt/$1/cert"; }

# certDirSuffix PRODUCT DIR - add certificate suffix to DIR: DIR/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT
certDirSuffix()
{ 
	local product="$1"; shift; 	GetArgs; [[ ! $1 ]] && return 1
	echo "$(RemoveTrailingSlash "$1")/certificate/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
}

# certDirUnmountPrivate - unmount the private certificate directory if mounted.  Directory is changed in case we are in the private certificate directory.
certDirUnmountPrivate()
{
	[[ ! -e "$certVolume" ]] && return
	cd && VeraCrypt unmount "$(GetFileName "$certVolume")"
}

# certExists DIR FILES - return 0 if all certificate files exist in the certificate directory
certExists()
{	
	local file dir="$PWD"; [[ -d "$1" ]] && { dir="$1"; shift; }

	for file in "$@"; do
		[[ ! -f "$dir/$file" ]] && return 1
	done

	return 0
}

# certInit PRODUCT- initialize certificate variables for the specified product
certInit()
{
	local product="$1"; [[ ! $product ]] && MissingOperand "product"

	log2 "initializing $product certificates..."


	# certificates
	ca="$product-ca.pem"
	caLocal="$ca" # CA to use for access to the local server
	caKey="$product-ca-key.pem"	
	certCli=$product-cli.pem
	certCliKey=$product-cli-key.pem
	certClient=$product-client.pem
	certClientKey=$product-client-key.pem
	certServer=$product-server.pem
	certServerKey=$product-server-key.pem

	# other variables
	certDirService="$(certDirService "$product")"
	certDirStore="/usr/local/share/ca-certificates"
	certStoreCa="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$ca").crt"

	# consul clients use an automatic CA
	unset caAuto certStoreCaAuto	
	if [[ "$product" == "consul" ]]; then
		caAuto="$product-ca-auto.pem"
		certStoreCaAuto="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$caAuto").crt"
		isClient && caLocal="$caAuto"
	fi

	return 0
}

# certPublicExists PRODUCT - return true if the public certificate directory for the specified product exists
certPublicExists() { quiet="--quiet" certPublicFind "$1" > /dev/null; }

# certPublicFind PRODUCT - find public certificates
certPublicFind()
{
	local dir product="$1"; certInit "$product" || return
	quiet="--quiet" certPublicCheck "$PWD" && return 																					# check current directory (makeCertCd was called)
	dir="$(certDirPublic | certDirSuffix "$product")" && certPublicCheck "$dir" && return 	# check public directory
	dir="$(certDirPrivate | certDirSuffix "$product")" && certPublicCheck "$dir" && return 	# check private certificate directory
}

certPublicCheck() { [[ -d "$1" ]] || return; certValidate "$1" "$ca" "$certCli" "$certCliKey" && echo "$dir"; }

certStoreInstall()
{
	hilight "Installing '$(GetFileName "$1")' into the operating system certificate store..."
	RunPlatform certStoreInstall "$1" "$2";
}

certStoreInstallMac()
{
	sudoc security add-trusted-cert -d -r trustRoot -k "/Library/Keychains/System.keychain" "$1"
}

certStoreInstallDebian()
{
	local src="$1" dest="$2"

	[[ ! -d "$(GetFilePath "$dest")" ]] && return
	[[ -f "$dest" && ! $force ]] && return
	
	sudoc cp "$src" "$dest" || return
	sudoc update-ca-certificates || return
}

certStoreInstallWin()
{
	local src="$1"
	local file="$(PlatformTmp)/$(GetFileName "$src")"
	cp "$src" "$file" || return
	if CanElevate; then
		RunScript --elevate "${globalArgs[@]}" -- certutil.exe -addstore root "$(utw "$file")" || return
	else
		certutil.exe -addstore NoRoot "$(utw "$file")" || return
	fi	
	rm "$file" || return
}

# certValidate DIR FILES - show an error if a certificate does not exist in the directory
certValidate()
{
	local file dir="$PWD"; [[ -d "$1" ]] && { dir="$1"; shift; }

	for file in "$@"; do 
		if [[ ! -f "$dir/$file" ]]; then
			[[ ! $quiet ]] && EchoErr "$(ProperCase "$product") certificate $file does not exist in '$(FileToDesc "$dir")'"
			return 1
		fi
	done

	return 0
}

#
# credential helper
#

credDelete() { RunLog credential rm "$(credPath)" "$@" "${globalArgs[@]}"; }
credExists() { test="" RunLog credential exists "$(credPath)" "$@" "${globalArgs[@]}"; }
credGet() { test="" RunLog credential get "$(credPath)" "$@" "${globalArgs[@]}"; }

credPath()
{
	local path="$(configGet "credentialPath")" product="${1:-$product}"

	if [[ "$path" ]]; then
		echo "$(RemoveTrailingSlash "$path")/$product"
	else
		echo "/hashi/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
	fi
}

# credSet KEY VALUE
credSet()
{
	log1 "Setting $(credPath) $1 credential to $2..."
	RunLog credential set "$(credPath)" "$@" "${globalArgs[@]}" || return
}

#
# host helper
#

# hostCheck HOST - validate the host argument is set and the host is available
hostCheck()
{
	local host="$1"
	[[ ! $host ]] && MissingOperand "host"
	! IsAvailable "$host" && { [[ ! $quiet ]] && EchoErr "$host is not available"; return 1; }
	return 0
}

# hostFqdn HOST - get and validate the host fully qualified DNS name
hostFqdn()
{
	local host="$1"

	hostCheck "$host" || return
	HasDnsSuffix "$host" && { ScriptErr "host '$host' should not have a DNS suffix"; return 1; }

	local fqdn expectedFqdn="$host.$domain"

	fqdn="$(DnsResolve "$host")" || return; [[ "$fqdn" != "$expectedFqdn" ]] && { ScriptErr "host '$host' fully qualified DNS name is '$fqdn' but '$expectedFqdn' was expected"; return 1; }

	echo "$expectedFqdn"
}

hostCleanup()
{
	local host="$1"; hostCheck "$host" || return 0

	scriptRun "$host" "$(cat <<-EOF
			printf "cleaning..."
			[[ \$(find "$TEMP" -maxdepth 1 -name "hashi.*") ]] && printf "." && sudoc rm -fr "$TEMP/hashi."*
			[[ -d "$TEMP/consul-test" ]] && printf "." && rmdir "$TEMP/consul-test"
			printf "." && rm -f "$TEMP/hashi.service."*
			echo "done"
			EOF
	)"
}

# hostFileExists HOST FILE - return true if the file exists on the host
hostFileExists()
{
	local host="$1" file="$2"
	scriptRun "$host" "[[ -f \"$file\" ]]"
}

#
# product helper
#

productTokenStatus() { local token="${1:-$(productVarGet "TOKEN")}"; [[ $token ]] && echo "true" || echo "${RED}false${RESET}"; }

# productEnvironment [PRODUCT] [HOST] - show the environment variables for the specified product
productEnvironment()
{
	local product="${1:-$product}" host="$2"; certInit "$product" || return

	# variables
	local certDir; certDir="$(quiet="--quiet" certDirLocal "$product")"
	local encrypt; [[ -d "$certDir" ]] && encrypt="true"
	local port; port="$(productGetPort "$product" "$(protocol)")"
	local server; server="$(productGetServer "$product" "$host")" || return
	local url="$(protocol)://$server:$port"
	
	# use the automatic certificate authority if connecting to a consul client
	if [[ "$product" == "consul" ]]; then

		# connecting to the local host
		if IsLocalHost "$server"; then
			[[ -f "$certDirService/$caAuto" ]] && ca="$caAuto" # only clients have the automatic certificate present
		elif [[ "$(typeCheck "$server")" == "client" ]]; then
			ca="$caAuto"
		fi

	fi

	# validate certificates
	certs && [[ ! $suppressErrors ]] && { certValidate "$certDir" "$ca" "$certCli" "$certCliKey" || return; }

	# arguments
	local args="-http-addr=$url"
	certs && args+=" -ca-file=$certDir/$ca -client-cert=$certDir/$certCli -client-key=$certDir/$certCliKey"

	# standard configuration
	cat <<-EOF
		export $(productVar "CONFIG")="$configPrefix"
		export $(productVar "DOMAIN")="$baseDomain"
		export $(productVar "SERVER")="$server"
		export $(productVar "ADDR")="$url"
		export $(productVar "ARGS")="$args"
	EOF

	# certificate configuration
	if certs; then
		cat <<-EOF
			export $(productVar "CACERT")="$certDir/$ca"
			export $(productVar "CLIENT_CERT")="$certDir/$certCli"
			export $(productVar "CLIENT_KEY")="$certDir/$certCliKey"
		EOF
	else
		cat <<-EOF
			export $(productVar "CACERT")=""
			export $(productVar "CLIENT_CERT")=""
			export $(productVar "CLIENT_KEY")=""
		EOF
	fi

	# get the token if not already set, i.e. if cached value, if Nomad sets the VAULT_TOKEN use it, etc.
	local tokenVar tokenVal
	tokenVar="$(productVar "TOKEN")"
	tokenVal="$(productVarGet "TOKEN")"

	if [[ $forceEnvironment || ! $tokenVal ]] && [[ ! $noToken ]]; then
		local exclude=(); [[ ! $VAULT_TOKEN ]] && exclude=( "--exclude-managers=vault" ) # prevent recursion	
		tokenVal="$(credGet "token" "${exclude[@]}")" || return
	fi
	[[ $tokenVal ]] && echo "export $tokenVar=\"$tokenVal\""

	log2 "productEnvironment: product='$product' token='$(productTokenStatus "$tokenVal")' args='$args'"
	return 0
}

# productGetPort PRODUCT http|https - get the primary port for the specified product
productGetPort()
{
	local product="$1" protocol="$2"
	declare -n port="${product}${protocol^}Port"
	echo "$port"
}

# productGetServer PRODUCT [HOST] - get the server for the product
productGetServer()
{
	local product="$1" host="$2"
	local server; server="$(productGetServerDo)" || return

	[[ ! $server ]] && { ScriptErr "unable to find a $product server for the '$configDesc' configuration"; return 1; }

	# return server - use 127.0.0.1 or the fully qualified DNS name (to match the certificate)
	IsLocalHost "$server" && echo "127.0.0.1" || DnsResolve $quiet "$server"
}

productGetServerDo()
{
	# use the passed host
	[[ $host ]] && { echo "$host"; return; }

	# use the --api argument
	[[ $api ]] && { echo "$api"; return; }

	# use the <product>_SERVER environment variable if it is valid
	if [[ ! $force && $(productVarGet "SERVER") ]]; then
		server="$(productVarGet "SERVER")"
		DnsResolve --quiet "$server" >& /dev/null && { echo "$server"; return; }
	fi

	# use the local host for the server if the product service is running
	if [[ "$product" != @(nomad) ]] && [[ -f "/etc/systemd/system/$product.service" ]] && IsProcessRunning "$product" && service running "$product"; then
		echo "127.0.0.1"; return
	fi

	# use DNS to resolve the service	
	if server="$(GetServer "$product" --quiet)"; then
		echo $server; return
	fi

	# use consul to resolve the server for the product
	if [[ "$product" != "consul" ]] && server="$(quiet="--quiet" productResolve "$product")"; then
		echo $server; return
	fi

	# use the first host specified by the --host or --servers arguments
	if [[ $hostArg || $servers ]]; then
		local hosts; getHosts "${servers[@]}" || return
		echo "${hosts[0]}"; return
	fi

	# use the first server specified in bootstrap-config.sh
	echo "$(configServer)"
}

# productInit PRODUCT [HOST] - enable product for use  on host in this script
productInit()
{
	local product="$1" host="$2"; [[ ! $product ]] && MissingOperand "product"
	log2 "productInit: initializing $product"
	productVerify "$product" && initConfig "$product" && certInit "$product" && ScriptEval productEnvironment "$product" "$host"
}

# productInstall PRODUCT HOST
productInstall()
{
	local product="$1" host="$2"

	# return if the product installation is not needed
	productInstallNeeded "$product" "$host" || return
	[[ ! $installNeeded ]] && return

	# install the product
	productInstallDo "$product" "$host"
}

# productInstallNeeded PRODUCT HOST - return true if the product install is needed on the host.
#   Exports installDir, installFile, and installNeeded
productInstallNeeded()
{
	local product="$1" host="$2"; hostCheck "$host" || return
	local fileExists currentVersion newVersion

	installNeeded="true"

	# location the installation directory
	installDir="$(findInstallFile "other/HashiCorp/$product")" || return

	# determine if the product is installed
	if IsLocalHost "$host"; then
		installFile="$(os executable find "$installDir")" || return
		[[ ! $force ]] && InPath "$product" && fileExists="true"
		what="$installFile"
	else
		[[ ! $force ]] && sshRun "$host" "[[ -f \"$binDir/$product\" ]]" && fileExists="true"
		what="$host"
	fi

	# check the versions
	if [[ ! $force && $fileExists ]]; then
		currentVersion="$(productVersion "$product")" || return
		newVersion="$(productVersion "$product" "$what")" || return
		[[ "$currentVersion" == "$newVersion" ]] && installNeeded=""
	fi

	return 0
}

# productInstallDo PRODUCT HOST - requires that productInstallNeeded is called first
productInstallDo()
{
	local product="$1" host="$2"
	
	hilight "Installing $product ($host)..."

	# local install
	if IsLocalHost "$host"; then
		local user="root" group="root"
		IsPlatform mac && group="wheel"
		IsPlatform qnap && { user="admin"; group="administrators"; }
		sudoc ${G}install -o "$user" -g "$group" -m 755 -T "$installFile" "$TEMP/$product" || return
		sudoc mv "$TEMP/$product" "$binDir/$product" || return # macOS requires mv or new process killed
		return
	fi

	# determine the host architecture	
	printf "$host architecture..."
	local machine="$(sshRun "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm";;
		*) machine="amd64";; 
	esac
	printf "$machine..."

	# find the program
	local file="$(find "$installDir" -maxdepth 1 -type f  -name "$product*_linux_$machine" | sort --numeric-sort | tail -1)"
	[[ ! -f "$file" ]] && { echo; ScriptErr "unable to find the $product program"; return 1; };
	echo "$(GetFileName "$file")"

	# copy the program to the host
	scp "$file" "$host:/tmp/$product" || return

	# update the program on the host
	local productServiceFile="/etc/systemd/system/$product.service"

	scriptRun "$host" "$(cat <<-EOF
		[[ -f "$productServiceFile" ]] && { printf "stopping service..."; sudoc systemctl stop "$product" || exit; echo "done"; }
		sudoc cp "/tmp/$product" "$binDir" || exit
		[[ -f "$productServiceFile" ]] && { printf "starting service..."; sudoc systemctl start "$product" --no-block || exit; echo "done";  }
		exit 0
		EOF
	)" || return

}

# productInstallCerts PRODUCT - copies certificates locally for command line use, creates certDirLocal
productInstallCerts()
{
	local product="$1"; certInit "$product" || return
	local src; src="$(certPublicFind "$product")" || return
	local dest="$(certDirSuffix "$product" "/opt/hashi")" # always install certificates to /opt/hashi 

	[[ -f "$dest/$ca" && ! $force ]] && return	

	hilight "Installing ${product^} certificates..."
	sudoc ${G}mkdir --parents "$dest" || return
	RunLog sudoc cp "$src/$ca" "$src/$certCli" "$src/$certCliKey" "$dest" || return
	[[ -f "$src/$caAuto" ]] && { RunLog sudoc cp "$src/$caAuto" "$dest" || return; }
	sudoc chmod +r "$dest/"* || return

	certStoreInstall "$src/$ca" "$certStoreCa" || return
	[[ -f "$src/$caAuto" ]] && { certStoreInstall "$src/$caAuto" "$certStoreCaAuto" || return; }
		
	return 0
}

productIsInstalled() { [[ $(FindInPath "${1:-$product}") ]]; }

# productResolve PRODUCT - resolve the host name for the specified product
productResolve()
{
	local product="$1"
	local name="$product"; [[ "$product" == "vault" ]] && name="active.vault"
	resolve "$name"
}

# productVar VAR - get the environment variable name
productVar()
{
	local var="${1^^}"
	local http; [[ "$product" == "consul" && "$var" == @(ADDR|TOKEN) ]] && http="HTTP_";
	echo "${product^^}_${http}${var}"; 
}

# productVarGet VAR - get a product variable from the environment
productVarGet()
{
	local var="$1"
	local -n v="$(productVar "$var")"
	echo "$v"
}

# productVarSet VAR VALUE - set a product environent variable 
productVarSet()
{
	local var="$1" value="$2"
	local -n v="$(productVar "$var")"
	v="$value"
}

# productVerify PRODUCT - return 1 and an error message if the product is not installed
productVerify() 
{
	local product="$1"; [[ ! $product ]] && MissingOperand "product"
	productIsInstalled "$product" && return
	[[ ! $quiet ]] && ScriptErr "$product is not installed"
	return 1
}

# productVersion PRODUCT WHAT - show the versionof the specified product
productVersion()
{
	local product="$1" what="${2:-$HOSTNAME}" desc version

	# file
	if [[ -f "$what" ]]; then

		# use the standard download file format (PRODUCT_VERSION_PLATFORM_ARCHITECURE) if possible, since running Go programs on network shares from Windows can fail
		local file="$(GetFileName "$what")"
		[[ "$(GetWord "$file" 1 _)" == "$product" ]] && version="$(GetWord "$file" 2 _)" || version="$("$what" --version)" 
		desc="$(FileToDesc "$what")"

	# localhost
	elif IsLocalHost "$what"; then
		version="$($product --version | productVersionFilter)"
		desc="local"

	# host
	else
		version="$(sshRun "$what" -- "$product" --version | productVersionFilter)"
		desc="$what"
	fi
	
	log1 "$product version ($desc) is $version"
	echo "$version"
}

productVersionFilter() { head -1 | cut -d" " -f 2 | RemoveFront v; }
	
#
# helper
#

certs() { [[ $encrypt ]]; } # true if certificates are being used
doHashi() { hashi "$@" $force $test "${configFileArg[@]}" "${configPrefixArg[@]}" "${otherArgs[@]}" "${globalArgs[@]}"; }
isClient() { [[ "$type" == "client" ]]; }
isServer() { [[ "$type" == "server" ]]; }
sshAgentCheck() { [[ $sshAgentChecked ]] && return; SshAgentConf --quiet "${globalArgs[@]}" && sshAgentChecked="true"; }
sshRun() { sshAgentCheck && RunLog ssh "$@"; }
sshRunInteractive() { sshAgentCheck && RunLog SshHelper "$1" --interactive "${globalArgs[@]}" -- "${@:2}"; }
protocol() { certs && echo "https" || echo "http"; }
whatArgGet() { ScriptOptGet "whatArg" "what" "$@"; StringToArray "${whatArg,,}" "," whatArg; }
whatCheck() { [[ ! $whatArg ]] && return 0; local w; for w in "$@"; do IsInArray "$w" whatArg && return; done; return 1; }
whatCheckConfig() { local c; for c in $configWhat; do whatCheck "$c" && return; done; return 1; }

# configFileValidate FILE - return true and the type of the file if thefile is a valid HashiCorp configuration file
configFileValidate()
{
	local type="$(GetFileExtension "$file")"
	[[ ! "$type" == @(hcl|json) ]] && { ScriptErr "Specified file /`$file/` is not a valid HashiCorp configuration file"; return 1; }
	echo "$type"
}

copyDirRemote()
{
	local dir="$1" host="$2"
	IsLocalHost "$host" && return
	hilight "Copying files to $host..."
	scp -r "$dir" "$host:/$dir"
}

copyFile()
{
	local file="$1" dest="$2"
	[[ -f "$dest/$file" && ! $force ]] && return	
	RunLog cp "$file" "$dest"
}

encryptOpt()
{
	case "$1" in
		-e|--encrypt|-e=*|--encrypt=*) ScriptOptGet --optional "encrypt" "$@" && ScriptCheckDir "$encrypt" || encrypt="true";;
		-ne|--no-encrypt) unset encrypt;;
		*) return 1;;
	esac
}

encryptCliOpt()
{
	encryptOpt "$@" && return
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		*) return 1;;
	esac
}

findInstallFile()
{
	i check || return # cache the installation directory
	FindInstallFile "$@"
}

# forAllHosts COMMAND [ARGS...] - run a command for all hosts.  If forAllHeader is set and there is more than one host display it as a header.
forAllHosts() { local host hosts; getHosts && ForAllHosts "$@"; }

# getDnsServer - get an available consul server for DNS queries on port 8600
getDnsServer()
{
	local server; server="$(productGetServer "consul")"
	[[ ! $server ]] && { [[ ! $quiet ]] && ScriptErr "no consul server found"; return 1; }
	log1 "found consul consul server '$server'"
	! IsAvailablePort "$server" 8600 && { [[ ! $quiet ]] && ScriptErr "consul server $server port 8600 is not available"; return 1; }
	echo "$server"
}

# getHosts [HOSTS]
getHosts() 
{
	local h="${hostArg,,}"

	# use the hostArg if specified
	if [[ $h ]]; then

		# active servers
		if [[ "$h" == "active" ]]; then
			hosts=( $(GetAllServers) )

		# all servers in configurations
		elif [[ "$h" == "all" ]]; then
			configServers

		# clients or servers in configuration
		elif [[ "$h" == @(clients|servers) ]]; then
			configGetArray "$h" hosts
		
		# ordered server from configuration, servers first, then clients
		elif [[ "$h" == @(1|2|3|4|5|6|first|second|third|fourth|fifth|sixth) ]]; then
			local servers; configGetArray "servers"
			local clients; configGetArray "clients"
			local hosts=(); ArrayAppend hosts servers clients

			[[ "$h" == @(1|first) ]] && hosts=( "${hosts[0]}" )
			[[ "$h" == @(2|second) ]] && hosts=( "${hosts[1]}" )
			[[ "$h" == @(3|third) ]] && hosts=( "${hosts[2]}" )
			[[ "$h" == @(4|fourth) ]] && hosts=( "${hosts[3]}" )
			[[ "$h" == @(5|fifth) ]] && hosts=( "${hosts[4]}" )
			[[ "$h" == @(6|sixth) ]] && hosts=( "${hosts[5]}" )

		# comma separated lists of hosts
		else 
			StringToArray "$hostArg" "," hosts
		fi

	# passed argument - empty or all
	elif [[ $# == 0 ]] || [[ $# == 1 && "$1" == "all" ]]; then
		configServers
		
	# passed argument - configuration variable (clients, servers, etc.)
	elif [[ $# == 1 && $(configGet "$1") ]] ; then
		configGetArray "$1" "hosts"
	
	# passed arguments
	else
		hosts=( "${@}" )
	fi

	[[ ! $hosts ]] && MissingOperand "host"

	return 0
}

# initConfig [PRODUCT] - initialize configuration variables configPrefix (i.e. test) and configDesc (i.e. prod, test).
#   If configPrefix is empty, this is a production configuration with description prod.
initConfig()
{
	local product="$1"

	# set the configuration prefix from the environment variable if it has not been set
	! IsVar configPrefix && [[ $product ]] && { configPrefix="$(productVarGet "CONFIG")"; } 

	# set configuration prefix aliases
	[[ "${configPrefix,,}" == "prod" ]] && configPrefix=""

	# set configuration description
	configDesc="${configPrefix:-prod}"

	return 0
}

policyDownload()
{
	local url="$1"	
	local install; install="$(FindInstallFile other/HashiCorp/acl)" || return
	local dest="$install/$(GetFileName "$url")"

	[[ ! -f "$dest" ]] && { curl "$url" --silent --show-error --location --output "$dest" || return; }
	echo "$dest"
}

removeDir()
{
	local dir="$1"
	[[ ! $dir || ! -d "$dir" || "$(DirCount "$dir")" == 0 ]] && return
	echo "Deleting '$(FileToDesc "$dir")'..."
	RunLog sudoc DelDir --contents "$dir"
}

scriptCertStore()
{
	local dest="$1"

	cat <<-EOF
		if [[ -f "$dest/$ca" ]] && [[ ! -f "$certStoreCa" || "$force" ]]; then
			echo "Installing CA certificate..."
			sudoc cp "$dest/$ca" "$certStoreCa" || exit
			sudoc update-ca-certificates || exit
		fi

		if [[ "$caAuto" && -f "$dest/$caAuto" ]] && [[ ! -f "$certStoreCaAuto" || "$force" ]]; then
			echo "Installing automatic CA certificate..."
			sudoc cp "$dest/$caAuto" "$certStoreCaAuto" || exit
			sudoc update-ca-certificates || exit
		fi
	EOF
}

scriptCleanup() 
{
	cat <<-EOF
		printf "Cleaning up..."; rm -fr "$tmpDir"; echo done
	EOF
}	

# scriptRun "$host" SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local host="$1" script="$2" functions="$(FindInPath function.sh | GetFullPath)"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		else
			sudoc() { sudoc "\$@"; }		  
		fi

		$script
		EOF
	)"

	# logging
	if [[ $verbose ]]; then
		header "$(ScriptPrefix)Running Script on $host" >& /dev/stderr; 
		log1 "$@"
		HeaderDone >& /dev/stderr
	fi

	# run
	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# --hashi - use HashiCorp Vault credentials if possible
		# --pseudo-terminal - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		# --x-forwarding - enable X11 forwardining for credential store access
		sshAgentCheck && SshHelper connect --x-forwarding --hashi "${globalArgs[@]}" "$host" -- "$script"
	fi
}

# serviceDnsName NAME - append the full Consul service DNS name to name, i.e. NAME -> NAME.service.hagerman.butare.net
serviceDnsName() { echo "$1.$(configGet "DnsDomain").$domain"; }

# serviceDnsNameShort NAME - append the short Consul service DNS name to name (without the datacenter), i.e. NAME -> NAME.service.butare.net
serviceDnsNameShort() { echo "$1.$(configGet "DnsDomain").$baseDomain"; }

tmpDirCreate()
{
	local dir; dir="$(${G}mktemp -d -t "hashi.XXXXXXXXXX")" || return
	(( verboseLevel > 2 )) && LogMessage "using temporary directory $(FileToDesc "$dir")"
	echo "$dir"
}

# typeCheck HOST
typeCheck()
{
	local host="$1" type="client"

	# resolve IP address to a hostname
	IsIpAddress "$host" && { host="$(DnsResolve "$host")" || return; }

	# check the HOSTNAME for the local host
	IsLocalHost "$host" && host="$HOSTNAME"

	# remove the DNS suffix from the hostname
	host="$(RemoveDnsSuffix "$1")" 

	# --assume-server was specified
	if [[ $assumeServer ]]; then
		type="server"

	# host is in the --servers argument
	elif IsArray servers && IsInArray "$host" servers; then
		type="server"

	# host is in the servers configuration
	else
		local servers; ! IsArray servers && configGetArray "servers"
		IsInArray "$host" servers && type="server"

	fi

	log1 "$host type is a $type"
	echo "$type"
}

ScriptRun "$@"
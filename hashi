#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script color || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Helper commands for HashiCorp consul, nomad, and vault products.

Product commands: consul|nomad|vault

Common commands:  app|cert|config|install|remove|service|update
	resolve						resolve a service
	PRODUCT|all				commands for a product or all products
	status						show status for all products

Common options:
	-a,	 --api						server for API communication
	-cf, --config-file		configuration file to use in place og bootstrap-config.sh
	-cp, --config-prefix	configuration prefix to use, i.e. test
	-H,  --host HOST			comma separated list of hosts for the command
												aliases: active|all|clients|servers|1|2|3|4|5|6|first|second|third|fourth|fifth|sixth
	-is, --is-server			assume the hosts are servers"
}

usageVerbose()
{ 
	ScriptUsageEcho "
Other commands: cleanup|version
	ui								start the hashi-ui server and launch it

Other options:
	-nrs, --no-restart-service	do not restart services
	-nt, 	--no-token 						do not use a token for the command
	-t, --timeout								$(ScriptOptTimeoutUsage)"
}

init()
{
	unset certVolume certVolumeWasMounted product sshAgentChecked
	products=( consul nomad vault )
	productUsage="consul|nomad|vault"
	binDir="/usr/local/bin"; IsPlatform entware && binDir="/opt/bin"
	certOptUsage="-e, --encrypt [DIR]		directory for PKI certificates
	-ne, --no-encrypt			disable TLS encryption
	-fc, --force-cert			force creation of certificate even if it exists (dangerous)"
	configWhat="consul-vault-data local-certs local-credentials private-certs public-certs"
	DbusConf $verbose $force || return # Vault error if DBUS_SESSION_BUS_ADDRESS is not set
}

argStart()
{
	unset -v api assumeServer configFile configFileArg configPrefix configPrefixArg hostArg noRestartService noToken
	ScriptOptTimeoutArgStart || return
}

opt()
{
	case "$1" in
		--api|--api=*|-a|-a=*) ScriptOptGet api "$@";;
		--config-file|--config-file=*|-cf|-cf=*) ScriptOptGet "configFile" "config-file" "$@" && ScriptCheckFile "$configFile" && configFileArg=(--config-file "$configFile");;
		--config-prefix|--config-prefix=*|-cp|-cp=*) ScriptOptGet "configPrefix" "config-prefix" "$@" && configPrefixArg=(--config-prefix "$configPrefix");;
		--host|--host=*|-H|-H=*) ScriptOptGet hostArg host "$@";;
		--no-restart-service|-nrs) noRestartService="--no-restart-service";;
		--no-token|-nt) noToken="--no-token";;
		--is-server|-is) assumeServer="true";;
		--timeout|-t|--timeout=*|-t=*) ScriptOptTimeout "$@";;
		*) return 1;;
	esac
}

argEnd()
{
	# basic configuration
	datacenter="$(GetDnsDomain | RemoveDnsSuffix)"; argValidate "$datacenter" "data center" || return
	baseDomain="$(GetNetworkDnsBaseDomain)"; argValidate "$baseDomain" "DNS base domain" || return
	domain="$(GetNetworkDnsDomain)"; argValidate "$domain" "DNS domain" || return

	# port configuration
	consulHttpPort="8500" consulHttpsPort="8501"
	nomadHttpPort="4646" nomadHttpsPort="$nomadHttpPort"
	vaultHttpPort="8200" vaultHttpsPort="$vaultHttpPort"
	vaultClusterHttpPort="8201" vaultClusterHttpsPort="$vaultClusterHttpPort"

	# product configuration - set product from command if possible
	if [[ $product ]]; then
		productInit "$product" || return
	else
		initConfig || return
	fi

	# set command specific forces
	unset forceEnvironment
	if [[ $force ]]; then
		if [[ "${commands[1]}" == @(configEnvironment) ]]; then forceEnvironment="true"
		fi
	fi

	return 0
}

argValidate()
{
	local argValue="$1" desc="$2";
	if [[ $argValue ]]; then
		log3 "argValidate: the '$desc' is '$argValue'"
		return
	fi
	ScriptErr "'$desc' is not set"
}

cleanup()
{
	[[ ! $certVolumeWasMounted ]] && return
	certDirUnmountPrivate
}

#
# commands
#

versionCommand() { :; }

cleanupCommand()
{
	local hosts; getHosts "localhost" || return

	for host in "${hosts[@]}"; do
		header "Cleanup ($host)"
		hostCleanup "$host" || return
	done
}

statusCommand()
{
	header "Consul"
	consul members || return
	echo

	header "Nomad"
 	nomad node status
 	echo
 	nomadVaultStatus
 	echo

 	header "Vault"
 	vault status
}

uiCommand()
{
	local product

	for product in "consul" "nomad"; do
		productInit "$product" || return
		export ${product}_ENABLE="true"
		export ${product}_ADDR="$(productVarGet "ADDR")"
		export ${product}_ACL_TOKEN="$(productVarGet "TOKEN")"	
		unset ${product}_HTTP_SSL; [[ "$(GetUriProtocol "${product}_ADDR")" == "https" ]] && export ${product}_HTTP_SSL="true"
	done

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# all commands
#

allUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) all environment|status
Commands for all products."; }

allCommand() { usage; }
allEnvironmentCommand() { configEnvironmentAll; }

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# app commands
#

appUsage() { ScriptUsageEcho "Usage: $(ScriptName) app alive|ls|node|server|verify"; }
appArgStart() { unset app; product="consul"; }
appCommand() { usage; }

appLsUsage() { ScriptUsageEcho "Usage: $(ScriptName) app ls\nList all applications."; }
appLsCommand() { appLs; }
appLs() { consul kv get -recurse app | ${G}grep "/hosts/" | cut -d/ -f2 | sort | uniq; }

#
# app alive command 
#

appAliveUsage() { ScriptUsageEcho "Usage: $(ScriptName) app alive APP\nReturn 0 if the application has at least one running node."; }
appAliveArgStart() { unset -v app; }
appAliveArgs() { ScriptArgGet "app" -- "$@"; }
appAliveCommand() { name="$app" quiet="--quiet" RunLog resolvePassingCommand > /dev/null; }

#
# app node commands
#

appNodeUsage()  { ScriptUsageEcho "Usage: $(ScriptName) app node [status|register|unregister](status)"; }
appNodeCommand() { appNodeStatusCommand; }

#
# app node status command 
#

appNodeStatusUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) app node status
Show applications configured on the host by checking the Nomad app.<APP> metadata tags.

	-a,	--active		show currently running applications on the host"
}

appNodeStatusArgStart() { unset -v active; }

appNodeStatusOpt()
{
	case "$1" in
		--active|-a) active="--active";;
		*) return 1;;
	esac
}

appNodeStatusCommand()
{
	local json; json="$(nomad node status -json)" || return
	forAllHosts --brief appNodeStatus
}

appNodeStatus()
{
	local host="$(RemoveDnsSuffix "$1")"

	# check status
	local status; status="$(nomadNodeEligibilityStatus "$host")" || return
	[[ "$status" == @(down|ineligible) ]] && { InitColor; printf "${RED}$status${RESET} "; }

	# get all apps for the host
	local app apps; IFS=$'\n' ArrayMake apps "$(appNodeGet "$host")" || return

	# show all apps
	[[ ! $active ]] && { ArrayDelimit apps " "; return; }

	# show active apps		
	for app in "${apps[@]}"; do
		GetServers --quiet "$app" | ${G}grep --quiet "^$host." && printf "$app "
	done
	echo
}

# appNodeGet HOST - get all of the applications on the specified host by searching for Nomad app.<APP> metadata tags
appNodeGet() { verbose="--verbose" RunErr nomadNodeStatus "$1" | ${G}grep '^app\.' | cut -d" " -f1 | cut -d. -f2 | sort; }

#
# app node [un]register commands
#

appNodeRegisterUsage() { ScriptUsageEcho "Usage: $(ScriptName) app node register APP\nRegister the application on this host with Consul and Nomad."; }
appNodeRegisterArgs() { ScriptArgGet "app" -- "$@"; }

appNodeRegisterCommand()
{
	local host="${hostArg:-$HOSTNAME}"; host="${host,,}"

	# Consul
	if [[ ! $(consul kv get -recurse "app/$app/hosts/${HOSTNAME,,}") ]]; then
		hilight "Registering '$app' application in Consul..."
		consul kv put "app/$app/hosts/${HOSTNAME,,}" || return
		echo
	fi
	
	# Nomad - remote host
	if ! IsLocalHost "$host"; then
		! IsAvailable "$host" $timeout && { ScriptErr "host '$host' is not available"; return 1; }
		sshRunInteractive "$host" "hashi app node register $app"; return
	fi

	# Nomad - local host
	local file="/etc/nomad.d/03_$app.hcl"
	[[ -f "$file" && ! $force ]] && return
	serviceVerify "nomad" || return	

	hilight "Registering '$app' application in Nomad..."

 	cat <<-EOF | sudoc ${G}tee "$file" || return
		client {
		  meta { 
		    app.$app = "true" 
		  }
		}
	EOF

	serviceRestartLocal "nomad"
}

appNodeUnregisterUsage() { ScriptUsageEcho "Usage: $(ScriptName) app node unregister APP\nUnregister the application on this or the specified host in Consul and Nomad."; }
appNodeUnregisterArgs() { ScriptArgGet "app" -- "$@"; }

appNodeUnregisterCommand()
{
	local host="${hostArg:-$HOSTNAME}"; host="${host,,}"

	# Consul
	if [[ $(RunLog consul kv get -recurse "app/$app/hosts/$host") ]]; then
		hilight "Unregistering '$app' application in Consul for host '$host'..."
		consul kv delete -recurse "app/$app/hosts/$host" || return
		echo
	fi

	# Nomad - remote host
	if ! IsLocalHost "$host"; then
		! IsAvailable "$host" && { ScriptErr "host $host is not available"; return 1; }
		sshRunInteractive "$host" "hashi app node unregister $app"; return
	fi

	# Nomad - local host
	local file="/etc/nomad.d/03_$app.hcl"
	serviceVerify "nomad" || return
	[[ ! -f "$file" ]] && return

	hilight "Unregistering '$app' application in Nomad on host '$host'..."
	sudoc rm "$file" && serviceRestartLocal "nomad"
}

#
# app server commands
#

appServerUsage()
{
	EchoWrap "Usage: $(ScriptName) app server [not] [all|active|available](all) APP
Show servers registered to run the application using the information in then Consul key 'app/<APP>/hosts'."
}

appServerArgs() { ScriptArgGet "app" -- "$@"; }
appServerCommand() { appServerAllCommand; }

appServerNotCommand() { usage; }

appServerActiveUsage() { ScriptUsageEcho "Usage: $(ScriptName) app server up APP\nShow servers where the application is actively running."; }
appServerActiveCommand() { appServerActive "$app" | sort -V; }

appServerAllUsage() { ScriptUsageEcho "Usage: $(ScriptName) app server all APP\nShow all servers that can host the application."; }
appServerAllCommand() { appServerAll "$app" | sort -V; }

appServerAvailableUsage() { ScriptUsageEcho "Usage: $(ScriptName) app server available APP\nShow available servers for the application.  These servers are accessible and may be running the applciation."; }
appServerAvailableCommand() { appServerAvailable "$app"; }

appServerNotActiveUsage() { ScriptUsageEcho "Usage: $(ScriptName) app server not active APP\nShow servers where the application is not currently running."; }
appServerNotActiveCommand() { appServerNotActive "$app"; }

appServerNotAvailableUsage() { ScriptUsageEcho "Usage: $(ScriptName) app server not available APP\nShow unavailable servers for the application.  These servers are down and are not available to run the applciation"; }
appServerNotAvailableCommand() { appServerNotAvailable "$app"; }

appServerActive() { resolveName "$1" --all; }
appServerAll() { consul kv get -recurse "app/$1/hosts" | cut -d/ -f4 | cut -d: -f1 | DnsResolveBatch; }
appServerAvailable() { local hosts; hosts="$(appServerAll "$1")" && IsAvailableBatch $hosts | sort -V; }
appServerNotAvailable() { local all available; available="$(appServerAvailable "$1")" && all=( $(appServerAll "$1") ) && ArrayRemove all "$available" && ArrayDelimit all $'\n' | RemoveEmptyLines | sort -V; }
appServerNotActive() { local all active; active="$(appServerActive "$1")" && all=( $(appServerAll "$1") ) && ArrayRemove all "$active" && ArrayDelimit all "\n" | RemoveEmptyLines | sort -V; }

#
# app verify
#

appVerifyUsage() { ScriptUsageEcho "Usage: $(ScriptName) app verify [APP|all]\nVerify all known servers for the application are configured to run the application, and vice-versa."; }
appVerifyArgs() { ScriptArgGet "app" -- "$@"; }

appVerifyCommand()
{
	[[ "$app" == "all" ]] && { appVerifyAll; return; }
	appVerify "$app"
}

appVerifyAll()
{
	local app apps errors=0; IFS=$'\n' ArrayMake apps "$(appLs)" || return
	for app in "${apps[@]}"; do
		appVerify "$app"; (( errors+=$? ))
	done
	return $errors
}

appVerify()
{
	local errors=0 app="$1";

	printf "Verifying the '$app' application..."

	# check if each registered server for the application is configured to run the application by checking the servers Nomad app.<APP> metadata tags
	local registeredServer registeredServers; IFS=$'\n' ArrayMake registeredServers "$(appServerAll "$app" | sort -V)" || return
	for registeredServer in "${registeredServers[@]}"; do
		! IsAvailable "$registeredServer" $timeout && { (( errors++ )); HilightErr "Cannot check if server '$(RemoveDnsSuffix "$registeredServer")' is configured to run '$app', it is not available"; continue; }
		! appNodeGet "$registeredServer" | sqgrep "^$app$" && { (( errors++ )); HilightErr "Server '$(RemoveDnsSuffix "$registeredServer")' is not configured to run '$app'"; continue; }
		[[ ! $errors ]] && print "."
	done

	# check if active servers configured to run the application (which have the Nomad app.<APP> metadata tag) are registered to run it
	local host; for host in $(GetAllServers); do
		IsInArray "$host" registeredServers && continue # already checked each registered server
		appNodeGet "$host" | sqgrep "$app" && { (( errors++ )); HilightErr "Server '$(RemoveDnsSuffix "$host")' is configured to run '$app', but it is not registered"; continue; }
	done
	
	(( errors == 0 )) && echo "ok"
	return $errors
}

#
# certificate commands
#

certUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) cert copy|make|status

	copy		copy public certificates
	make		make certificates
	status	show certificate status

	$certOptUsage"
}

certArgStart() { unset -v forceCert noEncrypt; encrypt="true"; }
certOpt() { encryptOpt "$@"; }
certCommand() { usage; }

#
# cert copy commands
#

certCopyUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) cert copy all|$productUsage
Copy public CLI certificates to the public installation location.\n\n  $certOptUsage"; }

certCopyCommand() { usage; }
certCopyAllCommand() { certCopyPublic "consul" && certCopyPublic "nomad" && certCopyPublic "vault"; }
certCopyConsulCommand() { certCopyPublic "consul"; }
certCopyNomadCommand() { certCopyPublic "nomad"; }
certCopyVaultCommand() { certCopyPublic "vault"; }

# certCopyPublic PRODUCT - copies public certificates from the private certificate directory to the public certificate directory
certCopyPublic()
{
	local product="$1"

	# initialization
	initConfig "$product" || return
	certInit "$product" || return

	# source directory (private certificates)
	local src; src="$(certDirPrivate | certDirSuffix "$product")" || return
	local cert certs=( "$ca" "$certCli" "$certCliKey" ); [[ $caAuto ]] && certs+=( "$caAuto" )

	certValidate "$src" "${certs[@]}" || return

	# destination directory (public certificates)
	local dest; dest="$(certDirPublicSuffix "$product")" || return
	${G}mkdir --parents "$dest" || return

	# return if the source (private) and destination (public) locations are the same
	[[ "$src" == "$dest" ]] && return

	# return if the certificates exist in the destination location
	[[ ! $force ]] && certExists "$dest" "${certs[@]}" && return

	# copy the certificates
	echo "Copying ${product^} public certificates to '$(FileToDesc "$dest")'..."
	for cert in "${certs[@]}"; do
		copyFile "$src/$cert" "$dest" || return
	done
}

#
# Certificate Make Command
#

certMakeUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) cert make all|$productUsage [server]
Create certificates required for HashiCorp products.\n\n  $certOptUsage"; }

certMakeArgEnd() { [[ ! $encrypt ]] && MissingOption "encrypt"; return 0; }
certMakeCommand() { usage; }
certMakeAllCommand() { certMake "consul" && certMake "nomad" && certMake "vault"; }
certMakeConsulCommand() { certMake "consul"; }
certMakeNomadCommand() { certMake "nomad"; }
certMakeVaultCommand() { certMake "vault"; }
certMakeConsulServerCommand() { forAllHosts certMakeConsulServer; }

certMakeNomadServerUsage() { ScriptUsageEcho "Usage: $(ScriptName) cert make nomad server\nCreate certificates required for Nomad server.  Updates nomad-server-key.pem and nomad-server.pem.  Useful if the Nomad server DNS names change.\n\n  $certOptUsage"; }

certMakeNomadServerCommand() { local hosts; getHosts "${hostArg:-servers}" && hostJoinInit "${hosts[@]}" && certMakeNomadServer; }
certMakeVaultServerCommand() { forAllHosts certMakeVaultServer; }

# certMakeCd PRODUCT - mount and change to the private certificate directory for the product
certMakeCd()
{
	local product="$1"; certInit "$product" || return
	local dir; dir="$(certDirPrivate | certDirSuffix "$product")" && ${G}mkdir --parents "$dir" && command cd "$dir"
}

# certMakeCp CERT... DEST - copy certificates to the destination directory
# - the certificates files are assumed to be relative, so change in to the private certifcate directory first
# - if a certificate file does not exist it is silently skipped
certMakeCp()
{
	! certs && return
	certMakeCd "$product" && FileCommand cp "$@"
}

# certMakeDnsArgs NAMES - return additional DNS name arguments for the comma separated list of names
certMakeDnsArgs()
{
	local args name names=(); StringToArray "$1" "," "names"

	for name in "${names[@]}"; do
		args+="--additional-dnsname=$(serviceDnsName "$name") --additional-dnsname=$(serviceDnsNameShort "$name") "
	done

	echo "$(RemoveSpaceTrim "$args")"	
}

# certMakeServer PRODUCT HOST [DEST] [CERT_ARGS...] - make server certificate for product on HOST.
#   Optionally copy it to the destination directory.
#   CERT_ARGS allow for additional (alternate) names using -additional-ipaddress="IP" or -additional-dnsname="DNS"
certMakeServer()
{
	local product="$1" host="$2"; shift 2; certMakeCd "$product" || return
	local dest; [[ -d "$1" ]] && { dest="$1"; shift; }
	local cert="$product-server-$host.pem"
	local key="$product-server-$host-key.pem"

	# initialzie
	certValidate "$ca" "$caKey" || return

	# create the certificate
	if ! certExists "$cert" "$key"; then
		hilight "Creating a ${product^} server certificate for $host..."

		# remove any existing temporary certs
		rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

		# create the cert
		local ip; ip="$(GetIpAddress "$host")" || return
		local fqdn; fqdn="$(hostFqdn "$host")" || return

		RunLog consul tls cert create -server \
			-dc="$datacenter" \
			-domain="$baseDomain" \
			-ca="$ca" \
			-key="$caKey" \
			-additional-ipaddress="$ip" \
			-additional-dnsname="$fqdn" \
			$@ \
			-node="$host" \
			-days="3650" || return

		# rename the temporary cert
		mv "$datacenter-server-$baseDomain-0.pem" "$cert" || return
		mv "$datacenter-server-$baseDomain-0-key.pem" "$key" || return
	fi

	# copy the certificates
	if [[ $dest ]]; then
		cp "$cert" "$dest/$certServer" || return
		cp "$key" "$dest/$certServerKey" || return
	fi
}

# certMakePRODUCTServer HOST [DEST] [CERT_ARGS...] - make a server certificate, see certMakeServer above
certMakeConsulServer() { certMakeServer "consul" "$@" "$(certMakeDnsArgs "consul")"; }
certMakeVaultServer() { certMakeServer "vault" "$@" "$(certMakeDnsArgs "vault,active.vault,standby.vault")"; }

# certMakeNomadServer - make a server certificate for a Nomad server
certMakeNomadServer()
{
	local product="nomad" host="$1"; shift 1; certMakeCd "$product" || return

	certValidate "$ca" "$caKey" || return
	certExists "$certServer" "$certServerKey" && return

	hilight "Creating the Nomad server certificates..."
	certMakeNomadInit || return

	# create the cfssl configuration file
	[[ $forceCert || ! -f "cfssl.json" ]] && { cat <<-EOF > "cfssl.json" || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local join=() joinFqdn=(); hostJoinInit || return
	local h="$(ArrayDelimit joinFqdn)"
	local hosts="$(serviceDnsNameShort "$product"),$(serviceDnsName "$product"),${h},server.global.$product,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -config="cfssl.json" -hostname="$hosts" - | cfssljson -bare "nomad-server" || return
}

# certMake PRODUCT - make certificates for the product.  All of the following certMake functions are should only be called from certMake.
certMake()
{	
	local product="$1"; certMakeCd "$product" || return
	RunFunction "cert" "Make${product^}" || return
}

certMakeCa()
{
	certExists "$ca" "$caKey" && return
	hilight "Creating the ${product^} certificate authority for $baseDomain..."

	# create the cert - name constraint required for HTTPS GUI
	consul tls ca create -domain="$baseDomain" -name-constraint || return

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

certMakeCli()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certCli" "$certCliKey" && return
	hilight "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-days="3650" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

# certMake - product specifics

certMakeConsul()
{
	# install consul to create certificates
	! InPath "consul" && { inst "consul" || return; }

	# create the certificates
	certMakeCa && certMakeCli && certMakeConsulCaAuto
}

# certMakeConsulCaAuto - get the auto generated Consul certficate authority.   This CA
# is used on Consul clients and is needed on the Consul client to access the Consul API
# from other programs like Nomad, curl, or wget.
certMakeConsulCaAuto()
{
	certValidate "$ca" || return
	certExists "$caAuto" && return

	header "Get Consul Certificates"
	hilight "Getting the automatic certificate authority..."

	! InPath "consul-k8s" && { inst "consul-k8s" || return; }

	consul-k8s get-consul-client-ca \
		--server-addr "$(productGetServer "consul" "${globalArgs[@]}")" \
		--server-port "$consulHttpsPort" \
		--ca-file="$ca" \
		--output-file "$caAuto" || return
}

certMakeNomad() {	certMakeNomadCa && certMakeNomadServer && certMakeNomadClient && certMakeNomadCli; }
certMakeNomadInit() { InPath "cfssl" || inst "cfssl"; }

certMakeNomadCa()
{
	certExists "$ca" "$caKey" && return
	hilight "Creating the Nomad certificate authority..."
	certMakeNomadInit && cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca
}

certMakeNomadCli()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certCli" "$certCliKey" && return
	hilight "Creating the Nomad CLI certificate..."
	certMakeNomadInit && echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-cli
}

certMakeNomadClient()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certClient" "$certClientKey" && return
	hilight "Creating the Nomad client certificate..."
	certMakeNomadInit && echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -config=cfssl.json -hostname="client.global.nomad,localhost,127.0.0.1" - | cfssljson -bare nomad-client
}

certMakeVault()
{
	# install vault to create certificates
	! InPath "vault" && { inst "vault" || return; }

	# create the certificates
	certMakeCa && certMakeCli
}

#
# cert status command
#

certStatusUsage()
{
	EchoWrap "Usage: $(ScriptName) cert status
Show certificate status.

	-P,	--private		show private certificate status by mounting the private certificate directory
	-p,	--public		show public certificate status by mounting the public certificate directory

Certification locations:
  local - certificate directory for command line clients (i.e. /opt/hashi/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT or /opt/PRODUCT/cert)
  service - certificate directory for services (i.e. /opt/PRODUCT/cert/)
  private - the root private certificate directory from the --encrypt option or certificateDir configuration
  public - public certificate directory on the installation share"; }

certStatusArgStart() { unset private public; }

certStatusOpt()
{
	case "$1" in
		-P|--private) private="true";;
		-p|--public) public="true";;
		*) return 1;;
	esac
}

certStatusCommand() { certStatus; }

certStatus() { certStatusConsul && certStatusNomad && certStatusVault && certStatusPublic && certStatusPrivate; }
certStatusConsul() { certStatusProduct "consul"; }
certStatusNomad() { certStatusProduct "nomad"; }
certStatusVault() { certStatusProduct "vault"; }

certStatusShow()
{
	local desc="$1" dir="$2"
	header "$desc Certificates"
	hilight "location: $(FileToDesc "$dir")"
	command cd "$dir" && tree -L 2 --prune --noreport
	echo
}

certStatusProduct()
{
	local product="$1"

	# initialization
	initConfig "$product" || return
	certInit "$product" || return

	# service
	if [[ -d "$certDirService" ]]; then
		certStatusShow "$(UpperCaseFirst "$product") Service" "$certDirService" || return
	fi

	local certDirLocal="$(certDirLocal "$product")" || return
	if [[ "$certDirLocal" != "$certDirService" && -d "$certDirLocal" ]]; then
		certStatusShow "$(UpperCaseFirst "$product") CLI" "$certDirLocal" || return
	fi
}

# certStatusPublic - show status for the public certificate directory on the installation file server
certStatusPublic()
{
	[[ ! $public ]] && return
	local dir; dir="$(certDirPublicSuffix "")" && certStatusShow "Public" "$dir"
}

# certStatusPrivate - show status for the private certificate directory on the encrypted volume
certStatusPrivate()
{
	[[ ! $private ]] && return
	local dir; dir="$(certDirPrivate | certDirSuffix "")" && certStatusShow "Private" "$dir"
}

#
# config commands
#

configUsage() { ScriptUsageEcho "Usage: $(ScriptName) config deploy|get|hosts|remove|set\nConfigure products."; }
configCommand() { usage; }
configHostsUsage() { ScriptUsageEcho "Usage: $(ScriptName) config hosts\nReturn the list of hosts."; }
configHostsCommand() { getHosts "config"; ArrayDelimit hosts $'\n'; }

# config deploy commands

configDeployUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) config deploy $productUsage FILE
Deploy a configuration file."; }

configDeployArgStart() { unset file; }
configDeployArgs() { ScriptArgGet "file" -- "$@" && ScriptCheckFile "$file"; }

configDeployCommand() { usage; }
configDeployConsulCommand() { forAllHosts configDeploy "consul" "$file"; }
configDeployNomadCommand() { forAllHosts configDeploy "nomad" "$file"; }
configDeployVaultCommand() { forAllHosts configDeploy "vault" "$file"; }

# configDeploy PRODUCT FILE HOST - deploy a product configuration file to a host
configDeploy()
{
	local product="$1" file="$2" host="$3"
	serviceConfigCopy "$product" "$host" "$file" && serviceRestart "$product" "$host"
}

# config environment commands

configEnvironmentUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) config environment [all|$productUsage|test|reset](all)
Show the product environment variables.  This command is typically called 
with ScriptEval to update current environment.

	-se, --suppress-errors			supress errors (like credential and certificate not found)"; }

configEnvironmentArgStart() { unset -v suppressErrors; }

configEnvironmentOpt()
{
	case "$1" in
		-se|--suppress-errors) suppressErrors="true";;
		*) return 1;;
	esac
}

configEnvironmentCommand() { configEnvironmentAll; }
configEnvironmentAllCommand() { configEnvironmentAll; }
configEnvironmentResetCommand() { echo "unset CONSUL_HTTP_TOKEN VAULT_TOKEN NOMAD_TOKEN"; }

configEnvironmentConsulCommand() { productEnvironment "consul"; }
configEnvironmentNomadCommand() { productEnvironment "nomad"; }
configEnvironmentVaultCommand() { productEnvironment "vault"; }

# environment aliases commands
configEnvironmentProdCommand() { configPrefix="" configEnvironmentCommand; }
configEnvironmentTestCommand() { configPrefix="test" configEnvironmentCommand; }

configEnvironmentAll()
{
	# initialize consul for product lookups
	productIsInstalled "consul" && { productInit "consul" || return; }

	local product
	for product in "${products[@]}"; do
		log1 "configuring '$product'"
		echo "# ${product^}"
		productEnvironment || return; echo
	done
}

# config get command

configGetUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) config get VAR
Get a configuration variable."; }

configGetArgStart() { unset varName; }
configGetArgs() { ScriptArgGet "varName" "var" -- "$@"; }
configGetCommand() { configGet "$varName"; }

# configExists VAR
configExists() { [[ $(configGet "$var") ]]; }

# configGet VAR
configGet()
{
	local var="hashi$(UpperCaseFirst "$configPrefix")$(UpperCaseFirst "$1")"
	ConfigExists "$var" "$configFile" && ConfigGet "$var" "$configFile"
}

# configGetArray VAR [ARRAY_NAME](VAR)
configGetArray()
{
	local var="$1" 
	local arrayName="${2:-$var}"
	StringToArray "$(configGet "$var")" "," "$arrayName"
}

# configGetList VAR
configGetList()
{
	local var="$1" a
	StringToArray "$(configGet "$var")" "," "a"
}

# configServer - return the first server for the current product
configServer()
{
	local var="servers"; [[ "$product" == "vault" ]] && var="VaultServers"
	local server="$(configGet "$var" | GetWord - "1" ",")";
	local domain="$(GetNetworkDnsDomain)"
	AddDnsSuffix "$server" "$domain"
}

# configServers - set hosts to an array of all of the servers in the configuration
configServers()
{
	local servers; configGetArray "servers"
	local clients; configGetArray "clients"
	local vaultServers; configGetArray "VaultServers" "vaultServers"
	hosts=(); ArrayAppend --remove-dups hosts servers clients vaultServers
}

# Config Remove Commands

configRemoveUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) config remove all|$productUsage
Remove all local and remote configuration.

	-w, --what=C1[,C2...] configuration to remove: $configWhat"; }

configRemoveArgStart() { unset whatArg yes; }

configRemoveOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

configRemoveOptArgEnd()
{
	[[ ! $what ]] && { MissingOption "what"; return; }

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' configuration from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

configRemoveCommand() { usage; }
configRemoveAllCommand() { removeConfig "vault" && removeConfig "nomad" && removeConfig "consul"; }
configRemoveConsulCommand() { removeConfig "consul"; }
configRemoveNomadCommand() { removeConfig "nomad"; }
configRemoveVaultCommand() { removeConfig "vault"; }

# removeConfid PRODUCT - remove configuration for the product
removeConfig()
{
	local product="$1"; certInit "$product" || return; ConfigInit || return

	if [[ ! $force || ! $yes ]]; then
		ScriptErr "To permanently delete all $product local and remote configuration and certificates for $baseDomain $configDesc, --force and --yes are required"
		return 1
	fi

	header "Remove $(ProperCase "$product") Configuration"

	# delete Vault data
	if [[ "$product" == "vault" ]] && whatCheck "consul-vault-data" && quiet="--quiet" productInit "consul"; then
		hilight "Removing Vault data from Consul..."
		RunLog consul kv delete -recurse "vault/"
	fi

	# delete certificates (local, private, and public)	
	local dir
	whatCheck "local-certs" && { hilight "Removing local certificates..."; removeLocalCerts || return; }
	whatCheck "private-certs" && { hilight "Removing private credentials..."; dir="$(certDirPrivate | certDirSuffix "$product")" || return; removeDir "$dir"; }
	whatCheck "public-certs" && { hilight "Removing public credentials..."; dir="$(certDirPublicSuffix "$product")" || return; removeDir "$dir"; }

	# delete local credentials
	whatCheck "local-credentials" && { hilight "Removing local credentials..."; credDelete "all" || return; }

	# delete host credentials and certificates
	local host hosts; getHosts "config" || return
	for host in "${hosts[@]}"; do
		hilight "Removing $host certificates and credentials..."
		sshRun -q -t "$host" bash -i "credential rm \"$(credPath)\" all ${globalArgs[@]} && rm -fr \"$(certDirSuffix "$product" "/opt/hashi")\"" || return
	done
}

removeLocalCerts()
{
	local product="${1:-$product}"; certInit "$product" || return

	removeDir "$(certDirLocal "$product")" || return

	if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
		RunLog sudoc rm -f "$certStoreCa" "$certStoreCaAuto" || return
		RunLog sudoc update-ca-certificates || return
	fi
}

#
# config set command
#

configSetUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) config local|remote [all|$productUsage](all)
Set local or remote credential configuration.

	-F,	--from MANAGER	first credential manager, defaults to local or remote
	-T,	--to MANAGER		second credential manager, defaults to local or remote"; }

configSetLocalArgStart() { from="remote" to="local"; }
configSetRemoveArgStart() { from="local" to="remote"; }

configSetOpt() 
{
	case "$1" in
		-F|--from|-F=*|--from=*) ScriptOptGet from "$@";;
		-T|--to|-T=*|--to=*) ScriptOptGet to "$@";;
		*) return 1
	esac
}

configSetCommand() { usage; }

configSetLocalCommand() { configSetLocalAllCommand; }
configSetLocalAllCommand() { configSetLocalConsulCommand && configSetLocalNomadCommand && configSetLocalVaultCommand; }
configSetLocalConsulCommand() { configSetLocal "consul"; }
configSetLocalNomadCommand() { configSetLocal "nomad"; }
configSetLocalVaultCommand() { configSetLocal "vault"; }

configSetRemoteCommand() { configSetRemoteAllCommand; }
configSetRemoteAllCommand() { configSetRemoteConsulCommand && configSetRemoteNomadCommand && configSetRemoteVaultCommand; }
configSetRemoteConsulCommand() { configSetRemote "consul"; }
configSetRemoteNomadCommand() { configSetRemote "nomad"; }
configSetRemoteVaultCommand() { configSetRemote "vault" && vaultTokenSetRemote; }

configSetLocal() { vaultTokenGetRemote && configMirror "$from" "$to" "$1"; }
configSetRemote() { configMirror "$from" "$to" "$1"; }

# configMirror FROM TO PRODUCT - mirror configuration credentials for a product
configMirror()
{
	local from="$1" to="$2" product="$3"

	# check if the configuration already exists in the TO credential store
	local check="token"; [[ "$product" == "vault" ]] && check="key5"
	[[ ! $force ]] && test="" RunLog credential exists "$(credPath)" "$check" --manager="$to" && return

	# get descriptions
	local fromDesc; fromDesc="$(credential manager name --manager="$from")"
	local toDesc; toDesc="$(credential manager name --manager="$to")"

	# mirror the credentials
	hilight "Mirroring ${product^} credentials from '$fromDesc' to '$toDesc'..."
	RunLog credential mirror --from="$from" --to="$to" "$(credPath)" --force "${globalArgs[@]}" || return
}

#
# config status command
#

configStatusCommand()
{
	local product term="$TERM"; [[ ! $term ]] && term="xterm-256color"

	{
		echo "${GREEN}product#url#certificate#token#config#domain${RESET}"

		for product in "${products[@]}"; do

			# product is not installed
			! productIsInstalled && continue

			# initialize product variables
			suppressErrors="true" productInit "$product" || return

			# do not show product if there is no URL
			local url="$(productVarGet "ADDR")"			
			[[ ! $url ]] && continue

			# get variables
			local cert="false"; [[ -f "$(productVarGet "CACERT")" ]] && cert="true"
			local token="false"; [[ $(productVarGet "TOKEN") ]] && token="true"
			local prefix="$(productVarGet "CONFIG")"; prefix="${prefix:-prod}"
			local domain="$(productVarGet "DOMAIN")"

			[[ "$cert" == "true" && "$product" == "consul" ]] && { productVarGet "CACERT" | ${G}grep -q "auto" && cert="client" || cert="server"; }

			echo "${RESET}$product#$url#$cert#$token#$prefix#$domain" # add resets to line up the columns

		done

	} | column -c $(tput cols -T "$term") -t -s#
}

#
# consul command
#

consulUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl|agent|api|backup|environment|reload|remove|restore|service|status|tag\nConsul commands."; }
consulArgStart() { product="consul"; }
consulCommand() { usage; }
consulEnvironmentCommand() { productEnvironment "$product"; }
consulReloadCommand() { forAllHosts consulReloadDo; }
consulStatusCommand() { consul members; }

consulBackupCommand()
{
	local file="$(GetDateStampNext "consul.$domain" "snap")"
	RunLog consul snapshot save "$TEMP/$file" || return # errors with operation not supported saving to SMB shares
	mv "$TEMP/$file" .  
}

consulReloadDo() { productInit "consul" "$1" && consul reload; }

consulRemoveUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul remove failed\nConsul remove commands."; }
consulRemoveCommand() { usage; }

consulRemoveFailedUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul remove failed\nRemove failed nodes."; }

consulRemoveFailedCommand()
{ 
	local host hosts; IFS=$'\n' ArrayMake hosts "$(consul members -status=failed | tail -n +2 | cut -d" " -f1)" || return
	for host in "${hosts[@]}"; do
		echo "Removing failed member '$host'..."
		consul force-leave "$host" || return
	done
}

consulTagUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul tag [run]\nConsul tag commands."; }
consulTagCommand() { consulTagRunCommand; }
consulTagRunUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul tag run -- [ARGS]...\nRun the consul-tag command, i.e. consul tag run -- ms ls."; }
consulTagRunArgStart() { consulTagRunArgs=(); }
consulTagRunArgs() { consulTagRunArgs=( "$@" ); (( shift+=$# )); return 0; }
consulTagRunCommand() { consul-tags "$@" "${otherArgs[@]}" --scheme $(GetUriProtocol "$CONSUL_HTTP_ADDR") --cert=$CONSUL_CLIENT_CERT --cacert=$CONSUL_CACERT --addr=$CONSUL_SERVER:$(GetUriPort "$CONSUL_HTTP_ADDR"); }

#
# consul acl command
#

consulAclUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl agent|create|policy|token\nConsul ACL commands."; }
consulAclCommand() { usage; }

#
# consul acl agent command
#

consulAclAgentUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl agent allow|create|deny|deploy\nConfigure the agent ACL system."; }
consulAclAgentCommand() { usage; }

consulAclAgentAllowUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl agent allow\nChange the default ACL policy to allow."; }
consulAclAgentAllowCommand() { forAllHosts consulAclAgentAllow; }

consulAclAgentCreateUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl agent create\nCreate agent ACL policies and tokens.  \
If this is a new agent, use --api to specify the API server.  For example:\n
hashi consul acl agent create --api=pi1 --host=pi5"; }
consulAclAgentCreateCommand() { consulApiCheck && forAllHosts consulAclAgentCreate; }

consulAclAgentDenyUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl agent deny\nChange the default ACL policy to deny."; }
consulAclAgentDenyCommand() { forAllHosts consulAclAgentDeny; }

consulAclAgentDeployUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl agent deploy\nDeploy the agent ACL tokens to the 02_acl_tokens.hcl configuration file."; }
consulAclAgentDeployCommand() { forAllHosts consulAclAgentDeploy; }

# consul acl agent helper

# consulAclAgentDefault HOST - change the ACL mode on a host to allow
consulAclAgentAllow() { local host="$1"; consulAclAgentDefaultPolicy "allow"; }
consulAclAgentDeny() { local host="$1"; consulAclAgentDefaultPolicy "deny"; }

consulAclAgentDefaultPolicy()
{
	local newPolicy="$1"; serviceVars "consul" || return
	local currentPolicy; currentPolicy="$(serviceConfigVarGet "default_policy" "$product" "$host")" || return

	# return if we don't need to change the default ACL policy
	[[ ! $force && "$currentPolicy" == "$newPolicy" ]] && return

	# change the default ACL policy

	printf "Changing the default ACL policy on $host from $currentPolicy to $newPolicy..."

	scriptRun "$host" "$(cat <<-EOF
		sudoc sed -i "s/default_policy = \"$currentPolicy\"/default_policy = \"$newPolicy\"/" "$productConfigFile" || exit
		sudoc systemctl restart "$product" --no-block || exit
		EOF
	)" || return

	echo "done"
}

# consulAgentAclCreate HOST - create the policies and tokens for a consul agent
consulAclAgentCreate()
{
	local host="$1"

	# create default token for DNS requests
	if ! consulAclTokenExists "dns-requests"; then
		consulAclCreate "dns-requests" "$(cat <<-EOF
			node_prefix "" {
			  policy = "read"
			}
			service_prefix "" {
			  policy = "read"
			}
			EOF
		)" || return
	fi

	# create the ACL policy for the host
	if ! consulAclTokenExists "agent-$host"; then
		consulAclCreate "agent-$host" "$(cat <<-EOF
			node "$host" {
			  policy = "write"
			}		
			EOF
		)" || return
	fi

	return 0
}

# consulAclAgentDeploy HOST - deploy ACL tokens to a host
consulAclAgentDeploy()
{
	local host="$1"

	# create the agent ACL's
	consulAclAgentCreate "$host" || return
	local defaultToken; defaultToken="$(consulAclTokenGetSecret "dns-requests")" || return
	local agentToken; agentToken="$(consulAclTokenGetSecret "agent-$host")" || return
	
	# deploy the configuration file
	serviceConfigCopyText "consul" "$host" "02_acl_tokens.hcl" "$(cat <<-EOF
		acl {
		  tokens {
		    default = "$defaultToken"
		    agent = "$agentToken"
		  }
		}
		EOF
	)"
}

#
# consul acl create command
#

consulAclCreateUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) consul acl create [NAME] [DEFINITION]
Create a Consul ACL."; }

consulAclCreateArgStart() { unset name def; }
consulAclCreateArgs() { ScriptArgGet "name" -- "$@" && shift && ScriptArgGet "def" -- "$@"; }
consulAclCreateCommand() { consulAclCreate "$name" "$def"; }

#
# consul acl policy commands
#

consulAclPolicyUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) consul acl policy [get|ls|rm](ls) [NAME]
Manage Consul ACL policies."; }

consulAclPolicyArgStart() { unset name; }
consulAclPolicyCommand() { consulAclPolicyLsCommand; }

consulAclPolicyGetArgs() { ScriptArgGet "name" -- "$@"; }
consulAclPolicyGetCommand() { consulAclPolicyGetId "$name"; }

consulAclPolicyLsUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl list\nList all Consul ACL policy names."; }
consulAclPolicyLsCommand() { consulAclPolicyLs; }

consulAclPolicyRmArgs() { ScriptArgGet "name" -- "$@"; }
consulAclPolicyRmCommand() { consulAclPolicyRm "$name"; }

#
# Consul ACL Token Command
#

consulAclTokenUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) consul acl token [get|ls|rm](ls)
Manage Consul ACL tokens."; }

consulAclTokenArgStart() { unset name; }
consulAclTokenCommand() { consulAclTokenLsCommand; }

consulAclTokenGetUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl token get [secret]"; }
consulAclTokenGetArgs() { ScriptArgGet "name" -- "$@"; }
consulAclTokenGetCommand() { consulAclTokenGetId "$name"; }
consulAclTokenGetSecretCommand() { consulAclTokenGetSecret "$name"; }

consulAclTokenLsUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul acl list\nList all Consul ACL token descriptions."; }
consulAclTokenLsCommand() { consulAclTokenLs; }

consulAclTokenRmArgs() { ScriptArgGet "name" -- "$@"; }
consulAclTokenRmCommand() { consulAclTokenRm "$name"; }

# Consul ACL Helper

consulAclPolicyLs() { consul acl policy list -format=json | jq '.[].Name' | RemoveQuotes | sort; }
consulAclTokenLs() { consul acl token list | ${G}grep "^Description:" | cut -d: -f2 | tr -s " " | cut -d" " -f2 | sort; }

# consulAclCreate NAME DEF - create an ACL with the specified name and definition.   Return the secret token for the policy.
consulAclCreate()
{
	local name="$1" def="$2"
	consulAclPolicyCreate "$name" "$def" && consulAclTokenCreate "$name"
}

# consulAclDelete NAME - delete the ACL policy and token
consulAclDelete() { local name="$1"; consulAclPolicyRm "$name" && consulAclTokenRm "$name"; }

# consulAclPolicyCreate NAME DEF - create a policy with the specified name and definition
consulAclPolicyCreate()
{
	local name="$1" def="$2"
	consulAclPolicyExists "$name" && { ScriptErr "the consul ACL policy '$name' already exists"; return 1; }
	log1 "consulAclPolicyCreate: creating the ACL policy '$name'..."
	echo "$def" | RunLog consul acl policy create -name "$name" -rules -
}

# consulAclPolicyExists NAME - return true if the specified policy exists
consulAclPolicyExists()
{
	local name="$1"
	[[ "$(consul acl policy list -format=json | jq ".[] | select(.Name == \"$1\").Name" | RemoveQuotes)" == "$name" ]]
}

# consulAclPolicyGetId NAME - get the policy ID for the specified policy name
consulAclPolicyGetId()
{
	local name="$1" id; id="$(consul acl policy list -format=json | jq '.[] | select(.Name == "'"$name"'").ID' | RemoveQuotes	)" || return
	consulValidateId "$id" "$name" "policy"
}

# consulAclPolicyRm NAME - delete the specified policy
consulAclPolicyRm()
{
	local name="$1"; ! consulAclPolicyExists "$name" && return

	hilight "Deleting ACL policy $name..."
	RunLog consul acl policy delete -name "$name"
}

# cosulTokenExists NAME - return true if the tokenexists
consulAclTokenExists()
{
	local name="$1"
	[[ "$(consul acl token list -format=json | jq ".[] | select(.Description == \"$name\").Description" | RemoveQuotes)" == "$name" ]]
}

# consulAclTokenGetSecret NAME - get the token Secret ID with the specified name
consulAclTokenGetSecret()
{
	local name="$1"
	! consulAclTokenExists "$1" && { ScriptErr "token '$name' does not exists"; return 1; }
	log1 "consulAclTokenGetSecret: getting the ACL token secret for '$name'..."
	consul acl token read -accessor-id "$(consulAclTokenGetId "$name")" | ${G}grep "SecretID" | cut -d: -f 2 | RemoveSpace
}

# consulAclPolicyGetId NAME - get the token accessor ID for the specified token name
consulAclTokenGetId()
{
	local name="$1" id; id="$(consul acl token list -format=json | jq '.[] | select(.Description == "'"$name"'").AccessorID' | RemoveQuotes	)" || return
	consulValidateId "$id" "$name" "token"
}

# consulAclTokenCreate NAME [POLICY] - create a token with the specified description that has the permission to the specified policy
consulAclTokenCreate()
{
	local name="$1" policy="${2:-$1}"
	consulAclTokenExists "$name" && { ScriptErr "the consul ACL token '$name' already exists"; return 1; }
	RunLog consul acl token create -description "$name" -policy-name "$policy"
}

# consulAclTokenRm NAME - delete the token with the specified name
consulAclTokenRm()
{
	local name="$1"; ! consulAclTokenExists "$name" && return
	local id; id="$(consulAclTokenGetId "$name")" || return

	hilight "Deleting ACL token $name..."
	RunLog consul acl token delete -accessor-id "$id"
}

#
# consul api Command
#

consulApiUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul api [check|put] PATH -- [curl arguments]\nCall the Consul API.  For example:\nhashi consul api /status/leader"; }
consulApiArgStart() { unset path; }
consulApiArgs() { [[ "$command" == "consulApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

consulApiCommand() { consulApi "$path" "${otherArgs[@]}"; }

# consulApi PATH [ARGS]...
consulApi()
{
	local args=(); IsPlatform mac && args=(--cacert $CONSUL_CACERT)
	RunLog curl --silent --show-error --header "X-Consul-Token: $CONSUL_HTTP_TOKEN" "${args[@]}" "$CONSUL_HTTP_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; 
}

consulApiPutCommand() { consulApiPut "$path" "${otherArgs[@]}"; }
consulApiPut() { consulApi "$1" --request PUT --data "$2" "${@:3}"; } # consulApiPut PATH DATA [ARGS]...

consulApiCheckCommand() { consulApiCheck; }
consulApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" $timeout && { ScriptErrQuiet "consul server '$host' is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" $timeout && { ScriptErrQuiet "consul server $host is not available on port $port"; return 1; }	

	# check api
	consulApi "/status/leader" 2> /dev/null | RemoveQuotes | RemovePort | IsIpAddress && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the consul API at $(productVarGet "ADDR") is not available"; consulApi "/status/leader"; return 1; }

	return 0
}

#
# consul agent command
#

consulAgentUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul agent [checks](checks)"; }
consulAgentCommand() { consulAgentChecksCommand; }
consulAgentChecksUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul agent checks\nShow all health checks on the agent."; }
consulAgentChecksCommand() { consulApi "/agent/checks" | jq '.[].CheckID' | RemoveQuotes | sort; }

#
# consul service commands
#

consulServiceInit() { unset file; }

consulServiceUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) consul service [add|clean|ls|rm](ls)
Consul service commands."; }

consulServiceCommand() { consulServiceLsCommand; }
consulServiceLsCommand() { consulServiceLs; }

#
# consul service add command
#

consulServiceAddUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) consul service add FILE
Add a Consul service using the service definition in FILE.

- FILE must be JSON or HCL
- if FILE is HCL, the CLI is used to perform the registeration, which allows HCL but does not allow script checks
- if FILE is JSON
  - curl is used to perform the registeration, which allows script checks
  - the JSON must contain a service attribute to provide future compatibility with CLI registration"; }

consulServiceAddArgs() { ScriptArgGet "file" -- "$@" && ScriptCheckFile "$file"; }

consulServiceAddCommand()
{
	local id; id="$(consulServiceFileGetId "$file")" || return
	local type; type="$(configFileValidate "$file")" || return

	# create the service ACL
	if ! consulAclTokenExists "service-$id"; then		
		consulAclCreate "service-$id" "$(cat <<-EOF
			service "$id" {
			  policy = "write"
			}
			EOF
		)" || return
	fi
	local token; token="$(consulAclTokenGetSecret "service-$id")" || return

	# add the service ACL token to the service file
	log1 "adding the service ACL token to the service file..."
	local f; f="$(${G}mktemp -t "hashi.service.XXXX.hcl")" || return
	if [[ "$type" == "json" ]]; then
		cat "$file" | jq '.[]' | sed "s/\"token\": \".*\"/\"token\": \"$token\"/" > "$f" || return
	else
		cat "$file" | sed "s/token = \".*\"/token = \"$token\"/" > "$f" || return
	fi

	# ensure the ACL token was added to the service file
	if ! ${G}grep --quiet "\"$token\"" "$f"; then
		ScriptErr "the token parameter was not found in the service file"
		return 1
	fi

	# register the service using curl for JSON as the CLI does not allow script checks (get Invalid check message)
	[[ $verbose ]] && { log1 "service file '$f':"; cat "$f"; }
	if [[ "$type" == "json" ]]; then
		consulApiPut "/agent/service/register?replace-existing-checks=true" @"$f" || return
	else
		RunLog consul services register "$f" || return
	fi

	# cleanup the file
	rm -f "$f"	

	return 0
}

#
# consul service clean command
#

consulServiceCleanUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul service clean\nCleanup orphaned service policies and tokens."; }

consulServiceCleanCommand()
{
	local name id policies tokens IFS=$'\n'

	# find orphan policies
	policies=(
		$(FileLeft \
			<(consulAclPolicyLs | ${G}grep "^service-" | sed 's/service-//') \
			<(consulServiceLs))
	)

	# delete orphan policies
	for name in "${policies[@]}"; do
		echo "Deleting orphan policy 'service-$name'..."
		id="$(consulAclPolicyGetId "service-$name")" || return
		RunLog consul acl policy delete -accessor-id "$id"
	done

	# find orphan tokens
	tokens=(
		$(FileLeft \
			<(consulAclTokenLs | ${G}grep "^service-" | sed 's/service-//') \
			<(consulServiceLs))
	)

	# delete orphan tokens
	for name in "${tokens[@]}"; do
		echo "Deleting orphan token 'service-$name'..."
		id="$(consulAclTokenGetId "service-$name")" || return
		RunLog consul acl token delete -accessor-id "$id"
	done
}

#
# consul service rm command
#

consulServiceRmUsage() { ScriptUsageEcho "Usage: $(ScriptName) consul service rm FILE|ID|NAME"; }
consulServiceRmArgs() { ScriptArgGet "service" -- "$@"; }

consulServiceRmCommand()
{
	local id

	# get the service ID
	if [[ -f "$service" ]]; then # file
		id="$(consulServiceFileGetId "$service")" || return
	elif consulServiceIdExists "$service"; then # id
		id="$service"
	else # name
		id="$(consulServiceGetId "$service")" || return
	fi

	# deregister the service
	consulServiceIdExists "$id" && { consul services deregister -id "$id" || return; }

	# delete the service ACL
	consulAclDelete "service-$id" || return
}

# consul service helper commands

consulServiceLs() { consul catalog services; }

# consulServiceFileGetId FILE - return the service name from a service file
consulServiceFileGetId()
{
	local file="$1" type; type="$(consulServiceFileValidate "$file")" || return

	# get the service ID, which is the name if the ID attribute if not present
	local id
	if [[ "$type" == "json" ]]; then
		id="$(cat "$file" | jq ".service.id" | RemoveQuotes)"
		[[ ! $id || "$id" == "null" ]] && id="$(cat "$file" | jq ".service.name" | RemoveQuotes)"
	else
		id="$(cat "$file" | ${G}grep "id =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
		[[ ! $id ]] && id="$(cat "$file" | ${G}grep "name =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
	fi

	# check for a valid id
	[[ ! $id || "$id" == "null" ]] && { ScriptErr "unable to determine the service ID in '$file' (no name or id attribute)"; return 1; }

	# return the name
	echo "$id"
}

# consulServiceFileValidate FILE - return true and the configu file type if the file is a valid consul service file
consulServiceFileValidate()
{
	local type; type="$(configFileValidate "$file")" || return

	# check for the service attribute
	if [[ "$type" == "json" && "$(cat "$file" | jq ".service")" == "null" ]]; then
		ScriptErr "service attribute is required"
		return 1
	fi

	# return the type
	echo "$type"
}

# consulServiceGetId NAME - get the service ID for the specified service name
consulServiceGetId()
{
	local name="$1" id; id="$(consulApi "/agent/services" | jq '.[] | select(.Service == "'$name'").ID' | RemoveQuotes)" || return
	consulValidateId "$id" "$name" "service"
}

consulServiceIdExists()
{
	local id="$1"
	[[ "$(consulApi "/agent/services" | jq '.[] | select(.ID == "'"$id"'").ID' | RemoveQuotes)" == "$id" ]]; 
}

# consuleServiceIdValidate ID - return true if the ID is a consul service ID
consulServiceIdValidate()
{
	local id="$1"; consulServiceIdExists "$id" && return
	ScriptErr "a service with ID '$id' does not exist"
	return 1
}

# consul helper

# consulValidateId ID NAME WHAT - validate ID is correct for the given NAME.   WHAT is what we are validating.
consulValidateId()
{
	local id="$1" name="$2" what="$3"

	# check for a valid id
	[[ ! $id || "$id" == "null" ]] && { ScriptErrQuiet "$what '$name' does not exist"; return 1; }

	# ensure there is only one WHAT with the specified name
	(( $(echo "$id" | wc -l) > 1 )) && { ScriptErrQuiet "there is more than one $what with the name '$name'"; return 1; }

	# return the id
	echo "$id"
}

#
# install command
#

installUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) install cli|service
Install a HashiCorp product."; }

installCommand() { usage; }

#
# install service command
#

installServiceUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) install service all|cli|$productUsage [integration]
Install a HashiCorp product.

	-c, --clients	HOSTS						comma separated list of clients to install
	-if, --interface	INTERFACE		host interface adapter name, i.e. wlan0, defaults to hosts default interface
	-s, --server HOSTS						comma separated list of servers to install
	-j, --join HOSTS							comma separated list of hosts to join to, defaults to servers
	$certOptUsage
	-w, --what=C1[,C2...] components to install: acl program service config
	                        cert (cert-local cert-make cert-public cert-service)"; }

installServiceArgStart() { unset -v force forceCert interface whatArg; clients=() servers=() join=(); encrypt="true"; }

installServiceOpt()
{
	encryptCliOpt "$@" && return
	case "$1" in
		--clients|-c|--clients=*|-c=*) ScriptOptGet "clients" "$@"; StringToArray "$clients" "," clients;;
		--interface|-if|--interface=*|-if=*) ScriptOptGet "interface" "$@";;
		--servers|-s|--servers=*|-s=*) ScriptOptGet "servers" "$@"; StringToArray "$1" "," servers;;
		--join|-j|--join=*|-j=*) ScriptOptGet "join" "$@"; StringToArray "$1" "," join;;
		*) return 1;;
	esac
}

installServiceCommand() { usage; }
installServiceAllCommand() { installServiceConsulCommand && installServiceVaultCommand && installServiceNomadCommand; }
installServiceConsulCommand() { installService "consul"; }
installServiceNomadCommand() { installService "nomad"; }
installServiceVaultCommand() { installService "vault"; }

# integrations
installServiceNomadIntegrationUsage() { ScriptUsageEcho "Usage: $(ScriptName) install service nomad integration vault\nInstall Nomad integrations."; }
installServiceNomadIntegrationCommand() { usage; }

installServiceNomadIntegrationVaultCommand() { product="nomad"; installServiceInit "$product" && productInit "$product" && installServiceNomadVaultIntegration; }

installServiceNomadVaultIntegration()
{	
	! whatCheck "config" && return

	header "Install Nomad Vault Integration"

	local policy; productInit "vault" || return

	#
	# Workload Identity
	#
	
	# enable JWT for Nomad
	if ! vault auth list | qgrep '^jwt-nomad/'; then
		vault auth enable -path 'jwt-nomad' 'jwt' || { ScriptErr "unable to enable JWT for Vault integration"; return 1; }
	fi

	# configure JWT for Nomad
	local address="https://$(serviceDnsName "nomad"):$(productGetPort "nomad" "$(protocol)")/.well-known/jwks.json"
	if [[ $force || "$(vault read "/auth/jwt-nomad/config" |& ${G}grep "^jwks_url " | tr -s " " | cut -d" " -f2)" != "$address" ]]; then
		hilight "Adding Nomad JWT to Vault..."
		
		local config="$(cat <<-EOF
			{
			  "jwks_url": "$address",
			  "jwt_supported_algs": ["RS256", "EdDSA"],
			  "default_role": "nomad-workloads"
			}
			EOF
		)"
		echo "$config" | vault write "/auth/jwt-nomad/config" - || return
	fi

	# create Vault ACL role
	if [[ $force ]] || ! vault read "/auth/jwt-nomad/role/nomad-workloads" >& /dev/null; then
		hilight "Creating Vault ACL role..."
		
		local config="$(cat <<-EOF
			{
			  "role_type": "jwt",
			  "bound_audiences": ["vault.io"],
			  "user_claim": "/nomad_job_id",
			  "user_claim_json_pointer": true,
			  "claim_mappings": {
			    "nomad_namespace": "nomad_namespace",
			    "nomad_job_id": "nomad_job_id",
			    "nomad_task": "nomad_task"
			  },
			  "token_type": "service",
			  "token_policies": ["nomad-workloads"],
			  "token_period": "30m",
			  "token_explicit_max_ttl": 0
			}
			EOF
		)"
		echo "$config" | vault write "/auth/jwt-nomad/role/nomad-workloads" - || return
	fi

	# create Vault ACL policy
	local accessor; accessor="$(vault auth list | ${G}grep "^jwt-nomad/" | tr -s " " | cut -d" " -f3)" || return
	if [[ $force ]] || ! vault policy read "nomad-workloads" >& /dev/null; then
		hilight "Creating Vault ACL policy..."
		
		local policy="$(cat <<-EOF
			path "kv/data/{{identity.entity.aliases.$accessor.metadata.nomad_namespace}}/{{identity.entity.aliases.$accessor.metadata.nomad_job_id}}/*" {
			  capabilities = ["read"]
			}

			path "kv/data/{{identity.entity.aliases.$accessor.metadata.nomad_namespace}}/{{identity.entity.aliases.$accessor.metadata.nomad_job_id}}" {
			  capabilities = ["read"]
			}

			path "kv/metadata/{{identity.entity.aliases.$accessor.metadata.nomad_namespace}}/*" {
			  capabilities = ["list"]
			}

			path "kv/metadata/*" {
			  capabilities = ["list"]
			}

			path "secret/data/*" {
			  capabilities = ["read"]
			}

			path "secret/data" {
			  capabilities = ["read"]
			}

			path "secret/metadata/*" {
			  capabilities = ["list"]
			}

			EOF
		)"
		echo "$policy" | vault policy write "nomad-workloads" - || return
	fi

	return 0
}

# install helper

installService()
{
	local product="$1" isServiceInstall="true"; installServiceInit "$product" || return

	# common service options
	local commonOptions="$(cat <<-EOF
		log_level = "info"\n
		EOF
	)"

	# install
	local certDir; certs && { certMakeCd "$product" || return; }
	local tmpDir; tmpDir="$(tmpDirCreate)" || return	
	installServiceCertMake || return 																	# make required certificates - current directory will be the private certificate directory
	installServiceProgram "${servers[@]}" "${clients[@]}" || return		# install the program the service uses on all servers and clients
	installServiceHosts "server" "${servers[@]}" || return						# install the service on the servers
	productInstall "$product" "localhost" || return										# install the program on the local computer
	installServiceCertLocal || return																	# install the program certificates on the local computer
	installServiceServerFinal || return																# run the final part of the server service install (i.e. such as ACL setup)
	installServiceHosts "client" "${clients[@]}" || return						# install the service on the clients
	installServiceFinal "${servers[@]}" "${clients[@]}" || return			# run the final part of the service install for all clients and servers
	installServiceCertPublic || return

	# cleanup
	unset servers clients
	rm -fr "$tmpDir"
}

installServiceInit()
{
	local product="$1"; serviceVars "$product" || return

	# add clients and servers from hostArg if specified
	if [[ $hostArg ]]; then
		local host hosts; StringToArray "$hostArg" "," hosts
		local configServers; configGetArray "servers" "configServers"
		for host in "${hosts[@]}"; do
			IsInArray "$host" configServers && servers+=( "$host" ) || clients+=( "$host" )
		done
		unset hostArg
	fi

	# use default clients and servers if needed
	if [[ ! $clients && ! $servers ]]; then
		if [[ "$product" == "vault" ]]; then
			clients=( )
			configGetArray "VaultServers" servers
		else
			configGetArray "clients"
			configGetArray "servers"
		fi
	fi

	hosts=( "${servers[@]}" "${clients[@]}" )

	# set join servers
	hostJoinInit "${join[@]}" || return

	if [[ $verbose ]]; then
		PrintErr "clients: "; ArrayShow clients
		PrintErr "servers: "; ArrayShow servers
		PrintErr "join: "; ArrayShow join
	fi
}

installServiceCertLocal() { ! whatCheck "cert" "cert-local" && return; header "Install Local Certificates" && certs && productInstallCerts "$product"; }
installServiceCertMake() { ! whatCheck "cert" "cert-make" && return; header "Create Certificates" && certMakeCd "$product" && certs && certMake "$product"; }
installServiceCertPublic() { ! whatCheck "cert" "cert-public" && return; header "Copy Public Certificates" && certs && certCopyPublic "$product"; }

installServiceAcl()
{
	{ ! whatCheck "acl" || isClient; } && return

	header "Install $(ProperCase "$product") ACL"
	productInit "$product" || return

	# generate the bootstrap token
	local header text
	local alreadyCreated="ACL bootstrap already done"; [[ "$product" == "consul" ]] && alreadyCreated="ACL bootstrap no longer allowed"
	local waitingForNodes="The ACL system is currently in legacy mode."
	
	# try up to 30 times to get the bootstrap text
	for (( i = 0; i < 30; i++ )); do
		text="$($product acl bootstrap 2>&1)" && break
		echo "$text" | ${G}grep -q "$alreadyCreated" && return
		echo "$text" | ${G}grep -q "$waitingForNodes" &&
			{ [[ $header ]] && printf "." || printf "bootstrap..."; header="true"; sleep 1; continue; }
		EchoErr "$text"; return 1
	done
	[[ $header ]] && echo
	echo "$text" | ${G}grep -q "$waitingForNodes" && { EchoErr "$text"; return 1; }
	
	# show the full bootstrap text
	hilight "Store the following bootstrap token in a secure location:"
	echo "$text"

	# get and store the token
	local secretId="Secret ID"; [[ "$product" == "consul" ]] && secretId="SecretID"
	local sep="="; [[ "$product" == "consul" ]] && sep=":"
	local token="$(echo "$text" | ${G}grep "$secretId" | cut -d$sep -f 2 | RemoveSpace)"
	[[ ! $token ]] && { ScriptErr "unable to determine the bootstrap token"; return 1; }
	credSet "token" "$token" || return

	productVarSet "TOKEN" "$token" || return
	log1 "updated environment variable $(productVar "TOKEN") to $(productVarGet "TOKEN")..."
}

installServiceConfig()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$product")
		Documentation=https://www.hashicorp.com/products/$product
		$networkTarget
		After=network-online.target$otherDependencies
		ConditionFileNotEmpty=$productConfigFile

		[Service]
		Type=$serviceType
		NotifyAccess=$notifyAccess
		User=$user
		Group=$user
		$restrictions
		$exec
		EnvironmentFile=$productServiceEnvFile
		KillMode=process
		KillSignal=$serviceKillSignal
		Restart=on-failure
		RestartSec=5
		TimeoutStopSec=$timeoutStopSec
		StartLimitInterval=60
		StartLimitBurst=3
		$serviceLimit

		[Install]
		WantedBy=multi-user.target
	EOF
}

# installServiceHost client|server host - install the client or server version of the service 
installServiceHost()
{
	local type="$1" host="$2"
	local f hostFqdn hostIp
	local o="$commonOptions" # product configuration file options
	local otherDependencies="" restrictions=""
	local execStart="$program agent -config=$productConfigDir" execReload="/bin/kill --signal HUP \$MAINPID" exectStop="" serviceKillSignal="SIGINT"
	local networkTarget="Requires=network-online.target"
	local serviceLimit="LimitMEMLOCK=infinity"$'\n'"LimitNOFILE=infinity"$'\n'"LimitNPROC=infinity"$'\n'"TasksMax=infinity"
	local serviceType="notify" notifyAccess="none" timeoutStopSec="60"

	# host information
	hostFqdn="$(hostFqdn "$host")" || return
	hostIp="$(GetIpAddress "$hostFqdn")" || return
	host="$(RemoveDnsSuffix "$hostFqdn")"

	# header
	header "Install $(ProperCase "$product") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	${G}mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return

	# copy certificates
	certMakeCp "$ca" "$certCli" "$certCliKey" "$tmpDir/cert" || return

	# environment
	printf "" > "$tmpDir/$product.env"

	# interface
	if [[ ! $interface ]]; then
		interface="$(sshRun "$host" "route | grep \"^default\" | head -1 | tr -s \" \" | cut -d\" \" -f8")" || return
		log1 "installServiceHost: using default host interface '$interface'"
	fi

	# product specifics
	hilight "Running ${product} service prep"
	RunFunction "installServicePrep" "${product}" || return

	# create the configuration files
	echo -e "$o" > "$tmpDir/config/$productConfigFileBase" || return
	installServiceConfig > "$tmpDir/$product.service" || return
	LogFile3 "$tmpDir/$product.service"

	# copy the files to the remote host	
	copyDirRemote "$tmpDir" "$host" || return

	# run the installation script - do not assume /usr/local/data/bin scripts are present, use only standard commands
	hilight "Running installation..."
	scriptRun "$host" "$(cat <<-EOF

		#
		# users
		#

		$(installServiceTextUser)

		#
		# directories
		#

		$(installServiceTextDirectories)

		if [[ "$productOtherDirs" ]] && [[ ! "\$(sudoc ls -A "${productOtherDirs[@]}")" || "$force" ]]; then
			sudoc install -o root -g root -m 755 -d "${productOtherDirs[@]}" || exit
		fi
		
		#
		# files
		#

		if [[ "\$(sudoc ls -A "$tmpDir/data")" ]] && [[ ! "\$(sudoc ls -A "$productDataDir")" || "$force" ]]; then
		  echo "Copying data files..."
		  sudoc install -o "$user" -g "$user" -m 755 -t "$productDataDir" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudoc ls -A "$tmpDir/config") ]] && [[ ! -f "$productConfigDir/$productConfigFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudoc install -o "$user" -g "$user" -m 755 -t "$productConfigDir" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudoc ls -A "$tmpDir/cert") ]] && [[ ! \$(sudoc ls -A "$certDirService") || (( \$(ls -1 "$tmpDir/cert" | wc -l) > \$(sudoc ls -A "$certDirService" | wc -l) )) || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudoc install -o "$user" -g "$user" -m 755 -t "$certDirService" "$tmpDir/cert/"* || exit
		fi

		#
		# certificates
		#

		$(scriptCertStore "$certDirService")

		#
		# product
		#

		$(installServiceTextProduct)

		#
		# service
		#

		if [[ -f "$productServiceFile" && "$force" ]]; then
		  echo "Stopping the service..."
		  sudoc systemctl stop "$product" || exit
		fi

		if [[ ! -f "$productServiceFile" || "$force" ]]; then
		  echo "Creating service files..."
		  sudoc cp "$tmpDir/$product.service" "$tmpDir/$product.env" "/etc/systemd/system" || exit
		  sudoc systemctl daemon-reload || exit
		  sudoc systemctl enable "$product" || exit
		  sudoc systemctl start "$product" --no-block || exit
		fi

		#
		# cleanup
		#

		$(scriptCleanup)
		EOF
	)" || return
}

# installServiceHosts client|server [HOST...] - install the service on the specified hosts
# - in Consul, use 'consul members' to view the servers and clients.
# - in Nomad, the clients are known as nodes, use 'nomad server members' to view the servers in the cluster, use 'nomad node status' to view the nodes in the cluster.
installServiceHosts()
{
	local type="$1"; shift

	! whatCheck "service" && return

	for host in "$@"; do
		installServiceHost "$type" "$host" || return
	done
}

# installServiceProgram [HOST...] - install the service program on the specified hosts
installServiceProgram()
{
	! whatCheck "program" && return

	for host in "$@"; do
		header "Install $product Program ($host)"
		productInstall "$product" "$host" || return
	done
}

# installServiceFinal [HOST...] - called after all servers and clients for a product are installed
installServiceFinal() { local hosts=( "$@" ); RunFunction "installServiceFinal" "${product}" "$@" || return; }

installServiceFinalConsul() { installServiceFinalConsulAgentAcl "@"; }

installServiceFinalConsulAgentAcl()
{
	! whatCheck "acl" && return

	# setup
	header "Agent ACL"	

	# deploy agent ACL's
	for host in "${hosts[@]}"; do
		 consulAclAgentDeploy "$host" || return
	done

	# change the ACL policy to deny
	for host in "${hosts[@]}"; do
		consulAclAgentDeny "$host" || return
	done
}

installServiceFinalNomad()
{
	! whatCheck "config" && return

	header "Nomad Configuration"

	# other
	installServiceForAllHosts "nomadConfigEnableVault" && \
		installServiceForAllHosts "nomadConfigEnableDocker" && \
		installServiceForAllHosts "nomadConfigEnableRawExec" && \
		installServiceForAllHosts "serviceRestart" "nomad"
}

installServiceForAllHosts()
{
	local host
	for host in "${hosts[@]}"; do
		"$@" "$host" || return
	done
}

installServicePrepConsul()
{ 
	# product configuration file options
	o+="$(cat <<-EOF
		datacenter = "$datacenter"
		data_dir = "/opt/$product"
		domain = "$baseDomain"
		enable_script_checks = true
		leave_on_terminate = true
		retry_join = [ $(ArrayShow join ", ") ]

		# network
		advertise_addr = "{{ GetInterfaceIP \"$interface\" }}"
		advertise_addr_ipv6 = "{{ GetAllInterfaces | include \"name\" \"$interface\" | include \"type\" \"IPv6\" | sort \"address\" | limit 1 | join \"address\" \" \" }}"
		bind_addr = "{{ GetInterfaceIP \"$interface\" }}"
		client_addr = "0.0.0.0"

		# access control
		acl {
		  enabled = true
		  default_policy = "allow"
		  enable_token_persistence=true
		}\n
		EOF
	)"

	# server
	isServer && o+="$(cat <<-EOF

		# server
		server = true
		bootstrap_expect = ${#join[@]}
		ui_config { enabled = true }\n
		EOF
	)"

	# certificates
	if certs; then

		local serverDefaults; isServer && serverDefaults="$(cat <<-EOF

			    cert_file = "$certDirService/$certServer"
			    key_file = "$certDirService/$certServerKey"
			EOF
		)"

		o+="$(cat <<-EOF

			# encryption
			addresses { https = "0.0.0.0" }
			ports { http = -1, https = $consulHttpsPort }
			tls {
			  defaults {
			    ca_file = "$certDirService/$ca"$serverDefaults
			    verify_incoming = false
			    verify_outgoing = true
			  }
			  internal_rpc {
			    verify_server_hostname = true 
			  }
			}\n
			EOF
		)"		

		# client certificates
		if isClient; then
			o+="$(cat <<-EOF
				auto_encrypt = {
				  tls = true
				  dns_san = [ "$hostFqdn" ]
				  ip_san = [ "$hostIp" ]
				}\n
				EOF
			)"		
			cp "$caAuto" "$tmpDir/cert" || return
		fi
	
		# server certificates
		if isServer; then
			o+="auto_encrypt = { allow_tls = true }"
			certMakeConsulServer "$host" "$tmpDir/cert" || return
		fi

	fi

	# service options
	execStart="$program agent -config-dir=$productConfigDir"
	notifyAccess="all"
	serviceKillSignal="SIGTERM"
	serviceLimit="LimitMEMLOCK=infinity"$'\n'"LimitNOFILE=65536"$'\n'"LimitNPROC=8192"$'\n'"TasksMax=8192"
	timeoutStopSec="60"
	restrictions="$(cat <<-EOF
		ProtectSystem=full
		ProtectHome=read-only
		PrivateTmp=yes
		PrivateDevices=yes
		SecureBits=keep-caps
		AmbientCapabilities=CAP_NET_BIND_SERVICE
		CapabilityBoundingSet=CAP_NET_BIND_SERVICE CAP_SYSLOG CAP_NET_RAW
		EOF
	)"
}

installServicePrepNomad()
{
	# Consul token
	local token; token="$(product="consul" credGet "token" --quiet)"
	[[ ! $token ]] && { ScriptErr "unable to get a Consul token for Nomad"; return 1; }

	# port
	local port; port="$(productGetPort "consul" "$(protocol)")" || return

	# product configuration file options
	o+="$(cat <<-EOF
		datacenter = "$datacenter"
		data_dir = "/opt/$product"
		acl { enabled = true }
		client { enabled = true }
		consul {
		  token = "$token"
		  address = "127.0.0.1:$port"
		}\n
		EOF
	)"
	
	# server
	isServer && o+="$(cat <<-EOF

		# server
		server {
		  enabled = true
		  bootstrap_expect = "${#join[@]}"
		  raft_protocol = 3
		}\n
		EOF
	)"

	# certificates 
	if certs; then		
		local certFile="$(eval echo "\$cert${type^}")"		# certClient or certServer
		local keyFile="$(eval echo "\$cert${type^}Key")"	# certClientKey or certServerKey
		o+="$(cat <<-EOF

			# encryption
			tls { 
			  http = true
			  rpc = true
			  ca_file = "$certDirService/$ca"
			  cert_file = "$certDirService/$certFile"
			  key_file = "$certDirService/$keyFile"
			  verify_server_hostname = false
			  verify_https_client = false
			}\n
			EOF
		)"
		cp "$ca" "$certFile" "$keyFile" "$tmpDir/cert" || return
	fi

	# consul encryption environment variables
	if certs; then
		certInit "consul" || return 
	
		cat > "$tmpDir/$product.env" <<-EOF
			CONSUL_HTTP_SSL=true
			CONSUL_CACERT=$certDirService/$caLocal
			CONSUL_CLIENT_CERT=$certDirService/$certServer
			CONSUL_CLIENT_KEY=$certDirService/$certServerKey
		EOF

		certInit "nomad" || return
	fi

	# other directories
	productOtherDirs+=("/opt/alloc_mounts")

	# service options
	networkTarget="Wants=network-online.target"
	otherDependencies="
After=consul.service
Wants=consul.service"
	serviceLimit="LimitMEMLOCK=infinity"$'\n'"LimitNOFILE=1048576"$'\n'"LimitNPROC=infinity"$'\n'"TasksMax=infinity"
	timeoutStopSec="120"
	restrictions="$(cat <<-EOF
		Delegate=yes
		ProtectSystem=strict
		ReadWritePaths=/opt/nomad
		ReadWritePaths=/opt/alloc_mounts
		ProtectHome=read-only
		PrivateTmp=yes
		PrivateDevices=no
		SecureBits=keep-caps
		AmbientCapabilities=CAP_NET_BIND_SERVICE CAP_NET_ADMIN CAP_SYS_ADMIN
		CapabilityBoundingSet=CAP_CHOWN CAP_NET_BIND_SERVICE CAP_NET_ADMIN CAP_SYS_ADMIN CAP_SETUID CAP_SETGID CAP_DAC_OVERRIDE CAP_SYSLOG
		EOF
	)"
}

installServicePrepVault()
{
	# certificates
	local certListenerConfig certConsulConfig
	if certs; then

		# vault certificates
		certListenerConfig="$(cat <<-EOF

		  tls_client_ca_file = "$certDirService/$ca"
		  tls_cert_file = "$certDirService/$certServer"
		  tls_key_file = "$certDirService/$certServerKey"
			EOF
		)"
		certMakeVaultServer "$host" "$tmpDir/cert" || return

		# consul certificates
		certInit "consul" || return
		certConsulConfig="$(cat <<-EOF

		  tls_ca_file = "$certDirService/$ca"
		  tls_cert_file = "$certDirService/$certCli"
		  tls_key_file = "$certDirService/$certCliKey"
			EOF
		)"
		certInit "vault" || return

	fi

	# product configuration file options
	local token; token="$(product="consul" credGet "token")" || return

	local joinConfig="" joinServer
	for joinServer in "${joinFqdn[@]}"; do
		echo $joinServer
		joinConfig+="$(cat <<-EOF
		
		  retry_join {
		    leader_api_addr = "https://$joinServer:$vaultHttpsPort"
		  }\n
			EOF
		)"		
	done

	o+="$(cat <<-EOF

		# storage
		storage "raft" {
		  path = "/opt/$product/data"
		  node_id = "$host"
		  $joinConfig
		}

		# API listener
		listener "tcp" {
		  address = "0.0.0.0:$vaultHttpsPort"
		  cluster_address = "0.0.0.0:$vaultClusterHttpsPort"$certListenerConfig
		}

		# service registration
		service_registration "consul" {
		  token = "$token"
		  address = "127.0.0.1:$(productGetPort "consul" "$(protocol)")"
		  scheme = "$(protocol)"$certConsulConfig
		}

		# Cluster communication
		api_addr = "https://$hostFqdn:$vaultHttpsPort"\n
		cluster_addr = "https://$hostFqdn:$vaultClusterHttpsPort"

		# settings
		cluster_name="vault-prod"
		disable_mlock = false\n
		EOF
	)"

	isServer && o+="$(cat <<-EOF
		ui = "true"\n
		EOF
	)"

	# service options
	execStart="$program server -config=$productConfigDir"
	serviceLimit="LimitMEMLOCK=infinity"$'\n'"LimitNOFILE=65536"$'\n'"LimitNPROC=4096"$'\n'"TasksMax=4096"
	timeoutStopSec="30"
	restrictions="$(cat <<-EOF
		ProtectSystem=full
		ProtectHome=read-only
		PrivateTmp=yes
		PrivateDevices=yes
		SecureBits=keep-caps
		AmbientCapabilities=CAP_IPC_LOCK
		CapabilityBoundingSet=CAP_IPC_LOCK CAP_SYSLOG
		EOF
	)"
}

# installServiceServerFinal - called after all servers for a product are installed
installServiceServerFinal() { RunFunction "installServiceServerFinal" "${product}"; }

installServiceServerFinalConsul()
{
	certs && { certMakeConsulCaAuto || return; }
	installServiceAcl || return
}

installServiceServerFinalNomad() { installServiceAcl && installServiceNomadVaultIntegration; }

installServiceServerFinalVault()
{
	# generate the unseal keys
	local n key result s seals; seals="$(vault operator init 2>&1)"; result="$?"
	echo "$seals" | ${G}grep -q "Vault is already initialized" && return
	(( result != 0 )) && { EchoErr "$seals"; return 1; }

	# show the seal keys
	hilight "Store the following vault unseal keys in a secure location:"
	echo "$seals"

	# store the root token
	declare token; token="$(echo "$seals" | ${G}grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credSet "token" "$token" || return
	export VAULT_TOKEN="$token"

	# store the seal keys
	IFS=$'\n' ArrayMake seals "$(echo "$seals" | ${G}grep "Unseal Key")"
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credSet "key$n" "$key" || return
	done

	# store the Vault token on a remote server
	vaultTokenSetRemote || return

	# unseal vault
	vaultUnsealCommand || return

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | ${G}grep -q "^secret"; then
		header "Vault Configuration"
		vault secrets enable -path=secret kv-v2 || return
	fi
}

installServiceTextDirectories()
{
	cat <<-EOF
		if ! [[ -d "$certDirService" && -d "$productConfigDir" && -d "$productDataDir" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudoc install -o "$user" -g "$user" -m 755 -d "$certDirService" "$productConfigDir" "$productDataDir" || exit
		fi
	EOF
}

installServiceTextProduct() { RunFunction "installServiceTextProduct" "$product"; }

installServiceTextProductVault()
{
	cat <<-EOF
		# allow Vault to lock memory (allows disable_mlock = false)
		sudoc setcap cap_ipc_lock=+ep "$(FindInPath "vault")"		

		# create data directory
		if [[ "$force" || ! -d "$productDataDir/data" ]]; then
		  sudoc mkdir --parents "$productDataDir/data" || return
		  sudoc chown --recursive "$product" "$productDataDir/data" || return
		fi
	EOF
}

installServiceTextUser()
{
	cat <<-EOF
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudoc useradd --system --home-dir "$productConfigDir" --shell "/bin/false" "$user" || exit
		fi
	EOF
}

#
# install cli command
#

installCliUsage() {	echot "\
Usage: $(ScriptName) install cli all|$productUsage
Install a HashiCorp program and certificates for command line access.

	$certOptUsage
	-w, --what=C1[,C2...] components to install: cert cred program"; }

installCliArgStart() { unset encrypt whatArg yes; }
installCliOpt() { encryptCliOpt "$@"; }
installCliCommand() { usage; }
installCliAllCommand() { local product; for product in vault consul nomad; do installCli "$product" || return; done; }
installCliConsulCommand() { installCli "consul"; }
installCliNomadCommand() { installCli "nomad"; }
installCliVaultCommand() { installCli "vault"; }

installCli()
{
	local product="$1"; initConfig "$product" || return

	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be installed locally"; return 1; }

	whatCheck "program" && { productInstall "$product" "localhost" || return; }
	whatCheck "cert" && { productInstallCerts "$product" || return; }
	whatCheck "cred" && InPath vault && { doHashi config set local || return; }

	return 0
}

#
# nomad commands
#

nomadUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad api|config|environment|node|job|status\nNomad commands."; }
nomadArgStart() { product="nomad"; }
nomadCommand() { usage; }
nomadEnvironmentCommand() { productEnvironment "$product"; }
nomadStatusCommand() { nomad node status; }

#
# nomad api command
#

nomadApiUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad api [check|put] PATH -- [curl arguments]\nCall the Nomad API.  For example:\nhashi nomad api /nodes?resources=true"; }
nomadApiArgStart() { unset path; }
nomadApiArgs() { [[ "$command" == "nomadApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

nomadApiCommand() { nomadApi "$path" "${otherArgs[@]}"; }
nomadApi() { RunLog curl --silent --show-error --header "X-Nomad-Token: $NOMAD_TOKEN" "$NOMAD_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }

nomadApiPutCommand() { nomadApiPut "$path" "${otherArgs[@]}"; }
nomadApiPut() { nomadApi "$1" --request PUT --data "$2" "${@:3}"; } # nomadApiPut PATH DATA [ARGS]...

nomadApiCheckCommand() { nomadApiCheck; }
nomadApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" $timeout && { ScriptErrQuiet "nomad server '$host' is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" $timeout && { ScriptErrQuiet "nomad server $host is not available on port $port"; return 1; }	

	# check api
	nomadApi "/status/leader" 2> /dev/null | RemoveQuotes | RemovePort | IsIpAddress && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the nomad API at $(productVarGet "ADDR") is not available"; nomadApi "/status/leader"; return 1; }

	return 0
}

#
# nomad config commands
#

nomadConfigUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) nomad config enable|disable docker|RawExec|vault
Enable or disable Nomad functionality."; }

nomadConfigCommand() { usage; }
nomadConfigEnableCommand() { usage; }
nomadConfigDisableCommand() { usage; }

nomadConfigEnableDockerCommand() { forAllHosts nomadConfigEnableDocker; }
nomadConfigDisableDockerCommand() { forAllHosts serviceConfigDelete "nomad" "10_docker.hcl"; }

nomadConfigEnableRawexecCommand() { forAllHosts nomadConfigEnableRawExec; }
nomadConfigDisableRawexecCommand() { forAllHosts serviceConfigDelete "nomad" "10_raw_exec.hcl"; }

nomadConfigEnableVaultCommand() { forAllHosts nomadConfigEnableVault; }
nomadConfigDisableVaultCommand() { forAllHosts serviceConfigDelete "nomad" "20_vault.hcl"; }

# nomadConfigEnablDocker HOST
nomadConfigEnableDocker()
{
	serviceConfigCopyText "nomad" "$1" "10_docker.hcl" "$(cat <<-EOF
		plugin "docker" {
		  config {
		    volumes {
		      enabled = true
		    }
		  }
		}
		EOF
	)"
}

# nomadConfigEnableRawExec HOST
nomadConfigEnableRawExec()
{
	serviceConfigCopyText "nomad" "$1" "10_raw_exec.hcl" "$(cat <<-EOF
		plugin "raw_exec" {
		  config {
		    enabled = true
		  }
		}
		EOF
	)"
}

# nomadConfigEnableVault HOST
nomadConfigEnableVault()
{
	local host="$1"

	# Vault integration requires vault executable and service certificates
	productInstall "vault" "$host" || return
	updateServiceCert "vault" "$host" || return

	# certificate configuration
	local certConfig
	if certs; then
		certInit "vault" || return
		certConfig="$(cat <<-EOF

		  ca_file = "$certDirService/$caLocal"
		  cert_file = "$certDirService/$certCli"
		  key_file = "$certDirService/$certCliKey"
			EOF
		)"
		certInit "nomad" || return
	fi

	# server configuration
	local server serverConfig; server="$(serviceIsServer "nomad" "$host")" || return
	if [[ "$server" == "true" ]]; then

		# create token for Nomad to access vault - Nomad will renew the token every 72h
		local token; token="$(vault token create -display-name nomad-server -policy nomad-server -period 72h -orphan -format=json | jq '.auth.client_token' | RemoveQuotes)" || return

		serverConfig="$(cat <<-EOF
			default_identity {
			  aud  = ["vault.io"]
			  ttl  = "2h"
			}
			EOF
		)"
	fi

	# configuration	
	serviceConfigCopyText "nomad" "$host" "02_vault.hcl" "$(cat <<-EOF
		vault {
		  enabled = true
		  address = "https://$(serviceDnsName "active.vault"):$(productGetPort "vault" "$(protocol)")"$certConfig$serverConfig
		}
		EOF
	)"
}

#
# nomad node commands
#

nomadNodeUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad node allocs|drain|exists|id|ls|name|status\nNomad node commands."; }
nomadNodeCommand() { usage; }
nomadNodeExistsCommand() { local quiet="--quiet"; nomadNodeIdCommand > /dev/null; }
nomadNodeIdCommand() { forAllHosts nomadGetNodeId; }
nomadNodeLsCommand() { nomad node status -json | jq '.[] | .Name' | RemoveQuotes | sort --version-sort; }
nomadNodeStatusCommand() { forAllHosts nomadNodeStatus --header "status"; }

nomadNodeAllocsUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) nomad node allocs
Show nomad node allocations.

	-n, --numeric		show the total number of allocations for the node"; }

nomadNodeAllocsArgStart() { unset numeric; }

nomadNodeAllocsOpt()
{
	case "$1" in
		-n|--numeric) numeric="--numeric";;
		*) return 1;;
	esac
}

nomadNodeAllocsCommand()
{
	local args=(--brief); [[ $verbose ]] && args=(--header "Allocations")
	forAllHosts "${args[@]}" nomadNodeAllocs; 
}

# nomadNodeAllocs HOST - show Nomad node allocations for the host
# - verbose - if set show allocation detail with a header
# - numeric - if set show allocation count for the host
# nomad node status -allocs -json "$id"
nomadNodeAllocs()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	# get allocations
	local allocations; 
	allocations="$(
		nomad node status "$id" |& 	# redirect stderr to remove "View client details and metrics in the Web UI"
		sed '1,/Allocations/d' | 		# remove everything before Allocations
		${G}tail --lines=+2 |				# remove the first two header lines
		${G}grep " running "
	)"

	if [[ $verbose ]]; then
		echo "$allocations"
	elif [[ $numeric ]]; then
		echo -n "$allocations" | wc -l
	else
		echo -n "$allocations" | cut -d" " -f1 | NewlineToSpace | RemoveSpaceTrim
	fi

	return 0
}

# nomadGetNodeId HOST - get the node ID for the HOST
nomadGetNodeId()
{
	local host="$(resolveHost "$1")";
	local id; id="$(nomad node status -json | jq '.[] | select((.Name | ascii_downcase) == "'"$host"'").ID' | RemoveQuotes)" || return
	[[ ! $id ]] && { ScriptErrQuiet "unable to get Nomad node ID for host '$host'"; return 1; }
	echo "$id"
}

nomadNodeStatus()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return	
	local args=(); [[ $verbose ]] && args+=(-verbose)
	RunLog2 nomad status "${args[@]}" "$id"
}

#
# nomad node name command
#

nomadNodeNameUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad node name ID\nGet the node name for the specified node ID."; }
nomadNodeNameArgStart() { unset -v id; }
nomadNodeNameArgs() { ScriptArgGet "id" -- "$@"; }
nomadNodeNameCommand() { nomadNodeName "$id"; }
nomadNodeName() { nomad node status "$1" | grep '^Name' | cut -d= -f2 | RemoveSpace; }

#
# nomad node drain commands
#

nomadNodeDrainUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad node drain enable|disable|status\nNomad node drain commands."; }
nomadNodeDrainCommand() { usage; }
nomadNodeDrainEnableCommand() { forAllHosts nomadNodeDrainEnable; }
nomadNodeDrainDisableCommand() { forAllHosts nomadNodeDrainDisable; }
nomadNodeDrainStatusUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad node drain status\nReturn true if all specified hosts are drained."; }
nomadNodeDrainStatusCommand() { forAllHosts nomadNodeDrainStatus; }

# nomadNodeDrainEnable HOST
nomadNodeDrainEnable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return
	local forceArg; [[ $force ]] && forceArg="-deadline 1m"

	# return if already enabled
	[[ ! $force ]] && nomadNodeDrainStatus "$host" && return

	# enable
	hilight "Draining Nomad on node $host..."
	RunLog nomad node drain -enable -yes $forceArg "$id" && echo
}

# nomadNodeDrainDisable HOST
nomadNodeDrainDisable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	# return if already disbaled
	[[ ! $force ]] && ! nomadNodeDrainStatus "$host" && return

	# disable
	hilight "Bringing Nomad node $host back online..."
	RunLog nomad node drain -disable -yes "$id" && echo
}

# nomadNodeDrainStatus HOST - return 0 if host is drained
nomadNodeDrainStatus()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	# get node status
	local status; status="$(nomad node status -json "$id")" || return

	# node is not drained if it is elegible to get jobs
	local eleigible; eleigible="$(echo "$status" | jq '.SchedulingEligibility' | RemoveQuotes)" || return
	[[ "$eleigible" == "eligible" ]] && { log2 "host '$host' is elegible for jobs"; return 1; }
		
	# node is drained if it is down
	local down; down="$(echo "$status" | jq '.Status' | RemoveQuotes)" || return
	[[ "$down" == "down" ]] && { log2 "host '$host' is down"; return 0; }

	# node is not drained if it has running allocations
	local hasAllocations; nomad status "$id" |& sed '1,/Allocations/d' | ${G}tail --lines=+2 | ${G}grep --quiet " running " && hasAllocations="true"
	(( verboseLevel > 2 )) && nomad status "$id" |& sed '1,/Allocations/d' | ${G}tail --lines=+2
	[[ $hasAllocations ]] && { log2 "host '$host' has running allocations"; return 1; }
	
	# node is drained: it is not elegible for jobs and has no allocations
	return 0	
}

#
# nomad node eligibility commands
#

nomadNodeEligibilityUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad node eligibility [disable|enable|status](status)\nNomad node eligibility commands."; }
nomadNodeEligibilityCommand() { nomadNodeEligibilityStatusCommand; }

#
# nomad node eligibility disable|enable
#

nomadNodeEligibilityDisableCommand()
{
	getHostsByEligibility "eligible" || return
	[[ ! $hosts ]] && { [[ ! $quiet ]] && echo "No hosts are eligible for scheduling"; return 0; }
	ForAllHosts --brief nomadNodeEligibilityDisable; 
}

nomadNodeEligibilityEnableCommand()
{
	getHostsByEligibility "ineligible" || return
	[[ ! $hosts ]] && { [[ ! $quiet ]] && echo "All hosts are eligible for scheduling"; return 0; }
	ForAllHosts --brief nomadNodeEligibilityEnable
}

# getHostsByEligibility eligible|ineligible
getHostsByEligibility()
{
	[[ $hostArg ]] && { getHosts; return; }
	IFS=$'\n' ArrayMake hosts "$(nomadNodeEligibilityStatusCommand | "${G}grep" " ${1}$"  | cut -d":" -f1)" || return
}

# nomadNodeEligibilityEnable HOST
nomadNodeEligibilityEnable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return
	log1 "enabling host '$host' (id=$id) eligibility"
	RunLog nomad node eligibility -enable "$id"
}

# nomadNodeEligibilityDisable HOST
nomadNodeEligibilityDisable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return
	RunLog nomad node eligibility -disable "$id"
}

#
# nomad node eligibility status
#

nomadNodeEligibilityStatusCommand()
{
	local json; json="$(nomad node status -json)" || return
	forAllHosts --brief nomadNodeEligibilityStatus
}

# nomadNodeEligibilityStatus HOST - requires json variable be set, returns down|elegible|ineligible
nomadNodeEligibilityStatus()
{
	local host="$(RemoveDnsSuffix "$1")"
	local status; status="$(echo "$json" | jq '.[] | select(.Name == "'$host'") | .Status' | RemoveQuotes)" || return
	[[ "$status" == "down" ]] && { echo "down"; return; }
	echo "$json" | jq '.[] | select(.Name == "'$host'") | .SchedulingEligibility' | RemoveQuotes
}

#
# nomad job commands
#

nomadJobUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) nomad job alloc|exec|force|log|run|status
Nomad job commands."; }

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() { nomadJobStatusCommand; }

# nomad job alloc
nomadJobAllocUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad job alloc NAME\nReturn all running allocations of a job."; }
nomadJobAllocCommand() { nomadJobAlloc "$job"; }

nomadJobAlloc()
{
	local alloc allocs; IFS=$'\n' ArrayMake allocs "$(nomad job allocs netbootxyz | grep " running " | tr -s " ")" || return
	{ 
		for alloc in "${allocs[@]}"; do
			local node="$(GetWord "$alloc" 2)"; node="$(nomadNodeName "$node")" || return
			local alloc="$(GetWord "$alloc" 1)"
			echo "$node:$alloc"
		done
	} | sort
}

# nomad job exec
nomadJobExecUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad job exec NAME -- COMMAND [OPTIONS...]\nExecute a command on all allocation of a job."; }
nomadJobExecCommand() { nomadJobExec "$job"; }

nomadJobExec()
{
	local alloc allocs errors; IFS=$'\n' ArrayMake allocs "$(nomadJobAlloc "$job")" || return
	for alloc in "${allocs[@]}"; do
		local node="$(GetWord "$alloc" 1 ":")"
		local alloc="$(GetWord "$alloc" 2 ":")"
		header "$node"
		nomad alloc exec "$alloc" "${otherArgs[@]}"; (( errors+=$? ))
	done

	return $errors
}

# nomad job run
nomadJobRunUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad job run NAME\nRun or update a job."; }
nomadJobRunCommand()
{
	local file; file="$(ConfigGet confDir)/hashi/job/$job.hcl"; [[ -f "$file" ]] && job="$file"
	ScriptCheckFile "$job" || return
	nomad run "$job" "${otherArgs[@]}" || return
}

# nomad job status 
nomadJobStatusUsage() { ScriptUsageEcho "Usage: $(ScriptName) nomad job status [NAME]\nStatus of all running jobs or the specified job."; }
nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadPeriodicJobGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | ${G}grep -v dead
	fi
}

# nomnd job force command

nomadJobForceUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"; }

nomadJobForceArgStart() { log=""; }

nomadJobForceOpt() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"; }

nomadJobLogArgStart() { follow=""; }

nomadJobLogOpt() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadPeriodicJobGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId" "${otherArgs[@]}"
		header "Standard Error"; nomad alloc logs -stderr "$allocId" "${otherArgs[@]}"
	fi		
}

# nomad helper

# nomadClientName ID - return the name of the Nomad client with ID
nomadClientName() { nomad status "$1" | ${G}grep "^Name " | tr -s ' ' | cut -d"=" -f2 | RemoveSpace; }

# nomadClients - return all Nomad client ID's
nomadClients() { nomad node status | ${G}tail --lines=+2 | cut -d" " -f1; }

# nomadPeriodicJobGetId - get the job ID for $job 
nomadPeriodicJobGetId()
{ 
	jobId="$(nomad job status "$job" |& ${G}tail --lines=-1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job '$job'"; exit 1
}

# nomadPeriodicJobGetAllocId - get the allocation ID for the $jobId or $job 
nomadPeriodicJobGetAllocId()
{
	[[ ! $jobId ]] && { nomadPeriodicJobGetId || return; }
	allocId="$(nomad job status "$jobId" |& ${G}tail --lines=-1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job '$job'"; exit 1
}

# nomadVaultStatus - show the status of the Vault integration for all Nomad clients
nomadVaultStatus()
{
	hilight "Nomad Vault integration status:"
	for id in $(nomadClients); do 
		echo "$(nomadClientName "$id"): $(nomad status -verbose "$id" | ${G}grep "^vault.accessible" | tr -s " " | cut -d"=" -f2 | RemoveSpace)"; 
	done
}

#
# remove command
#

removeUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) remove all|cli|$productUsage
Remove a HashiCorp product configuration and data.

	-w, --what=C1[,C2...] components to remove: program service
		$configWhat"; }

removeArgStart() { unset whatArg yes; }

removeOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

removeOptArgEnd()
{
	[[ ! $what ]] && { MissingOption "what"; return; }

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

removeCommand() { removeAllCommand; }
removeAllCommand() { removeDo "vault" && removeDo "nomad" && removeDo "consul"; }
removeConsulCommand() { removeDo "consul"; }
removeNomadCommand() { removeDo "nomad"; }
removeVaultCommand() { removeDo "vault"; }

removeDo()
{
	local product="$1"
	whatCheckConfig && { removeConfig "$product" || return; }
	whatCheck "service" && { removeService || return; }
	return 0
}

removeService()
{
	local removeProgram; whatCheck "program" && removeProgram="true"

	if [[ ! $force || ! $yes ]]; then
		ScriptErr "To permanently delete all $product services and programs for $baseDomain $configDesc, --force and --yes are required"
		return 1
	fi

	local host hosts; getHosts "config" || return
	for host in "${hosts[@]}"; do
		header "Remove $(ProperCase "$product") Service ($host)"
		serviceRemove "$product" "$host" || return
	done
}

#
# remove cli command
#

removeCliUsage() { ScriptUsageEcho "\
Usage: $(ScriptName) remove cli all|$productUsage
Remove a HashiCorp program and certificates used for command line access."; }

removeCliCommand() { local product; for product in "${products[@]}"; do removeCli "$product" || return; done; }
removeCliConsulCommand() { removeCli "consul"; }
removeCliNomadCommand() { removeCli "nomad"; }
removeCliVaultCommand() { removeCli "vault"; }

removeCli() 
{ 
	local product="$1"
	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be removed locally"; return 1; }
	whatCheck "config" && { certInit "$product" && removeDir "$(certDirLocal "$product")"; }
	whatCheck "program" && { RunLog sudoc rm -f "/usr/local/bin/$product" || return; }
	return 0
}

#
# resolve command
#

resolveUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) resolve [api|dig|name|nslookup|passing|list](passing) SERVICE
Resolve the nodes of a service.

	Resolve using Consul DNS servers:
	name				return passing service node DNS names
	passing			return passing service node IP addresses
	dig					use dig to return passing service nodes
	nslookup		use nslookup to return passing servers

	Resolve using the Consul API:
	api					use the API to return all service nodes detail as JSON
	list				return a list of passing service node names from the API

  -a, --all		return all passing service nodes instead of the first"
}

resolveArgStart() { unset -v all name; }
resolveArgs() { ScriptArgGet "name" -- "$@"; }

resolveOpt()
{
	case "$1" in
		-a|--all) all="true";;
		*) return 1;;
	esac
}

resolveCommand() { resolvePassingCommand; }
resolvePassingCommand() { resolve "$name" "$all"; }
resolveApiCommand() { resolveApi "$name"; }
resolveNameCommand() { resolveName "$name" "$all" | sort --version-sort; }

resolveApi()
{
	local name="$1"
	log1 "using API to resolve the '$name' service"
	local product="consul"; noToken="true" productInit "$product" || return
	test="" RunLog curl --silent --show-error "$(productVarGet "ADDR")/v1/catalog/service/$name"
}

resolveDigCommand()
{
	log1 "using dig to resolve the '$name' service"
	name="$(serviceDnsName "$name")" || return
	local server; server="$(getDnsServer)" || return
	test="" RunLog dig -4 "@$server" -p 8600 "$name" SRV
}

resolveListCommand()
{
	log1 "using API to resolve the '$name' service to a list of available nodes from the API"
	test="" resolveApi "$name" | jq ".[].Node" | RemoveQuotes
}

resolveNslookupCommand()
{
	log1 "using nslookup to resolve the '$name' service"
	name="$(serviceDnsName "$name")" || return
	local server; server="$(getDnsServer)" || return
	test="" RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server"
}

resolve()
{
	local name="$1" all="$2"
	local filter=(head -1); [[ $all ]] && { filter=(cat); }

	if InPath dig; then
		resolveDig "$name" | "${filter[@]}" || return
	elif InPath "nslookup" && ! IsBusyBox; then # nslookup does not work properly on BusyBox
		resolveNslookup "$name" | "${filter[@]}" || return
	else
		[[ ! $quiet ]] && HostUnresolved "$name"; return 1
	fi
}

resolveDig()
{
	local name; name="$(serviceDnsName "$1")" || return
	local server; server="$(getDnsServer)" || return
	local ip; ip="$(test="" RunLog dig -4 "@$server" -p 8600 "$name" A +short)"
	[[ ! $ip ]] && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }
	log1 "dig resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

resolveNslookup()
{
	local name; name="$(serviceDnsName "$1")" || return
	local server; server="$(getDnsServer)" || return

	local result; result="$(test="" RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server")"
	(( $? != 0 )) && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }

	local ip
	if [[ "$result" =~ .*canonical\ name.* ]]; then
		ip="$(printf "$result" | ${G}tail --lines=+4 | ${G}grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//')"
	else
		ip="$(printf "$result" | ${G}tail --lines=+4 | ${G}grep "^Address:" | cut -d: -f2 | RemoveSpace)"
	fi
	
	log1 "nslooklup resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

resolveName()
{
	local name="$1" all="$2"
	resolve "$name" "$all" | DnsResolveBatch
}

#
# update command
#

updateUsage() { ScriptUsageEcho "usage: $(ScriptName) update cli|service"; }
updateCommand() { usage; }

# update cli command
updateCliUsage() { ScriptUsageEcho "usage: $(ScriptName) update cli cert|program\n\n	$certOptUsage"; }
updateCliArgStart() { certArgStart; }
updateCliOpt() { encryptOpt "$@"; }
updateCliCommand() { usage; }

# update cli cert command
updateCliCertUsage() { ScriptUsageEcho "usage: $(ScriptName) update cli cert all|$productUsage"; }
updateCliCertCommand() { usage; }
updateCliCertAllCommand() { updateCliCertConsulCommand && updateCliCertNomadCommand && updateCliCertVaultCommand; }
updateCliCertConsulCommand() { forAllHosts updateCliCert "consul"; }
updateCliCertNomadCommand() { forAllHosts updateCliCert "nomad"; }
updateCliCertVaultCommand() { forAllHosts updateCliCert "vault"; }

# updateCliCert PRODUCT HOST
updateCliCert()
{
	local product="$1" host="$2"; certInit "$product" || return
	local src; src="$(certPublicFind "$product")" || return
	local dest="$(certDirSuffix "$product" "/opt/hashi")" # always install certificates to /opt/hashi 

	# copy certificates to a temporary directory
	local tmpDir; tmpDir="$(tmpDirCreate)" || return
	certMakeCp "$src/$ca" "$src/$certCli" "$src/$certCliKey" "$tmpDir" || return
	[[ -f "$src/$caAuto" ]] && { certMakeCp "$src/$caAuto" "$tmpDir" || return; }

	# copy certificates to the host
	copyDirRemote "$tmpDir" "$host" || return

	# install the new certificates on the host
	scriptRun "$host" "$(cat <<-EOF
		
		echo "Installing ${product^} certificates..."
		sudoc install --backup=numbered -m 644 -t "$dest" "$tmpDir/"* || exit

		$(scriptCertStore "$dest")
		$(scriptCleanup)
		EOF
	)" || return

	# cleanup
	rm -fr "$tmpDir"
}

# update cli program command
updateCliProgramUsage() { ScriptUsageEcho "usage: $(ScriptName) update cli program all|$productUsage"; }
updateCliProgramCommand() { usage; }
updateCliProgramAllCommand() { updateCliProgramConsulCommand && updateCliProgramNomadCommand && updateCliProgramVaultCommand; }
updateCliProgramConsulCommand() { forAllHosts updateCliProgram "consul"; }
updateCliProgramNomadCommand() { forAllHosts updateCliProgram "nomad"; }
updateCliProgramVaultCommand() { forAllHosts updateCliProgram "vault"; }

# updateCliProgram PRODUCT HOST - assumes the host is not running the product service
updateCliProgram()
{
	local product="$1" host="$2"
	
	header "Update $(ProperCase "$product") CLI ($host)"

	# return if the product installation is not needed
	productInstallNeeded "$product" "$host" || return; [[ ! $installNeeded ]] && return

	# install the product
	productInstallDo "$product" "$host"
}

# update service command
updateServiceUsage() { ScriptUsageEcho "usage: $(ScriptName) update service cert|program\n\n	$certOptUsage"; }
updateServiceArgStart() { certArgStart; }
updateServiceOpt() { encryptOpt "$@"; }
updateServiceCommand() { usage; }

# update service cert command
updateServiceCertUsage() { ScriptUsageEcho "usage: $(ScriptName) update service cert all|$productUsage\n\n	$certOptUsage"; }
updateServiceCertCommand() { usage; }
updateServiceCertAllCommand() { updateServiceCertConsulCommand && updateServiceCertNomadCommand && updateServiceCertVaultCommand; }
updateServiceCertConsulCommand() { forAllHosts updateServiceCert "consul"; }
updateServiceCertNomadCommand() { forAllHosts updateServiceCert "nomad"; }
updateServiceCertVaultCommand() { forAllHosts updateServiceCert "vault"; }

# updateServiceCert PRODUCT HOST
updateServiceCert()
{
	local product="$1" host="$2"; serviceVars "$product" || return; certMakeCd "$product" || return
	
	# copy certificates to a temporary directory
	local tmpDir; tmpDir="$(tmpDirCreate)" || return
	certMakeCp "$ca" "$certCli" "$certCliKey" "$tmpDir" || return

	# only copy the server certifcates for servers
	local server; server="$(serviceIsServer "$product" "$host")" || return
	[[ "$server" == "true" ]] && { certMake${product^}Server "$host" "$tmpDir/cert" || return; }

	# copy certificates to the host
	copyDirRemote "$tmpDir" "$host" || return

	# install the new certificates on the host
	scriptRun "$host" "$(cat <<-EOF
		$(installServiceTextUser)
		$(installServiceTextDirectories)
		sudoc install --backup=numbered -o "$user" -g "$user" -m 755 -t "$certDirService" "$tmpDir/"* || exit
		$(scriptCleanup)
		EOF
	)" || return

	# restart the service on the host
	[[ "$server" == "true" ]] && { serviceRestart "$product" "$host" || return; }

	# cleanup
	rm -fr "$tmpDir"
}

# update service program command
updateServiceProgramUsage() { ScriptUsageEcho "usage: $(ScriptName) update service program all|$productUsage\n\n	$certOptUsage"; }
updateServiceProgramCommand() { usage; }
updateServiceProgramAllCommand() { updateServiceProgramConsulCommand && updateServiceProgramNomadCommand && updateServiceProgramVaultCommand; }
updateServiceProgramConsulCommand() { forAllHosts updateServiceProgram "consul"; }
updateServiceProgramNomadCommand() { forAllHosts updateServiceProgram "nomad"; }
updateServiceProgramVaultCommand() { forAllHosts updateServiceProgram "vault"; }

# updateServiceProgram PRODUCT HOST
updateServiceProgram()
{
	local product="$1" host="$2"
	
	header "Update $(ProperCase "$product") Service ($host)"

	# return if the product installation is not needed
	productInstallNeeded "$product" "$host" || return; [[ ! $installNeeded ]] && return

	# install the product
	RunFunction "updateStart" "$product" && productInstallDo "$product" "$host" && RunFunction "updateEnd" "$product"
}

updateStartNomad() { nomadNodeDrainEnable "$host"; }
updateEndNomad() { nomadNodeDrainDisable "$host"; }

#
# service commands
#

serviceUsage() { ScriptUsageEcho "Usage: $(ScriptName) service check|config|IsServer|monitor|restart|retry|start|stop|verify $productUsage\nControl Hashi product services."; }

serviceCommand() { usage; }

serviceCheckUsage() { ScriptUsageEcho "Usage: $(ScriptName) service check $productUsage\nReturn 1 and an error message if the service for PRODUCT on HOST is not running properly."; }
serviceCheckConsulCommand() { forAllHosts "serviceCheck" "consul"; }
serviceCheckNomadCommand() { forAllHosts "serviceCheck" "nomad"; }
serviceCheckVaultCommand() { forAllHosts "serviceCheck" "vault"; }

serviceConfigUsage() { ScriptUsageEcho "Usage: $(ScriptName) service config $productUsage\nReturn a service configuration variable."; }
serviceConfigCommand() { usage; }
serviceConfigArgs() { ScriptArgGet "varArg" "var" -- "$@"; }
serviceConfigConsulCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "consul"; }
serviceConfigNomadCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "nomad"; }
serviceConfigVaultCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "vault"; }

serviceIsServerCommand() { usage; }
serviceIsServerUsage() { ScriptUsageEcho "Usage: $(ScriptName) service IsServer $productUsage\nReturn true if HOST is a PRODUCT server, otherwise return false."; }
serviceIsServerConsulCommand() { forAllHosts "serviceIsServer" "consul"; }
serviceIsServerNomadCommand() { forAllHosts "serviceIsServer" "nomad"; }
serviceIsServerVaultCommand() { forAllHosts "serviceIsServer" "vault"; }

serviceMonitorUsage() { ScriptUsageEcho "Usage: $(ScriptName) service monitor $productUsage\nStream logs from PRODUCT on HOST."; }
serviceMonitorCommand() { usage; }
serviceMonitorConsulCommand() { serviceMonitorDo "consul"; }
serviceMonitorNomadCommand() { serviceMonitorDo "nomad"; }
serviceMonitorVaultCommand() { serviceMonitorDo "vault"; }
serviceMonitorDo() { productInit "$1" && "$1" monitor "${otherArgs[@]}"; }

serviceRestartUsage() { ScriptUsageEcho "Usage: $(ScriptName) service restart $productUsage\nRestart the PRODUCT service on HOST."; }
serviceRestartCommand() { usage; }
serviceRestartConsulCommand() { forAllHosts serviceRestart "consul"; }
serviceRestartNomadCommand() { forAllHosts serviceRestart "nomad"; }
serviceRestartVaultCommand() { forAllHosts serviceRestart "vault"; }

serviceRestartUsage() { ScriptUsageEcho "Usage: $(ScriptName) service restart $productUsage\nStart the PRODUCT service on HOST, and restart it if it does not start successfully."; }
serviceRetryCommand() { usage; }
serviceRetryConsulCommand() { forAllHosts serviceRetry "consul"; }
serviceRetryNomadCommand() { forAllHosts serviceRetry "nomad"; }
serviceRetryVaultCommand() { forAllHosts serviceRetry "vault"; }

serviceRestartUsage() { ScriptUsageEcho "Usage: $(ScriptName) service restart $productUsage\nRestart the PRODUCT service on HOST."; }
serviceStartCommand() { usage; }
serviceStartConsulCommand() { forAllHosts serviceStart "consul"; }
serviceStartNomadCommand() { forAllHosts serviceStart "nomad"; }
serviceStartVaultCommand() { forAllHosts serviceStart "vault"; }

serviceStopUsage() { ScriptUsageEcho "Usage: $(ScriptName) service stop $productUsage\nStop the PRODUCT service on HOST."; }
serviceStopCommand() { usage; }
serviceStopConsulCommand() { forAllHosts serviceStop "consul"; }
serviceStopNomadCommand() { forAllHosts serviceStop "nomad"; }
serviceStopVaultCommand() { forAllHosts serviceStop "vault"; }

serviceVerifyUsage() { ScriptUsageEcho "Usage: $(ScriptName) service verify $productUsage\nReturn 1 and an error message if the service for PRODUCT is not installed on HOST"; }
serviceVerifyCommand() { usage; }
serviceVerifyConsulCommand() { forAllHosts serviceVerify "consul"; }
serviceVerifyNomadCommand() { forAllHosts serviceVerify "nomad"; }
serviceVerifyVaultCommand() { forAllHosts serviceVerify "vault"; }

# serviceVerify PRODUCT - return 1 and an error message if the service for a product is not installed
serviceVerify()
{
	local product="$1" host="$2"; [[ ! $product ]] && { MissingOperand "product"; return; }

	productVerify "$product" && [[ -d "/etc/$product.d" ]] && service exists "$product" && return
	ScriptErrQuiet "the $product service is not installed"
}

# service helper

serviceCheck()
{
	local product="$1" host="$2"
	RunFunction serviceCheck "$product" "$host"
}

serviceCheckConsul() { consul members | ${G}grep -i "^$(resolveHost "$1") " | qgrep " alive "; }
serviceCheckNomad() { [[ "$(nomadEligibilityCheck "$1")" == "eligible" ]]; }
serviceCheckVault() {	vault operator members | qgrep -i "^$(resolveHost "$1") "; }

serviceCheckWait()
{
	local seconds=10 product="$1" host="$2"

	printf "Checking $product on $host..."

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		serviceCheck "$product" "$host" && { echo "healthy"; return; }
		printf "."
	done

	echo "failed"
	return 1
}

# hostCopy PRODUCT HOST FILE - copy a service configuration file to the host destination directory with the correct permissions
serviceConfigCopy()
{
	local product="$1" host="$2" file="$3"; serviceVars "$product" || return
	local name="$(GetFileName "$file")" exists; productServiceConfigReturn && return

	serviceConfigCopyStart && LogFile2 "$file" && RunLog scp "$file" "$host:/tmp" && serviceConfigCopyEnd 
}

# serviceConfigCopyText PRODUCT HOST NAME TEXT - copy text to a service configuration file on the host
serviceConfigCopyText()
{
	local product="$1" host="$2" name="$3" text="$4"; serviceVars "$product" || return
	local exists; productServiceConfigReturn && return

	serviceConfigCopyStart && sshRun "$host" "cat <<-EOF > /tmp/$name
		$text
		EOF" && serviceConfigCopyEnd
}

productServiceConfigReturn()
{
	hostFileExists "$host" "$productConfigDir/$name" && exists="true"
	[[ $isServiceInstall && ! $force && $exists ]]
}

# serviceConfigCopyStart - start copying a service configuration file
serviceConfigCopyStart()
{
	# check if the configuration file alreadys exists
	[[ ! $force && $exists ]] && { ScriptErr "configuration file '$name' already exists, use --force to overwrite"; return 1; }
	
	# logging
	hilight "Copying '$name' to $host:$productConfigDir..."
}

# serviceConfigCopyEnd - finish copying a service configuration file
serviceConfigCopyEnd()
{
	local dest="$productConfigDir/$name"

	# move and set permissions on the configuration file
	RunLog scriptRun "$host" "$(cat <<-EOF
		sudoc mv "/tmp/$name" "$dest" || exit
		sudoc chmod 600 "$dest" || exit
		sudoc chown "$user" "$dest" || exit
		sudoc chgrp "$user" "$dest" || exit
		EOF
	)"
}

# serviceConfigDelete PRODUCT FILE HOST - delete a service configuration file on the host
serviceConfigDelete()
{
	local product="$1" file="$2" host="$3"; serviceVars "$product" || return
	local dest="$productConfigDir/$file"

	RunLog scriptRun "$host" "$(cat <<-EOF
		[[ ! -f "$dest" ]] && exit 0
		sudoc rm "$dest"
		EOF
	)"
}

# serviceConfigVarGet VAR PRODUCT HOST - get a variable from the product configuration file, return error if the variable does not exist
serviceConfigVarGet() 
{
	local var="$1" product="$2" host="$3"; serviceVars "$product" || return;
	scriptRun "$host" "grep \"[ ]*$var[ ]*=[ ]*\" \"$productConfigFile\"" | tr -s " " | cut -d"=" -f2 | RemoveCarriageReturn | RemoveSpace | RemoveQuotes
}

# serviceIsServer PRODUCT HOST - return true if HOST is a PRODUCT server, otherwise return false
serviceIsServer()
{
	local product="$1" host="$2"; hostCheck "$host" || return
	local check="bootstrap_expect"; [[ "$product" == "vault" ]] && check="ui"
	serviceConfigVarGet "$check" "$product" "$host" > /dev/null && echo "true" || echo "false"
}

# serviceRemove PRODUCT HOST - remove the service from the host
serviceRemove()
{
	local product="$1"; serviceVars "$product" || return
	local host="$2"; hostCheck "$host" || return 0
	
	scriptRun "$host" "$(cat <<-EOF

		# delete service
		if [[ -f "$productServiceFile" ]]; then
		  echo "Deleting the service..."
		  sudoc systemctl stop "$product" || exit
		  sudoc systemctl disable "$product" || exit
		  sudoc rm -f "$productServiceFile" || exit
		  sudoc systemctl daemon-reload || exit
		  sudoc systemctl reset-failed || exit
		fi

		# remove certificates
		if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
		  echoc "Removing automatic CA certificate..."
		  sudoc rm -f "$certStoreCa" "$certStoreCaAuto" || exit
		  sudoc update-ca-certificates || return
		fi

		printf "cleaning..."
		getent passwd "$product" >&/dev/null && { printf "user..."; sudoc userdel "$product" >& /dev/null; }
		getent group "$product" >&/dev/null && { printf "group..."; sudoc groupdel "$product" >& /dev/null; }
		[[ -d "/etc/$product.d" ]] && { printf "configuration..."; sudoc rm -fr "/etc/$product.d"; }
		[[ -d "/opt/$product" ]] && { printf "data..."; sudoc rm -fr "/opt/$product"; }
		[[ "$removeProgram" && -f "$binDir/$product" ]] && { printf "program..."; sudoc rm -f "$binDir/$product"; }

		[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && { printf "tempory files..."; sudoc rm -fr "/tmp/hashi."*; }
		[[ -d "/tmp/consul-test" ]] && sudoc rmdir "/tmp/consul-test"

		echo "done"

		EOF
	)"
}

# serviceCOMMAND PRODUCT HOST

serviceRestart() 
{
	[[ $noRestartService ]] && return
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudoc systemctl restart "$product" --no-block || exit"; 
}

serviceRestartLocal() 
{
	[[ $noRestartService ]] && return
	local product="$1"; service restart "$product" 
}

serviceRetry() 
{	
	local product="$1" host="$2" try tries=3

	# return if the pre-check succeeds
	RunFunction serviceRetryPre "$product" "$host" && return

	# return if the service is ok
	serviceCheck "$product" "$host" && return

	# ensure the service is started, if it's already started we may just need to wait for it to be OK
	service start "$product" --host="$host" || return
	serviceCheckWait "$product" "$host" && return

	# wait for health and restart
	local  product="$1" host="$2"
	for (( try=1; try<=tries; ++try )); do
		echo "${product^} is not healthy, attempting service restart (try $try of $tries)..."
		service restart "$product" --host="$host" --wait || return
		serviceCheckWait "$product" "$host" && return
	done

	echo "${product^} is not healthy after $tries service restarts"
}

# serviceRetryPreNomad HOST - return true if the host is eleigible for scheduling, or we can make it eligible.  Errors are suppressed.
serviceRetryPreNomad()
{
	local host="$1"
	local eligible="$(nomadEligibilityCheck "$host" 2>&1)"
	log1 "host '$host' eligibility is '$eligible'"
	[[ "$eligible" == "eligible" ]] && return
	[[ "$eligible" != "ineligible" ]] && return 1
	nomadNodeEligibilityEnable "$host" > /dev/null && [[ "$(nomadEligibilityCheck "$host" 2>&1)" == "eligible" ]]
}

serviceStart() 
{
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudoc systemctl start "$product" --no-block || exit"; 
}

serviceStop() 
{
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudoc systemctl stop "$product" --no-block || exit"; 
}

serviceVars()
{
	local product="$1"; certInit "$product" || return
	
	# variables
	program="$(FindInPath "$product")" || return
	user="$product"; [[ "$product" == "nomad" ]] && user="root"; # many Nomad jobs require running as root

	# directories	
	productConfigDir="/etc/$product.d" 
	productDataDir="/opt/$product"
	productOtherDirs=()

	# configuration
	productConfigFileBase="01_$product.hcl"
	productConfigFile="$productConfigDir/$productConfigFileBase"
	productServiceFile="/etc/systemd/system/$product.service"
	productServiceEnvFile="/etc/systemd/system/$product.env"
}

#
# vault commands
#

vaultUsage() { ScriptUsageEcho "Usage: $(ScriptName) vault api|environment|status|token|unseal\nVault commands."; }
vaultArgStart() { product="vault"; }
vaultCommand() { usage; }
vaultEnvironmentCommand() { productEnvironment "$product"; }

#
# vault api command
#

vaultApiUsage() { ScriptUsageEcho "Usage: $(ScriptName) vault api [check|list|put] PATH -- [curl arguments]\nCall the Consul API.  For example:\nhashi vault api /sys/health"; }
vaultApiArgStart() { unset path; }
vaultApiArgs() { [[ "$command" == "vaultApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

vaultApiCommand() { vaultApi "$path" "${otherArgs[@]}"; }
vaultApi() { RunLog curl --silent --show-error --header "X-Vault-Token: $VAULT_TOKEN" "$VAULT_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }

vaultApiListCommand() { vaultApiList "$path" "${otherArgs[@]}"; }
vaultApiList() { vaultApi "$@" --request LIST; }

vaultApiPutCommand() { vaultApiPut "$path" "${otherArgs[@]}"; }
vaultApiPut() { vaultApi "$1" --request PUT --data "$2" "${@:3}"; } # vaultApiPut PATH DATA [ARGS]...

vaultApiCheckCommand() { vaultApiCheck; }
vaultApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" $timeout && { ScriptErrQuiet "vault server '$host' is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" $timeout && { ScriptErrQuiet "vault server $host is not available on port $port"; return 1; }	

	# check api
	[[ "$(vaultApi "/sys/health" 2> /dev/null | jq '.initialized')" == "true" ]]  && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the vault API at $(productVarGet "ADDR") is not available"; vaultApi "/sys/health"; return 1; }

	return 0
}

#
# vault seal command
#

vaultSealCommand()
{
	local active="$(resolve active.vault)"
	local standby="$(resolve standby.vault)"
	
	header "Vault Seal"
	vaultSeal "$active" && vaultSeal "$standby"
}

vaultSeal()
{
	local host="$1"

	[[ ! $host ]] && return
	echo "Sealing Vault host $host..."
	productInit "vault" "$host" || return
	RunLog vault operator seal || return
}

#
# vault status command
#

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	echo "Active Node            $(resolve active.vault)"
	echo "Standby Node           $(resolve standby.vault)"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac

}

#
# vault token command
#

vaultTokenCommand()
{
	for accessor in $(vault list auth/token/accessors | ${G}tail --lines=+3); do
		header "$accessor"
		vault token lookup -accessor "$accessor"
	done
}

#
# vault unseal command
#

vaultUnsealUsage() { ScriptUsageEcho "Usage: $(ScriptName) vault unseal\nUnseal the vault using keys from the credential store."; }

vaultUnsealCommand()
{
	local host hosts key; vaultHostsGet || return

	for host in "${hosts[@]}"; do

		# check availability
		! IsAvailable "$host" && { echo "warning: '$host' is not available"; continue; }

		header "Vault Unseal ($host)"
		productInit "vault" "$host" || return
		vaultIsUnsealed && { echo "Vault on $host is already unsealed"; continue; }

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credGet "key$n")" || return
			RunLog vault operator unseal "$key" || return
		done

	done
}

# vault helper

# vaultHostsGet - set the hosts array to all the Vault hosts
vaultHostsGet()
{
	local json

	# get the hosts from the host argument
	[[ $hostArg ]] && { GetHosts "${hostArg,,}"; return; }
	
	# get the hosts from Consul if possible
	if productIsInstalled "consul" && json="$(resolveApi "vault")"; then
		IFS=$'\n' ArrayMake hosts "$( echo "$json" | jq -r '.[].ServiceAddress')"
	fi
	
	# get the hosts from configuration 
	[[ ! $hosts ]] && { getHosts "VaultServers" || return; }

	# no hosts found
	[[ "${#hosts[@]}" == "0" ]] && { ScriptErr "no Vault hosts found"; return 1; }

	return 0
}

vaultIsUnsealed() { vault status | ${G}grep -q '^Sealed[ ]*false$'; }

# vaultTokenSetRemote - set the Vault token on a remote host
vaultTokenSetRemote()
{	
	local product="vault"; productInit "$product" || return

	# return if the Vault token is already set on the remote host
	local host; host="$(configServer)" || return
	local token; token="$(sshRunInteractive "$host" credential get "$(credPath)" token --queit "${globalArgs[@]}")" || return
	[[ "$token" == "$VAULT_TOKEN" ]] && return

	sshRunInteractive "$host" credential set "$(credPath)" token "$VAULT_TOKEN" "${globalArgs[@]}" || return
}

# vaultTokenGetRemote - get the Vault token from a remote host if needed
vaultTokenGetRemote()
{
	local product="vault" token
	log1 "vaultTokenGetRemote: getting the vault token"

	# get the vault token from the VAULT_TOKEN environment variable
	if [[ $VAULT_TOKEN ]]; then
		token="$VAULT_TOKEN"
		log1 "vaultTokenGetRemote: got the Vault token from the environment"
		export VAULT_TOKEN="$token"; return
	fi

	# get the vault token from the credential store
	if credExists "token"; then
		log1 "vaultTokenGetRemote: looking for the Vault token in the credential store"
		token="$(credGet "token")" || return
		if [[ $token ]]; then
			log1 "vaultTokenGetRemote: got the Vault token from the credential store"
			export VAULT_TOKEN="$token"; return
		fi
		log1 "vaultTokenGetRemote: the Vault token in the credential store is empty"
	fi
	
	# get the Vault token from the Consul server
	log1 "vaultTokenGetRemote: looking for the Vault token from the Consul server"
	local credPath; credPath="$(credPath)" || return

	local host; host="$(productGetServer "consul")" || return
	IsLocalHost "$host" && { ScriptErr "unable to get the Vault token from the local Consul server"; return; }

	echo "Getting the Vault token from '$host' at path $credPath..."
	token="$(sshRunInteractive "$host" credential get "$credPath" token "${globalArgs[@]}" | RemoveCarriageReturn)" || return
	[[ ! $token ]] && { ScriptEr "the Vault token at '$host' is empty"; return; }
	
	log1 "vaultTokenGetRemote: got the Vault token from '$host'"
	export VAULT_TOKEN="$token"
}

#
# certificate helper
#

# certDirLocal PRODUCT - return the local certificate directory for CLI certificates, /opt/hashi/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT if present,
#   otherwise use /opt/PRODUCT/cert (when using the CLI on Hashi servers)
certDirLocal()
{
	local product="$1"
	local dir="$(certDirSuffix "$product" "/opt/hashi")"

	if [[ -d "$dir" ]]; then echo "$dir"
	elif [[ -d "$(certDirService "$product")" ]]; then echo "$(certDirService "$product")"
	else ScriptErrQuiet "unable to find the $product local certificate directory '/opt/hashi/certificate' or '/opt/$product/cert'"
	fi
}

# certDirPrivate - the root private certificate directory from the --encrypt option or certificateDir configuration
certDirPrivate()
{	
	# private encryption directory specified on command line
	[[ -d "$encrypt" ]] && { echo "$encrypt"; return; }

	# mount encrypted private certificate directory
	CloudConf || return
	local mountDir="$(configGet "CertificateDevice")"
	local dir="$(configGet "CertificateDir")"

	# return if not found
	if [[ ! -d "$mountDir" || ! $dir ]]; then
		ScriptErrQuiet "the private certificate directory '$(FileToDesc "$mountDir")' does not exist"
		return 1
	fi 
	
	# check if the certificate volume was mounted already so we don't unmount it later
	certVolumeWasMounted=""; encrypt IsMounted "$mountDir" && certVolumeWasMount="true"

	# mount
	certVolume="$(RunLog encrypt mount "$mountDir" "$@")" || return

	# check
	local fullDir="$certVolume/$dir"
	[[ ! -d "$fullDir" ]] && { ScriptErrQuiet "certificate directory '$dir' is missing on '$(FileToDesc "$mountDir")'"; return 1; }

	echo "$fullDir"
}

# certDirPrivateSuffix PRODUCT - add certificate suffix to the private certificate directory
certDirPrivateSuffix() { local product="$1" dir; dir="$(certDirPrivate)" && certDirSuffix "$product" "$dir"; }

# certDirPublic - return the public certificate directory from an installation file server
certDirPublic() { findInstallFile --quiet "other/HashiCorp"; }

# certDirPublicSuffix PRODUCT - add certificate suffix to the public certificate directory
certDirPublicSuffix() { local product="$1" dir; dir="$(certDirPublic)" && certDirSuffix "$product" "$dir"; }

# certDirService PRODUCT - return the product service certificate directory
certDirService() { echo "/opt/$1/cert"; }

# certDirSuffix PRODUCT DIR - add certificate suffix to DIR: DIR/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT
certDirSuffix()
{ 
	local product="$1"; shift; 	GetArgs; [[ ! $1 ]] && { ScriptErrQuiet "certDirSuffix: directory not specified"; return 1; }
	echo "$(RemoveTrailingSlash "$1")/certificate/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
}

# certDirUnmountPrivate - unmount the private certificate directory if mounted.  Directory is changed in case we are in the private certificate directory.
certDirUnmountPrivate()
{
	[[ ! -e "$certVolume" ]] && return
	cd && encrypt unmount "$certVolume"
}

# certExists DIR FILES - return 0 if all certificate files exist in the certificate directory
certExists()
{	
	[[ $forceCert ]] && return 1

	local file dir="$PWD"; [[ -d "$1" ]] && { dir="$1"; shift; }

	for file in "$@"; do
		[[ ! -f "$dir/$file" ]] && return 1
	done

	return 0
}

# certInit PRODUCT- initialize certificate variables for the specified product
certInit()
{
	local product="$1"; [[ ! $product ]] && { MissingOperand "product"; return; }

	log2 "initializing $product certificates..."

	# certificates
	ca="$product-ca.pem"
	caLocal="$ca" # CA to use for access to the local server
	caKey="$product-ca-key.pem"	
	certCli=$product-cli.pem
	certCliKey=$product-cli-key.pem
	certClient=$product-client.pem
	certClientKey=$product-client-key.pem
	certServer=$product-server.pem
	certServerKey=$product-server-key.pem

	# other variables
	certDirService="$(certDirService "$product")"
	certDirStore="/usr/local/share/ca-certificates"; IsPlatform rhel && certDirStore="/etc/pki/ca-trust/source/anchors"
	certStoreCa="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$ca").crt"

	# consul clients use an automatic CA
	unset caAuto certStoreCaAuto	
	if [[ "$product" == "consul" ]]; then
		caAuto="$product-ca-auto.pem"
		certStoreCaAuto="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$caAuto").crt"
		isClient && caLocal="$caAuto"
	fi

	return 0
}

# certPublicExists PRODUCT - return true if the public certificate directory for the specified product exists
certPublicExists() { quiet="--quiet" certPublicFind "$1" > /dev/null; }

# certPublicFind PRODUCT - find public certificates
certPublicFind()
{
	local dir product="$1"; certInit "$product" || return

	# check current directory (makeCertCd was called)
	quiet="--quiet" certPublicCheck "$PWD" && return

	# check public directory
	if dir="$(certDirPublicSuffix "$product")"; then
		certPublicCheck "$dir" && return
		ScriptErr "warning: '$(FileToDesc "$dir")' does not contain the public certificates"
	fi

	# fall back to the private certificate directory
	dir="$(certDirPrivateSuffix "$product")" && certPublicCheck "$dir"
}

certPublicCheck()
{
	local dir="$1"; [[ -d "$dir" ]] || return
	certValidate "$dir" "$ca" "$certCli" "$certCliKey" && echo "$dir"
}

certStoreInstall()
{
	hilight "Installing '$(GetFileName "$1")' into the operating system certificate store..."
	RunPlatform certStoreInstall "$1" "$2";
}

certStoreInstallMac()
{
	sudoc security add-trusted-cert -d -r trustRoot -k "/Library/Keychains/System.keychain" "$1"
}

certStoreInstallDebian()
{
	local src="$1" dest="$2"

	[[ ! -d "$(GetFilePath "$dest")" ]] && return
	[[ -f "$dest" && ! $force ]] && return
	
	sudoc cp "$src" "$dest" || return
	sudoc update-ca-certificates || return
}

certStoreInstallRhel()
{
	local src="$1" dest="$2"
	local destDir="$(GetFilePath "$dest")"

	# checks
	[[ ! -d "$destDir" ]] && { sudoc mkdir --parents "$destDir"; }
	[[ -f "$dest" && ! $force ]] && return
	
	# copy and update
	sudoc cp "$src" "$dest" || return
	sudoc update-ca-trust || return
}

certStoreInstallWin()
{
	local src="$1"
	local file="$(PlatformTmp)/$(GetFileName "$src")"
	cp "$src" "$file" || return
	if CanElevate; then
		RunScript --elevate "${globalArgs[@]}" -- certutil.exe -addstore -f root "$(utw "$file")" || return
	else
		certutil.exe -addstore -f NoRoot "$(utw "$file")" || return
	fi	
	rm "$file" || return
}

# certValidate DIR FILES - show an error if a certificate does not exist in the directory
certValidate()
{
	local file dir="$PWD"; [[ -d "$1" ]] && { dir="$1"; shift; }

	for file in "$@"; do 
		if [[ ! -f "$dir/$file" ]]; then
			[[ ! $quiet ]] && EchoErr "$(ProperCase "$product") certificate $file does not exist in '$(FileToDesc "$dir")'"
			return 1
		fi
	done

	return 0
}

#
# credential helper
#

credDelete() { RunLog credential rm "$(credPath)" "$@" "${globalArgsLessVerbose[@]}"; }
credExists() { test="" RunLog credential exists "$(credPath)" "$@" "${globalArgsLessVerbose[@]}"; }
credGet() { test="" RunLog credential get "$(credPath)" "$@" "${globalArgsLessVerbose[@]}"; }

credPath()
{
	local path="$(configGet "credentialPath")"; checkProduct "credPath" || return

	if [[ "$path" ]]; then
		echo "$(RemoveTrailingSlash "$path")/$product"
	else
		echo "/hashi/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
	fi
}

# credSet KEY VALUE
credSet()
{
	log1 "Setting $(credPath) $1 credential to $2..."
	RunLog credential set "$(credPath)" "$@" "${globalArgs[@]}" || return
}

#
# host helper
#

# hostCheck HOST - validate the host argument is set and the host is available
hostCheck()
{
	local host="$1"
	[[ ! $host ]] && { MissingOperand "host"; return; }
	! IsAvailable "$host" $timeout && { [[ ! $quiet ]] && EchoErr "$host is not available"; return 1; }
	return 0
}

hostCleanup()
{
	local host="$1"; hostCheck "$host" || return 0

	scriptRun "$host" "$(cat <<-EOF
			printf "cleaning..."
			[[ \$(find "$TEMP" -maxdepth 1 -name "hashi.*") ]] && printf "." && sudoc rm -fr "$TEMP/hashi."*
			[[ -d "$TEMP/consul-test" ]] && printf "." && rmdir "$TEMP/consul-test"
			printf "." && rm -f "$TEMP/hashi.service."*
			echo "done"
			EOF
	)"
}

# hostFileExists HOST FILE - return true if the file exists on the host
hostFileExists()
{
	local host="$1" file="$2"
	scriptRun "$host" "[[ -f \"$file\" ]]"
}

# hostFqdn HOST - get and validate the host fully qualified DNS name
hostFqdn()
{
	local host="$1"

	hostCheck "$host" || return
	HasDnsSuffix "$host" && { ScriptErr "host '$host' should not have a DNS suffix"; return 1; }

	local fqdn expectedFqdn="$host.$domain"

	fqdn="$(DnsResolve "$host" "${globalArgs[@]}")" || return; [[ "$fqdn" != "$expectedFqdn" ]] && { ScriptErr "host '$host' fully qualified DNS name is '$fqdn' but '$expectedFqdn' was expected"; return 1; }

	echo "$expectedFqdn"
}

# hostJoinInit [HOST...] - set join and joinFqdn to the passed (or default) join servers
hostJoinInit()
{
	local var="servers"; [[ "$product" == "vault" ]] && var="VaultServers"
	join=("$@"); [[ ! $join ]] && configGetArray "$var" "join"
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(hostFqdn "$h")" ); done
}

#
# product helper
#

productTokenStatus() { local token="${1:-$(productVarGet "TOKEN")}"; [[ $token ]] && echo "true" || echo "${RED}false${RESET}"; }

# productEnvironment [PRODUCT] [HOST] - show the environment variables for the specified product
productEnvironment()
{
	local clear product="${1:-$product}" host="$2"; certInit "$product" || return
	local tokenVar="$(productVar "TOKEN")"

	# return - consul and nomad are not used at Sandia
	IsOnNetwork sandia && [[ "$product" == @(consul|nomad) ]] && { clear="true" productEnvironmentVars; return; }

	# variables - certificate
	local certDir; certDir="$(quiet="--quiet" certDirLocal "$product")"
	local encrypt; [[ -d "$certDir" ]] && encrypt="true"

	# variables - port, server, url
	local port server url="$(ConfigGetCurrent "${product}Url")"
	if [[ $url ]]; then
		port="$(GetUriPort "$url")"
		server="$(GetUriServer "$url")"
	else
		port="$(productGetPort "$product" "$(protocol)")"
		server="$(productGetServer "$product" "$host")" || return
		url="$(protocol)://$server:$port"
	fi

	# use the automatic certificate authority if connecting to a consul client
	if [[ "$product" == "consul" ]]; then

		# connecting to the local host
		if IsLocalHost "$server"; then
			[[ -f "$certDirService/$caAuto" ]] && ca="$caAuto" # only clients have the automatic certificate present
		elif [[ "$(typeCheck "$server")" == "client" ]]; then
			ca="$caAuto"
		fi

	fi

	# validate certificates
	certs && [[ ! $suppressErrors ]] && { certValidate "$certDir" "$ca" "$certCli" "$certCliKey" || return; }

	# arguments
	local args="-http-addr=$url"
	certs && args+=" -ca-file=$certDir/$ca -client-cert=$certDir/$certCli -client-key=$certDir/$certCliKey"

	# get the token if not already set, i.e. if cached value, if Nomad sets the VAULT_TOKEN use it, etc.
	local tokenVal="$(productVarGet "TOKEN")"
	if [[ $forceEnvironment || ! $tokenVal ]] && [[ ! $noToken ]]; then
		local exclude=(); [[ ! $VAULT_TOKEN ]] && exclude=( "--exclude-managers=vault" ) # prevent recursion	
		local quiet; [[ $suppressErrors ]] && quiet="--quiet"
		if ! tokenVal="$(credGet "token" $quiet "${exclude[@]}")"; then
			if [[ $suppressErrors ]]; then
				log1 "productEnvironment: unable to get the '$product' token, this error will be supressed"
			else
				ScriptErr "productEnvironment: unable to get the '$product' token"
				return 1
			fi
		fi
	fi

	productEnvironmentVars

	log2 "productEnvironment: product='$product' token='$(productTokenStatus "$tokenVal")' args='$args'"
	return 0
}

productEnvironmentVars()
{
	local unset=()

	# standard configuration
	if [[ ! $clear ]]; then
		cat <<-EOF
			export $(productVar "CONFIG")="$configPrefix"
			export $(productVar "DOMAIN")="$baseDomain"
			export $(productVar "SERVER")="$server"
			export $(productVar "ADDR")="$url"
			export $(productVar "ARGS")="$args"
		EOF
	else
		unset+=( $(productVar "CONFIG") $(productVar "DOMAIN") $(productVar "SERVER") $(productVar "ADDR") )
	fi

	# certificate configuration
	if [[ $clear ]]; then
		unset+=( $(productVar "CACERT") $(productVar "CLIENT_CERT") $(productVar "CLIENT_KEY") )
	elif certs; then
		cat <<-EOF
			export $(productVar "CACERT")="$certDir/$ca"
			export $(productVar "CLIENT_CERT")="$certDir/$certCli"
			export $(productVar "CLIENT_KEY")="$certDir/$certCliKey"
		EOF
	fi

	if [[ ! $clear && $tokenVal ]]; then
		echo "export $tokenVar=\"$tokenVal\""
	else
		unset+=( "$tokenVar" )
	fi

	[[ $unset ]] && echo "unset -v ${unset[@]}"

	return 0
}

# productGetPort PRODUCT http|https - get the primary port for the specified product
productGetPort()
{
	local product="$1" protocol="$2"
	declare -n port="${product}${protocol^}Port"
	echo "$port"
}

# productGetServer PRODUCT [HOST] - get the server for the product
productGetServer()
{
	local product="$1" host="$2"
	local server; server="$(productGetServerDo)" || return

	[[ ! $server ]] && { ScriptErr "unable to find a $product server for the '$configDesc' configuration"; return 1; }

	# return server - use 127.0.0.1 or the fully qualified DNS name (to match the certificate)
	if IsLocalHost "$server"; then echo "127.0.0.1"
	elif ! HasDnsSuffix "$server"; then DnsResolve $quiet "$server" "${globalArgs[@]}"
	else echo "$server"
	fi
}

productGetServerDo()
{
	# use the passed host
	[[ $host ]] && { echo "$host"; return; }

	# use the --api argument
	[[ $api ]] && { echo "$api"; return; }

	# use the <product>_SERVER environment variable if it is valid
	if [[ ! $force && $(productVarGet "SERVER") ]]; then
		server="$(productVarGet "SERVER")"
		DnsResolve "$server" --quiet "${globalArgs[@]}" >& /dev/null && { echo "$server"; return; }
	fi

	# use the vanity DNS name in the current network configuration
	server="$(ConfigGetCurrent "${product}Url" | GetUriServer)"
	[[ $server ]] && { echo "$server"; return; }

	# use the local host for the server if the product service is running
	if [[ "$product" != @(nomad) ]] && [[ -f "/etc/systemd/system/$product.service" ]] && IsProcessRunning "$product" && service running "$product"; then
		echo "127.0.0.1"; return
	fi
	
	# use DNS to resolve the service	
	if server="$(GetServer "$product" --quiet "${globalArgs[@]}")"; then
		echo $server; return
	fi
		
	# use consul to resolve the server for the product
	if [[ "$product" != "consul" ]] && server="$(quiet="--quiet" productResolve "$product")"; then
		echo $server; return
	fi

	# use the first host specified by the --host or --servers arguments
	if [[ $hostArg || $servers ]]; then
		local hosts; getHosts "${servers[@]}" || return
		echo "${hosts[0]}"; return
	fi

	# use the first server specified in bootstrap-config.sh
	echo "$(configServer)"
}

# productInit PRODUCT [HOST] - enable product for use  on host in this script
productInit()
{
	local product="$1" host="$2"; [[ ! $product ]] && { MissingOperand "product"; return; }
	log2 "productInit: initializing $product"
	productVerify "$product" && initConfig "$product" && certInit "$product" && ScriptEval productEnvironment "$product" "$host"
}

# productInstall PRODUCT HOST
productInstall()
{
	local product="$1" host="$2"

	# return if the product installation is not needed
	productInstallNeeded "$product" "$host" || return
	[[ ! $installNeeded ]] && return

	# install the product
	productInstallDo "$product" "$host"
}

# productInstallNeeded PRODUCT HOST - return true if the product install is needed on the host.
#   Exports installDir, installFile, and installNeeded
productInstallNeeded()
{
	local product="$1" host="$2"; hostCheck "$host" || return
	local fileExists currentVersion newVersion

	installNeeded="true"

	# location the installation directory
	installDir="$(findInstallFile "other/HashiCorp/$product")" || return

	# determine if the product is installed
	if IsLocalHost "$host"; then
		installFile="$(os executable find "$installDir" "${globalArgs[@]}")" || return
		[[ ! $force ]] && InPath "$product" && fileExists="true"
		what="$installFile"
	else
		[[ ! $force ]] && sshRun "$host" "[[ -f \"$binDir/$product\" ]]" && fileExists="true"
		what="$host"
	fi

	# check the versions
	if [[ ! $force && $fileExists ]]; then
		currentVersion="$(productVersion "$product")" || return
		newVersion="$(productVersion "$product" "$what")" || return
		[[ "$currentVersion" == "$newVersion" ]] && installNeeded=""
		log3 "productInstallNeeded: installNeeded=$installNeeded currentVersion=$currentVersion newVersion=$newVersion"
	fi

	return 0
}

# productInstallDo PRODUCT HOST - requires that productInstallNeeded is called first
productInstallDo()
{
	local product="$1" host="$2"
	
	hilight "Installing ${product^} on '$host' for the '$datacenter' datacenter..."

	# local install
	if IsLocalHost "$host"; then
		local user="root" group="root"
		IsPlatform mac && group="wheel"
		IsPlatform qnap && { user="admin"; group="administrators"; }
		sudoc ${G}install -o "$user" -g "$group" -m 755 -T "$installFile" "$TEMP/$product" || return
		sudoc mv "$TEMP/$product" "$binDir/$product" || return # macOS requires mv or new process killed
		return
	fi

	# determine the host architecture	
	printf "$host architecture..."
	local machine="$(sshRun "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm";;
		*) machine="amd64";; 
	esac
	printf "$machine..."

	# find the program
	local file="$(find "$installDir" -maxdepth 1 -type f  -name "$product*_linux_$machine" | ${G}sort --version-sort | ${G}tail --lines=-1)"
	[[ ! -f "$file" ]] && { echo; ScriptErr "unable to find the $product program"; return 1; };
	echo "$(GetFileName "$file")"

	# copy the program to the host
	scp "$file" "$host:/tmp/$product" || return

	# update the program on the host
	local productServiceFile="/etc/systemd/system/$product.service"

	scriptRun "$host" "$(cat <<-EOF
		[[ -f "$productServiceFile" ]] && { printf "stopping service..."; sudoc systemctl stop "$product" || exit; echo "done"; }
		sudoc cp "/tmp/$product" "$binDir" || exit
		[[ -f "$productServiceFile" ]] && { printf "starting service..."; sudoc systemctl start "$product" --no-block || exit; echo "done";  }
		exit 0
		EOF
	)" || return

}

# productInstallCerts PRODUCT - copies certificates locally for command line use, creates certDirLocal
productInstallCerts()
{
	local product="$1"; certInit "$product" || return
	local src; src="$(certPublicFind "$product")" || return
	local dest="$(certDirSuffix "$product" "/opt/hashi")" # always install certificates to /opt/hashi 

	[[ ! $force && -f "$dest/$ca" ]] && return	

	hilight "Installing ${product^} certificates..."
	sudoc ${G}mkdir --parents "$dest" || return

	# copy certificates - use a temp directory - sudo cannot access CryFS encrypted shares
	local tmpDir; tmpDir="$(tmpDirCreate)" || return
	RunLog cp "$src/$ca" "$src/$certCli" "$src/$certCliKey" "$tmpDir" || return
	[[ -f "$src/$caAuto" ]] && { RunLog cp "$src/$caAuto" "$tmpDir" || return; }
	RunLog sudoc cp "$tmpDir/"* "$dest" || return
		
	# install certificates into the certificate store
	certStoreInstall "$tmpDir/$ca" "$certStoreCa" || return
	[[ -f "$src/$caAuto" ]] && { certStoreInstall "$tmpDir/$caAuto" "$certStoreCaAuto" || return; }
	
	# cleanup
	rm -fr "$tmpDir" || return
}

productIsInstalled() { [[ $(FindInPath "${1:-$product}") ]]; }

# productResolve PRODUCT - resolve the host name for the specified product
productResolve()
{
	local product="$1"
	local name="$product"; [[ "$product" == "vault" ]] && name="active.vault"
	resolve "$name"
}

# productVar VAR - get the environment variable name
productVar()
{
	local var="${1^^}"
	local http; [[ "$product" == "consul" && "$var" == @(ADDR|TOKEN) ]] && http="HTTP_";
	echo "${product^^}_${http}${var}"; 
}

# productVarGet VAR - get a product variable from the environment
productVarGet()
{
	local var="$1"
	local -n v="$(productVar "$var")"
	echo "$v"
}

# productVarSet VAR VALUE - set a product environent variable 
productVarSet()
{
	local var="$1" value="$2"
	local -n v="$(productVar "$var")"
	v="$value"
}

# productVerify PRODUCT - return 1 and an error message if the product is not installed
productVerify() 
{
	local product="$1"; [[ ! $product ]] && { MissingOperand "product"; return; }
	productIsInstalled "$product" && return
	ScriptErrQuiet "$product is not installed"
}

# productVersion PRODUCT WHAT - show the versionof the specified product
productVersion()
{
	local product="$1" what="${2:-$HOSTNAME}" desc version

	# file
	if [[ -f "$what" ]]; then

		# use the standard download file format (PRODUCT_VERSION_PLATFORM_ARCHITECURE) if possible, since running Go programs on network shares from Windows can fail
		local file="$(GetFileName "$what")"
		[[ "$(GetWord "$file" 1 _)" == "$product" ]] && version="$(GetWord "$file" 2 _)" || version="$("$what" --version)" 
		desc="$(FileToDesc "$what")"

	# localhost
	elif IsLocalHost "$what"; then
		version="$($product --version | productVersionFilter)"
		desc="local"

	# host
	else
		version="$(sshRun "$what" -- "$product" --version | productVersionFilter)"
		desc="$what"
	fi
	log1 "$product version ($desc) is $version"

	echo "$version"
}

productVersionFilter() { head -1 | cut -d" " -f 2 | RemoveFront v; }
	
#
# helper
#

certs() { [[ $encrypt ]]; } # true if certificates are being used
checkProduct() { [[ $product ]] && return; ScriptErr "$1: product is not set"; return 1; }
doHashi() { hashi "$@" $force $test "${configFileArg[@]}" "${configPrefixArg[@]}" "${otherArgs[@]}" "${globalArgs[@]}"; }
isClient() { [[ "$type" == "client" ]]; }
isServer() { [[ "$type" == "server" ]]; }
nomadEligibilityCheck() {	nomad node status -json | jq '.[] | select((.Name | ascii_downcase) == "'"$(resolveHost "$1")"'").SchedulingEligibility' | RemoveQuotes; } # nomadEligibilityCheck HOST - returns eligible|ineligible
resolveHost() { DnsResolve "$1" "${globalArgs[@]}"| RemoveDnsSuffix | LowerCase; } # resolveHost HOST - resolve HOST to a lower case DNS name without the suffix
sshAgentCheck() { [[ $sshAgentChecked ]] && return; SshAgentConf --quiet "${globalArgs[@]}" && sshAgentChecked="true"; }
sshRun() { sshAgentCheck && RunLog ssh "$@"; }
sshRunInteractive() { sshAgentCheck && RunLog SshHelper "$1" --interactive "${globalArgs[@]}" -- "${@:2}"; }
protocol() { certs && echo "https" || echo "http"; }
whatArgGet() { ScriptOptGet "whatArg" "what" "$@"; StringToArray "${whatArg,,}" "," whatArg; }
whatCheck() { [[ ! $whatArg ]] && return 0; local w; for w in "$@"; do IsInArray "$w" whatArg && return; done; return 1; }
whatCheckConfig() { local c; for c in $configWhat; do whatCheck "$c" && return; done; return 1; }

# configFileValidate FILE - return true and the type of the file if thefile is a valid HashiCorp configuration file
configFileValidate()
{
	local type="$(GetFileExtension "$file")"
	[[ ! "$type" == @(hcl|json) ]] && { ScriptErr "Specified file /`$file/` is not a valid HashiCorp configuration file"; return 1; }
	echo "$type"
}

copyDirRemote()
{
	local dir="$1" host="$2"
	IsLocalHost "$host" && return
	hilight "Copying files to $host..."
	scp -r "$dir" "$host:/$dir"
}

copyFile()
{
	local file="$1" dest="$2"
	[[ -f "$dest/$file" && ! $force ]] && return	
	RunLog cp "$file" "$dest"
}

encryptOpt()
{
	case "$1" in
		-e|--encrypt|-e=*|--encrypt=*) ScriptOptGet --optional "encrypt" "$@" && ScriptCheckDir "$encrypt" || encrypt="true";;
		-ne|--no-encrypt) noEncrypt="--no-encrypt"; unset encrypt;;
		-fc|--force-cert) forceCert="--force-cert";;
		*) return 1;;
	esac
}

encryptCliOpt()
{
	encryptOpt "$@" && return
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		*) return 1;;
	esac
}

findInstallFile()
{
	i check || return # cache the installation directory
	FindInstallFile "$@" "${globalArgs[@]}"
}

# forAllHosts COMMAND [ARGS...] - run a command for all hosts.  If forAllHeader is set and there is more than one host display it as a header.
forAllHosts() { local host hosts; getHosts && ForAllHosts "$@"; }

# getDnsServer - get an available consul server for DNS queries on port 8600
getDnsServer()
{
	local server; server="$(productGetServer "consul")"
	[[ ! $server ]] && { ScriptErrQuiet "no consul server found"; return 1; }
	log1 "found consul consul server '$server'"
	! IsAvailablePort "$server" 8600 $timeout && { ScriptErrQuiet "consul server $server port 8600 is not available"; return 1; }
	echo "$server"
}

# getHosts [HOSTS] - set hosts array from different sources
getHosts() 
{
	(( $# > 1 )) && { hosts=( "${@}" ); return; }

	# use hostArg if specified
	local h="${hostArg:-$1}"

	# all servers from configuration with duplicates removed
	if [[ "${h,,}" == @(config) ]]; then
		configServers
	
	# ordered server from configuration, servers first, then clients
	elif [[ "${h,,}" == @(1|2|3|4|5|6|first|second|third|fourth|fifth|sixth) ]]; then
		local servers; configGetArray "servers"
		local clients; configGetArray "clients"
		local all=(); ArrayAppend all servers clients

		[[ "$h" == @(1|first) ]] && hosts=( "${all[0]}" )
		[[ "$h" == @(2|second) ]] && hosts=( "${all[1]}" )
		[[ "$h" == @(3|third) ]] && hosts=( "${all[2]}" )
		[[ "$h" == @(4|fourth) ]] && hosts=( "${all[3]}" )
		[[ "$h" == @(5|fifth) ]] && hosts=( "${all[4]}" )
		[[ "$h" == @(6|sixth) ]] && hosts=( "${all[5]}" )

	# servers from a configuration variable (clients, servers, VaultServers)
	elif [[ $(configGet "$h") ]]; then
		configGetArray "$h" hosts

	# comma separated lists of hosts
	else
		GetHosts "${h,,}" || return

	fi

	# validate
	[[ ! $hosts ]] && { MissingOperand "host"; return; }

	return 0
}

# initConfig [PRODUCT] - initialize configuration variables configPrefix (i.e. test) and configDesc (i.e. prod, test).
#   If configPrefix is empty, this is a production configuration with description prod.
initConfig()
{
	local product="$1"

	# set the configuration prefix from the environment variable if it has not been set
	! IsVar configPrefix && [[ $product ]] && { configPrefix="$(productVarGet "CONFIG")"; } 

	# set configuration prefix aliases
	[[ "${configPrefix,,}" == "prod" ]] && configPrefix=""

	# set configuration description
	configDesc="${configPrefix:-prod}"

	return 0
}

policyDownload()
{
	local url="$1"	
	local install; install="$(FindInstallFile other/HashiCorp/acl)" || return
	local dest="$install/$(GetFileName "$url")"

	[[ ! -f "$dest" ]] && { curl "$url" --silent --show-error --location --output "$dest" || return; }
	echo "$dest"
}

removeDir()
{
	local dir="$1"
	[[ ! $dir || ! -d "$dir" || "$(DirCount "$dir")" == 0 ]] && return
	echo "Deleting '$(FileToDesc "$dir")'..."
	RunLog sudoc DelDir --contents "$dir"
}

scriptCertStore()
{
	local dest="$1"

	cat <<-EOF
		if [[ -f "$dest/$ca" ]] && [[ ! -f "$certStoreCa" || "$force" ]]; then
		  echo "Installing CA certificate..."
		  sudoc cp "$dest/$ca" "$certStoreCa" || exit
		  sudoc update-ca-certificates || exit
		fi

		if [[ "$caAuto" && -f "$dest/$caAuto" ]] && [[ ! -f "$certStoreCaAuto" || "$force" ]]; then
		  echo "Installing automatic CA certificate..."
		  sudoc cp "$dest/$caAuto" "$certStoreCaAuto" || exit
		  sudoc update-ca-certificates || exit
		fi
	EOF
}

scriptCleanup() 
{
	cat <<-EOF
		printf "Cleaning up..."; rm -fr "$tmpDir"; echo done
	EOF
}	

# scriptRun "$host" SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local host="$1" script="$2" functions="$(FindInPath function.sh | GetFullPath)"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" "" || exit
		else
		  sudoc() { sudoc "\$@"; }		  
		fi

		$script
		EOF
	)"

	# logging
	if [[ $verbose ]]; then
		header "$(ScriptPrefix)Running Script on $host" >& /dev/stderr; 
		log1 "$@"
		HeaderDone >& /dev/stderr
		
	fi

	# run
	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# --hashi - use HashiCorp Vault credentials if possible
		# --pseudo-terminal - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		# --x-forwarding - enable X11 forwardining for credential store access
		sshAgentCheck && SshHelper connect --hashi --pseudo-terminal --x-forwarding "${globalArgs[@]}" "$host" -- "$script"
	fi
}

# serviceDnsName NAME - append the full Consul service DNS name to name, i.e. NAME -> NAME.service.butare.net
serviceDnsName() { echo "$1.$(configGet "DnsDomain").$domain"; }

# serviceDnsNameShort NAME - append the short Consul service DNS name to name (without the datacenter), i.e. NAME -> NAME.service.butare.net
serviceDnsNameShort() { echo "$1.$(configGet "DnsDomain").$baseDomain"; }

# tmpDirCreate - create a temporary directory in /tmp (a location in common for src and dest host)
tmpDirCreate()
{	
	local dir; dir="$(${G}mktemp --directory "/tmp/hashi.XXXXXXXXXX")" || return
	(( verboseLevel > 2 )) && ScriptMessage "using temporary directory $(FileToDesc "$dir")"
	echo "$dir"
}

# typeCheck HOST
typeCheck()
{
	local host="$1" type="client"

	# resolve IP address to a hostname
	IsIpAddress "$host" && { host="$(DnsResolve "$host" "${globalArgs[@]}")" || return; }

	# check the HOSTNAME for the local host
	IsLocalHost "$host" && host="$HOSTNAME"

	# remove the DNS suffix from the hostname
	host="$(RemoveDnsSuffix "$1")" 

	# --assume-server was specified
	if [[ $assumeServer ]]; then
		type="server"

	# host is in the --servers argument
	elif IsArray servers && IsInArray "$host" servers; then
		type="server"

	# host is in the servers configuration
	else
		local servers; ! IsArray servers && configGetArray "servers"
		IsInArray "$host" servers && type="server"

	fi

	log1 "$host type is a $type"
	echo "$type"
}

ScriptRun "$@"
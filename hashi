#!/usr/bin/env bash
. script.sh || exit
. bootstrap-config.sh || exit

run() {	init && args "$@" && initFinal && "${command}Command" "${args[@]}"; }

usage()
{
	ScriptUsage "$1" "\
Usage: hashi [OPTION]... [COMMAND]...
Helper commands for HashiCorp consul, nomad, and vault products.

Common commands:
	cleanup|install|remove|update
	cert							create certificates
	config						configure all products
	lookup|resolve		lookup or resolve a service
	PRODUCT|all				commands for a product or all products
	status						show status for all products
	ui								start the hashi-ui server and launch it

Common options:
	-f, --force				force the operation
	-H, --host HOST		host for the command
	-t, --test				do not make changes
	-v, --verbose			show additional status"
}

args()
{
	unset force hostArg test verbose

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-f|--force) force="--force";;
			-h|--help) usage 0;;
			-H|--host|-H*|--host=*) ScriptArg hostArg host "$@";;
			-t|--test) test="--test";;
			-v|--verbose) verbose="true";;
			*) ScriptOption "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	[[ $@ ]] && usage

	return 0
}

#
# configuration
#

init()
{
	products=( consul vault nomad )
	productUsage="consul|nomad|vault"
	datacenter="$workgroup"
	binDir="/usr/local/bin"

	# ports
	consulHttpPort="8500" consulHttpsPort="8501"
	declare -g {nomadHttpPort,nomadHttpsPort}="4646"
	declare -g {vaultHttpPort,vaultHttpsPort}="8200"
}

initFinal()
{
	# if the command is a product command then initialize
	if IsInArray "${commandNames[0]}" products; then
		product="${commandNames[0]}"
		productConfig "$product" || return
	fi
		
	return 0
}

#
# Commands
#

cleanupCommand()
{
	local hosts; getHosts "localhost" || return

	for host in "${hosts[@]}"; do
		header "Cleanup ($host)"
		hostCleanup "$host" || return
	done
}

statusCommand()
{
	local product

	{
		hilight "product-ui-token"
		for product in "${products[@]}"; do

			! productIsInstalled "$product" && continue

			local http="$(httpVar "$product")";
			local -n addr="${product^^}_${http}ADDR"
			local -n token="${product^^}_${http}TOKEN"; [[ $token ]] && token="true" || token="false"

			echo "$product-${addr}-$token"
		done
	} | column -c $(tput cols) -t -s- -n
}

uiCommand()
{
	local product

	productInit "consul" || return
	certInit "$product" || return	
	export CONSUL_ENABLE="true"
	export CONSUL_ADDR="$(productGetUrl "$product")"
	export CONSUL_ACL_TOKEN="$(credGet token)"
	export CONSUL_HTTP_SSL="true"
	export CONSUL_CACERT="$(certGetCa "$product")"
	export CONSUL_CLIENT_CERT="$cert/$certCli"
	export CONSUL_CLIENT_KEY="$cert/$certCliKey"

	productInit "nomad" || return
	certInit "$product" || return
	export NOMAD_ENABLE="true"
	export NOMAD_ADDR="$(productGetUrl "$product")"
	export NOMAD_ACL_TOKEN="$(credGet token)"
	export NOMAD_HTTP_SSL="true"
	export NOMAD_CACERT="$(certGetCa "$product")"
	export NOMAD_CLIENT_CERT="$cert/$certCli"
	export NOMAD_CLIENT_KEY="$cert/$certCliKey"

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# Certificate Commands
#

certVars() { unset encrypt; }

certUsage() { echot "\
Usage: hashi cert all|consul|nomad
Create certificates required for HashiCorp products.

	-e, --encrypt DIR			directory for PKI certificates"; }

certOption()
{
	case "$1" in "") : ;;
		-e|--encrypt|-e*|--encrypt=*) ScriptArg "encrypt" "$@"; ScriptCheckDir "$encrypt";;
		*) return 1;;
	esac

	[[ ! $encrypt ]] && MissingOption "encrypt"
}

certCommand() { usage; }
certAllCommand() { certMake "consul" && certMake "nomad"; }
certNomadCommand() { certMake "nomad"; }

certUsage() { echot "\
Usage: hashi cert consul client|server|
Create certificates required for HashiCorp products.

	-e, --encrypt DIR			directory for PKI certificates"; }

certConsulCommand() { certMake "consul"; }

certExist() { [[ -f "$certDir/$1" && -f "$certDir/$2" ]]; }

certInit()
{
	local product="$1"; [[ "$product" == "vault" ]] && product="consul" # vault uses consul certificates

	# certDir - the source certificate directory including private certificates
	if [[ $encrypt ]]; then
		certDir="$encrypt/$product"	
		[[ ! -d "$certDir" ]] && { mkdir "$certDir" || return; }
	fi

	cert="/opt/$product/cert" 		
	ca="$product-ca.pem"
	caAuto="$product-ca-auto.pem"
	caKey="$product-ca-key.pem"
	certCli=$product-cli.pem
	certCliKey=$product-cli-key.pem
	certClient=$product-client.pem
	certClientKey=$product-client-key.pem
	certServer=$product-server.pem
	certServerKey=$product-server-key.pem

	certStore="/usr/local/share/ca-certificates"
	certStoreCa="$certStore/$(GetFileNameWithoutExtension "$caAuto").crt"
}

certCheck()
{
	local product="$1" cert; shift

	for cert in "$@"; do
		[[ ! -f "$cert" ]] && { EchoErr "$(ProperCase "$product") certificate $(GetFileName "$cert") does not exist"; return 1; }
	done

	return 0
}

certGetCa()
{
	local product="$1"

	if [[ -f "$cert/$caAuto" && "$product" == "consul" ]] ; then
		echo "$cert/$caAuto"
	else
		echo "$cert/$ca"
	fi
}

certMake()
{
	local product="$1"
	certInit "$product" || return
	RunFunction "cert$(ProperCase $product)Make"
}

certClientCopy()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$ca" "$certDir/$certClient" "$certDir/$certClientKey" "$tmpDir/cert" || return
}

certServerCopy()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$ca" "$certDir/$certServer" "$certDir/$certServerKey" "$tmpDir/cert" || return
}

# Make Consul certificates

certConsulMake()
{
	# certificates are created using consul
	! InPath "consul" && { inst "consul" || return; }

	pushd "$certDir" > /dev/null || return

	# create the CA and CLI certificates
	certConsulCaMake || return
	certConsulCliMake || return

	popd > /dev/null || return
}

certConsulCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the certificate authority for $baseDomain..."

	# create the cert
	consul tls ca create \
		-domain="$baseDomain" \
		-name-constraint || return # name constraint required for HTTPS GUI

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

certConsulCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

# certConsulGetAutoCa - get the auto generated Consul certficate authority.   This CA
# is used on Consul clients and is needed on the Consul client to access the Consul API
# from other programs like Nomad, curl, or wget.
certConsulGetAutoCa()
{
	local f="$certDir/$caAuto"
	[[ -f "$f" ]] && return

	! InPath "consul-k8s" && { inst "consul-k8s" || return; }

	consul-k8s get-consul-client-ca \
		--server-addr "$(productGetServer "consul")" \
		--server-port "$consulHttpsPort" \
		--ca-file="$certDir/$ca" \
		--output-file "$f" || return
}

certConsulServerMake()
{
	local cert="$1" key="$2" host="$3"

	certExist "$cert" "$key" && return

	hilight "Creating the $host server certificate..."

	# move to the certificate directory
	pushd "$certDir" >& /dev/null || return

	# remove any existing temporary certs
	rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

	# create the cert
	consul tls cert create -server \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-additional-ipaddress="$(GetIpAddress "$host")" \
		-additional-dnsname="$(os name "$host")" \
		-node="$host" || return

	# rename the temporary cert
	mv "$datacenter-server-$baseDomain-0.pem" "$cert" || return
	mv "$datacenter-server-$baseDomain-0-key.pem" "$key" || return

	popd >& /dev/null || return
}

# Make Nomad certificates

certNomadMake()
{
	# certificates are created using cfssl
	! InPath "cfssl" && { inst "cfssl" || return; }

	pushd "$certDir" >& /dev/null || return

	# create the CA and CLI certificates
	certNomadCaMake || return
	certNomadServerMake || return
	certNomadClientMake || return
	certNomadCliMake || return

	popd >& /dev/null || return
}

certNomadCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the Nomad certificate authority..."
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca || return
}

certNomadCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the Nomad CLI certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-cli
}

certNomadClientMake()
{
	certExist "$certClient" "$certClientKey" && return

	hilight "Creating the Nomad client certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-client || return
}

certNomadServerMake()
{
	certExist "$certServer" "$certServerKey" && return

	hilight "Creating the Nomad server certificate..."

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > cfssl.json || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(DelimitArray "," joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -config=cfssl.json -hostname="$hosts" - | \
		cfssljson -bare nomad-server || return
}

#
# Install Command
#

installVars() { clients=() servers=() join=() encrypt="" force=""; }

installUsage() { echot "\
Usage: hashi install cli|$productUsage
Install a HashiCorp product.  If no hosts are specified use the hosts specified
in bootstrap-config.sh.

	-c, --clients	HOSTS		comma separated list of clients to install
	-s, --server HOSTS		comma separated list of servers to install
	-j, --join HOSTS			comma separated list of hosts to join to, defaults to servers
	-e, --encrypt DIR			directory for PKI certificates, if specified TLS will be enabled
	-w, --what=C1[,C2...] components to install
													components: acl cert program service
													Nomad: VaultIntegration
													Vault: seals"; }

installOption()
{
	case "$1" in "") : ;;
		-c|--clients|-c*|--clients=*) ScriptArg "clients" "$@"; StringToArray "$clients" "," clients;;
		-s|--servers|-s*|--servers=*) ScriptArg "servers" "$@"; StringToArray "$1" "," servers;;
		-j|--join|-j*|--join=*) ScriptArg "join" "$@"; StringToArray "$1" "," join;;
		-e|--encrypt|-e*|--encrypt=*) ScriptArg "encrypt" "$@"; ScriptCheckDir "$encrypt";;
		-w|--what|-w*|--what=*) ScriptArg "what" "$@"; StringToArray "${what,,}" "," what;;
		*) return 1;;
	esac
}

installCommand() { usage; }

installInit()
{
	local product="$1"

	# ensure the CLI program exists locally
	! InPath "$product" && { inst "$product" || return; }

	# general
	tmpDirTemplate="hashi.XXXXXXXXXX"
	program="$(FindInPath "$product")" || return
	user="$product"
	commonOptions=( [log_level]="Info" )

	# add clients and servers from hostArg
	local host hosts=(); StringToArray "$hostArg" "," hosts; 
	for host in "${hosts[@]}"; do
			IsInArray "$host" hashiServers && servers+=( "$host" ) || clients+=( "$host" )
	done
	unset hostArg

	# set clients and servers defaults
	if [[ ! $clients && ! $servers ]]; then
		if [[ "$product" == "vault" ]]; then
			servers=( "${vaultServers[@]}" ) 
		else
			clients=( "${hashiClients[@]}" ) 
			servers=( "${hashiServers[@]}" )
		fi
	fi

	# join servers	
	[[ ! $join ]] && join=( "${hashiServers[@]}" )
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(os name "$h")" ); done

	if [[ $verbose ]]; then
		printf "clients: "; ShowArray clients
		printf "servers: "; ShowArray servers
		printf "join: "; ShowArray join
	fi
	
	return 0
}

#
# Install CLI COmmand
#

installCliUsage() {	echot "\
Usage: hashi install cli all|$productUsage
Install a HashiCorp product for command line access."; }

installCliCommand() { installCliAllCommand; }
installCliConsulCommand() { installCli "consul"; }
installCliNomadCommand() { installCli "nomad"; }
installCliVaultCommand() { installCli "vault"; }

installCliAllCommand()
{
	local product

	for product in "${products[@]}"; do
		installCliDo "$product" || return
	done
}

installCliDo() 
{ 
	[[ $hostArg || $servers || $clients ]] && { EchoErr "CLI can only be installed locally"; return 1; }
	installCli "$@" || return
}

installCli() { productInstall "$1" "localhost" && productInstallCert "$1"; }

#
# Install Consul Command
#

installConsulCommand()
{ 
	installCommon || return

	# configuration
	local -A options serverOptions guiOptions 
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	options=(
		[domain]="$baseDomain"
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[client_addr]="0.0.0.0"
		[bind_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[retry_join]="[ $(ShowArray join ", ") ]"
		[acl]="$(cat <<-EOF
			{ 
			  enabled = true
			  default_policy = "allow"
			  enable_token_persistence=true
			}
			EOF
		)"
	)

	serverOptions=(
		[server]="true"
		[bootstrap_expect]="${#join[@]}"
		[advertise_addr]='{{ GetInterfaceIP \"eth0\" }}'
	)

	commonEncryptOptions=(
		[addresses]='{ https = "0.0.0.0" }'
		[ports]="{ http = -1, https = $consulHttpsPort }"
		[verify_incoming]="false"
		[verify_incoming_rpc]="true"
		[verify_outgoing]="true"
		[verify_server_hostname]="true"
	)

	clientEncryptOptions=(
		[ca_file]="$cert/$ca"
		[auto_encrypt]="{ tls = true }"
	)

	serverEncryptOptions=(
		[ca_file]="$cert/$ca"
		[cert_file]="$cert/$certServer"
		[key_file]="$cert/$certServerKey"
		[auto_encrypt]="{ allow_tls = true }"
	)

	guiOptions=( [ui]="true" )

	# install
	installDo || return
}

installConsulCommon()
{
	# service
	local cliArgs="$(cat <<-EOF
		-http-addr="https://127.0.0.1:$consulHttpsPort" \
		-ca-file="$cert/$ca" \
		-client-cert="$cert/$certCli" \
		-client-key="$cert/$certCliKey"
	EOF
	)"

	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$program agent -config-dir=$config"
	execReload="$program reload $cliArgs"
	execStop="$program leave $cliArgs"
}

installConsulClient() { installConsulAutoCa; }

installConsulServer() 
{ 
	installConsulCertServer || return
	AppendArray o serverOptions guiOptions
}

installConsulAutoCa()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$caAuto" "$tmpDir/cert" || return	
}

installConsulCertServer()
{	
	[[ ! $encrypt ]] && return

	local cert="consul-server-$host.pem"
	local key="consul-server-$host-key.pem"

	certConsulServerMake "$cert" "$key" "$host" || return

	cp "$certDir/$cert" "$tmpDir/cert/$certServer" || return
	cp "$certDir/$key" "$tmpDir/cert/$certServerKey" || return
}

installConsulServerFinal()
{
	if [[ $encrypt && ! -f "$certDir/$certClient" ]] && installComponentCheck "cert"; then
		header "Automatic Certificate"
		certConsulGetAutoCa || return
	fi

	installAcl || return
}

#
# Install Nomad Command
#

installNomadCommand()
{
	installCommon || return

	# configuration
	local -A options clientOptions serverOptions guiOptions
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 
	local token; token="$(productGetToken "consul")" || return
	local port; port="$(productGetPort "consul")" || return

	options=( 
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[acl]="{ enabled = true }"
		[consul]="{
	token = \"$token\"
	address = \"127.0.0.1:$port\"
}"
	)

	serverOptions=(
		[server]="{
	enabled = true
	bootstrap_expect = "${#join[@]}"
}"
	)

	commonEncryptOptions=()

	clientOptions=(
		[client]="{
	enabled = true 
}"
	)

	clientEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certClient\"
	key_file = \"$cert/$certClientKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	serverEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certServer\"
	key_file = \"$cert/$certServerKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	# install
	installDo || return
}

installNomadCommon()
{ 
	[[ ! $encrypt ]] && return
	certInit "consul" || return # nomad uses consul certificates
	
	# create the service environment file
	cat > "$tmpDir/$product.env" <<-EOF
		CONSUL_HTTP_SSL=true
		CONSUL_CACERT=$(certGetCa "consul")
		CONSUL_CLIENT_CERT=$cert/$certServer
		CONSUL_CLIENT_KEY=$cert/$certServerKey
	EOF

	# return to the nomad certificate configuration
	certInit "nomad" || return
}

installNomadClient()
{
	certClientCopy || return
	AppendArray o clientOptions
}

installNomadServer()
{
	certServerCopy || return
	AppendArray o serverOptions clientOptions
}

installNomadServerFinal() { installAcl; }
installNomadFinal() { initNomadVaultIntegration; }

initNomadVaultIntegration()
{
	! installComponentCheck "vaultintegration" && return	
	! InPath vault && { echo "Vault is not installed, skipping nomad vault integration"; return; }

	productConfig "vault" || return

	local tmpDir="$(tmpDirCreate)" || return
	pushd "$tmpDir" >& /dev/null || return

	# add the nomad-cluster policy to Vault
	if ! vault policy list | grep -q "^nomad-server$"; then
		hilight "Adding the nomad-cluster policy to Vault..."
		curl https://nomadproject.io/data/vault/nomad-server-policy.hcl -O -s -L || return
		vault policy write nomad-server nomad-server-policy.hcl || return
	fi

	# add the nomad-cluster role to Vault
	if ! vault list "/auth/token/roles" |& grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster role to Vault..."
		curl https://nomadproject.io/data/vault/nomad-cluster-role.json -O -s -L || return
		vault write /auth/token/roles/nomad-cluster @nomad-cluster-role.json || return
	fi

	popd >& /dev/null || return
	
	# grant the nomad-cluster role permission to required secrets
	if ! vault policy list | grep -q "^nomad-cluster$"; then
		hilight "Granting the nomad-cluster role permission in Vault..."
		cat | vault policy write nomad-cluster - <<-EOF
			path "secret/*" {
			  capabilities = ["read"]
			}
		EOF
	fi

	# create a token for nomad to access vault
	local token="$(vault token create -policy nomad-server -orphan -format=json | jq '.auth.client_token' | RemoveQuotes)" || return

	# add vault integration configuration to nomad
	local file="$tmpDir/02_vault.hcl"

	certInit "consul" || return

	cat > "$file" <<-EOF
		vault {
		  enabled          = true
		  ca_file          = "$cert/$ca"
		  cert_file        = "$cert/$certCli"
		  key_file         = "$cert/$certCliKey"
		  address          = "https://127.0.0.1:$vaultHttpsPort"
		  create_from_role = "nomad-cluster"
		  token            = "$token"
		}
	EOF

	if [[ $test ]]; then
		header "$(ProperCase "$product") Configuration ($(GetFileName "$file"))"
		cat "$file" || return
	fi

	# copy the vault configuration files
	for host in "${servers[@]}" "${clients[@]}"; do
		hostCopy "$file" "$config" || return
	done

	# install vault client for nomad jobs
	for host in "${servers[@]}" "${clients[@]}"; do
		productInstall "vault" "$host" || return
	done

	# cleanup
	rm -fr rm -fr "$tmpDir"

	return 0
}

#
# Install Vault Command
#

installVaultCommand()
{
	installCommon || return

	# configuration
	local -A options clientOptions serverOptions guiOptions
	local token; token="$(productGetToken "consul")" || return
	local port; port="$(productGetPort "consul")" || return

	# configuration
	options=(
		[listener]="\"tcp\" $(cat <<-EOF
			{ 
			  address = "0.0.0.0:$vaultHttpsPort"
			  tls_cert_file = "$cert/$certServer"
			  tls_key_file = "$cert/$certServerKey"
			}
			EOF
		)"

		[storage]="\"consul\" $(cat <<-EOF
			{
				token = "$token"
			  path = "vault/"
			  address = "127.0.0.1:$port"
			  scheme = "https"
			  tls_ca_file = "$cert/$ca"
			  tls_cert_file = "$cert/$certCli"
			  tls_key_file = "$cert/$certCliKey"
			}
			EOF
		)"

		[service_registration]="\"consul\" $(cat <<-EOF
				{
					token = "$token"
				  address="127.0.0.1:$port"
				  scheme="https"
				  tls_ca_file = "$cert/$ca"
				  tls_cert_file = "$cert/$certCli"
				  tls_key_file = "$cert/$certCliKey"
				}
			EOF
		)"
	)

	guiOptions=( [ui]="true" )

	# install
	installDo || return
}

installVaultCommon()
{
	# options
	o[api_addr]="https://$hostFqdn:$vaultHttpsPort"

	# service
	execStart="$program server -config=$config"
	serviceLimit+=$'\n'"LimitMEMLOCK=infinity"

	# script
	scriptFinal="$(cat <<-EOF
		echo "Configuring vault..."

		# allow memory locking without elevation (so don't need to run as root)
		sudo setcap cap_ipc_lock=+ep "$program" || return
		EOF
	)"
}

installVaultServer() { AppendArray o guiOptions; }

installVaultServerFinal()
{
	installVaultAcl || return; 

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | grep -q "^secret"; then
		header "Vault Configuration"
		vault secrets enable -path=secret kv-v2 || return
	fi

	return 0
}

installVaultAcl()
{
	! installComponentCheck "acl" && return
	header "Install Vault ACL"
	
	local product="vault"; productConfig "$product" || return

	# generate the unseal keys
	local n key result s seals; seals="$(vault operator init 2>&1)"; result="$?"
	echo "$seals" | grep -q "Vault is already initialized" && return
	(( result != 0 )) && { EchoErr "$seals"; return 1; }

	# show the seal keys
	hilight "Store the following vault unseal keys in a secure location:"
	echo "$seals"

	# store the root token
	declare token; token="$(echo "$seals" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credSet "token" "$token" || return
	export VAULT_TOKEN="$token"

	# store the seal keys
	IFS=$'\n' seals=( $(echo "$seals" | grep "Unseal Key") )
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credSet "key$n" "$key" || return
	done

	# unseal the vault
	vaultUnsealCommand || return
}

#
# Lookup Command
#

lookupVars() { name=""; }

lookupUsage() { echot "Usage: hashi lookup NAME
Lookup all information about consul service using nslookup.
.service.<domain> is appended to the specified name."; }

lookupArgs() { ScriptGetArg "name" "$1"; shift; }

lookupCommand()
{
	local addr="$(productGetServer "consul")"
	name+=".service.$domain"
	productInit "consul" || return
	[[ $verbose ]] && HilightErr "Using Consul server at $addr"
	! IsAvailablePort "$addr" 8600 && { EchoErr "$name port 8600 is not available"; return 1; }
	nslookup -port=8600 -type=a -norecurse "$name" "$addr"
}

#
# Remove Command
#

removeVars() { program=""; }

removeUsage() { echot "\
Usage: $(ScriptName) remove all|$productUsage
Remove a HashiCorp product configuration and data.

	-p, --program		also remove the HashiCorp program"; }

removeOption()
{
	case "$1" in "") : ;;
		-p|--program) program="true";;
		*) return 1;;
	esac
}

removeCommand() { usage; }
removeAllCommand() { removeDo "vault" && removeDo "nomad" && removeDo "consul"; }
removeConsulCommand() { removeDo "consul"; }
removeNomadCommand() { removeDo "nomad"; }
removeVaultCommand() { removeDo "vault"; }

removeDo()
{
	local product="$1" host hosts; getHosts || return

	for host in "${hosts[@]}"; do
		header "Remove $(ProperCase "$product") ($host)"
		productRemove "$product" "$host" || return
	done
}

#
# Resolve Command
#

resolveVars() { all=""; name=""; }

resolveUsage() { echot "Usage: hashi resolve [-a|all] NAME[.service]
Resolve a service in consul to an IP address or canonical name.
If all is not specified the first IP address is returned.
.service.<domain> is appended to the specified name."; }

resolveOption()
{
	case "$1" in "") : ;;
		-a|--all) all="true";;
		*) return 1;;
	esac
}

resolveArgs() { ScriptGetArg "name" "$1"; shift; }

resolveCommand()
{
	local filter="head -1"; [[ $all ]] && { filter="cat"; }

	local result; result="$(lookupCommand)" || return

	if [[ "$result" =~ .*canonical\ name.* ]]; then
		printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//' | $filter
	else
		printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace | $filter
	fi

	return "${PIPESTATUS[0]}"
}

#
# Update Command
#

updateUsage() { echot "usage: $(ScriptName) program all|$productUsage"; }
updateCommand() { usage; }
updateAllCommand() { updateDo "vault" && updateDo "nomad" && updateDo "consul"; }
updateConsulCommand() { updateDo "consul"; }
updateNomadCommand() { updateDo "nomad"; }
updateVaultCommand() { updateDo "vault"; }

updateDo()
{
	local product="$1" host hosts; getHosts "${hashiServers[@]}" "${hashiClients[@]}" || return
	
	for host in "${hosts[@]}"; do
		header "Update $(ProperCase "$product") ($host)"
		productInstall "$product" "$host" || return
	done
}

#
# Install Helper
#

installComponentCheck() { [[ ! $what ]] && return 0; IsInArray "$1" what; }

installCommon()
{
	declare -g certDir 
	declare -g product="${commandNames[1]}"; [[ ! $product ]] && usage
	declare -Ag commonOptions

	productInit "$product" || return
	certInit "$product" || return
	installInit "$product" || return
}
	
installDo()
{
	local result tmpDir="$(tmpDirCreate)" || return

	installCert || return
	installProgram || return
	installServiceServers || return
	installServerFinal || return
	installServiceClients || return
	installFinal || return

	# cleanup
	rm -fr "$tmpDir"
	ssh "$host" rm -fr "$tmpDir"

	return 0
}

installCert() 
{
	[[ $encrypt ]] && installComponentCheck "cert" && { certMake "$product" || return; }
	return 0
}

installProgram()
{
	! installComponentCheck "program" && return

	for host in "${servers[@]}" "${clients[@]}"; do
		productInstall "$product" "$host" || return
	done
}

installServiceServers()
{
	! installComponentCheck "service" && return

	for host in "${servers[@]}"; do
		installServiceHost "server" "$host" || return
	done
}

installServiceClients()
{
	! installComponentCheck "service" && return

	for host in "${clients[@]}"; do
		installServiceHost "client" "$host" || return
	done
}

installServiceHost()
{
	local type="$1" host="$2"
	local f hostFqdn scriptFinal
	local -A o
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local serviceLimit="LimitNOFILE=infinity"$'\n'"LimitNPROC=infinity"
	local execStart="$program agent -config=$config"
	local execReload="/bin/kill -HUP"
	local exectStop=""

	# host information
	hostFqdn="$(os name "$host")" || return
	host="$(RemoveDnsSuffix "$hostFqdn")"

	# header
	header "Install $(ProperCase "$product") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	DelDir --contents "$tmpDir" || return
	mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return		

	# copy certificates
	[[ $encrypt ]] && { FileCommand cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$tmpDir/cert" || return; }

	# service
	printf "" > "$tmpDir/$product.env"

	# options - other options added in installPRODUCTServer or installPRODUCTClient
	o=( ); AppendArray o commonOptions options

	[[ "$encrypt" ]] && IsDeclared commonEncryptOptions && AppendArray o commonEncryptOptions
	[[ "$encrypt" ]] && IsDeclared ${type}EncryptOptions && AppendArray o ${type}EncryptOptions

	RunFunction "install$(ProperCase "$product")Common"
	RunFunction "install$(ProperCase "$product")$(ProperCase "$type")" || return

	# create the configuration files
	installConfigHcl o > "$tmpDir/config/$configFileBase" || return
	installConfigService > "$tmpDir/$product.service" || return

	# copy the files to the remote host
	if ! IsLocalHost "$host"; then
		hilight "Copying files to $host..."
		scp -r "$tmpDir" "$host:/$tmpDir" || return
	fi

	# run the installation script - use only standard commands
	hilight "Running installation..."
	scriptRun "$(cat <<-EOF

		# user
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudo useradd -r -d "$config" -s "/bin/false" "$user" || exit
		fi

		# directories
		if ! [[ -d "$cert" && -d "$config" && -d "$data" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudo install -o "$user" -g "$user" -m 755 -d "$cert" "$config" "$data" || exit
		fi

		# files

		if [[ \$(sudo ls -A "$tmpDir/data") ]] && [[ ! \$(sudo ls -A "$data") || "$force" ]]; then
		  echo "Copying data files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$data" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/config") ]] && [[ ! -f "$config/$configFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$config" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/cert") ]] && [[ ! \$(sudo ls -A "$cert") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$cert" "$tmpDir/cert/"* || exit
		fi

		if [[ -f "$cert/$caAuto" ]] && [[ ! -f "$certStoreCa" || "$force" ]]; then
			echo "Installing automatic CA certificate..."
			sudo cp "$cert/$caAuto" "$certStoreCa" || exit
			sudo update-ca-certificates || return
		fi

		# service		

		if [[ -f "$serviceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudo systemctl stop "$product" || exit
		fi

		if [[ ! -f "$serviceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudo cp "$tmpDir/$product.service" "$tmpDir/$product.env" "/etc/systemd/system" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl enable "$product" || exit
			sudo systemctl start "$product" || exit
		fi

		$scriptFinal

		# cleanup
		echo "Cleaning up..."
		rm -fr "/tmp/$product.tmp"

		exit 0

		EOF
	)"

	if [[ $test ]]; then
		header "$(ProperCase "$product") Configuration ($(GetFileName "$configFileBase"))"
		cat "$tmpDir/config/$configFileBase" || return

		header "Service Configuration"
		cat "$tmpDir/$product.service" || return
	fi

	return 0
}

installServerFinal()
{	
	[[ ! $servers ]] && return
	RunFunction "install$(ProperCase "$product")ServerFinal"
}

installAcl()
{
	! installComponentCheck "acl" && return
	header "Install $(ProperCase "$product") ACL"

	installCli "$product" || return
	productConfig "$product" || return

	# generate the bootstrap token
	local token header
	local alreadyCreated="ACL bootstrap already done"; [[ "$product" == "consul" ]] && alreadyCreated="ACL bootstrap no longer allowed"
	local waitingForNodes="The ACL system is currently in legacy mode."
	
	for (( i = 0; i < 30; i++ )); do
		token="$($product acl bootstrap 2>&1)" && break
		echo "$token" | grep -q "$alreadyCreated" && return
		echo "$token" | grep -q "$waitingForNodes" &&
			{ [[ $header ]] && printf "." || printf "bootstrap..."; header="true"; sleep 1; continue; }
		EchoErr "$token"; return 1
	done
	[[ $header ]] && echo
	echo "$token" | grep -q "$waitingForNodes" && { EchoErr "$token"; return 1; }
	
	# show the full bootstrap text
	hilight "Store the following bootstrap token in a secure location:"
	echo "$token"

	# store the bootstrap token
	local secretId="Secret ID"; [[ "$product" == "consul" ]] && secretId="SecretID"
	local secret="$(echo "$token" | grep "SecretID" | cut -d: -f 2 | RemoveSpace)"
	[[ ! $secret ]] && { ScriptErr "unable to determine the bootstrap token"; return 1; }
	credSet "token" "$secret" || return

	return 0
}

# installConfigHcl - turn the passed array variables into an HCL script
installConfigHcl()
{
	local key var

	for var in "$@"; do
		local -n config="$var"

		for key in "${!config[@]}"; do

			local equal=" =" quote="true" v="${config[$key]}"
			local fc="${v:0:1}" sc="${v:1:1}" # first and second characters

			# example: addresses { https = "0.0.0.0" }
			[[ "$fc" == "{" && "$sc" != "{" ]] && quote="" equal=""

			# example: retry_join = [ "pi3", "pi4" ]
			[[ "$fc" == "[" ]] && quote=""

			# listener "tcp" { address = "0.0.0.0:8200", tls_disable = 1 }
			[[ "$fc" == "\"" ]] && quote="" equal=""

			# boolean, example: server = true			
			[[ "$v" == @(true|false) ]] && quote=""

			# integer, example: bootstrap_expect = 2
			IsInteger "$v" && quote=""

			[[ $quote ]] && echo "$key$equal \"${config[$key]}\"" || echo "$key$equal ${config[$key]}"

		done

	done
}

installConfigService()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$product")
		Documentation=https://www.hashicorp.com/products/$product
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$configFile
		StartLimitIntervalSec=10
		StartLimitBurst=3

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$serviceEnvFile
		KillMode=process
		KillSignal=SIGINT
		Restart=on-failure
		RestartSec=2
		TasksMax=infinity
		$serviceLimit

		[Install]
		WantedBy=multi-user.target
	EOF
}

installFinal()
{
	RunFunction "install$(ProperCase "$product")Final" || return
}

#
# All Commands
#

allUsage() { echot "\
Usage: hashi all config|status
Commands for all products."; }

allCommand() { usage; }

allConfigCommand()
{
	local product

	for product in "${products[@]}"; do
		! productIsInstalled "$product" && continue
		productConfigShow "$product" || return
		echo
	done
}

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# Config Commands
#

configUsage() { echot "\
Usage: hashi config [local|remote|show](show)
Configure all products

	local			set the local configuration
	remote		set the remote configuration
	show			show the confioguration"; }

configCommand() { allConfigCommand; }
configShowCommand() { allConfigCommand; }

configLocalCommand()
{
	# get vault token using SSH
	productConfig "vault" || return
	if [[ ! $VAULT_TOKEN || $force ]]; then
		local hosts; getHosts "${vaultServers[@]}"
		local host="${hosts[0]}"
		local token; token="$(ssh -q -t pi3 bash -i credential get vault token | RemoveCarriageReturn)" || return
		export VAULT_TOKEN="$token"
	fi

	# save tokens
	local product token

	for product in "${products[@]}"; do
		token="$(credGetV "token")" || return
		[[ ! $token ]] && continue
		credSet "token" "$token" || return
	done

	# save seals
	product="vault"
	for n in 1 2 3 4 5; do
		key="$(credGetV "key$n")" || return
		[[ ! $key ]] && continue
		credSet "key$n" "$key" || return
	done
}

configRemoteCommand()
{
	local product token

	# save tokens
	for product in "${products[@]}"; do
		token="$(credGet "token")" || return
		[[ ! $token ]] && continue
		credSetV "token" "$token" || return
	done

	# save seals
	product="vault"
	for n in 1 2 3 4 5; do
		key="$(credGet "key$n")" || return
		[[ ! $key ]] && continue
		credSetV "key$n" "$key" || return
	done
}

#
# Consul Commands
#

consulUsage() { echot "\
Usage: hashi consul config|status
Consul commands."; }

consulCommand() { usage; }
consulConfigCommand() { productConfigShow "consul"; }
consulStatusCommand() { consul members; }

#
# Nomad Commands
#

nomadUsage() { echot "\
Usage: hashi nomad config|job|status
Nomad commands."; }

nomadCommand() { usage; }
nomadConfigCommand() { productConfigShow "nomad"; }
nomadStatusCommand() { nomad node status; }

#
# Nomad Job Commands
#

nomadJobUsage() { echot "\
Usage: hashi nomad job NAME
Nomad job commands.

	force	NAME		force a periodic job to start
	log	NAME			show the log for a periodic job
	status [NAME]	status of all running jobs or the specified job"; }

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() {	nomadJobStatusCommand; }

# nomad job status 

nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | grep -v dead
	fi
}

# nomnd job force

nomadJobForceVars() { log=""; }

nomadJobForceUsage() { echot "\
Usage: hashi nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"; }

nomadJobForceOption() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogVars() { follow=""; }

nomadJobLogUsage() { echot "\
Usage: hashi nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"; }

nomadJobLogOption() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId"
		header "Standard Error"; nomad alloc logs -stderr "$allocId"
	fi		
}

# nomad helper

nomadGetJobId()
{ 
	jobId="$(nomad job status "$job" |& tail -1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job \`$job\`"; exit 1
}

nomadGetAllocId()
{
	[[ ! $jobId ]] && { nomadGetJobId || return; }
	allocId="$(nomad job status "$jobId" |& tail -1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job \`$job\`"; exit 1
}

#
# Vault Commands
#

vaultUsage() { echot "\
Usage: hashi vault config|status|unseal
Vault commands.

	unseal			unseal the vault using keys from the credential store"; }

vaultCommand() { usage; }
vaultConfigCommand() { productConfigShow "vault"; }
vaultSealCommand() { vault operator seal; }

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	echo "Active Node            $(hashi resolve active.vault)"
	echo "Standby Node           $(hashi resolve standby.vault)"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac

}

vaultUnsealCommand()
{
	local host hosts key; getHosts "${vaultServers[@]}" || return

	# unseal each host
	for host in "${hosts[@]}"; do
		header "$host"
		eval "$(hashi vault config --host "$host")"

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credGet "key$n")"
			if [[ $key ]]; then
				vault operator unseal "$key" || return
			else
				echo "key $n does not exist in the credential store"
			fi
		done

	done
}

#
# Credential Helper
#

credKey()
{
	local prefix="$hashiCredentialPrefix" prod="${1:-$product}"

	[[ "$prefix" == "none" ]] && { echo "$prod"; return; }
	[[ $prefix ]] && echo "$prefix-$prod" || echo "$domain-$prod"
}

credSet() { credential set "$(credKey)" "$1" "$2" --manager="local"; }
credGet() { credential get "$(credKey)" "$1" --manager="local"; }
credSetV() { credential set "$(credKey)" "$1" "$2" --manager="vault"; }
credGetV() { credential get "$(credKey)" "$1" --manager="vault"; }

#
# Host Helper
#

hostCheck()
{
	local host="$1"
	[[ ! $host ]] && MissingOperand "host"
	! IsAvailable "$host" && { EchoErr "$host is not available"; return 1; }
	return 0
}

hostCleanup()
{
	local host="$1"; hostCheck "$host" || return 0

	scriptRun "$(cat <<-EOF
			printf "cleaning..."
			[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && sudo rm -fr "/tmp/hashi."*
			[[ -d "/tmp/consul-test" ]] && rmdir "/tmp/consul-test"
			echo "done"
			EOF
	)"
}

# hostCopy "FILE" "DEST" - copy file to the host destination directory withthe correct permissions
hostCopy()
{
	local file="$1" dest="$2"
	local name="$(GetFileName "$file")"

	scp "$file" "$host:/tmp" || return

	scriptRun "$(cat <<-EOF
		sudo mv "/tmp/$name" "$dest" || exit
		sudo chmod 755 "$dest/$name" || exit
		sudo chown "$user" "$dest/$name" || exit
		sudo chgrp "$user" "$dest/$name" || exit
		EOF
	)"
}

#
# Product Helper
#

productIsInstalled() { [[ $(FindInPath "$1") ]]; }

productInit()
{
	product="$1"

	# directories	
	config="/etc/$product.d" 
	data="/opt/$product"

	# configuration files
	configFileBase="01_$product.hcl"
	configFile="$config/$configFileBase"
	serviceFile="/etc/systemd/system/$product.service"
	serviceEnvFile="/etc/systemd/system/$product.env"
}

productCheck()
{
	local product="$1"; [[ ! $product ]] && MissingOperand "product"
	! productIsInstalled "$1" && { EchoErr "$product is not installed"; return 1; }
	return 0
}

# productConfig PRODUCT - set the configuration variables for the specified product, which enables use of
#   the the product in this script
productConfig()
{
	local product="$1"; productCheck "$1" || return
	local -n addr="${product^^}_$(httpVar "$product")ADDR"

	[[ $hostArg || ! $addr ]] && { eval "$(productConfigShow "$product")" || return; }
	productConfigStatus || return
}

productConfigStatus()
{ 
	[[ ! $verbose ]] && return
	hilight "Using $product server at $addr"
}

# productConfigShow PRODUCT - show the configuration variables for the specified product
productConfigShow()
{
	local product="$1"; productCheck "$1" || return

	# configuration variables
	productInit "$product" || return
	certInit "$product" || return
	
	local args="" 
	local server="$(productGetServer "$product")"
	local url="$(productGetUrl "$product" "$server")"
	local http="$(httpVar "$product")";

	[[ -f "$cert/$certCli" ]] && args+=" -ca-file=$cert/$ca -client-cert=$cert/$certCli -client-key=$cert/$certCliKey"

	# standard configuration
	cat <<-EOF
		export ${product^^}_SERVER="$server"
		export ${product^^}_${http}ADDR="$url"
		export ${product^^}_ARGS="-http-addr=$url$args"
	EOF

	# certificate configuration
	if [[ -f "$cert/$certCli" ]]; then
		cat <<-EOF
			export ${product^^}_CACERT="$(certGetCa "$product")"
			export ${product^^}_CLIENT_CERT="$cert/$certCli"
			export ${product^^}_CLIENT_KEY="$cert/$certCliKey"
		EOF
	fi

	# token configuration - set if not already set, i.e. nomad can set the VAULT_TOKEN
	local token tokenVar tokenVal
	tokenVar="${product^^}_${http}TOKEN"
	tokenVal="$(eval echo "\$$tokenVar")"
	[[ $force || ! $tokenVal ]] && token="$(productGetToken "$product" 2>&1)" && echo "export $tokenVar=\"$token\""

	return 0
}

# productGetServer PRODUCT - get the server for the product
productGetServer()
{
	local product="$1" server
	local -n serverVar="${product^^}_SERVER"

	# arguments: use the host specified by the --host, --servers, or -clients arguments
	if [[ $hostArg || $servers || $clients ]]; then
		local host hosts; getHosts "${servers[@]}" "${clients[@]}" || return; host="${hosts[0]}"
		server="$(IsLocalHost "$host" && echo "127.0.0.1" || AddDnsSuffix "$host" "$domain")"

	# use the <product>_SERVER environment variable
	elif [[ ! $force && $serverVar ]]; then
		server="$serverVar"

	# use the local host for the server if the product service is running
	elif [[ "$product" != @(nomad) ]] && [[ -f $serviceFile ]] && IsProcessRunning "$product" && service running "$product"; then
		server="127.0.0.1"

	# use consul to resolve the server for the product
	elif [[ "$product" != "consul" ]] && server="$(hashi resolve "$product")"; then		
		:

	# use the first server specified in bootstrap-config.sh
	else
		local servers="$hashiServers"; [[ "$product" == "vault" ]] && servers="${vaultServers[@]}"
		server="$(AddDnsSuffix "$(GetWord "$hashiServers" 1)" "$domain")"

	fi

	# return server - use 127.0.0.1 or the DNS name to match the certificate
	if IsLocalHost "$server"; then
		echo "127.0.0.1"
	elif IsIpAddress "$server"; then
		DnsResolve "$server"
	else
		echo "$server"
	fi

}

# productGetPort PRODUCT - get the primary port for the specified product
productGetPort()
{
	local p="$1"
	declare -n port; useHttps && port="${p}HttpsPort" || port="${p}HttpPort"
	echo "$port"
}

# productGetToken PRODUCT - get the authentication token for the product
productGetToken()
{
	local excludeVault; [[ "$1" == "vault" ]] && excludeVault="--exclude-vault"
	credential "$excludeVault" get "$1" token	
}

# productGetUrl PRODUCT [SERVER] [PORT] - get the communication URL for the product
productGetUrl()
{
	local p="$1"
	local server="$2"; [[ ! $server ]] && server="$(productGetServer "$p")"
	local port="$3"; [[ ! $port ]] && port="$(productGetPort "$p")"
	useHttps && echo "https://$server:$port" || echo "http://$server:$port"
}

productInstall()
{
	! installComponentCheck "program" && return

	local product; productInit "$1" || return
	local host="$2"; hostCheck "$host" || return
	local installDir="$(FindInstallFile "other/HashiCorp/$product")" || return		

	# local install
	if IsLocalHost "$host"; then
		local file="$(os executable find "$installDir")" || return
		InPath "$product" && [[ "$(productVersion "$product")" == "$(productVersion "$product" "$file")" ]] && return	
		header "Install $(ProperCase "$product")"
		sudoc cp "$file" "$binDir/$product"; return		
	fi

	local dest="$binDir/$product"

	# header
	header "Install $(ProperCase "$product") ($host)"

	# version check
	ssh "$host" "[[ -f \"$dest\" ]]" && [[ "$(productVersion "$product")" == "$(productVersion "$product" "$host")" ]] && return

	# determine the host architecture
	printf "$host architecture..."
	local machine="$(ssh "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm"; [[ "$product" == "consul" ]] && machine="armhfv6";;
		*) machine="amd64";; 
	esac
	printf "$machine..."

	# find the program
	printf "program..."
	local file="$(find "$installDir" -maxdepth 1 -type f  -name "$product*_linux_$machine" | tail -1)"
	[[ ! -f "$file" ]] && { echo; ScriptErr "unable to find the $product program"; return 1; };
	echo "$(GetFileName "$file")"

	# copy the program
	scp "$file" "$host:/tmp/$product" || return

	scriptRun "$(cat <<-EOF
		[[ -f "$serviceFile" ]] && { printf "stopping service..."; sudo systemctl stop "$product" || exit; echo "done"; }
		sudo cp "/tmp/$product" "$binDir" || exit
		[[ -f "$serviceFile" ]] && { printf "starting service..."; sudo systemctl start "$product" || exit; echo "done";  }
		exit 0
		EOF
	)"
}

productInstallCert()
{
	local product="$1"; productCheck "$product" || return

	[[ ! $encrypt ]] && return
	certInit "$product" || return

	# return if already installed
	[[ ! $force && -f "$cert/$ca" ]] && return	

	# if the certificates do not exist the product may not be install so return without error
	! certCheck "$product" "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" && return

	printf "Installing $product certificates..."
	sudoc mkdir --parents "$cert" || return
	sudoc cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$cert" || return
	sudoc chmod +r "$certDir/"* || return

	echo "done"
}

productRemove()
{
	local product="$1"; productInit "$1" || return
	local host="$2"; hostCheck "$host" || return 0
	
	scriptRun "$(cat <<-EOF

		# delete service
		if [[ -f "$serviceFile" ]]; then
			echo "Deleting the service..."
			sudo systemctl stop "$product" || exit
			sudo systemctl disable "$product" || exit
			sudo rm -f "$serviceFile" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl reset-failed || exit
		fi

		# remove certificates
		if [[ -f "$certStoreCa" ]]; then
			echo "Removing automatic CA certificate..."
			sudo rm "$certStoreCa" || exit
			sudo update-ca-certificates || return
		fi

		printf "cleaning..."
		getent passwd "$product" >&/dev/null && { printf "user..."; sudo userdel "$product" >& /dev/null; }
		getent group "$product" >&/dev/null && { printf "group..."; sudo groupdel "$product" >& /dev/null; }
		[[ -d "/etc/$product.d" ]] && { printf "configuration..."; sudo rm -fr "/etc/$product.d"; }
		[[ -d "/opt/$product" ]] && { printf "data..."; sudo rm -fr "/opt/$product"; }
		[[ "$program" && -f "$binDir/$product" ]] && { printf "program..."; sudo rm -f "$binDir/$product"; }

		[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && { printf "tempory files..."; sudo rm -fr "/tmp/hashi."*; }
		[[ -d "/tmp/consul-test" ]] && sudo rmdir "/tmp/consul-test"

		echo "done"

		EOF
	)"
}

productVersion()
{
	local product="$1" what="${2:-$HOSTNAME}" desc version

	if [[ -f "$what" ]]; then
		version="$("$what" --version)"
		desc="$(FileToDesc "$what")"
	elif IsLocalHost "$what"; then
		version="$($product --version)"
		desc="local"
	else
		version="$(ssh $host -- $product --version)"
		desc="$what"
	fi
	
	[[ $verbose ]] && EchoErr "$product version ($desc) is $(echo "$version" | head -1 | cut -d" " -f 2)"
	echo "$version"
}

#
# helper
#

httpVar() { [[ "$1" != "consul" ]] && return; echo "HTTP_"; }

getHosts() 
{
	if [[ $hostArg ]]; then
		StringToArray "$hostArg" "," hosts
	else
		hosts=( "${@}" )
	fi

	[[ ! $hosts ]] && MissingOperand "host"
	return 0
}

# scriptRun SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local functions="$(FindInPath function.sh | GetFullPath)" script="$1"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		  sudo() { sudoc "\$@"; }
		fi

		$script
		EOF
	)"

	[[ $test ]] && { printf "%s\n" "$script"; return; }

	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		DISPLAY="" ssh -X -t "$host" "$script"
	fi
}

tmpDirCreate() { mktemp -d -t "$tmpDirTemplate"; }
useHttps() { [[ $encrypt || -d "$cert" ]]; } # use HTTPS during installation ($encrupt) and client configuration (cert directory exists)

run "$@"

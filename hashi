#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

run() {	init && args "$@" && initFinal && "${command}Command" "${args[@]}"; }

usage()
{
	ScriptUsage "$1" "\
Usage: hashi [OPTION]... [COMMAND]...
Helper commands for HashiCorp consul, nomad, and vault products.

Common commands:
	cleanup|install|remove|update
	cert							create certificates
	config						configure all products
	lookup|resolve		lookup or resolve a service
	PRODUCT|all				commands for a product or all products
	status						show status for all products
	ui								start the hashi-ui server and launch it

Common options:
	-f, --force						force the operation
	-H, --host HOST				host for the command
			--product-server	server for product communication.  If not specified 
													the server is inferred if possible. 
	-t, --test						do not make changes
	-v, --verbose					show additional status"
}

args()
{
	unset force hostArg hostArgOrig productServer test testEcho verbose

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-f|--force) force="--force";;
			-h|--help) usage 0;;
			-H|--host|-H*|--host=*) ScriptArg hostArg host "$@"; hostArgOrig="$hostArg";;
			   --product-server|--product-server=*) ScriptArg productServer product-server "$@";;
			-t|--test) test="--test"; testEcho="echo";;
			-v|--verbose) verbose="--verbose";;
			*) ScriptOption "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	[[ $@ ]] && usage

	# logging
	[[ $encrypt && $verbose ]] && echo "certificates: $(FileToDesc "$encrypt")"

	return 0
}

#
# configuration
#

init()
{
	products=( consul vault nomad )
	productUsage="consul|nomad|vault"
	datacenter="$(ConfigGet "workgroup")"
	binDir="/usr/local/bin"

	baseDomain="$(ConfigGet "baseDomain")"
	domain="$(ConfigGet "domain")"

	# default servers and clients
	hashiServers=(); StringToArray "$(HashiConfigGet "servers")" "," servers
	hashiClients=(); StringToArray "$(HashiConfigGet "clients")" "," clients
	vaultServers=(); StringToArray "$(HashiConfigGet "VaultServers")" "," vaultServers

	# ports
	consulHttpPort="8500" consulHttpsPort="8501"
	declare -g {nomadHttpPort,nomadHttpsPort}="4646"
	declare -g {vaultHttpPort,vaultHttpsPort}="8200"
}

initFinal()
{
	# if the command is a product command then initialize
	if IsInArray "${commandNames[0]}" products; then
		product="${commandNames[0]}"
		productConfig "$product" || return
	fi
		
	return 0
}

#
# Commands
#

cleanupCommand()
{
	local hosts; getHosts "localhost" || return

	for host in "${hosts[@]}"; do
		header "Cleanup ($host)"
		hostCleanup "$host" || return
	done
}

statusCommand()
{
	local product

	{
		hilight "product-ui-token"
		for product in "${products[@]}"; do

			! productIsInstalled "$product" && continue

			local http="$(httpVar "$product")";
			local -n addr="${product^^}_${http}ADDR"
			local -n token="${product^^}_${http}TOKEN"; [[ $token ]] && token="true" || token="false"

			echo "$product-${addr}-$token"
		done
	} | column -c $(tput cols) -t -s- -n
}

uiCommand()
{
	local product

	productInit "consul" || return; certInit || return	
	export CONSUL_ENABLE="true"
	export CONSUL_ADDR="$(productGetUrl "$product")"
	export CONSUL_ACL_TOKEN="$(credGet token)"
	export CONSUL_HTTP_SSL="true"
	export CONSUL_CACERT="$(certGetCa "$product")"
	export CONSUL_CLIENT_CERT="$cert/$certCli"
	export CONSUL_CLIENT_KEY="$cert/$certCliKey"

	productInit "nomad" || return; certInit || return
	export NOMAD_ENABLE="true"
	export NOMAD_ADDR="$(productGetUrl "$product")"
	export NOMAD_ACL_TOKEN="$(credGet token)"
	export NOMAD_HTTP_SSL="true"
	export NOMAD_CACERT="$(certGetCa "$product")"
	export NOMAD_CLIENT_CERT="$cert/$certCli"
	export NOMAD_CLIENT_KEY="$cert/$certCliKey"

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# Certificate Commands
#

certVars() { unset encrypt; }

certUsage() { echot "Usage: hashi cert copy|make"; }

certOption()
{
	case "$1" in "") : ;;
		-e|--encrypt|-e*|--encrypt=*) ScriptArg "encrypt" "$@"; ScriptCheckDir "$encrypt";;
		*) return 1;;
	esac
}

certCheckArgs() { [[ ! $encrypt ]] && MissingOption "encrypt"; return 0; }

certCommand() { usage; }

#
# Certificate Copy Command
#

certCopyUsage() { echot "\
Usage: hashi cert copy [all|consul|nomad](all)

	-e, --encrypt DIR			directory for PKI certificates"; }


certCopyCommand() { certCopyAllCommand; }
certCopyAllCommand() { certCopyConsulCommand && certCopyNomadCommand; }
certCopyConsulCommand() { product="consul"; certInit || return; installPublicCerts; }
certCopyNomadCommand() { product="nomad"; certInit || return; installPublicCerts; }

#
# Certificate Make Command
#

certMakeUsage() { echot "\
Usage: hashi cert make all|consul|nomad
Create certificates required for HashiCorp products.

	-e, --encrypt DIR			directory for PKI certificates"; }

certMakeCommand() { usage; }
certMakeAllCommand() { certMake "consul" && certMake "nomad"; }
certMakeNomadCommand() { certMake "nomad"; }
certMakeConsulCommand() { certMake "consul"; }

certExist() { [[ -f "$certDir/$1" && -f "$certDir/$2" ]]; }

certInit()
{
	local product="${1:-$product}"; [[ $verbose ]] && echo "Initializing $product certificates..."

	# vault uses consul certificates
	[[ "$product" == "vault" ]] && product="consul"

	# certDir - the source certificate directory including private certificates
	if [[ $encrypt ]]; then
		certDir="$encrypt/$product"	
		[[ ! -d "$certDir" ]] && { mkdir "$certDir" || return; }
	fi

	cert="/opt/$product/cert" 		
	ca="$product-ca.pem"
	caAuto="$product-ca-auto.pem"
	caKey="$product-ca-key.pem"
	certCli=$product-cli.pem
	certCliKey=$product-cli-key.pem
	certClient=$product-client.pem
	certClientKey=$product-client-key.pem
	certServer=$product-server.pem
	certServerKey=$product-server-key.pem

	certStore="/usr/local/share/ca-certificates"
	certStoreCa="$certStore/$(GetFileNameWithoutExtension "$caAuto").crt"
}

certCheckFiles()
{
	local product="$1" cert; shift

	for cert in "$@"; do
		[[ ! -f "$cert" ]] && { EchoErr "$(ProperCase "$product") certificate $(GetFileName "$cert") does not exist"; return 1; }
	done

	return 0
}

# certGetCaType - get the CA based on the type of service being installed
certGetCaType()
{
	local product="$1" type="$2"

	# Consul clients use the automatic CA
	if [[ "$product" == "consul" && "$type" == "client" ]]; then
		echo "$cert/$caAuto"
	else
		echo "$cert/$ca"
	fi
}

# certGetCa - get the CA based on the presense of the automatic certificate in the certificate directory (/opt/PRODUCT/cert)
certGetCa()
{
	local product="$1"

	# Consul clients use the automatic CA
	if [[ "$product" == "consul" && -f "$cert/$caAuto" ]]; then
		echo "$cert/$caAuto"
	else
		echo "$cert/$ca"
	fi
}

# certPublicCopy FILE
certPublicCopy()
{
	local file="$1"
	local dir; dir="$(FindInstallFile "other/HashiCorp")" || return

	# verify the certificate exists
	[[ ! -f "$file" ]] && { ScriptErr "\`$file\` does not exist"; return 1; }

	# create the certificate directory
	dir="$dir/certificate/$baseDomain/$product"
	[[ ! -d "$dir" ]] && { mkdir --parents "$dir" || return; }

	# return if the certificate does not exist
	local fileName="$(GetFileName "$file")"
	[[ -f "$dir/$fileName" && ! $force ]] && return	

	# copy the certificate does not exist
	echo "Copying $fileName..."
	$testEcho cp "$file" "$dir" || return
}

certMake()
{
	local product="$1"; certInit || return
	RunFunction "cert$(ProperCase $product)Make"
}

certClientCopy()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$ca" "$certDir/$certClient" "$certDir/$certClientKey" "$tmpDir/cert" || return
}

certServerCopy()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$ca" "$certDir/$certServer" "$certDir/$certServerKey" "$tmpDir/cert" || return
}

# Make Consul certificates

certConsulMake()
{
	# certificates are created using consul
	! InPath "consul" && { inst "consul" || return; }

	pushd "$certDir" > /dev/null || return

	# create the CA and CLI certificates
	certConsulCaMake || return
	certConsulCliMake || return

	popd > /dev/null || return
}

certConsulCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the certificate authority for $baseDomain..."

	# create the cert
	consul tls ca create \
		-domain="$baseDomain" \
		-name-constraint || return # name constraint required for HTTPS GUI

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

certConsulCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

# certConsulGetAutoCa - get the auto generated Consul certficate authority.   This CA
# is used on Consul clients and is needed on the Consul client to access the Consul API
# from other programs like Nomad, curl, or wget.
certConsulGetAutoCa()
{
	local f="$certDir/$caAuto"
	[[ -f "$f" ]] && return

	! InPath "consul-k8s" && { inst "consul-k8s" || return; }

	consul-k8s get-consul-client-ca \
		--server-addr "$(productGetServer "consul")" \
		--server-port "$consulHttpsPort" \
		--ca-file="$certDir/$ca" \
		--output-file "$f" || return
}

certConsulServerMake()
{
	local cert="$1" key="$2" host="$3"

	certExist "$cert" "$key" && return

	hilight "Creating the $host server certificate..."

	# move to the certificate directory
	pushd "$certDir" >& /dev/null || return

	# remove any existing temporary certs
	rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

	# create the cert
	consul tls cert create -server \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-additional-ipaddress="$(GetIpAddress "$host")" \
		-additional-dnsname="$(os name "$host")" \
		-node="$host" || return

	# rename the temporary cert
	mv "$datacenter-server-$baseDomain-0.pem" "$cert" || return
	mv "$datacenter-server-$baseDomain-0-key.pem" "$key" || return

	popd >& /dev/null || return
}

# Make Nomad certificates

certNomadMake()
{
	# certificates are created using cfssl
	! InPath "cfssl" && { inst "cfssl" || return; }

	pushd "$certDir" >& /dev/null || return

	# create the CA and CLI certificates
	certNomadCaMake || return
	certNomadServerMake || return
	certNomadClientMake || return
	certNomadCliMake || return

	popd >& /dev/null || return
}

certNomadCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the Nomad certificate authority..."
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca || return
}

certNomadCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the Nomad CLI certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-cli
}

certNomadClientMake()
{
	certExist "$certClient" "$certClientKey" && return

	hilight "Creating the Nomad client certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-client || return
}

certNomadServerMake()
{
	certExist "$certServer" "$certServerKey" && return

	hilight "Creating the Nomad server certificate..."

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > cfssl.json || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(ArrayDelimit joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -config=cfssl.json -hostname="$hosts" - | \
		cfssljson -bare nomad-server || return
}

#
# Install Command
#

installVars() { clients=() servers=() join=() encrypt="" force=""; }

installUsage() { echot "\
Usage: hashi install all|cli|$productUsage
Install a HashiCorp product.

	-c, --clients	HOSTS		comma separated list of clients to install
	-s, --server HOSTS		comma separated list of servers to install
	-j, --join HOSTS			comma separated list of hosts to join to, defaults to servers
	-e, --encrypt DIR			directory for PKI certificates, if specified TLS will be enabled
	-w, --what=C1[,C2...] components to install
													components: acl cert program service
													Nomad: VaultIntegration
													Vault: seals"; }

installOption()
{
	case "$1" in "") : ;;
		-c|--clients|-c*|--clients=*) ScriptArg "clients" "$@"; StringToArray "$clients" "," clients;;
		-s|--servers|-s*|--servers=*) ScriptArg "servers" "$@"; StringToArray "$1" "," servers;;
		-j|--join|-j*|--join=*) ScriptArg "join" "$@"; StringToArray "$1" "," join;;
		-e|--encrypt|-e*|--encrypt=*) ScriptArg "encrypt" "$@"; ScriptCheckDir "$encrypt";;
		-w|--what|-w*|--what=*) ScriptArg "what" "$@"; StringToArray "${what,,}" "," what;;
		*) return 1;;
	esac
}

installCommand() { usage; }
installAllCommand() { installConsulCommand && installVaultCommand && installNomadCommand; }

#
# Install CLI COmmand
#

installCliUsage() {	echot "\
Usage: hashi install cli all|$productUsage
Install a HashiCorp product for command line access."; }

installCliCommand() { installCliAllCommand; }
installCliConsulCommand() { installCli "consul"; }
installCliNomadCommand() { installCli "nomad"; }
installCliVaultCommand() { installCli "vault"; }

installCliAllCommand()
{
	local product

	for product in "${products[@]}"; do
		installCliDo "$product" || return
	done
}

installCliDo() 
{ 
	[[ $hostArg || $servers || $clients ]] && { EchoErr "CLI can only be installed locally"; return 1; }
	installCli "$@" || return
}

installCli() { productInstall "$1" "localhost" && productInstallCert "$1"; }

#
# Install Consul Command
#

installConsulCommand()
{ 
	installCommon "consul" || return

	# configuration
	local -A options serverOptions guiOptions 
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	options=(
		[domain]="$baseDomain"
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[client_addr]="0.0.0.0"
		[bind_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[retry_join]="[ $(ArrayShow join ", ") ]"
		[leave_on_terminate]="true"
		[telemetry]="{ disable_compat_1.9 = true }"
		[acl]="$(cat <<-EOF
			{ 
			  enabled = true
			  default_policy = "allow"
			  enable_token_persistence=true
			}
			EOF
		)"
	)

	serverOptions=(
		[server]="true"
		[bootstrap_expect]="${#join[@]}"
		[advertise_addr]='{{ GetInterfaceIP \"eth0\" }}'
	)

	commonEncryptOptions=(
		[addresses]='{ https = "0.0.0.0" }'
		[ports]="{ http = -1, https = $consulHttpsPort }"
		[verify_incoming]="false"
		[verify_incoming_rpc]="true"
		[verify_outgoing]="true"
		[verify_server_hostname]="true"
	)

	clientEncryptOptions=(
		[ca_file]="$cert/$ca"
		[auto_encrypt]="{ tls = true }"
	)

	serverEncryptOptions=(
		[ca_file]="$cert/$ca"
		[cert_file]="$cert/$certServer"
		[key_file]="$cert/$certServerKey"
		[auto_encrypt]="{ allow_tls = true }"
	)

	guiOptions=( [ui_config]="{ enabled = true }" )

	# install
	installDo || return
}

installConsulCommon()
{
	# service
	local cliArgs; cliArgs="$(productConfigArgs "127.0.0.1")" || return
	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$program agent -config-dir=$config"
	serviceKillSignal="SIGTERM"
}

installConsulClient() { installConsulAutoCa; }

installConsulServer() 
{ 
	installConsulCertServer || return
	ArrayAppend o serverOptions guiOptions
}

installConsulAutoCa()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$caAuto" "$tmpDir/cert" || return	
}

installConsulCertServer()
{	
	[[ ! $encrypt ]] && return

	local cert="consul-server-$host.pem"
	local key="consul-server-$host-key.pem"

	certConsulServerMake "$cert" "$key" "$host" || return

	cp "$certDir/$cert" "$tmpDir/cert/$certServer" || return
	cp "$certDir/$key" "$tmpDir/cert/$certServerKey" || return
}

installConsulServerFinal()
{
	if [[ $encrypt && ! -f "$certDir/$caAuto" ]] && installComponentCheck "cert"; then
		header "Automatic Certificate"
		certConsulGetAutoCa || return
	fi

	installAcl || return
}

installConsulFinal() { installConsulAgentAcl; }

installConsulAgentAcl()
{
	! installComponentCheck "acl" && return

	header "Add Tokens"

	productConfig "consul" || return


	# create the default policy and token (for DNS resolution)	
	local defaultToken policy="$(cat <<-EOF
		node_prefix "" {
		  policy = "read"
		}
		service_prefix "" {
		  policy = "read"
		}
		EOF
	)"
	defaultToken="$(consulAclCreate "dns-requests" "$policy")" || return

	# create the host specific policy and configure the host 
	local type
	for host in server"${servers[@]}" client "${clients[@]}"; do

		# determine if the remaining hosts are clients
		[[ "$host" == @(client|server) ]] && { type="$host"; continue; }

		# create the ACL policy
		local token policy="$(cat <<-EOF
			node "$host" {
			  policy = "write"
			}		
			EOF
		)"
		token="$(consulAclCreate "agent-$host" "$policy")" || return

		# update the token on the agent
		hilight "Updating the ACL configuration on $host..."
		local args; args="$(productConfigArgs "127.0.0.1")" || return

		scriptRun "$(cat <<-EOF
			export CONSUL_HTTP_TOKEN=$CONSUL_HTTP_TOKEN
			consul acl set-agent-token $args agent "$token" || exit
			consul acl set-agent-token $args default "$defaultToken" || exit
			sudo sed -i 's/default_policy = "allow"/default_policy = "deny"/' "$configFile" || return
			sudo systemctl restart "$product" || exit
			EOF
		)"

	done
}


#
# Install Nomad Command
#

installNomadCommand()
{
	installCommon "nomad" || return

	# configuration
	local -A options clientOptions serverOptions guiOptions
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 
	local token; token="$(productGetToken "consul")" || return
	local port; port="$(productGetPort "consul")" || return

	options=( 
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[acl]="{ enabled = true }"
		[consul]="{
	token = \"$token\"
	address = \"127.0.0.1:$port\"
}"
	)

	serverOptions=(
		[server]="{
	enabled = true
	bootstrap_expect = "${#join[@]}"
}"
	)

	commonEncryptOptions=()

	clientOptions=(
		[client]="{
	enabled = true 
}"
	)

	clientEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certClient\"
	key_file = \"$cert/$certClientKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	serverEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certServer\"
	key_file = \"$cert/$certServerKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	# install
	installDo || return
}

installNomadCommon()
{ 
	# service - many Nomad jobs require running as root
	user="root"

	# encryption
	if [[ $encrypt ]]; then

		# nomad uses consul certificates
		certInit "consul" || return 
	
		# create the service environment file
		cat > "$tmpDir/$product.env" <<-EOF
			CONSUL_HTTP_SSL=true
			CONSUL_CACERT=$(certGetCaType "consul" "$type")
			CONSUL_CLIENT_CERT=$cert/$certServer
			CONSUL_CLIENT_KEY=$cert/$certServerKey
		EOF

		# return to the nomad certificate configuration
		certInit "nomad" || return

	fi

	return 0
}

installNomadClient()
{
	certClientCopy || return
	ArrayAppend o clientOptions
}

installNomadServer()
{
	certServerCopy || return
	ArrayAppend o serverOptions clientOptions
}

installNomadServerFinal() { installAcl; }
installNomadFinal() { initNomadVaultIntegration; }

initNomadVaultIntegration()
{
	! installComponentCheck "vaultintegration" && return	
	! InPath vault && { echo "Vault is not installed, skipping nomad vault integration"; return; }

	productConfig "vault" || return

	local tmpDir="$(tmpDirCreate)" || return
	pushd "$tmpDir" >& /dev/null || return

	# add the nomad-cluster policy to Vault
	if ! vault policy list | grep -q "^nomad-server$"; then
		hilight "Adding the nomad-cluster policy to Vault..."
		curl https://nomadproject.io/data/vault/nomad-server-policy.hcl -O -s -L || return
		vault policy write nomad-server nomad-server-policy.hcl || return
	fi

	# add the nomad-cluster role to Vault
	if ! vault list "/auth/token/roles" |& grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster role to Vault..."
		curl https://nomadproject.io/data/vault/nomad-cluster-role.json -O -s -L || return
		vault write /auth/token/roles/nomad-cluster @nomad-cluster-role.json || return
	fi

	popd >& /dev/null || return
	
	# grant the nomad-cluster role permission to required secrets
	if ! vault policy list | grep -q "^nomad-cluster$"; then
		hilight "Granting the nomad-cluster role permission in Vault..."
		local policy="$(cat <<-EOF
			path "secret/*" {
			  capabilities = ["read"]
			}
			EOF
		)"
		echo "$policy" | vault policy write nomad-cluster - || return
	fi

	# create a token for nomad to access vault
	local token="$(vault token create -policy nomad-server -orphan -format=json | jq '.auth.client_token' | RemoveQuotes)" || return

	# add vault integration configuration to nomad
	local file="$tmpDir/02_vault.hcl"

	certInit "consul" || return

	cat > "$file" <<-EOF
		vault {
		  enabled          = true
		  ca_file          = "$cert/$ca"
		  cert_file        = "$cert/$certCli"
		  key_file         = "$cert/$certCliKey"
		  address          = "https://127.0.0.1:$vaultHttpsPort"
		  create_from_role = "nomad-cluster"
		  token            = "$token"
		}
	EOF

	if [[ $test ]]; then
		header "$(ProperCase "$product") Configuration ($(GetFileName "$file"))"
		cat "$file" || return
	fi

	# copy the vault configuration files
	for host in "${servers[@]}" "${clients[@]}"; do
		hostCopy "$file" "$config" || return
	done

	# install vault client for nomad jobs
	for host in "${servers[@]}" "${clients[@]}"; do
		productInstall "vault" "$host" || return
	done

	# cleanup
	rm -fr "$tmpDir"

	return 0
}

#
# Install Vault Command
#

installVaultCommand()
{
	installCommon "vault" || return

	# configuration
	local -A options clientOptions serverOptions guiOptions
	local token; token="$(productGetToken "consul")" || return
	local port; port="$(productGetPort "consul")" || return

	# configuration
	options=(
		[listener]="\"tcp\" $(cat <<-EOF
			{ 
			  address = "0.0.0.0:$vaultHttpsPort"
			  tls_cert_file = "$cert/$certServer"
			  tls_key_file = "$cert/$certServerKey"
			}
			EOF
		)"

		[storage]="\"consul\" $(cat <<-EOF
			{
				token = "$token"
			  path = "vault/"
			  address = "127.0.0.1:$port"
			  scheme = "https"
			  tls_ca_file = "$cert/$ca"
			  tls_cert_file = "$cert/$certCli"
			  tls_key_file = "$cert/$certCliKey"
			}
			EOF
		)"

		[service_registration]="\"consul\" $(cat <<-EOF
				{
					token = "$token"
				  address="127.0.0.1:$port"
				  scheme="https"
				  tls_ca_file = "$cert/$ca"
				  tls_cert_file = "$cert/$certCli"
				  tls_key_file = "$cert/$certCliKey"
				}
			EOF
		)"
	)

	guiOptions=( [ui]="true" )

	# install
	installDo || return
}

installVaultCommon()
{
	# options
	o[api_addr]="https://$hostFqdn:$vaultHttpsPort"

	# service
	execStart="$program server -config=$config"
	serviceLimit+=$'\n'"LimitMEMLOCK=infinity"
}

installVaultServer() { ArrayAppend o guiOptions; }

installVaultServerFinal()
{
	installVaultAcl || return; 

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | grep -q "^secret"; then
		header "Vault Configuration"
		vault secrets enable -path=secret kv-v2 || return
	fi

	return 0
}

installVaultAcl()
{
	! installComponentCheck "acl" && return
	header "Install Vault ACL"
	
	local product="vault"; productConfig "$product" || return

	# generate the unseal keys
	local n key result s seals; seals="$(vault operator init 2>&1)"; result="$?"
	echo "$seals" | grep -q "Vault is already initialized" && return
	(( result != 0 )) && { EchoErr "$seals"; return 1; }

	# show the seal keys
	hilight "Store the following vault unseal keys in a secure location:"
	echo "$seals"

	# store the root token
	declare token; token="$(echo "$seals" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credSet "token" "$token" || return
	export VAULT_TOKEN="$token"

	# store the seal keys
	IFS=$'\n' seals=( $(echo "$seals" | grep "Unseal Key") )
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credSet "key$n" "$key" || return
	done

	# unseal the vault
	vaultUnsealCommand || return
}

#
# Lookup Command
#

lookupVars() { name=""; }

lookupUsage() { echot "Usage: hashi lookup NAME
Lookup all information about consul service using nslookup.
.service.<domain> is appended to the specified name."; }

lookupArgs() { ScriptGetArg "name" "$1"; shift; }

lookupCommand()
{
	local addr="$(productGetServer "consul")"
	name+=".service.$domain"
	productInit "consul" || return
	[[ $verbose ]] && HilightErr "Using Consul server at $addr"
	! IsAvailablePort "$addr" 8600 && { EchoErr "$name port 8600 is not available"; return 1; }
	nslookup -port=8600 -type=a -norecurse "$name" "$addr"
}

#
# Remove Command
#

removeVars() { program=""; }

removeUsage() { echot "\
Usage: $(ScriptName) remove all|$productUsage
Remove a HashiCorp product configuration and data.

	-p, --program		also remove the HashiCorp program"; }

removeOption()
{
	case "$1" in "") : ;;
		-p|--program) program="true";;
		*) return 1;;
	esac
}

removeCommand() { usage; }
removeAllCommand() { removeDo "vault" && removeDo "nomad" && removeDo "consul"; }
removeConsulCommand() { removeDo "consul"; }
removeNomadCommand() { removeDo "nomad"; }
removeVaultCommand() { removeDo "vault"; }

removeDo()
{
	local product="$1" host hosts; getHosts || return

	for host in "${hosts[@]}"; do
		header "Remove $(ProperCase "$product") ($host)"
		productRemove "$product" "$host" || return
	done
}

#
# Resolve Command
#

resolveVars() { all=""; name=""; }

resolveUsage() { echot "Usage: hashi resolve [-a|--all] NAME[.service]
Resolve a service in consul to an IP address or canonical name.
If all is not specified the first IP address is returned.
.service.<domain> is appended to the specified name."; }

resolveOption()
{
	case "$1" in "") : ;;
		-a|--all) all="true";;
		*) return 1;;
	esac
}

resolveArgs() { ScriptGetArg "name" "$1"; shift; }

resolveCommand()
{
	local filter="head -1"; [[ $all ]] && { filter="cat"; }

	local result; result="$(lookupCommand)" || return

	if [[ "$result" =~ .*canonical\ name.* ]]; then
		printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//' | $filter
	else
		printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace | $filter
	fi

	return "${PIPESTATUS[0]}"
}

#
# Update Command
#

updateUsage() { echot "usage: $(ScriptName) program all|$productUsage"; }
updateCommand() { usage; }
updateAllCommand() { updateDo "vault" && updateDo "nomad" && updateDo "consul"; }
updateConsulCommand() { updateDo "consul"; }
updateNomadCommand() { updateDo "nomad"; }
updateVaultCommand() { updateDo "vault"; }

updateDo()
{
	local product="$1" host hosts; getHosts "${hashiServers[@]}" "${hashiClients[@]}" || return
	
	for host in "${hosts[@]}"; do
		header "Update $(ProperCase "$product") ($host)"
		productInstall "$product" "$host" || return
	done
}

#
# Install Helper
#

installComponentCheck() { [[ ! $what ]] && return 0; IsInArray "$1" what; }

installCommon()
{
	declare -g product="$1" certDir 
	declare -Ag commonOptions

	productInit "$product" || return; certInit || return
	
	# ensure the CLI program exists locally
	productInstall "$product" "localhost" || return

	# general
	tmpDirTemplate="hashi.XXXXXXXXXX"
	program="$(FindInPath "$product")" || return
	user="$product"
	commonOptions=( [log_level]="Info" )

	# add clients and servers from hostArg
	local host hosts=(); StringToArray "$hostArg" "," hosts; 
	for host in "${hosts[@]}"; do
			IsInArray "$host" hashiServers && servers+=( "$host" ) || clients+=( "$host" )
	done
	unset hostArg

	# set clients and servers defaults
	if [[ ! $clients && ! $servers ]]; then
		if [[ "$product" == "vault" ]]; then
			servers=( "${vaultServers[@]}" ) 
		else
			clients=( "${hashiClients[@]}" ) 
			servers=( "${hashiServers[@]}" )
		fi
	fi

	# join servers	
	[[ ! $join ]] && join=( "${hashiServers[@]}" )
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(os name "$h")" ); done

	if [[ $verbose ]]; then
		printf "clients: "; ArrayShow clients
		printf "servers: "; ArrayShow servers
		printf "join: "; ArrayShow join
	fi
	
	return 0
}
	
installDo()
{
	local result tmpDir="$(tmpDirCreate)" || return

	installCert || return
	installProgram || return
	installServiceServers || return
	installCli "$product" || return
	installServerFinal || return
	installServiceClients || return
	installFinal || return
	installPublicCerts || return

	rm -fr "$tmpDir"
	unset servers clients; hostArg="$hostArgOrig"

	return 0
}

installCert() 
{
	[[ $encrypt ]] && installComponentCheck "cert" && { certMake "$product" || return; }
	return 0
}

installProgram()
{
	! installComponentCheck "program" && return

	for host in "${servers[@]}" "${clients[@]}"; do
		productInstall "$product" "$host" || return
	done
}

installPublicCerts()
{
	[[ ! $encrypt ]] && return

	certPublicCopy "$certDir/$ca" || return
	[[ "$product" == @(consul) ]] && { certPublicCopy "$certDir/$caAuto" || return; }
	certPublicCopy "$certDir/$certCli" || return
	certPublicCopy "$certDir/$certCliKey" || return

}

installServiceServers()
{
	! installComponentCheck "service" && return

	for host in "${servers[@]}"; do
		installServiceHost "server" "$host" || return
	done
}

installServiceClients()
{
	! installComponentCheck "service" && return

	for host in "${clients[@]}"; do
		installServiceHost "client" "$host" || return
	done
}

installServiceHost()
{
	local type="$1" host="$2"
	local f hostFqdn scriptFinal
	local -A o
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local serviceLimit="LimitNOFILE=infinity"$'\n'"LimitNPROC=infinity"
	local execStart="$program agent -config=$config"
	local execReload="/bin/kill --signal HUP \$MAINPID"
	local exectStop=""
	local serviceKillSignal="SIGINT"

	# host information
	hostFqdn="$(os name "$host")" || return
	host="$(RemoveDnsSuffix "$hostFqdn")"

	# header
	header "Install $(ProperCase "$product") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	DelDir --contents "$tmpDir" || return
	mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return		

	# copy certificates
	[[ $encrypt ]] && { FileCommand cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$tmpDir/cert" || return; }

	# service
	printf "" > "$tmpDir/$product.env"

	# options - other options added in installPRODUCTServer or installPRODUCTClient
	o=( ); ArrayAppend o commonOptions options

	[[ "$encrypt" ]] && IsDeclared commonEncryptOptions && ArrayAppend o commonEncryptOptions
	[[ "$encrypt" ]] && IsDeclared ${type}EncryptOptions && ArrayAppend o ${type}EncryptOptions

	RunFunction "install$(ProperCase "$product")Common"
	RunFunction "install$(ProperCase "$product")$(ProperCase "$type")" || return

	# create the configuration files
	installConfigHcl o > "$tmpDir/config/$configFileBase" || return
	installConfigService > "$tmpDir/$product.service" || return

	# copy the files to the remote host
	if ! IsLocalHost "$host"; then
		hilight "Copying files to $host..."
		scp -r "$tmpDir" "$host:/$tmpDir" || return
	fi

	# run the installation script - use only standard commands
	hilight "Running installation..."
	scriptRun "$(cat <<-EOF

		# user
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudo useradd -r -d "$config" -s "/bin/false" "$user" || exit
		fi

		# directories
		if ! [[ -d "$cert" && -d "$config" && -d "$data" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudo install -o "$user" -g "$user" -m 755 -d "$cert" "$config" "$data" || exit
		fi

		# files

		if [[ \$(sudo ls -A "$tmpDir/data") ]] && [[ ! \$(sudo ls -A "$data") || "$force" ]]; then
		  echo "Copying data files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$data" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/config") ]] && [[ ! -f "$config/$configFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$config" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/cert") ]] && [[ ! \$(sudo ls -A "$cert") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$cert" "$tmpDir/cert/"* || exit
		fi

		if [[ -f "$cert/$caAuto" ]] && [[ ! -f "$certStoreCa" || "$force" ]]; then
			echo "Installing automatic CA certificate..."
			sudo cp "$cert/$caAuto" "$certStoreCa" || exit
			sudo update-ca-certificates || exit
		fi

		# service		

		if [[ -f "$serviceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudo systemctl stop "$product" || exit
		fi

		if [[ ! -f "$serviceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudo cp "$tmpDir/$product.service" "$tmpDir/$product.env" "/etc/systemd/system" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl enable "$product" || exit
			sudo systemctl start "$product" || exit
		fi

		$scriptFinal

		# cleanup
		printf "Cleaning up..."; rm -fr "$tmpDir"; echo done

		exit 0

		EOF
	)" || return

	if [[ $test ]]; then
		header "$(ProperCase "$product") Configuration ($(GetFileName "$configFileBase"))"
		cat "$tmpDir/config/$configFileBase" || return

		header "Service Configuration"
		cat "$tmpDir/$product.service" || return
	fi

	return 0
}

installServerFinal()
{	
	[[ ! $servers ]] && return
	RunFunction "install$(ProperCase "$product")ServerFinal"
}

installAcl()
{
	! installComponentCheck "acl" && return

	header "Install $(ProperCase "$product") ACL"
	productConfig "$product" || return

	# generate the bootstrap token
	local token header
	local alreadyCreated="ACL bootstrap already done"; [[ "$product" == "consul" ]] && alreadyCreated="ACL bootstrap no longer allowed"
	local waitingForNodes="The ACL system is currently in legacy mode."
	
	for (( i = 0; i < 30; i++ )); do
		token="$($product acl bootstrap 2>&1)" && break
		echo "$token" | grep -q "$alreadyCreated" && return
		echo "$token" | grep -q "$waitingForNodes" &&
			{ [[ $header ]] && printf "." || printf "bootstrap..."; header="true"; sleep 1; continue; }
		EchoErr "$token"; return 1
	done
	[[ $header ]] && echo
	echo "$token" | grep -q "$waitingForNodes" && { EchoErr "$token"; return 1; }
	
	# show the full bootstrap text
	hilight "Store the following bootstrap token in a secure location:"
	echo "$token"

	# store the bootstrap token
	local secretId="Secret ID"; [[ "$product" == "consul" ]] && secretId="SecretID"
	local sep="="; [[ "$product" == "consul" ]] && sep=":"
	local secret="$(echo "$token" | grep "$secretId" | cut -d$sep -f 2 | RemoveSpace)"
	[[ ! $secret ]] && { ScriptErr "unable to determine the bootstrap token"; return 1; }
	credSet "token" "$secret" || return

	return 0
}

# installConfigHcl - turn the passed array variables into an HCL script
installConfigHcl()
{
	local key var

	for var in "$@"; do
		local -n config="$var"

		for key in "${!config[@]}"; do

			local equal=" =" quote="true" v="${config[$key]}"
			local fc="${v:0:1}" sc="${v:1:1}" # first and second characters

			# example: addresses { https = "0.0.0.0" }
			[[ "$fc" == "{" && "$sc" != "{" ]] && quote="" equal=""

			# example: retry_join = [ "pi3", "pi4" ]
			[[ "$fc" == "[" ]] && quote=""

			# listener "tcp" { address = "0.0.0.0:8200", tls_disable = 1 }
			[[ "$fc" == "\"" ]] && quote="" equal=""

			# boolean, example: server = true			
			[[ "$v" == @(true|false) ]] && quote=""

			# integer, example: bootstrap_expect = 2
			IsInteger "$v" && quote=""

			[[ $quote ]] && echo "$key$equal \"${config[$key]}\"" || echo "$key$equal ${config[$key]}"

		done

	done
}

installConfigService()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$product")
		Documentation=https://www.hashicorp.com/products/$product
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$configFile
		StartLimitIntervalSec=10
		StartLimitBurst=3

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$serviceEnvFile
		KillMode=process
		KillSignal=$serviceKillSignal
		Restart=on-failure
		RestartSec=2
		TasksMax=infinity
		$serviceLimit

		[Install]
		WantedBy=multi-user.target
	EOF
}

installFinal() { RunFunction "install$(ProperCase "$product")Final" || return; }

#
# All Commands
#

allUsage() { echot "\
Usage: hashi all config|status
Commands for all products."; }

allCommand() { usage; }

allConfigCommand()
{
	local product

	for product in "${products[@]}"; do
		! productIsInstalled "$product" && continue
		productConfigShow "$product" || return
		echo
	done
}

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# Config Commands
#

configUsage() { echot "\
Usage: hashi config [local|nuke|remote|show](show)
Configure products

	local			set the local configuration
	nuke			delete all local and remote configuration
	remote		set the remote configuration
	show			show the confioguration"; }

configCommand() { allConfigCommand; }

configLocalCommand()
{	
	productConfig "vault" || return

	# get vault token using SSH	
	if [[ ! $VAULT_TOKEN || $force ]]; then
		local hosts; getHosts "${vaultServers[@]}"
		local host="${hosts[0]}"
		local token; token="$(ssh -q -t pi3 bash -i credential get vault token | RemoveCarriageReturn)" || return
		export VAULT_TOKEN="$token"
	fi

	# save tokens
	local product
	for product in "${products[@]}"; do
		credFromV "token" || return
	done

	# save seals
	local n
	product="vault"
	for n in 1 2 3 4 5; do
		credFromV "key$n" || return
	done
}

configRemoteCommand()
{
	productConfig "vault" || return

	# save tokens
	local product
	for product in "${products[@]}"; do
		credToV "token" || return
	done

	# save seals
	local n
	product="vault"
	for n in 1 2 3 4 5; do
		credToV "key$n" || return
	done
}

# Config Nuke Commands

configNukeUsage() { echot "\
Usage: hashi config nuke all|$productUsage
Delete all local and remote configuration"; }

configNukeCommand() { usage; }
configNukeAllCommand() { nukeDo "vault" && nukeDo "nomad" && nukeDo "consul"; }
configNukeConsulCommand() { nukeDo "consul"; }
configNukeNomadCommand() { nukeDo "nomad"; }
configNukeVaultCommand() { nukeDo "vault"; }

nukeDo()
{
	local product="$1"

	[[ ! $force ]] && { ScriptErr "Nuke deletes all local and remote configuration, --force is required."; return 1; }

	header "Remove $(ProperCase "$product") Configuration"
	[[ "$product" == "vault" ]] && consul kv delete -recurse "vault/"
	credential delete "$product" token	
}

# Config Show Commands

configShowUsage() { echot "\
Usage: hashi config show [all|$productUsage](all)
Show configuration variables"; }

configShowCommand() { allConfigCommand; }
configShowConsulCommand() { productConfigShow "consul"; }
configShowNomadCommand() { productConfigShow "nomad"; }
configShowVaultCommand() { productConfigShow "vault"; }

#
# Consul Commands
#

consulInit() { productConfig "consul" || return; }

consulUsage() { echot "\
Usage: hashi consul config|status|backup|restore|service
Consul commands."; }

consulCommand() { usage; }
consulConfigCommand() { productConfigShow "consul"; }
consulStatusCommand() { consul members; }
consulBackupCommand() { consul snapshot save "$(GetDateStampNext "consul.$domain" "snap")"; }

#
# Consul Service
#

consulServiceInit() { unset file; }

consulServiceUsage() { echot "\
Usage: hashi consul service register|deregister FILE
Consul service commands."; }

consulServiceArgs() { ScriptGetArg "file" "$1"; ScriptCheckFile "$file"; shift; }

consulServiceCommand() { usage; }

consulServiceRegisterCommand()
{
	# get the service ID
	local id type; type="$(validateConfigFile "$file")" || return
	if [[ "$type" == "json" ]]; then
		id="$(cat "$file" | jq ".service.name" | RemoveQuotes)"
	else
		id="$(cat "$file" | grep "name =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
	fi
	[[ ! $id ]] && { ScriptErr "Unable to determine the service id in \`$file\`"; return 1; }

	# create the service ACL policy
	local token policy="$(cat <<-EOF
		service "$id" {
		  policy = "write"
		}
		EOF
	)"	
	token="$(consulAclCreate "service-$id" "$policy")" || return

	# register the service
	local f; f="$(mktemp -t "hashi.service.XXXX.hcl")" || return
	if [[ "$type" == "json" ]]; then
		cat "$file" | sed "s/\"token\": \".*\"/\"token\" = \"$token\"/" > "$f" || return
	else
		cat "$file" | sed "s/token = \".*\"/token = \"$token\"/" > "$f" || return
	fi
	[[ $test ]] && { cat "$f"; return; }
	consul services register "$f" || return

	# cleanup
	rm -f "$f"	

	return 0
}


# -id|FILE
consulServiceDeregister() { consul services deregister; }

#
# Nomad Commands
#

nomadUsage() { echot "\
Usage: hashi nomad config|job|status
Nomad commands."; }

nomadCommand() { usage; }
nomadConfigCommand() { productConfigShow "nomad"; }
nomadStatusCommand() { nomad node status; }

#
# Nomad Job Commands
#

nomadJobUsage() { echot "\
Usage: hashi nomad job NAME
Nomad job commands.

	force	NAME		force a periodic job to start
	log	NAME			show the log for a periodic job
	status [NAME]	status of all running jobs or the specified job"; }

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() {	nomadJobStatusCommand; }

# nomad job status 

nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | grep -v dead
	fi
}

# nomnd job force

nomadJobForceVars() { log=""; }

nomadJobForceUsage() { echot "\
Usage: hashi nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"; }

nomadJobForceOption() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogVars() { follow=""; }

nomadJobLogUsage() { echot "\
Usage: hashi nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"; }

nomadJobLogOption() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId"
		header "Standard Error"; nomad alloc logs -stderr "$allocId"
	fi		
}

# nomad helper

nomadGetJobId()
{ 
	jobId="$(nomad job status "$job" |& tail -1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job \`$job\`"; exit 1
}

nomadGetAllocId()
{
	[[ ! $jobId ]] && { nomadGetJobId || return; }
	allocId="$(nomad job status "$jobId" |& tail -1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job \`$job\`"; exit 1
}

#
# Vault Commands
#

vaultUsage() { echot "\
Usage: hashi vault config|status|unseal
Vault commands.

	unseal			unseal the vault using keys from the credential store"; }

vaultCommand() { usage; }
vaultConfigCommand() { productConfigShow "vault" "" "2"; }
vaultSealCommand() { vault operator seal; }

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	echo "Active Node            $(hashi resolve active.vault)"
	echo "Standby Node           $(hashi resolve standby.vault)"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac

}

vaultUnsealCommand()
{
	local host hosts key; getHosts "${vaultServers[@]}" || return

	# unseal each host
	for host in "${hosts[@]}"; do
		header "$host"
		eval "$(hashi vault config --host "$host")"

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credGet "key$n")"
			if [[ $key ]]; then
				vault operator unseal "$key" || return
			else
				echo "key $n does not exist in the credential store"
			fi
		done

	done
}

#
# Credential Helper
#

credKey()
{
	local prefix="$(HashiConfigGet "CredentialPrefix")" prod="${1:-$product}"

	[[ "$prefix" == "none" ]] && { echo "$prod"; return; }
	[[ $prefix ]] && echo "$prefix-$prod" || echo "$domain-$prod"
}

credExists() { credential exists "$(credKey)" "$1" --manager="local"; }
credSet() { $testEcho credential set "$(credKey)" "$1" "$2" --manager="local"; }
credGet() { credential get "$(credKey)" "$1" --manager="local"; }

credExistsV() { credential exists "$(credKey)" "$1" --manager="vault"; }
credSetV() { $testEcho credential set "$(credKey)" "$1" "$2" --manager="vault"; }
credGetV() { credential get "$(credKey)" "$1" --manager="vault"; }

credToV()
{
	local key="$1" value valueV

	value="$(credGet "$key")" || return
	[[ ! $value ]] && { ScriptErr "$product $key does not exist in the local credential store"; return 1; }

	hilight "Copying $product $key to Vault..."

	valueV="$(credGetV "$key")"
	[[ $verbose ]] && printf "local=$value\nvault=$valueV\n"
	[[ "$value" == "$valueV" ]] && return

	echo "Updating $product $key in Vault..."
	credSetV "$key" "$value" || return
}

credFromV()
{
	local key="$1" value valueL

	value="$(credGetV "$key")" || return
	[[ ! $value ]] && { ScriptErr "$product $key does not exist in Vault"; return 1; }

	hilight "Copying $product $key to the local credential store..."

	valueL="$(credGet "$key")"
	[[ $verbose ]] && printf "local=$valueL\nvault=$value\n"
	[[ "$value" == "$valueL" ]] && return

	echo "Updating $product $key in the local credential store..."
	credSet "$key" "$value" || return
}

#
# Host Helper
#

hostCheck()
{
	local host="$1"
	[[ ! $host ]] && MissingOperand "host"
	! IsAvailable "$host" && { EchoErr "$host is not available"; return 1; }
	return 0
}

hostCleanup()
{
	local host="$1"; hostCheck "$host" || return 0

	scriptRun "$(cat <<-EOF
			printf "cleaning..."
			[[ \$(find "$TEMP" -maxdepth 1 -name "hashi.*") ]] && printf "." && sudo rm -fr "$TEMP/hashi."*
			[[ -d "$TEMP/consul-test" ]] && printf "." && rmdir "$TEMP/consul-test"
			printf "." && rm -f "$TEMP/hashi.service."*
			echo "done"
			EOF
	)"
}

# hostCopy "FILE" "DEST" - copy file to the host destination directory withthe correct permissions
hostCopy()
{
	local file="$1" dest="$2"
	local name="$(GetFileName "$file")"

	hilight "Copying files to $host..."
	scp "$file" "$host:/tmp" || return

	scriptRun "$(cat <<-EOF
		sudo mv "/tmp/$name" "$dest" || exit
		sudo chmod 755 "$dest/$name" || exit
		sudo chown "$user" "$dest/$name" || exit
		sudo chgrp "$user" "$dest/$name" || exit
		EOF
	)"
}

#
# Product Helper
#

productIsInstalled() { [[ $(FindInPath "$1") ]]; }

productInit()
{
	product="$1"; [[ $verbose ]] && echo "Initializing $product..."

	# directories	
	config="/etc/$product.d" 
	data="/opt/$product"

	# configuration files
	configFileBase="01_$product.hcl"
	configFile="$config/$configFileBase"
	serviceFile="/etc/systemd/system/$product.service"
	serviceEnvFile="/etc/systemd/system/$product.env"
}

productCheck()
{
	local product="$1"; [[ ! $product ]] && MissingOperand "product"
	! productIsInstalled "$1" && { EchoErr "$product is not installed"; return 1; }
	return 0
}

# productConfig PRODUCT [HOST] - set the configuration variables for the specified product, which enables use of
#   the the product in this script
productConfig()
{
	local product="$1" host="$2"; productCheck "$1" || return
	local -n addr="${product^^}_$(httpVar "$product")ADDR"

	eval "$(productConfigShow "$product" "$host")" || return
	productConfigStatus || return
}

# productConfigArgs [HOST] - return configuration arguments for the specified host and current product
productConfigArgs()
{
	local host="$1"
	local args=""
	local server; server="$(productGetServer "$product" "$host")" || return
	local url; url="$(productGetUrl "$product" "$server")" || return
	local http; http="$(httpVar "$product")" || return
	local certCa; certCa="$(certGetCaType "$product" "$type")" || return
	local args="-http-addr=$url"

	[[ -f "$cert/$certCli" ]] && args+=" -ca-file=$certCa -client-cert=$cert/$certCli -client-key=$cert/$certCliKey"
	echo "$args"
}

productConfigStatus()
{ 
	[[ ! $verbose ]] && return
	hilight "Using $product server at $addr"
}

# productConfigShow PRODUCT [HOST] - show the configuration variables for the specified product
productConfigShow()
{
	local product="$1" host="$2"; productCheck "$1" || return

	# configuration variables
	productInit "$product" || return; certInit || return
	
	local args="" 
	local server; server="$(productGetServer "$product" "$host")" || return
	local url; url="$(productGetUrl "$product" "$server")" || return
	local http; http="$(httpVar "$product")" || return
	local certCa; certCa="$(certGetCa "$product")" || return

	[[ -f "$cert/$certCli" ]] && args+=" -ca-file=$certCa -client-cert=$cert/$certCli -client-key=$cert/$certCliKey"

	# standard configuration
	cat <<-EOF
		export ${product^^}_SERVER="$server"
		export ${product^^}_${http}ADDR="$url"
		export ${product^^}_ARGS="-http-addr=$url$args"
	EOF

	# certificate configuration
	if [[ -f "$cert/$certCli" ]]; then
		cat <<-EOF
			export ${product^^}_CACERT="$certCa"
			export ${product^^}_CLIENT_CERT="$cert/$certCli"
			export ${product^^}_CLIENT_KEY="$cert/$certCliKey"
		EOF
	fi

	# token configuration - set if not already set, i.e. nomad can set the VAULT_TOKEN
	local token tokenVar tokenVal
	tokenVar="${product^^}_${http}TOKEN"
	tokenVal="$(eval echo "\$$tokenVar")"
	[[ $force || ! $tokenVal ]] && { tokenVal="$(productGetToken "$product" 2>&1)" || return; }
	echo "export $tokenVar=\"$tokenVal\""

	return 0
}

# productGetServer PRODUCT [HOST] - get the server for the product
productGetServer()
{
	local product="$1" host="$2" server
	local -n serverVar="${product^^}_SERVER"
	local resolve="$product"; [[ "$product" == "vault" ]] && resolve="active.vault"

	# use the passed host
	if [[ $host ]]; then
		server="$host"

	# product-server argument
	elif [[ $productServer ]]; then
		server="$productServer"

	# arguments: use the host specified by the --host, --servers, or -clients arguments
	elif [[ $hostArg || $servers ]]; then
		local hosts; getHosts "${servers[@]}" || return
		server="${hosts[0]}"

	# use the <product>_SERVER environment variable
	elif [[ ! $force && $serverVar ]]; then
		server="$serverVar"

	# use the local host for the server if the product service is running
	elif [[ "$product" != @(nomad) ]] && [[ -f $serviceFile ]] && IsProcessRunning "$product" && service running "$product"; then
		server="127.0.0.1"

	# use consul to resolve the server for the product
	elif [[ "$product" != "consul" ]] && server="$(hashi resolve "$resolve")"; then		
		:

	# use the first server specified in bootstrap-config.sh
	else
		local servers="$hashiServers"; [[ "$product" == "vault" ]] && servers="${vaultServers[@]}"
		server="$(GetWord "$hashiServers" 1)"

	fi

	# return server - use 127.0.0.1 or the fully qualified DNS name to match the certificate
	IsLocalHost "$server" && echo "127.0.0.1" || DnsResolve "$server"
}

# productGetPort PRODUCT - get the primary port for the specified product
productGetPort()
{
	local p="$1"
	declare -n port; useHttps && port="${p}HttpsPort" || port="${p}HttpPort"
	echo "$port"
}

# productGetToken PRODUCT - get the authentication token for the product
productGetToken()
{
	local exclude; [[ "$1" == "vault" ]] && exclude="--exclude-managers=vault" # prevent recursion
	local token="$(credential "$exclude" get "$1" token)"
	[[ ! $token ]] && { ScriptErr "unable to get the $1 token"; return 1; }
	echo "$token"
}

# productGetUrl PRODUCT [SERVER] [PORT] - get the communication URL for the product
productGetUrl()
{
	local p="$1"
	local server="$2"; [[ ! $server ]] && server="$(productGetServer "$p")"
	local port="$3"; [[ ! $port ]] && port="$(productGetPort "$p")"
	useHttps && echo "https://$server:$port" || echo "http://$server:$port"
}

productInstall()
{
	! installComponentCheck "program" && return

	local product; productInit "$1" || return
	local host="$2"; hostCheck "$host" || return
	local installDir="$(FindInstallFile "other/HashiCorp/$product")" || return		

	# local install
	if IsLocalHost "$host"; then
		header "Install $(ProperCase "$product") (local)"
		local file="$(os executable find "$installDir")" || return
		InPath "$product" && [[ "$(productVersion "$product")" == "$(productVersion "$product" "$file")" ]] && return	
		sudoc cp "$file" "$binDir/$product"; return		
	fi

	local dest="$binDir/$product"

	# header
	header "Install $(ProperCase "$product") ($host)"

	# version check
	ssh "$host" "[[ -f \"$dest\" ]]" && [[ "$(productVersion "$product")" == "$(productVersion "$product" "$host")" ]] && return

	# determine the host architecture
	printf "$host architecture..."
	local machine="$(ssh "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm"; [[ "$product" == "consul" ]] && machine="armhfv6";;
		*) machine="amd64";; 
	esac
	printf "$machine..."

	# find the program
	printf "program..."
	local file="$(find "$installDir" -maxdepth 1 -type f  -name "$product*_linux_$machine" | tail -1)"
	[[ ! -f "$file" ]] && { echo; ScriptErr "unable to find the $product program"; return 1; };
	echo "$(GetFileName "$file")"

	# copy the program
	scp "$file" "$host:/tmp/$product" || return

	scriptRun "$(cat <<-EOF
		[[ -f "$serviceFile" ]] && { printf "stopping service..."; sudo systemctl stop "$product" || exit; echo "done"; }
		sudo cp "/tmp/$product" "$binDir" || exit
		[[ -f "$serviceFile" ]] && { printf "starting service..."; sudo systemctl start "$product" || exit; echo "done";  }
		exit 0
		EOF
	)"
}

productInstallCert()
{
	local product="$1"; productCheck "$product" || return

	[[ ! $encrypt ]] && return
	certInit || return

	# return if already installed
	[[ ! $force && -f "$cert/$ca" ]] && return	

	# ensure the certificates exist
	certCheckFiles "$product" "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" || return

	printf "Installing $product certificates..."
	sudoc mkdir --parents "$cert" || return
	sudoc cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$cert" || return
	sudoc chmod +r "$cert/"* || return
	echo "done"

	if IsPlatform win; then
		echo "Installing certificate authority..."
		local file="$ADATA/Temp/$ca"
		cp "$cert/$ca" "$file" || return
		RunScript --elevate "$verbose" -- certutil.exe -addstore root "$(utw "$ADATA/Temp/$ca")" || return
		rm "$file" || return
	fi

	return 0
}

productRemove()
{
	local product="$1"; productInit "$1" || return
	local host="$2"; hostCheck "$host" || return 0
	
	scriptRun "$(cat <<-EOF

		# delete service
		if [[ -f "$serviceFile" ]]; then
			echo "Deleting the service..."
			sudo systemctl stop "$product" || exit
			sudo systemctl disable "$product" || exit
			sudo rm -f "$serviceFile" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl reset-failed || exit
		fi

		# remove certificates
		if [[ -f "$certStoreCa" ]]; then
			echo "Removing automatic CA certificate..."
			sudo rm "$certStoreCa" || exit
			sudo update-ca-certificates || return
		fi

		printf "cleaning..."
		getent passwd "$product" >&/dev/null && { printf "user..."; sudo userdel "$product" >& /dev/null; }
		getent group "$product" >&/dev/null && { printf "group..."; sudo groupdel "$product" >& /dev/null; }
		[[ -d "/etc/$product.d" ]] && { printf "configuration..."; sudo rm -fr "/etc/$product.d"; }
		[[ -d "/opt/$product" ]] && { printf "data..."; sudo rm -fr "/opt/$product"; }
		[[ "$program" && -f "$binDir/$product" ]] && { printf "program..."; sudo rm -f "$binDir/$product"; }

		[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && { printf "tempory files..."; sudo rm -fr "/tmp/hashi."*; }
		[[ -d "/tmp/consul-test" ]] && sudo rmdir "/tmp/consul-test"

		echo "done"

		EOF
	)"
}

productVersion()
{
	local product="$1" what="${2:-$HOSTNAME}" desc version

	if [[ -f "$what" ]]; then
		version="$("$what" --version)"
		desc="$(FileToDesc "$what")"

	elif IsLocalHost "$what"; then
		version="$($product --version)"
		desc="local"

	else
		version="$(ssh $host -- $product --version)"
		desc="$what"
	fi
	
	[[ $verbose ]] && EchoErr "$product version ($desc) is $(echo "$version" | head -1 | cut -d" " -f 2)"
	echo "$version"
}

#
# helper
#

httpVar() { [[ "$1" != "consul" ]] && return; echo "HTTP_"; }
tmpDirCreate() { mktemp -d -t "$tmpDirTemplate"; }
useHttps() { [[ $encrypt || -d "$cert" ]]; } # use HTTPS during installation ($encrupt) and client configuration (cert directory exists)

getHosts() 
{
	if [[ $hostArg ]]; then
		StringToArray "$hostArg" "," hosts
	else
		hosts=( "${@}" )
	fi

	[[ ! $hosts ]] && MissingOperand "host"
	return 0
}

# scriptRun SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local functions="$(FindInPath function.sh | GetFullPath)" script="$1"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		  sudo() { sudoc "\$@"; }
		fi

		$script
		EOF
	)"

	[[ $test ]] && { printf "%s\n" "$script"; return; }

	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		DISPLAY="" ssh -q -X -t "$host" "$script"
	fi
}

# validateConfigFile FILE - return false if the specified file is not a valid HashiCorp configuration file.
validateConfigFile()
{
	local type="$(GetFileExtension "$file")"
	[[ ! "$type" == @(hcl|json) ]] && { ScriptErr "Specified file /`$file/` is not a valid HashiCorp configuration file"; return 1; }
	echo "$type"
}

#
# Consul ACL Helper
#

# consulAclCreate NAME DEF - create an ACL with the specified name and definition.   Return a token for the policy.
consulAclCreate()
{
	local name="$1" def="$2"
	consulPolicyCreate "$name" "$def" || return
	consulTokenCreate "$name" || return
	consulTokenGet "$name"
}

#
# Consul Policy Helper
#

# consulPolicyExists NAME - return true if the specified policy exists
consulPolicyExists()
{
	local name="$1"
	[[ "$(consul acl policy list -format=json | jq ".[] | select(.Name == \"$1\").Name" | RemoveQuotes)" == "$name" ]]
}

# consulPolicyCreate NAME DEF - create a policy with the specified name and definition
consulPolicyCreate()
{
	local name="$1" def="$2"
	[[ ! $force ]] && consulPolicyExists "$name" && return
	consulPolicyDelete "$name" || return

	hilight "Creatning ACL policy $name..."
	[[ $test ]] && { printf "${GREEN}create policy $name:${RESET}\n%s\n" "$(cat)"; return; }
	echo "$def" | consul acl policy create -name "$name" -rules -
}

# consulPolicyDelete NAME - delete the specified policy
consulPolicyDelete()
{
	local name="$1"
	! consulPolicyExists "$name" && return

	hilight "Deleting ACL policy $name..."
	[[ $test ]] && { hilight "delete policy $name"; return; }
	consul acl policy delete -name "$name"
}

#
# Consul Token Helper
#

# cosulTokenExists DESC - return true if a token with description exists
consulTokenExists()
{
	local desc="$1"
	[[ "$(consul acl token list -format=json | jq ".[] | select(.Description == \"$desc\").Description" | RemoveQuotes)" == "$desc" ]]
}

# consulTokenId DESC - get the token ID for the specified token description
consulTokenId()
{
	local desc="$1"
	consul acl token list -format=json | jq ".[] | select(.Description == \"$desc\").AccessorID" | RemoveQuotes
}

# consulTokenCreate DESC POLICY - create a token with the specified description that has the permission to the specified policy
consulTokenCreate()
{
	local desc="$1" policy="${2:-$1}"
	[[ ! $force ]] && consulTokenExists "$desc" && return	
	consulTokenDelete "$desc" || return

	hilight "Creating ACL token $desc for policy $policy..."
	[[ $test ]] && { hilight "create token $desc for policy $policy"; return; }
	consul acl token create -description "$1" -policy-name "$policy"
}

# consulTokenDelete DESC - delete the token with the specified description
consulTokenDelete()
{
	local desc="$1"
	! consulTokenExists "$desc" && return

	hilight "Deleting ACL token $desc..."
	[[ $test ]] && { hilight "delete token $desc"; return; }
	consul acl token delete -id "$(consulTokenId "$desc")"
}

# consulTokenGet DESC - get the token Secret ID with the specified description
consulTokenGet()
{
	local desc="$1"
	! consulTokenExists "$1" && { ScriptErr "token \`$desc\` does not exists"; return 1; }
	consul acl token read -id "$(consulTokenId "$desc")" | grep "SecretID" | cut -d: -f 2 | RemoveSpace
}

run "$@"

#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [COMMAND]... [OPTION]...
Helper commands for HashiCorp consul, nomad, and vault products.

Common commands: cert|config|install|remove|service|update
	resolve						resolve a service
	PRODUCT|all				commands for a product or all products
	status						show status for all products

Common options:
	-a,	 --api						server for API communication
	-cf, --config-file		configuration file to use in place og bootstrap-config.sh
	-cp, --config-prefix	configuration prefix to use, i.e. test
	-H,  --host HOST			comma separated list of hosts for the command, or one of the
												following aliases: all|clients|servers|1|2|3|4|5|6|first|second|third|fourth|fifth|sixth
	-is, --is-server			assume the hosts are servers"
}

usageVerbose()
{ 
	ScriptUsageEcho "
Other commands: cleanup
	ui								start the hashi-ui server and launch it

Other options:
	-nt, --no-token 	do not use a token for the command"
}

init()
{
	products=( consul nomad vault )
	productUsage="consul|nomad|vault"
	binDir="/usr/local/bin"; IsPlatform entware && binDir="/opt/bin"
	certVolume="/mnt/p"; certVolumeWasMounted=""; [[ -e "$certVolume" ]] && certVolumeWasMount="true"
	certOptUsage="-e, --encrypt [DIR]		directory for PKI certificates\n	-ne, --no-encrypt		disable TLS encryption"
	configWhat="consul-vault-data local-certs local-credentials private-certs public-certs"
}

argStart() { unset -v api assumeServer configFile configFileArg configPrefix configPrefixArg hostArg hostArgOrig; }

opt()
{
	case "$1" in
		-a|--api|-a=*|--api=*) ScriptOptGet api "$@";;
		-cf|--config-file|-cf=*|--config-file=*) ScriptOptGet "configFile" "config-file" "$@" && ScriptCheckFile "$configFile" && configFileArg=(--config-file "$configFile");;
		-cp|--config-prefix|-cp=*|--config-prefix=*) ScriptOptGet "configPrefix" "config-prefix" "$@" && configPrefixArg=(--config-prefix "$configPrefix");;
		-H|--host|-H=*|--host=*) ScriptOptGet hostArg host "$@"; hostArgOrig="$hostArg";;
		-nt|--no-token) noToken="--no-token";;
		-is|--is-server) assumeServer="true";;
		*) return 1;;
	esac
}

argEnd()
{
	# basic configuration
	datacenter="$(ConfigGet "workgroup")"
	baseDomain="$(ConfigGet "baseDomain")"
	domain="$(ConfigGet "domain")"

	# port configuration
	consulHttpPort="8500" consulHttpsPort="8501"
	nomadHttpPort="4646" nomadHttpsPort="$nomadHttpPort"
	vaultHttpPort="8200" vaultHttpsPort="$vaultHttpPort"

	# product configuration - set product from command if possible
	product=""
	if IsInArray "${commandNames[0]}" products; then
		product="${commandNames[0]}"
		productInit "$product" || return
	else
		initConfig || return
	fi

	# set command specific forces
	unset forceEnvironment
	if [[ $force ]]; then
		if [[ "${commands[1]}" == @(configEnvironment) ]]; then forceEnvironment="true"
		fi
	fi

	return 0

}

cleanup()
{
	[[ ! $certVolumeWasMounted ]] && return
	certDirUnmountPrivate
}

#
# commands
#

cleanupCommand()
{
	local hosts; getHosts "localhost" || return

	for host in "${hosts[@]}"; do
		header "Cleanup ($host)"
		hostCleanup "$host" || return
	done
}

statusCommand()
{
	header "Consul"
	consul members || return
	echo

	header "Nomad"
 	nomad node status
 	echo
 	nomadVaultStatus
 	echo

 	header "Vault"
 	vault status
}

uiCommand()
{
	local product

	for product in "consul" "nomad"; do
		productInit "$product" || return
		export ${product}_ENABLE="true"
		export ${product}_ADDR="$(productVarGet "ADDR")"
		export ${product}_ACL_TOKEN="$(productVarGet "TOKEN")"	
		unset ${product}_HTTP_SSL; [[ "$(GetUriProtocol "${product}_ADDR")" == "https" ]] && export ${product}_HTTP_SSL="true"
	done

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# all commands
#

allUsage() { echot "\
Usage: $(ScriptName) all environment|status
Commands for all products."; }

allCommand() { usage; }
allEnvironmentCommand() { configEnvironmentAll; }

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# certificate commands
#

certUsage()
{
	echot "Usage: $(ScriptName) cert copy|info|make

	copy		copy public certificates
	make		make certificates
	status	show certificate status

	$certOptUsage"
}

certArgStart() { encrypt="true"; }

certOpt()
{
	case "$1" in
		-e|--encrypt|-e=*|--encrypt=*) encryptOptGet "$@";;
		-ne|--no-encrypt) unset encrypt;;
		*) return 1;;
	esac
}

certCommand() { usage; }

#
# cert copy commands
#

certCopyUsage() { echot "\
Usage: $(ScriptName) cert copy all|$productUsage
Copy public certificates to the public installation location.\n\n  $certOptUsage"; }

certCopyCommand() { usage; }
certCopyAllCommand() { certCopyPublic "consul" && certCopyPublic "nomad" && certCopyPublic "vault"; }
certCopyConsulCommand() { certCopyPublic "consul"; }
certCopyNomadCommand() { certCopyPublic "nomad"; }
certCopyVaultCommand() { certCopyPublic "vault"; }

# certCopyPublic PRODUCT - copies public certificates from the private certificate directory to the public certificate directory
certCopyPublic()
{
	local product="$1"

	# initialization
	initConfig "$product" || return
	certInit "$product" || return

	# source directory (private certificates)
	local src; src="$(certDirPrivate | certDirSuffix "$product")" || return
	local cert certs=( "$ca" "$certCli" "$certCliKey" ); [[ $caAuto ]] && certs+=( "$caAuto" )

	certValidate "$src" "${certs[@]}" || return

	# destination directory (public certificates)
	local dest; dest="$(certDirPublic | certDirSuffix "$product")" || return
	${G}mkdir --parents "$dest" || return

	# return if the source (private) and destination (public) locations are the same
	[[ "$src" == "$dest" ]] && return

	# return if the certificates exist in the destination location
	[[ ! $force ]] && certExists "$dest" "${certs[@]}" && return

	# copy the certificates
	echo "Copying ${product^} public certificates to '$(FileToDesc "$dest")'..."
	for cert in "${certs[@]}"; do
		copyFile "$src/$cert" "$dest" || return
	done
}

#
# Certificate Make Command
#

certMakeUsage() { echot "\
Usage: $(ScriptName) cert make all|$productUsage [server]
Create certificates required for HashiCorp products.\n\n  $certOptUsage"; }

certMakeArgEnd() { [[ ! $encrypt ]] && MissingOption "encrypt"; return 0; }
certMakeCommand() { usage; }
certMakeAllCommand() { certMake "consul" && certMake "nomad" && certMake "vault"; }
certMakeConsulCommand() { certMake "consul"; }
certMakeNomadCommand() { certMake "nomad"; }
certMakeVaultCommand() { certMake "vault"; }
certMakeConsulServerCommand() { forAllHosts certMakeConsulServer; }
certMakeVaultServerCommand() { forAllHosts certMakeVaultServer; }

# certMakeCd PRODUCT - mount and change to the private certificate directory for the product
certMakeCd()
{
	local product="$1"; certInit "$product" || return
	local dir; dir="$(certDirPrivate | certDirSuffix "$product")" && sudoc ${G}mkdir --parents "$dir" && command cd "$dir"
}

# certMakeDnsArgs NAMES - return additional DNS name arguments for the comma separated list of names
certMakeDnsArgs()
{
	local args name names=(); StringToArray "$1" "," "names"

	for name in "${names[@]}"; do
		args+="--additional-dnsname=$(serviceDnsName "$name") --additional-dnsname=$(serviceDnsNameShort "$name") "
	done

	echo "$(RemoveSpaceTrim "$args")"	
}

# certMakeServer PRODUCT HOST [DEST] [CERT_ARGS...] - make server certificate for product.  Optionally copy it
#   to the destination directory.   CERT_ARGS allow for additional (alternate) names using -additional-ipaddress="IP"
#   or -additional-dnsname="DNS"
certMakeServer()
{
	local product="$1" host="$2"; shift 2; certMakeCd "$product" || return
	local dest; [[ -d "$1" ]] && { dest="$1"; shift; }
	local cert="$product-server-$host.pem"
	local key="$product-server-$host-key.pem"

	# initialzie
	certValidate "$ca" "$caKey" || return
	certExists "$cert" "$key" && return
	hilight "Creating a ${product^} server certificate for $host..."

	# remove any existing temporary certs
	rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

	# create the cert
	local ip; ip="$(GetIpAddress "$host")" || return
	local fqdn; fqdn="$(hostFqdn "$host")" || return

	RunLog consul tls cert create -server \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-additional-ipaddress="$ip" \
		-additional-dnsname="$fqdn" \
		$@ \
		-node="$host" \
		-days="3650" || return

	# rename the temporary cert
	mv "$datacenter-server-$baseDomain-0.pem" "$cert" || return
	mv "$datacenter-server-$baseDomain-0-key.pem" "$key" || return

	# copy the certificates
	if [[ $dest ]]; then
		cp "$cert" "$dest/$certServer" || return
		cp "$key" "$dest/$certServerKey" || return
	fi
}

# certMakePRODUCTServer HOST [DIR] - make a server certificate
certMakeConsulServer() { certMakeServer "consul" "$@" "$(certMakeDnsArgs "consul")"; }
certMakeVaultServer() { certMakeServer "vault" "$@" "$(certMakeDnsArgs "vault,active.vault,standby.vault")"; }

certMakeNomadServer()
{
	local product="nomad" host="$1"; shift 1; certMakeCd "$product" || return
	local dest; [[ -d "$1" ]] && { dest="$1"; shift; }

	certValidate "$ca" "$caKey" || return
	certExists "$certServer" "$certServerKey" && return
	hilight "Creating the Nomad server certificates..."

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > "cfssl.json" || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(ArrayDelimit joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -config="cfssl.json" -hostname="$hosts" - | cfssljson -bare "nomad-server" || return

	# copy the certificates
	if [[ $dest ]]; then
		cp "$certServer" "$dest/$certServer" || return
		cp "$certServerKey" "$dest/$certServerKey" || return
	fi
}


# certMake PRODUCT - make certificates for the product.  All of the following certMake functions are should only be called from certMake.
certMake()
{	
	local product="$1"; certMakeCd "$product" || return
	RunFunction "cert" "Make${product^}" || return
}

certMakeCa()
{
	certExists "$ca" "$caKey" && return
	hilight "Creating the ${product^} certificate authority for $baseDomain..."

	# create the cert - name constraint required for HTTPS GUI
	consul tls ca create -domain="$baseDomain" -name-constraint || return

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

certMakeCli()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certCli" "$certCliKey" && return
	hilight "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-days="3650" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

# certMake - product specifics

certMakeConsul()
{
	# install consul to create certificates
	! InPath "consul" && { inst "consul" || return; }

	# create the certificates
	certMakeConsulCa || return
	certMakeCli || return
}

# certMakeConsulCaAuto - get the auto generated Consul certficate authority.   This CA
# is used on Consul clients and is needed on the Consul client to access the Consul API
# from other programs like Nomad, curl, or wget.
certMakeConsulCaAuto()
{
	certValidate "$ca" || return
	certExists "$caAuto" && return

	header "Get Consul Certificates"
	hilight "Getting the automatic certificate authority..."

	! InPath "consul-k8s" && { inst "consul-k8s" || return; }

	consul-k8s get-consul-client-ca \
		--server-addr "$(productGetServer "consul")" \
		--server-port "$consulHttpsPort" \
		--ca-file="$ca" \
		--output-file "$caAuto" || return
}

certMakeNomad()
{
	# install cfssl to create certificates
	! InPath "cfssl" && { inst "cfssl" || return; }

	# create certificates
	certMakeNomadCa || return
	certMakeNomadServer || return
	certMakeNomadClient || return
	certMakeNomadCli || return
}

certMakeNomadCa()
{
	certExists "$ca" "$caKey" && return
	hilight "Creating the Nomad certificate authority..."
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca
}

certMakeNomadCli()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certCli" "$certCliKey" && return
	hilight "Creating the Nomad CLI certificate..."
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-cli
}

certMakeNomadClient()
{
	certValidate "$ca" "$caKey" || return
	certExists "$certClient" "$certClientKey" && return
	hilight "Creating the Nomad client certificate..."
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-client
}

certMakeVault()
{
	# install consul to create certificates
	! InPath "vault" && { inst "vault" || return; }

	# create the certificates
	certMakeCa || return
	certMakeCli || return
}

#
# cert status command
#

certStatusUsage() { EchoWrap "Usage: $(ScriptName) cert status
Show certificate status.

	-P,	--private		show private certificate status by mounting the private certificate directory
	-p,	--public		show public certificate status by mounting the public certificate directory

Certification locations:
  local - certificate directory for command line clients (i.e. /opt/hashi/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT or /opt/PRODUCT/cert)
  service - certificate directory for services (i.e. /opt/PRODUCT/cert/)
  private - the root private certificate directory from the --encrypt option or certificateDir configuration
  public - public certificate directory on the installation share"; }

certStatusArgStart() { unset private public; }

certStatusOpt()
{
	case "$1" in
		-P|--private) private="true";;
		-p|--public) public="true";;
		*) return 1;;
	esac
}

certStatusCommand() { certStatus; }

certStatus() { certStatusConsul && certStatusNomad && certStatusVault && certStatusPublic && certStatusPrivate; }
certStatusConsul() { certStatusProduct "consul"; }
certStatusNomad() { certStatusProduct "nomad"; }
certStatusVault() { certStatusProduct "vault"; }

certStatusShow()
{
	local desc="$1" dir="$2"
	header "$desc Certificates"
	hilight "location: $(FileToDesc "$dir")"
	command cd "$dir" && tree -L 2 --prune --noreport
	echo
}

certStatusProduct()
{
	local product="$1"

	# initialization
	initConfig "$product" || return
	certInit "$product" || return

	# service
	if [[ -d "$certDirService" ]]; then
		certStatusShow "$(UpperCaseFirst "$product") Service" "$certDirService" || return
	fi

	local certDirLocal="$(certDirLocal "$product")" || return
	if [[ "$certDirLocal" != "$certDirService" && -d "$certDirLocal" ]]; then
		certStatusShow "$(UpperCaseFirst "$product") CLI" "$certDirLocal" || return
	fi
}

# certStatusPublic - show status for the public certificate directory on the installation file server
certStatusPublic()
{
	[[ ! $public ]] && return
	local dir; dir="$(certDirPublic)" && certStatusShow "Public" "$dir"
}

# certStatusPrivate - show status for the private certificate directory on the encrypted volume
certStatusPrivate()
{
	[[ ! $private ]] && return
	local dir; dir="$(certDirPrivate | certDirSuffix "")" && certStatusShow "Private" "$dir"
}

#
# config commands
#

configUsage() { echot "\
Usage: $(ScriptName) config deploy|get|remove|set
Configure products."; }

configCommand() { usage; }

# config deploy commands

configDeployUsage() { echot "\
Usage: $(ScriptName) config deploy $productUsage FILE
Deploy a configuration file."; }

configDeployArgStart() { unset file; }
configDeployArgs() { ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift; }

configDeployCommand() { usage; }
configDeployConsulCommand() { forAllHosts configDeploy "consul" "$file"; }
configDeployNomadCommand() { forAllHosts configDeploy "nomad" "$file"; }
configDeployVaultCommand() { forAllHosts configDeploy "vault" "$file"; }

# configDeploy PRODUCT FILE HOST - deploy a product configuration file to a host
configDeploy()
{
	local product="$1" file="$2" host="$3"
	serviceConfigCopy "$product" "$host" "$file" && serviceRestart "$product" "$host"
}

# config environment commands

configEnvironmentUsage() { echot "\
Usage: $(ScriptName) config environment [all|$productUsage|test|reset](all)
Show the product environment variables.  This command is typically called 
with ScriptEval to update current environment.

	-se, --suppress-errors			supress certificate not found errors"; }

configEnvironmentArgStart() { unset -v suppressErrors; }

configEnvironmentOpt()
{
	case "$1" in
		-se|--suppress-errors) suppressErrors="true";;
		*) return 1;;
	esac
}

configEnvironmentCommand() { configEnvironmentAll; }
configEnvironmentAllCommand() { configEnvironmentAll; }
configEnvironmentResetCommand() { echo "unset CONSUL_HTTP_TOKEN VAULT_TOKEN NOMAD_TOKEN"; }

configEnvironmentConsulCommand() { productEnvironment "consul"; }
configEnvironmentNomadCommand() { productEnvironment "nomad"; }
configEnvironmentVaultCommand() { productEnvironment "vault"; }

# environment aliases commands
configEnvironmentProdCommand() { configPrefix="" configEnvironmentCommand; }
configEnvironmentTestCommand() { configPrefix="test" configEnvironmentCommand; }

configEnvironmentAll()
{
	# initialize consul for product lookups
	productIsInstalled "consul" && { productInit "consul" || return; }

	local product
	for product in "${products[@]}"; do		
		! productIsInstalled && continue
		productEnvironment || return; echo
	done
}

# config get command

configGetUsage() { echot "\
Usage: $(ScriptName) config get VAR
Get a configuration variable."; }

configGetArgStart() { unset varName; }
configGetArgs() { ScriptArgGet "varName" "var" -- "$@"; shift; }
configGetCommand() { configGet "$varName"; }

# configExists VAR
configExists() { [[ $(configGet "$var") ]]; }

# configGet VAR
configGet()
{
	local var="hashi$(UpperCaseFirst "$configPrefix")$(UpperCaseFirst "$1")"
	ConfigInit "$configFile" && ConfigExists "$var" && ConfigGet "$var"
}

# configGetArray VAR [ARRAY_NAME](VAR)
configGetArray()
{
	local var="$1" 
	local arrayName="${2:-$var}"
	StringToArray "$(configGet "$var")" "," "$arrayName"
}

# configGetList VAR
configGetList()
{
	local var="$1" a
	StringToArray "$(configGet "$var")" "," "a"
}

# configServer - return the first server for the current product
configServer()
{
	local var="servers"; [[ "$product" == "vault" ]] && var="VaultServers"
	configGet "$var" | GetWord - "1" ","
}

# configServers - return a comma separated list of all of the servers in the configuration
configServers()
{
	local servers; configGetArray "servers"
	local clients; configGetArray "clients"
	local vaultServers; configGetArray "VaultServers" "vaultServers"
	local hosts=(); ArrayAppend --remove-dups hosts servers clients vaultServers
	ArrayDelimit hosts	
}

# Config Remove Commands

configRemoveUsage() { echot "\
Usage: $(ScriptName) config remove all|$productUsage
Remove all local and remote configuration.

	-w, --what=C1[,C2...] configuration to remove: $configWhat"; }

configRemoveArgStart() { unset whatArg yes; }

configRemoveOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

configRemoveOptArgEnd()
{
	[[ ! $what ]] && MissingOption "what"

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' configuration from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

configRemoveCommand() { usage; }
configRemoveAllCommand() { removeConfig "vault" && removeConfig "nomad" && removeConfig "consul"; }
configRemoveConsulCommand() { removeConfig "consul"; }
configRemoveNomadCommand() { removeConfig "nomad"; }
configRemoveVaultCommand() { removeConfig "vault"; }

# removeConfid PRODUCT - remove configuration for the product
removeConfig()
{
	local product="$1"; certInit "$product" || return; ConfigInit || return

	if [[ ! $force || ! $yes ]]; then
		ScriptErr "To permanently deletes all local and remote configuration and certificates for $baseDomain $configDesc, --force and --yes are required"
		return 1
	fi

	header "Remove $(ProperCase "$product") Configuration"

	# Vault data
	if [[ "$product" == "vault" ]] && whatCheck "consul-vault-data" && quiet="--quiet" productInit "consul"; then
		hilight "Removing Vault data from Consul..."
		RunLog consul kv delete -recurse "vault/"
	fi

	# certificates (local, private, and public)	
	if [[ "$product" != "vault" ]]; then # Vault uses Consul certificates
		local dir
		whatCheck "local-certs" && { hilight "Removing local certificates..."; removeLocalCerts || return; }
		whatCheck "private-certs" && { hilight "Removing private credentials..."; dir="$(certDirPrivate | certDirSuffix "$product")" || return; removeDir "$dir"; }
		whatCheck "public-certs" && { hilight "Removing public credentials..."; dir="$(certDirPublic | certDirSuffix "$product")" || return; removeDir "$dir"; }
	fi

	# credentials (local)
	whatCheck "local-credentials" && { hilight "Removing local credentials..."; credDelete "all" || return; }

	# delete host certificates
	local host hosts; getHosts "all" || return
	for host in "${hosts[@]}"; do
		hilight "Removing $host certificates and credentials..."
		sshRun -q -t "$host" bash -i "credential rm \"$(credPath)\" all ${globalArgs[@]} && rm -fr \"$(certDirSuffix "$product" "/opt/hashi")\"" || return
	done
}

removeLocalCerts()
{
	local product="${1:-$product}"; certInit "$product" || return

	removeDir "$(certDirLocal "$product")" || return

	if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
		RunLog sudoc rm -f "$certStoreCa" "$certStoreCaAuto" || return
		RunLog sudo update-ca-certificates || return
	fi
}

#
# config set command
#

configSetUsage() { echot "\
Usage: $(ScriptName) config local|remote [all|$productUsage](all)
Set local or remote credential configuration.

	-F,	--from MANAGER	first credential manager, defaults to local or remote
	-T,	--to MANAGER		second credential manager, defaults to local or remote"; }

configSetLocalArgStart() { from="remote" to="local"; }
configSetRemoveArgStart() { from="local" to="remote"; }

configSetOpt() 
{
	case "$1" in
		-F|--from|-F=*|--from=*) ScriptOptGet from "$@";;
		-T|--to|-T=*|--to=*) ScriptOptGet to "$@";;
		*) return 1
	esac
}

configSetCommand() { usage; }

configSetLocalCommand() { configSetLocalAllCommand; }
configSetLocalAllCommand() { configSetLocalConsulCommand && configSetLocalNomadCommand && configSetLocalVaultCommand; }
configSetLocalConsulCommand() { configSetLocal "consul"; }
configSetLocalNomadCommand() { configSetLocal "nomad"; }
configSetLocalVaultCommand() { configSetLocal "vault"; }

configSetRemoteCommand() { configSetRemoteAllCommand; }
configSetRemoteAllCommand() { configSetRemoteConsulCommand && configSetRemoteNomadCommand && configSetRemoteVaultCommand; }
configSetRemoteConsulCommand() { configSetRemote "consul"; }
configSetRemoteNomadCommand() { configSetRemote "nomad"; }
configSetRemoteVaultCommand() { configSetRemote "vault" && vaultTokenSetRemote; }

configSetLocal() { vaultTokenGetRemote && configMirror "$from" "$to" "$1"; }
configSetRemote() { configMirror "$from" "$to" "$1"; }

# configMirror FROM TO PRODUCT - mirror configuration credentials for a product
configMirror()
{
	local from="$1" to="$2" product="$3"

	# check if the configuration already exists in the TO credential store
	local check="token"; [[ "$product" == "vault" ]] && check="key5"
	[[ ! $force ]] && test="" RunLog credential exists "$(credPath)" "$check" --manager="$to" && return

	# get descriptions
	local fromDesc; fromDesc="$(credential manager name --manager="$from")"
	local toDesc; toDesc="$(credential manager name --manager="$to")"

	# mirror the credentials
	hilight "Mirroring ${product^} credentials from '$fromDesc' to '$toDesc'..."
	RunLog credential mirror --from="$from" --to="$to" "$(credPath)" --force "${globalArgs[@]}" || return
}

#
# config status command
#

configStatusCommand()
{
	local product term="$TERM"; [[ ! $term ]] && term="xterm-256color"

	{
		#(productVarGet "CACERT" | GetFilePath | FileToDesc
		hilight "product-ui-certificate-token-config-domain"

		for product in "${products[@]}"; do			
			! productIsInstalled && continue

			suppressErrors="true" productInit "$product" || return

			local ui="$(productVarGet "ADDR")"			
			local cert="false"; [[ -f "$(productVarGet "CACERT")" ]] && cert="true"
			local token="false"; [[ $(productVarGet "TOKEN") ]] && token="true"
			local prefix="$(productVarGet "CONFIG")"; prefix="${prefix:-prod}"
			local domain="$(productVarGet "DOMAIN")"

			[[ "$cert" == "true" && "$product" == "consul" ]] && { productVarGet "CACERT" | grep -q "auto" && cert="client" || cert="server"; }

			echo "${RESET}${RESET}$product-$ui-$cert-$token-$prefix-$domain" # add resets to line up the columns

		done

	} | column -c $(tput cols -T "$term") -t -s-
}

#
# consul command
#

consulUsage() { EchoWrap "Usage: $(ScriptName) consul acl|agent|api|backup|environment|reload|restore|service|status\nConsul commands."; }
consulCommand() { usage; }
consulBackupCommand() { consul snapshot save "$(GetDateStampNext "consul.$domain" "snap")"; }
consulEnvironmentCommand() { productEnvironment "$product"; }
consulReloadCommand() { forAllHosts consulReloadDo; }
consulStatusCommand() { consul members; }

consulReloadDo() { productInit "consul" "$1" && consul reload; }

#
# consul acl command
#

consulAclUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent|create|policy|token\nConsul ACL commands."; }
consulAclCommand() { usage; }

#
# consul acl agent command
#

consulAclAgentUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent allow|create|deny|deploy\nConfigure the agent ACL system."; }
consulAclAgentCommand() { usage; }

consulAclAgentAllowUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent allow\nChange the default ACL policy to allow."; }
consulAclAgentAllowCommand() { forAllHosts consulAclAgentAllow; }

consulAclAgentCreateUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent create\nCreate agent ACL policies and tokens.  \
If this is a new agent, use --api to specify the API server.  For example:\n
hashi consul acl agent create --api=pi1 -H=pi5"; }
consulAclAgentCreateCommand() { consulApiCheck && forAllHosts consulAclAgentCreate; }

consulAclAgentDenyUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent deny\nChange the default ACL policy to deny."; }
consulAclAgentDenyCommand() { forAllHosts consulAclAgentDeny; }

consulAclAgentDeployUsage() { EchoWrap "Usage: $(ScriptName) consul acl agent deploy\nDeploy the agent ACL tokens to the 02_acl_tokens.hcl configuration file."; }
consulAclAgentDeployCommand() { forAllHosts consulAclAgentDeploy; }

# consul acl agent helper

# consulAclAgentDefault HOST - change the ACL mode on a host to allow
consulAclAgentAllow() { local host="$1"; consulAclAgentDefaultPolicy "allow"; }
consulAclAgentDeny() { local host="$1"; consulAclAgentDefaultPolicy "deny"; }

consulAclAgentDefaultPolicy()
{
	local newPolicy="$1"; serviceVars "consul" || return
	local currentPolicy; currentPolicy="$(serviceConfigVarGet "default_policy" "$product" "$host")" || return

	# return if we don't need to change the default ACL policy
	[[ ! $force && "$currentPolicy" == "$newPolicy" ]] && return

	# change the default ACL policy

	printf "Changing the default ACL policy on $host from $currentPolicy to $newPolicy..."

	scriptRun "$host" "$(cat <<-EOF
		sudo sed -i "s/default_policy = \"$currentPolicy\"/default_policy = \"$newPolicy\"/" "$productConfigFile" || exit
		sudo systemctl restart "$product" --no-block || exit
		EOF
	)" || return

	echo "done"
}

# consulAgentAclCreate HOST - create the policies and tokens for a consul agent
consulAclAgentCreate()
{
	local host="$1"

	# create default token for DNS requests
	consulAclCreate "dns-requests" "$(cat <<-EOF
		node_prefix "" {
		  policy = "read"
		}
		service_prefix "" {
		  policy = "read"
		}
		EOF
	)" || return

	# create the ACL policy for the host
	consulAclCreate "agent-$host" "$(cat <<-EOF
		node "$host" {
		  policy = "write"
		}		
		EOF
	)" || return
}

# consulAclAgentDeploy HOST - deploy ACL tokens to a host
consulAclAgentDeploy()
{
	local host="$1"

	# create the agent ACL's
	consulAclAgentCreate "$host" || return
	local defaultToken; defaultToken="$(consulAclTokenGetSecret "dns-requests")" || return
	local agentToken; agentToken="$(consulAclTokenGetSecret "agent-$host")" || return
	
	# deploy the configuration file
	serviceConfigCopyText "consul" "$host" "02_acl_tokens.hcl" "$(cat <<-EOF
		acl {
		  tokens {
		    default = "$defaultToken"
		    agent = "$agentToken"
		  }
		}
		EOF
	)"
}

#
# consul acl create command
#

consulAclCreateUsage() { echot "\
Usage: $(ScriptName) consul acl create [NAME] [DEFINITION]
Create a Consul ACL."; }

consulAclCreateArgStart() { unset name def; }

consulAclCreateArgs()
{
	ScriptArgGet "name" -- "$@"; shift
	ScriptArgGet "def" -- "$@"; shift
}

consulAclCreateCommand() { consulAclCreate "$name" "$def"; }

#
# consul acl policy commands
#

consulAclPolicyUsage() { echot "\
Usage: $(ScriptName) consul acl policy [get|ls|rm](ls) [NAME]
Manage Consul ACL policies."; }

consulAclPolicyArgStart() { unset name; }
consulAclPolicyCommand() { consulAclPolicyLsCommand; }

consulAclPolicyGetArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclPolicyGetCommand() { consulAclPolicyGetId "$name"; }

consulAclPolicyLsUsage() { echot "Usage: $(ScriptName) consul acl list\nList all Consul ACL policy names."; }
consulAclPolicyLsCommand() { consulAclPolicyLs; }

consulAclPolicyRmArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclPolicyRmCommand() { consulAclPolicyRm "$name"; }

#
# Consul ACL Token Command
#

consulAclTokenUsage() { echot "\
Usage: $(ScriptName) consul acl token [get|ls|rm](ls)
Manage Consul ACL tokens."; }

consulAclTokenArgStart() { unset name; }
consulAclTokenCommand() { consulAclTokenLsCommand; }

consulAclTokenGetUsage() { echot "Usage: $(ScriptName) consul acl token get [secret]"; }
consulAclTokenGetArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclTokenGetCommand() { consulAclTokenGetId "$name"; }
consulAclTokenGetSecretCommand() { consulAclTokenGetSecret "$name"; }

consulAclTokenLsUsage() { echot "Usage: $(ScriptName) consul acl list\nList all Consul ACL token descriptions."; }
consulAclTokenLsCommand() { consulAclTokenLs; }

consulAclTokenRmArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclTokenRmCommand() { consulAclTokenRm "$name"; }

# Consul ACL Helper

consulAclPolicyLs() { consul acl policy list -format=json | jq '.[].Name' | RemoveQuotes | sort; }
consulAclTokenLs() { consul acl token list | grep "^Description:" | cut -d: -f2 | tr -s " " | cut -d" " -f2 | sort; }

# consulAclCreate NAME DEF - create an ACL with the specified name and definition.   Return the secret token for the policy.
consulAclCreate()
{
	local name="$1" def="$2"
	consulAclPolicyCreate "$name" "$def" && consulAclTokenCreate "$name"
}

# consulAclDelete NAME - delete the ACL policy and token
consulAclDelete() { local name="$1"; consulAclPolicyRm "$name" && consulAclTokenRm "$name"; }

# consulAclPolicyCreate NAME DEF - create a policy with the specified name and definition
consulAclPolicyCreate()
{
	local name="$1" def="$2"
	consulAclPolicyExists "$name" && { [[ ! $force ]] && return; consulAclPolicyRm "$name" || return; }
	echo "$def" | RunLog consul acl policy create -name "$name" -rules -
}

# consulAclPolicyExists NAME - return true if the specified policy exists
consulAclPolicyExists()
{
	local name="$1"
	[[ "$(consul acl policy list -format=json | jq ".[] | select(.Name == \"$1\").Name" | RemoveQuotes)" == "$name" ]]
}

# consulAclPolicyGetId NAME - get the policy ID for the specified policy name
consulAclPolicyGetId()
{
	local name="$1" id; id="$(consul acl policy list -format=json | jq '.[] | select(.Name == "'"$name"'").ID' | RemoveQuotes	)" || return
	consulValidateId "$id" "$name" "policy"
}

# consulAclPolicyRm NAME - delete the specified policy
consulAclPolicyRm()
{
	local name="$1"; ! consulAclPolicyExists "$name" && return

	hilight "Deleting ACL policy $name..."
	RunLog consul acl policy delete -name "$name"
}

# cosulTokenExists NAME - return true if the tokenexists
consulAclTokenExists()
{
	local name="$1"
	[[ "$(consul acl token list -format=json | jq ".[] | select(.Description == \"$name\").Description" | RemoveQuotes)" == "$name" ]]
}

# consulAclTokenGetSecret NAME - get the token Secret ID with the specified name
consulAclTokenGetSecret()
{
	local name="$1"
	! consulAclTokenExists "$1" && { ScriptErr "token '$name' does not exists"; return 1; }
	consul acl token read -id "$(consulAclTokenGetId "$name")" | grep "SecretID" | cut -d: -f 2 | RemoveSpace
}

# consulAclPolicyGetId NAME - get the token accessor ID for the specified token name
consulAclTokenGetId()
{
	local name="$1" id; id="$(consul acl token list -format=json | jq '.[] | select(.Description == "'"$name"'").AccessorID' | RemoveQuotes	)" || return
	consulValidateId "$id" "$name" "token"
}

# consulAclTokenCreate NAME [POLICY] - create a token with the specified description that has the permission to the specified policy
consulAclTokenCreate()
{
	local name="$1" policy="${2:-$1}"
	consulAclTokenExists "$name" && { [[ ! $force ]] && return; consulAclTokenRm "$name" || return; }
	RunLog consul acl token create -description "$name" -policy-name "$policy"
}

# consulAclTokenRm NAME - delete the token with the specified name
consulAclTokenRm()
{
	local name="$1"; ! consulAclTokenExists "$name" && return
	local id; id="$(consulAclTokenGetId "$name")" || return

	hilight "Deleting ACL token $name..."
	RunLog consul acl token delete -id "$id"
}

#
# consul api Command
#

consulApiUsage() { echot "Usage: $(ScriptName) consul api [check|put] PATH -- [curl arguments]\nCall the Consul API.  For example:\nhashi consul api /status/leader"; }
consulApiArgStart() { unset path; }
consulApiArgs() { [[ "$command" == "consulApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

consulApi() { RunLog curl --silent --show-error --header "X-Consul-Token: $CONSUL_HTTP_TOKEN" "$CONSUL_HTTP_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }
consulApiCommand() { consulApi "$path" "${otherArgs[@]}"; }

consulApiPutCommand() { consulApiPut "$path" "${otherArgs[@]}"; }
consulApiPut() { consulApi "$@" --request PUT; }

consulApiCheckCommand() { consulApiCheck; }
consulApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" && { [[ ! $quiet ]] && ScriptErr "consul server $host is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" && { [[ ! $quiet ]] && ScriptErr "consul server $host is not available on port $port"; return 1; }	

	# check api
	consulApi "/status/leader" 2> /dev/null | RemoveQuotes | RemovePort | IsIpAddress && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the consul API at $(productVarGet "ADDR") is not available"; consulApi "/status/leader"; return 1; }

	return 0
}

#
# consul agent command
#

consulAgentUsage() { echot "Usage: $(ScriptName) consul agent [checks](checks)"; }
consulAgentCommand() { consulAgentChecksCommand; }
consulAgentChecksUsage() { echot "Usage: $(ScriptName) consul agent checks\nShow all health checks on the agent."; }
consulAgentChecksCommand() { consulApi "/agent/checks" | jq '.[].CheckID' | RemoveQuotes | sort; }

#
# consul service commands
#

consulServiceInit() { unset file; }

consulServiceUsage() { echot "\
Usage: $(ScriptName) consul service [add|clean|ls|rm](ls)
Consul service commands."; }

consulServiceCommand() { consulServiceLsCommand; }
consulServiceLsCommand() { consulServiceLs; }

#
# consul service add command
#

consulServiceAddUsage() { echot "\
Usage: $(ScriptName) consul service add FILE
Add a Consul service using the service definition in FILE.

- FILE must be JSON or HCL
- if FILE is HCL, the CLI is used to perform the registeration, which allows HCL but does not allow script checks
- if FILE is JSON
  - curl is used to perform the registeration, which allows script checks
  - the JSON must contain a service attribute to provide future compatibility with CLI registration"; }

consulServiceAddArgs() { ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift; }

consulServiceAddCommand()
{
	local id; id="$(consulServiceFileGetId "$file")" || return
	local type; type="$(configFileValidate "$file")" || return

	# create the service ACL
	consulAclCreate "service-$id" "$(cat <<-EOF
		service "$id" {
		  policy = "write"
		}
		EOF
	)" || return
	local token; token="$(consulAclTokenGetSecret "service-$id")" || return

	# add the service ACL token to the service file
	local f; f="$(${G}mktemp -t "hashi.service.XXXX.hcl")" || return
	if [[ "$type" == "json" ]]; then
		cat "$file" | jq '.[]' | sed "s/\"token\": \".*\"/\"token\": \"$token\"/" > "$f" || return
	else
		cat "$file" | sed "s/token = \".*\"/token = \"$token\"/" > "$f" || return
	fi

	# ensure the ACL token was added to the service file
	if ! grep --quiet "\"$token\"" "$f"; then
		ScriptErr "the token parameter was not found in the service file"
		return 1
	fi

	# register the service using curl for JSON as the CLI does not allow script checks
	[[ $verbose ]] && cat "$f"
	if [[ "$type" == "json" ]]; then
		consulApiPut "/agent/service/register?replace-existing-checks=true" --data @"$f" || return
	else
		RunLog consul services register "$f" || return
	fi

	# cleanup the file
	rm -f "$f"	

	return 0
}

#
# consul service clean command
#

consulServiceCleanUsage() { echot "Usage: $(ScriptName) consul service clean\nCleanup orphaned service policies and tokens."; }

consulServiceCleanCommand()
{
	local name id policies tokens

	# find orphan policies
	IFS=$'\n' policies=(
		$(FileLeft \
			<(consulAclPolicyLs | grep "^service-" | sed 's/service-//') \
			<(consulServiceLs))
	)

	# delete orphan policies
	for name in "${policies[@]}"; do
		echo "Deleting orphan policy 'service-$name'..."
		id="$(consulAclPolicyGetId "service-$name")" || return
		RunLog consul acl policy delete -id "$id"
	done

	# find orphan tokens
	IFS=$'\n' tokens=(
		$(FileLeft \
			<(consulAclTokenLs | grep "^service-" | sed 's/service-//') \
			<(consulServiceLs))
	)

	# delete orphan tokens
	for name in "${tokens[@]}"; do
		echo "Deleting orphan token 'service-$name'..."
		id="$(consulAclTokenGetId "service-$name")" || return
		RunLog consul acl token delete -id "$id"
	done
}

#
# consul service rm command
#

consulServiceRmUsage() { echot "Usage: $(ScriptName) consul service rm FILE|ID|NAME"; }
consulServiceRmArgs() { ScriptArgGet "service" -- "$@"; shift; }

consulServiceRmCommand()
{
	local id

	# get the service ID
	if [[ -f "$service" ]]; then # file
		id="$(consulServiceFileGetId "$service")" || return
	elif consulServiceIdExists "$service"; then # id
		id="$service"
	else # name
		id="$(consulServiceGetId "$service")" || return
	fi

	# deregister the service
	consulServiceIdExists "$id" && { consul services deregister -id "$id" || return; }

	# delete the service ACL
	consulAclDelete "service-$id" || return
}

# consul service helper commands

consulServiceLs() { consul catalog services; }

# consulServiceFileGetId FILE - return the service name from a service file
consulServiceFileGetId()
{
	local file="$1" type; type="$(consulServiceFileValidate "$file")" || return

	# get the service ID, which is the name if the ID attribute is not present
	local id
	if [[ "$type" == "json" ]]; then
		id="$(cat "$file" | jq ".service.id" | RemoveQuotes)"
		[[ ! $id || "$id" == "null" ]] && id="$(cat "$file" | jq ".service.name" | RemoveQuotes)"
	else
		id="$(cat "$file" | grep "id =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
		[[ ! $id ]] && id="$(cat "$file" | grep "name =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
	fi

	# check for a valid id
	[[ ! $id || "$id" == "null" ]] && { ScriptErr "unable to determine the service ID in '$file' (no name or id attribute)"; return 1; }

	# return the name
	echo "$id"
}

# consulServiceFileValidate FILE - return true and the configu file type if the file is a valid consul service file
consulServiceFileValidate()
{
	local type; type="$(configFileValidate "$file")" || return

	# check for the service attribute
	if [[ "$type" == "json" && "$(cat "$file" | jq ".service")" == "null" ]]; then
		ScriptErr "service attribute is required"
		return 1
	fi

	# return the type
	echo "$type"
}

# consulServiceGetId NAME - get the service ID for the specified service name
consulServiceGetId()
{
	local name="$1" id; id="$(consulApi "/agent/services" | jq '.[] | select(.Service == '"$name"').ID' | RemoveQuotes)" || return
	consulValidateId "$id" "$name" "service"
}

consulServiceIdExists()
{
	local id="$1"
	[[ "$(consulApi "/agent/services" | jq '.[] | select(.ID == "'"$id"'").ID' | RemoveQuotes)" == "$id" ]]; 
}

# consuleServiceIdValidate ID - return true if the ID is a consul service ID
consulServiceIdValidate()
{
	local id="$1"; consulServiceIdExists "$id" && return
	ScriptErr "a service with ID '$id' does not exist"
	return 1
}

# consul helper

# consulValidateId ID NAME WHAT - validate ID is correct for the given NAME.   WHAT is what we are validating.
consulValidateId()
{
	local id="$1" name="$2" what="$3"

	# check for a valid id
	[[ ! $id || "$id" == "null" ]] && { [[ ! $quiet ]] && ScriptErr "$what '$name' does not exist"; return 1; }

	# ensure there is only one WHAT with the specified name
	(( $(echo "$id" | wc -l) > 1 )) && { [[ ! $quiet ]] && ScriptErr "there is more than one $what with the name '$name'"; return 1; }

	# return the id
	echo "$id"
}

#
# install command
#

installUsage() { echot "\
Usage: $(ScriptName) install cli|service
Install a HashiCorp product."; }

installCommand() { usage; }

#
# install service command
#

installServiceUsage() { echot "\
Usage: $(ScriptName) install service all|cli|$productUsage
Install a HashiCorp product.

	-c, --clients	HOSTS		comma separated list of clients to install
	-s, --server HOSTS		comma separated list of servers to install
	-j, --join HOSTS			comma separated list of hosts to join to, defaults to servers
	$certOptUsage
	-w, --what=C1[,C2...] components to install: acl program service config
	                        cert (cert-local cert-make cert-public cert-service)"; }

installServiceArgStart() { unset force whatArg; clients=() servers=() join=() encrypt="true"; }

installServiceOpt()
{
	case "$1" in
		-c|--clients|-c=*|--clients=*) ScriptOptGet "clients" "$@"; StringToArray "$clients" "," clients;;
		-s|--servers|-s=*|--servers=*) ScriptOptGet "servers" "$@"; StringToArray "$1" "," servers;;
		-j|--join|-j=*|--join=*) ScriptOptGet "join" "$@"; StringToArray "$1" "," join;;
		-e|--encrypt|-e=*|--encrypt=*) encryptOptGet "$@";;
		-ne|--no-encrypt) unset encrypt;;
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		*) return 1;;
	esac
}

installServiceCommand() { usage; }
installServiceAllCommand() { installServiceConsulCommand && installServiceVaultCommand && installServiceNomadCommand; }
installServiceConsulCommand() { installService "consul"; }
installServiceNomadCommand() { installService "nomad"; }
installServiceVaultCommand() { installService "vault"; }

# install helper

installService()
{
	local product="$1" isServiceInstall="true"; serviceVars "$product" || return

	# common service options
	declare -Ag commonOptions=( [log_level]="info" )

	# add clients and servers from hostArg if specified
	if [[ $hostArg ]]; then
		local host hosts; StringToArray "$hostArg" "," hosts
		local defaultServers; configGetArray "servers" "defaultServers"
		for host in "${hosts[@]}"; do
			IsInArray "$host" defaultServers && servers+=( "$host" ) || clients+=( "$host" )
		done
		unset hostArg
	fi

	# use default clients and servers if needed
	if [[ ! $clients && ! $servers ]]; then
		if [[ "$product" == "vault" ]]; then
			clients=( )
			configGetArray "VaultServers" servers
		else
			configGetArray "clients"
			configGetArray "servers"
		fi
	fi

	hosts=( "${servers[@]}" "${clients[@]}" )

	# set join servers	
	[[ ! $join ]] && configGetArray "servers" "join"
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(hostFqdn "$h")" ); done

	if [[ $verbose ]]; then
		PrintErr "clients: "; ArrayShow clients
		PrintErr "servers: "; ArrayShow servers
		PrintErr "join: "; ArrayShow join
	fi

	# install
	local certDir tmpDir; tmpDir="$(tmpDirCreate)" || return	
	installServiceCertMake || return # current directory will be the private certificate directory
	installServiceProgram || return
	installServiceServers || return
	installServiceCertLocal || return
	installServiceServerFinal || return
	installServiceClients || return
	installServiceFinal || return
	installServiceCertPublic || return

	# cleanup
	unset servers clients; hostArg="$hostArgOrig"
	rm -fr "$tmpDir"
}

installServiceCertLocal() { header "Install Local Certificates" && certs && whatCheck "cert" "cert-local" && productInstallCerts "$product"; }
installServiceCertMake() { header "Create Certificates" && certMakeCd "$product" && certs && whatCheck "cert" "cert-make" && certMake "$product"; }
installServiceCertPublic() { header "Copy Public Certificates" && certs && whatCheck "cert" "cert-public" && certCopyPublic "$product"; }

installServiceAcl()
{
	{ ! whatCheck "acl" || isClient; } && return

	header "Install $(ProperCase "$product") ACL"
	productInit "$product" || return

	# generate the bootstrap token
	local header text
	local alreadyCreated="ACL bootstrap already done"; [[ "$product" == "consul" ]] && alreadyCreated="ACL bootstrap no longer allowed"
	local waitingForNodes="The ACL system is currently in legacy mode."
	
	# try up to 30 times to get the bootstrap text
	for (( i = 0; i < 30; i++ )); do
		text="$($product acl bootstrap 2>&1)" && break
		echo "$text" | grep -q "$alreadyCreated" && return
		echo "$text" | grep -q "$waitingForNodes" &&
			{ [[ $header ]] && printf "." || printf "bootstrap..."; header="true"; sleep 1; continue; }
		EchoErr "$text"; return 1
	done
	[[ $header ]] && echo
	echo "$text" | grep -q "$waitingForNodes" && { EchoErr "$text"; return 1; }
	
	# show the full bootstrap text
	hilight "Store the following bootstrap token in a secure location:"
	echo "$text"

	# get and store the token
	local secretId="Secret ID"; [[ "$product" == "consul" ]] && secretId="SecretID"
	local sep="="; [[ "$product" == "consul" ]] && sep=":"
	local token="$(echo "$text" | grep "$secretId" | cut -d$sep -f 2 | RemoveSpace)"
	[[ ! $token ]] && { ScriptErr "unable to determine the bootstrap token"; return 1; }
	credSet "token" "$token" || return

	productVarSet "TOKEN" "$token" || return
	log1 "updated environment variable $(productVar "TOKEN") to $(productVarGet "TOKEN")..."
}

installServiceClients()
{
	! whatCheck "service" && return

	for host in "${clients[@]}"; do
		installServiceDo "client" "$host" || return
	done
}

installServiceConfig()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$product")
		Documentation=https://www.hashicorp.com/products/$product
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$productConfigFile
		StartLimitIntervalSec=10
		StartLimitBurst=3

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$productServiceEnvFile
		KillMode=process
		KillSignal=$serviceKillSignal
		Restart=on-failure
		RestartSec=2
		TasksMax=infinity
		$serviceLimit

		[Install]
		WantedBy=multi-user.target
	EOF
}

installServiceDo()
{
	local type="$1" host="$2"
	local f hostFqdn hostIp
	local -A o; o=( ); ArrayAppend o commonOptions || return
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local serviceLimit="LimitNOFILE=infinity"$'\n'"LimitNPROC=infinity"
	local execStart="$program agent -config=$productConfigDir"
	local execReload="/bin/kill --signal HUP \$MAINPID"
	local exectStop=""
	local serviceKillSignal="SIGINT"

	# host information
	hostFqdn="$(hostFqdn "$host")" || return
	hostIp="$(GetIpAddress "$hostFqdn")" || return
	host="$(RemoveDnsSuffix "$hostFqdn")"

	# header
	header "Install $(ProperCase "$product") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	${G}mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return		

	# copy certificates
	certs && { FileCommand cp "$ca" "$certCli" "$certCliKey" "$tmpDir/cert" || return; }

	# environment
	printf "" > "$tmpDir/$product.env"

	# product specifics
	RunFunction "installServicePrep" "${product}"

	# create the configuration files
	installServiceProductConfig o > "$tmpDir/config/$productConfigFileBase" || return
	installServiceConfig > "$tmpDir/$product.service" || return

	# copy the files to the remote host
	copyDirRemote "$tmpDir" "$host" || return

	# run the installation script - do notuse only standard commands
	hilight "Running installation..."
	scriptRun "$host" "$(cat <<-EOF

		$(installServiceDoUser)

		$(installServiceDoDirectories)

		# files

		if [[ \$(sudo ls -A "$tmpDir/data") ]] && [[ ! \$(sudo ls -A "$productDataDir") || "$force" ]]; then
		  echo "Copying data files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$productDataDir" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/config") ]] && [[ ! -f "$productConfigDir/$productConfigFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$productConfigDir" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/cert") ]] && [[ ! \$(sudo ls -A "$certDirService") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$certDirService" "$tmpDir/cert/"* || exit
		fi

		$(scriptCertStore "$certDirService")

		# service		

		if [[ -f "$productServiceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudo systemctl stop "$product" || exit
		fi

		if [[ ! -f "$productServiceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudo cp "$tmpDir/$product.service" "$tmpDir/$product.env" "/etc/systemd/system" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl enable "$product" || exit
			sudo systemctl start "$product" --no-block || exit
		fi

		$(scriptCleanup)
		EOF
	)" || return

}

installServiceDoDirectories()
{
	cat <<-EOF
		if ! [[ -d "$certDirService" && -d "$productConfigDir" && -d "$productDataDir" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudo install -o "$user" -g "$user" -m 755 -d "$certDirService" "$productConfigDir" "$productDataDir" || exit
		fi
	EOF
}

installServiceDoUser()
{
	cat <<-EOF
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudo useradd --system --home-dir "$productConfigDir" --shell "/bin/false" "$user" || exit
		fi
	EOF
}

installServiceProgram()
{
	! whatCheck "program" && return

	local hosts=("${servers[@]}" "${clients[@]}")
	! InPath "$product" && other+="localhost"

	for host in "${hosts[@]}"; do
		header "Install $product Program ($host)"
		productInstall "$product" "$host" || return
	done
}

installServiceFinal() { RunFunction "installServiceFinal" "${product}" || return; }

installServiceFinalConsul() { installServiceFinalConsulAgentAcl; }

installServiceFinalConsulAgentAcl()
{
	! whatCheck "acl" && return

	# setup
	header "Agent ACL"	

	# deploy agent ACL's
	for host in "${hosts[@]}"; do
		 consulAclAgentDeploy "$host" || return
	done

	# change the ACL policy to deny
	for host in "${hosts[@]}"; do
		consulAclAgentDeny "$host" || return
	done
}


installServiceFinalNomad() 
{
	! whatCheck "config" && return

	header "Nomad Configuration"
	forAllHosts "nomadConfigEnableVault" && \
		forAllHosts "nomadConfigEnableDocker" && \
		forAllHosts "nomadConfigEnableRawExec" && \
		forAllHosts "serviceRestart" "nomad"
}

installServicePrepConsul()
{ 
	# options

	o+=(
		[domain]="$baseDomain"
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[client_addr]="0.0.0.0"
		[bind_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[advertise_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[advertise_addr_ipv6]='{{ GetAllInterfaces | include \"name\" \"eth0\" | include \"type\" \"IPv6\" | sort \"address\" | limit 1 | join \"address\" \" \" }}'
		[retry_join]="[ $(ArrayShow join ", ") ]"
		[leave_on_terminate]="true"
		[telemetry]="{ disable_compat_1.9 = true }"
		[acl]="$(cat <<-EOF
			{ 
			  enabled = true
			  default_policy = "allow"
			  enable_token_persistence=true
			}
			EOF
		)"
		[enable_script_checks]="true"
	)

	isServer && o+=(
		[server]="true"
		[bootstrap_expect]="${#join[@]}"
		[ui_config]="{ enabled = true }"
	)

	certs && o+=(
		[addresses]='{ https = "0.0.0.0" }'
		[ports]="{ http = -1, https = $consulHttpsPort }"
		[verify_incoming]="false"
		[verify_incoming_rpc]="true"
		[verify_outgoing]="true"
		[verify_server_hostname]="true"
	)

	certs && isClient && o+=(
		[ca_file]="$certDirService/$ca"
		[auto_encrypt]="$(cat <<-EOF
			{
			  tls = true
			  dns_san = [ "$hostFqdn" ]
			  ip_san = [ "$hostIp" ]
			}
			EOF
		)"		
	)

	# client certificates
	isClient && certs && { cp "$caAuto" "$tmpDir/cert" || return; }
	
	# server certificates
	if certs && isServer; then
		o+=(
			[ca_file]="$certDirService/$ca"
			[cert_file]="$certDirService/$certServer"
			[key_file]="$certDirService/$certServerKey"
			[auto_encrypt]="{ allow_tls = true }"
		)
		certMakeConsulServer "$host" "$tmpDir/cert" || return
	fi

	# service options
	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$program agent -config-dir=$productConfigDir"
	serviceKillSignal="SIGTERM"
}

installServicePrepNomad()
{
	# options
	local token; token="$(product="consul" credGet "token" --quiet)"; [[ ! $token ]] && { ScriptErr "unable to get a Consul token for Nomad"; return 1; }
	local port; port="$(productGetPort "consul" "$(protocol)")" || return

	o+=( 
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[acl]="{ enabled = true }"
		[client]="{ enabled = true }"
		[consul]="$(cat <<-EOF
			{
			  token = "$token"
			  address = "127.0.0.1:$port"
			}
			EOF
		)"
	)
	
	isServer && o+=(
		[server]="$(cat <<-EOF
			{
			  enabled = true
			  bootstrap_expect = "${#join[@]}"
			  raft_protocol = 3
			}
			EOF
		)"
	)

	certs && isClient && o+=(
		[tls]="$(cat <<-EOF
			{ 
			  http = true
			  rpc = true
			  ca_file = "$certDirService/$ca"
			  cert_file = "$certDirService/$certClient"
			  key_file = "$certDirService/$certClientKey"
			  verify_server_hostname = false
			  verify_https_client = false
			}
			EOF
		)"
	)

	certs && isServer && o+=(
		[tls]="$(cat <<-EOF
			{
			  http = true
			  rpc = true
			  ca_file = "$certDirService/$ca"
			  cert_file = "$certDirService/$certServer"
			  key_file = "$certDirService/$certServerKey"
			  verify_server_hostname = false
			  verify_https_client = false
			}
			EOF
		)"		
	)

	# certificates
	certs && isClient && { cp "$$ca" "$certClient" "$certClientKey" "$tmpDir/cert" || return; }
	certs && isServer && { cp "$ca" "$certServer" "$certServerKey" "$tmpDir/cert" || return; }

	# consul encryption environment variables
	if certs; then
		certInit "consul" || return 
	
		cat > "$tmpDir/$product.env" <<-EOF
			CONSUL_HTTP_SSL=true
			CONSUL_CACERT=$certDirService/$caLocal
			CONSUL_CLIENT_CERT=$certDirService/$certServer
			CONSUL_CLIENT_KEY=$certDirService/$certServerKey
		EOF

		certInit "nomad" || return
	fi
}

installServicePrepVault()
{
	# certificates
	local certListenerConfig certConsulConfig
	if certs; then

		certListenerConfig="$(cat <<-EOF

			tls_client_ca_file = "$certDirService/$ca"
		  tls_cert_file = "$certDirService/$certServer"
		  tls_key_file = "$certDirService/$certServerKey"
			EOF
		)"
		certMakeVaultServer "$host" "$tmpDir/cert" || return

		certInit "consul" || return
		certConsulConfig="$(cat <<-EOF

		  tls_ca_file = "$certDirService/$ca"
		  tls_cert_file = "$certDirService/$certCli"
		  tls_key_file = "$certDirService/$certCliKey"
			EOF
		)"
		certInit "vault" || return

	fi

	# options
	local token; token="$(product="consul" credGet "token")" || return
	
	o+=(
		[listener]="\"tcp\" $(cat <<-EOF
			{
			  address = "0.0.0.0:$(productGetPort "$product" "$(protocol)")"$certListenerConfig
			}
			EOF
		)"

		[storage]="\"consul\" $(cat <<-EOF
			{
			  token = "$token"
			  path = "vault/"
			  address = "127.0.0.1:$(productGetPort "consul" "$(protocol)")"
			  scheme = "$(protocol)"$certConsulConfig
			}
			EOF
		)"

		[service_registration]="\"consul\" $(cat <<-EOF
				{
				  token = "$token"
				  address="127.0.0.1:$(productGetPort "consul" "$(protocol)")"
				  scheme="$(protocol)"$certConsulConfig
				}
			EOF
		)"

		[api_addr]="https://$hostFqdn:$vaultHttpsPort"
	)

	isServer && o+=( [ui]="true" )

	# service options
	execStart="$program server -config=$productConfigDir"
	serviceLimit+=$'\n'"LimitMEMLOCK=infinity"
}

# installServiceProductConfig VAR... - turn the passed array variables into an HCL script
installServiceProductConfig()
{
	local key var

	for var in "$@"; do
		local -n config="$var"

		for key in "${!config[@]}"; do

			local equal=" =" quote="true" v="${config[$key]}"
			local fc="${v:0:1}" sc="${v:1:1}" # first and second characters

			# example: addresses { https = "0.0.0.0" }
			[[ "$fc" == "{" && "$sc" != "{" ]] && quote="" equal=""

			# example: retry_join = [ "pi3", "pi4" ]
			[[ "$fc" == "[" ]] && quote=""

			# listener "tcp" { address = "0.0.0.0:8200", tls_disable = 1 }
			[[ "$fc" == "\"" ]] && quote="" equal=""

			# boolean, example: server = true			
			[[ "$v" == @(true|false) ]] && quote=""

			# integer, example: bootstrap_expect = 2
			IsInteger "$v" && quote=""

			[[ $quote ]] && echo "$key$equal \"${config[$key]}\"" || echo "$key$equal ${config[$key]}"

		done

	done
}

installServiceServerFinal() { RunFunction "installServiceServerFinal" "${product}"; }

installServiceServerFinalConsul()
{
	certs && { certMakeConsulCaAuto || return; }
	installServiceAcl || return
}

installServiceServerFinalNomad() { installServiceAcl && installServiceServerFinalNomadVaultIntegration; }

installServiceServerFinalNomadVaultIntegration()
{	
	header "Install Nomad Vault Integration"

	local policy; productInit "vault" || return

	# nomad-cluster policy - policy for jobs (specifiy in job configuration)
	if ! vault policy list | grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster policy to Vault..."
		local policy="$(cat <<-EOF
			path "secret/*" {
			  capabilities = ["read"]
			}
			EOF
		)"
		echo "$policy" | vault policy write nomad-cluster - || return
	fi

	# nomad-cluster role - role Nomad uses to create tokens for jobs (specifies which policies jobs can request)
	if ! vault list "/auth/token/roles" |& grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster role to Vault..."
		policy="$(policyDownload "https://nomadproject.io/data/vault/nomad-cluster-role.json")" || return
		vault write /auth/token/roles/nomad-cluster @"$policy" || return
	fi

	# nomad-server policy - policy for the token Nomad uses to access Vault
	if ! vault policy list | grep -q "^nomad-server$"; then
		hilight "Adding the nomad-server policy to Vault..."
		policy="$(policyDownload "https://nomadproject.io/data/vault/nomad-server-policy.hcl")" || return
		vault policy write nomad-server "$policy" || return
	fi
}


installServiceServerFinalVault()
{
	# generate the unseal keys
	local n key result s seals; seals="$(vault operator init 2>&1)"; result="$?"
	echo "$seals" | grep -q "Vault is already initialized" && return
	(( result != 0 )) && { EchoErr "$seals"; return 1; }

	# show the seal keys
	hilight "Store the following vault unseal keys in a secure location:"
	echo "$seals"

	# store the root token
	declare token; token="$(echo "$seals" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credSet "token" "$token" || return
	export VAULT_TOKEN="$token"

	# store the seal keys
	IFS=$'\n' seals=( $(echo "$seals" | grep "Unseal Key") )
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credSet "key$n" "$key" || return
	done

	# store the Vault token on a remote server
	vaultTokenSetRemote || return

	# unseal vault
	vaultUnsealCommand || return

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | grep -q "^secret"; then
		header "Vault Configuration"
		vault secrets enable -path=secret kv-v2 || return
	fi
}

installServiceServers()
{
	! whatCheck "service" && return

	for host in "${servers[@]}"; do
		installServiceDo "server" "$host" || return
	done
}

#
# install cli command
#

installCliUsage() {	echot "\
Usage: $(ScriptName) install cli all|$productUsage
Install a HashiCorp program and certificates for command line access.

	$certOptUsage
	-w, --what=C1[,C2...] components to install: cert cred program"; }

installCliArgStart() { unset whatArg yes; }

installCliOpt()
{
	case "$1" in
		-e|--encrypt|-e=*|--encrypt=*) encryptOptGet "$@";;
		-ne|--no-encrypt) unset encrypt;;
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		*) return 1;;
	esac
}

installCliCommand() { usage; }
installCliAllCommand() { local product; for product in vault consul nomad; do installCli "$product" || return; done; }
installCliConsulCommand() { installCli "consul"; }
installCliNomadCommand() { installCli "nomad"; }
installCliVaultCommand() { installCli "vault"; }

installCli()
{
	local product="$1"; initConfig "$product" || return

	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be installed locally"; return 1; }
	
	whatCheck "program" && { productInstall "$product" "localhost" || return; }
	whatCheck "cert" && { productInstallCerts "$product" || return; }
	whatCheck "cred" && InPath vault && { configSetLocal "$product" || return; }

	return 0
}

#
# nomad commands
#

nomadUsage() { echot "\
Usage: $(ScriptName) nomad api|config|environment|node|job|status
Nomad commands."; }

nomadCommand() { usage; }
nomadEnvironmentCommand() { productEnvironment "$product"; }
nomadStatusCommand() { nomad node status; }

#
# nomad api command
#

nomadApiUsage() { echot "Usage: $(ScriptName) nomad api [check|put] PATH -- [curl arguments]\nCall the Nomad API.  For example:\nhashi nomad api /nodes?resources=true"; }
nomadApiArgStart() { unset path; }
nomadApiArgs() { [[ "$command" == "nomadApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

nomadApiCommand() { nomadApi "$path" "${otherArgs[@]}"; }
nomadApi() { RunLog curl --silent --show-error --header "X-Nomad-Token: $NOMAD_TOKEN" "$NOMAD_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }

nomadApiPutCommand() { nomadApiPut "$path" "${otherArgs[@]}"; }
nomadApiPut() { nomadApi "$@" --request PUT; }

nomadApiCheckCommand() { nomadApiCheck; }
nomadApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" && { [[ ! $quiet ]] && ScriptErr "nomad server $host is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" && { [[ ! $quiet ]] && ScriptErr "nomad server $host is not available on port $port"; return 1; }	

	# check api
	nomadApi "/status/leader" 2> /dev/null | RemoveQuotes | RemovePort | IsIpAddress && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the nomad API at $(productVarGet "ADDR") is not available"; nomadApi "/status/leader"; return 1; }

	return 0
}

#
# nomad config commands
#

nomadConfigUsage() { echot "\
Usage: $(ScriptName) nomad config enable|disable docker|RawExec|vault
Enable or disable Nomad functionality."; }

nomadConfigCommand() { usage; }
nomadConfigEnableCommand() { usage; }
nomadConfigDisableCommand() { usage; }

nomadConfigEnableDockerCommand() { forAllHosts nomadConfigEnableDocker; }
nomadConfigDisableDockerCommand() { forAllHosts serviceConfigDelete "nomad" "10_docker.hcl"; }

nomadConfigEnableRawexecCommand() { forAllHosts nomadConfigEnableRawExec; }
nomadConfigDisableRawexecCommand() { forAllHosts serviceConfigDelete "nomad" "10_raw_exec.hcl"; }

nomadConfigEnableVaultCommand() { forAllHosts nomadConfigEnableVault; }
nomadConfigDisableVaultCommand() { forAllHosts serviceConfigDelete "nomad" "20_vault.hcl"; }

# nomadConfigEnablDocker HOST
nomadConfigEnableDocker()
{
	serviceConfigCopyText "nomad" "$1" "10_docker.hcl" "$(cat <<-EOF
		plugin "docker" {
		  config {
		    volumes {
		      enabled = true
		    }
		  }
		}
		EOF
	)"
}

# nomadConfigEnableRawExec HOST
nomadConfigEnableRawExec()
{
	serviceConfigCopyText "nomad" "$1" "10_raw_exec.hcl" "$(cat <<-EOF
		plugin "raw_exec" {
		  config {
		    enabled = true
		  }
		}
		EOF
	)"
}

# nomadConfigEnableVault HOST
nomadConfigEnableVault()
{
	local host="$1"
	
	# Vault integration requires vault executable and service certificates
	productInstall "vault" "$host" || return
	updateServiceCert "vault" "$host" || return

	# certificate configuration
	local certConfig
	if certs; then
		certInit "vault" || return
		certConfig="$(cat <<-EOF

		  ca_file = "$certDirService/$caLocal"
		  cert_file = "$certDirService/$certCli"
		  key_file = "$certDirService/$certCliKey"
			EOF
		)"
		certInit "nomad" || return
	fi

	# server configuration
	local server serverConfig; server="$(serviceIsServer "nomad" "$host")" || return
	if [[ "$server" == "true" ]]; then

		# create token for Nomad to access vault - Nomad will renew the token every 72h
		local token; token="$(vault token create -display-name nomad-server -policy nomad-server -period 72h -orphan -format=json | jq '.auth.client_token' | RemoveQuotes)" || return

		serverConfig="$(cat <<-EOF

		  create_from_role = "nomad-cluster"
		  token = "$token"
			EOF
		)"
	fi

	# configuration	
	serviceConfigCopyText "nomad" "$host" "02_vault.hcl" "$(cat <<-EOF
		vault {
		  enabled = true
		  address = "$(serviceDnsName "active.vault")"$certConfig$serverConfig
		}
		EOF
	)"
}

#
# nomad node commands
#

nomadNodeUsage() { echot "Usage: $(ScriptName) nomad node drain|id\nNomad node commands."; }
nomadNodeCommand() { usage; }
nomadNodeIdCommand() { forAllHosts nomadGetNodeId; }

# nomadGetNodeId HOST
nomadGetNodeId()
{
	local host="$1"
	local id; id="$(nomad node status -json | jq '.[] | select(.Name == "'"$host"'").ID' | RemoveQuotes)" || return
	echo "$id"; [[ $id ]]
}

#
# nomad node drain commands
#

nomadNodeDrainUsage() { echot "Usage: $(ScriptName) nomad node drain enable|disable|id\nNomad node drain commands."; }

nomadNodeDrainCommand() { usage; }
nomadNodeDrainEnableCommand() { forAllHosts nomadNodeDrainEnable; }
nomadNodeDrainDisableCommand() { forAllHosts nomadNodeDrainDisable; }

# nomadNodeDrainEnable HOST
nomadNodeDrainEnable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return
	local forceArg; [[ $force ]] && forceArg="-deadline 1m"

	hilight "Draining Nomad on node $host..."
	RunLog nomad node drain -enable -yes $forceArg "$id" && echo
}

# nomadNodeDrainDisable HOST
nomadNodeDrainDisable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	hilight "Bringing Nomad node $host back online..."
	RunLog nomad node drain -disable -yes "$id" && echo
}

#
# nomad node eligibility commands
#

nomadNodeEligibilityUsage() { echot "Usage: $(ScriptName) nomad node eligibility enable|disable|id\nNomad node eligibility commands."; }

nomadNodeEligibilityCommand() { usage; }
nomadNodeEligibilityEnableCommand() { forAllHosts nomadNodeEligibilityEnable; }
nomadNodeEligibilityDisableCommand() { forAllHosts nomadNodeEligibilityDisable; }

# nomadNodeEligibilityEnable HOST
nomadNodeEligibilityEnable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	hilight "Making Nomad node $host eligible..."
	RunLog nomad node eligibility -enable "$id"
}

# nomadNodeEligibilityDisable HOST
nomadNodeEligibilityDisable()
{
	local host="$1" id; id="$(nomadGetNodeId "$host")" || return

	hilight "Making Nomad node $host ineligible..."
	RunLog nomad node eligibility -disable "$id"
}

#
# nomad job commands
#

nomadJobUsage() { echot "\
Usage: $(ScriptName) nomad job NAME
Nomad job commands.

	force	NAME		force a periodic job to start
	log	NAME			show the log for a periodic job
	run NAME			run or update a job
	status [NAME]	status of all running jobs or the specified job"; }

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() { nomadJobStatusCommand; }

# nomad job run
nomadJobRunCommand()
{
	[[ -f "$CLOUD/network/system/hashi/job/$job.hcl" ]] && job="$CLOUD/network/system/hashi/job/$job.hcl"
	ScriptCheckFile "$job" || return
	nomad run "$job" "${otherArgs[@]}" || return
}

# nomad job status 
nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | grep -v dead
	fi
}

# nomnd job force command

nomadJobForceUsage() { echot "\
Usage: $(ScriptName) nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"; }

nomadJobForceArgStart() { log=""; }

nomadJobForceOpt() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogUsage() { echot "\
Usage: $(ScriptName) nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"; }

nomadJobLogArgStart() { follow=""; }

nomadJobLogOpt() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId" "${otherArgs[@]}"
		header "Standard Error"; nomad alloc logs -stderr "$allocId" "${otherArgs[@]}"
	fi		
}

# nomad helper

# nomadClientName ID - return the name of the Nomad client with ID
nomadClientName() { nomad status "$1" | grep "^Name " | tr -s ' ' | cut -d"=" -f2 | RemoveSpace; }

# nomadClients - return all Nomad client ID's
nomadClients() { nomad node status | tail +2 | cut -d" " -f1; }

# nomadGetJobId - get the job ID for $job 
nomadGetJobId()
{ 
	jobId="$(nomad job status "$job" |& tail -1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job '$job'"; exit 1
}

# nomadGetAllocId - get the allocation ID for the $jobId or $job 
nomadGetAllocId()
{
	[[ ! $jobId ]] && { nomadGetJobId || return; }
	allocId="$(nomad job status "$jobId" |& tail -1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job '$job'"; exit 1
}

# nomadVaultStatus - show the status of the Vault integration for all Nomad clients
nomadVaultStatus()
{
	hilight "Nomad Vault integration status:"
	for id in $(nomadClients); do 
		echo "$(nomadClientName "$id"): $(nomad status -verbose "$id" | grep "^vault.accessible" | tr -s " " | cut -d"=" -f2 | RemoveSpace)"; 
	done
}

#
# remove command
#

removeUsage() { echot "\
Usage: $(ScriptName) remove all|cli|$productUsage
Remove a HashiCorp product configuration and data.

	-w, --what=C1[,C2...] components to remove: program service
		$configWhat"; }

removeArgStart() { unset whatArg yes; }

removeOpt()
{
	case "$1" in
		-w|--what|-w=*|--what=*) whatArgGet "$@";;
		-y|--yes) yes="--yes";;
		*) return 1;;
	esac
}

removeOptArgEnd()
{
	[[ ! $what ]] && MissingOption "what"

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To remove '$what' from $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi
}

removeCommand() { removeAllCommand; }
removeAllCommand() { removeDo "vault" && removeDo "nomad" && removeDo "consul"; }
removeConsulCommand() { removeDo "consul"; }
removeNomadCommand() { removeDo "nomad"; }
removeVaultCommand() { removeDo "vault"; }

removeDo()
{
	local product="$1"
	whatCheckConfig && { removeConfig "$product" || return; }
	whatCheck "service" && { removeService || return; }
	return 0
}

removeService()
{
	local removeProgram; whatCheck "program" && removeProgram="true"

	local host hosts; getHosts "all" || return
	for host in "${hosts[@]}"; do
		header "Remove $(ProperCase "$product") Service ($host)"
		serviceRemove "$product" "$host" || return
	done
}

#
# remove cli command
#

removeCliUsage() { echot "\
Usage: $(ScriptName) remove cli all|$productUsage
Remove a HashiCorp program and certificates used for command line access."; }

removeCliCommand() { local product; for product in "${products[@]}"; do removeCli "$product" || return; done; }
removeCliConsulCommand() { removeCli "consul"; }
removeCliNomadCommand() { removeCli "nomad"; }
removeCliVaultCommand() { removeCli "vault"; }

removeCli() 
{ 
	local product="$1"
	[[ $hostArg || $servers || $clients ]] && { EchoErr "$product CLI can only be removed locally"; return 1; }
	whatCheck "config" && { certInit "$product" && removeDir "$(certDirLocal "$product")"; }
	whatCheck "program" && { RunLog sudo rm -f "/usr/local/bin/$product" || return; }
	return 0
}

#
# resolve command
#

resolveUsage()
{
	echot "Usage: $(ScriptName) resolve [api|dig|name|nslookup|passing|list](passing) SERVICE
Resolve the nodes of a service.

	Resolve using Consul DNS servers:
	name				return passing service node DNS names
	passing			return passing service node IP addresses
	dig					use dig to return passing service nodes
	nslookup		use nslookup to return passing servers

	Resolve using the Consul API:
	api					use the API to return all service nodes detail as JSON
	list				return a list of passing service node names from the API

  -a, --all		return all passing service nodes instead of the first"
}

resolveArgStart() { unset -v all name; }
resolveArgs() { ScriptArgGet "name" -- "$@"; shift; }

resolveOpt()
{
	case "$1" in
		-a|--all) all="true";;
		*) return 1;;
	esac
}

resolveCommand() { resolvePassingCommand; }
resolvePassingCommand() { resolve "$name" "$all"; }

resolveApiCommand()
{
	log1 "using API to resolve the '$name' service"
	local product="consul"; noToken="true" productInit "$product" || return
	test="" RunLog curl --silent --show-error "$(productVarGet "ADDR")/v1/catalog/service/$name"
}

resolveDigCommand()
{
	log1 "using dig to resolve the '$name' service"
	name="$(serviceDnsName "$name")" || return
	local server; server="$(getDnsServer)" || return
	test="" RunLog dig "@$server" -p 8600 "$name" SRV
}

resolveListCommand()
{
	log1 "using API to resolve the '$name' service to a list of available nodes from the API"
	test="" resolveApiCommand | jq ".[].Node" | RemoveQuotes
}

resolveNameCommand()
{
	local ip ips; ips="$(resolvePassingCommand | sort --numeric)" || return
	for ip in ${ips[@]}; do
		DnsResolve "$ip" || return
	done
}

resolveNslookupCommand()
{
	log1 "using nslookup to resolve the '$name' service"
	name="$(serviceDnsName "$name")" || return
	local server; server="$(getDnsServer)" || return
	test="" RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server"
}

resolve()
{
	local name="$1" all="$2"
	local filter=(head -1); [[ $all ]] && { filter=(cat); }

	if InPath dig; then
		resolveDig "$name" | "${filter[@]}" || return
	elif InPath "nslookup" && ! IsBusyBox; then # nslookup does not work properly on BusyBox
		resolveNslookup "$name" | "${filter[@]}" || return
	else
		[[ ! $quiet ]] && HostUnresolved "$name"; return 1
	fi
}

resolveDig()
{
	local name; name="$(serviceDnsName "$1")" || return
	local server; server="$(getDnsServer)" || return
	local ip; ip="$(test="" RunLog dig "@$server" -p 8600 "$name" A +short)"
	[[ ! $ip ]] && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }
	log1 "dig resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

resolveNslookup()
{
	local name; name="$(serviceDnsName "$1")" || return
	local server; server="$(getDnsServer)" || return

	local result; result="$(test="" RunLog nslookup -port=8600 -type=a -norecurse "$name" "$server")"
	(( $? != 0 )) && { [[ ! $quiet ]] && HostUnresolved "$name"; return 1; }

	local ip
	if [[ "$result" =~ .*canonical\ name.* ]]; then
		ip="$(printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//')"
	else
		ip="$(printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace)"
	fi
	
	log1 "nslooklup resolved '$name' to '$(echo "$ip" | NewlineToSpace | RemoveSpaceTrim)'"
	echo "$ip"
}

#
# update command
#

updateUsage() { echot "usage: $(ScriptName) update cli|service"; }
updateCommand() { usage; }

# update cli command
updateCliUsage() { echot "usage: $(ScriptName) update cli cert|program"; }
updateCliCommand() { usage; }

# update cli cert command
updateCliCertUsage() { echot "usage: $(ScriptName) update cli cert all|$productUsage"; }
updateCliCertCommand() { usage; }
updateCliCertAllCommand() { updateCliCertConsulCommand && updateCliCertNomadCommand && updateCliCertVaultCommand; }
updateCliCertConsulCommand() { forAllHosts updateCliCert "consul"; }
updateCliCertNomadCommand() { forAllHosts updateCliCert "nomad"; }
updateCliCertVaultCommand() { forAllHosts updateCliCert "vault"; }

# updateCliCert PRODUCT HOST
updateCliCert()
{
	local product="$1" host="$2"; certInit "$product" || return
	local src; src="$(certPublicFind "$product")" || return
	local dest="$(certDirSuffix "$product" "/opt/hashi")" # always install certificates to /opt/hashi 

	# copy certificates to a temporary directory
	local tmpDir; tmpDir="$(tmpDirCreate)" || return
	FileCommand cp "$src/$ca" "$src/$certCli" "$src/$certCliKey" "$tmpDir" || return
	[[ -f "$src/$caAuto" ]] && { FileCommand cp "$src/$caAuto" "$tmpDir" || return; }

	# copy certificates to the host
	copyDirRemote "$tmpDir" "$host" || return

	# install the new certificates on the host
	scriptRun "$host" "$(cat <<-EOF
		
		echo "Installing ${product^} certificates..."
		sudo install --backup=numbered -m 644 -t "$dest" "$tmpDir/"* || exit

		$(scriptCertStore "$dest")
		$(scriptCleanup)
		EOF
	)" || return

	# cleanup
	rm -fr "$tmpDir"
}

# update cli program command
updateCliProgramUsage() { echot "usage: $(ScriptName) update cli program all|$productUsage"; }
updateCliProgramAllCommand() { updateCliProgramConsulCommand && updateCliProgramNomadCommand && updateCliProgramVaultCommand; }
updateCliProgramConsulCommand() { forAllHosts updateCliProgram "consul"; }
updateCliProgramNomadCommand() { forAllHosts updateCliProgram "nomad"; }
updateCliProgramVaultCommand() { forAllHosts updateCliProgram "vault"; }

# updateCliProgram PRODUCT HOST - assumes the host is not running the product service
updateCliProgram()
{
	local product="$1" host="$2"
	
	header "Update $(ProperCase "$product") CLI ($host)"

	# return if the product installation is not needed
	productInstallCheck "$product" "$host" || return; [[ ! $installNeeded ]] && return

	# install the product
	productInstallDo "$product" "$host"
}

# update service command
updateServiceUsage() { echot "usage: $(ScriptName) update service cert|program"; }
updateServiceCommand() { usage; }

# update service cert command
updateServiceCertUsage() { echot "usage: $(ScriptName) update service cert all|$productUsage"; }
updateServiceCertCommand() { usage; }
updateServiceCertAllCommand() { updateServiceCertConsulCommand && updateServiceCertNomadCommand && updateServiceCertVaultCommand; }
updateServiceCertConsulCommand() { forAllHosts updateServiceCert "consul"; }
updateServiceCertNomadCommand() { forAllHosts updateServiceCert "nomad"; }
updateServiceCertVaultCommand() { forAllHosts updateServiceCert "vault"; }

# updateServiceCert PRODUCT HOST
updateServiceCert()
{
	local product="$1" host="$2"; serviceVars "$product" || return; certMakeCd "$product" || return
	
	# copy certificates to a temporary directory
	local tmpDir; tmpDir="$(tmpDirCreate)" || return
	FileCommand cp "$ca" "$certCli" "$certCliKey" "$tmpDir" || return

	# only copy the server certifcates for servers
	local server; server="$(serviceIsServer "$product" "$host")" || return
	[[ "$server" == "true" ]] && { certMake${product^}Server "$host" "$tmpDir/cert" || return; }

	# copy certificates to the host
	copyDirRemote "$tmpDir" "$host" || return

	# install the new certificates on the host
	scriptRun "$host" "$(cat <<-EOF
		$(installServiceDoUser)
		$(installServiceDoDirectories)
		sudo install --backup=numbered -o "$user" -g "$user" -m 755 -t "$certDirService" "$tmpDir/"* || exit
		$(scriptCleanup)
		EOF
	)" || return

	# restart the service on the host
	[[ "$server" == "true" ]] && { serviceRestart "$product" "$host" || return; }

	# cleanup
	rm -fr "$tmpDir"
}

# update service program command
updateServiceProgramUsage() { echot "usage: $(ScriptName) update service program all|$productUsage"; }
updateServiceProgramAllCommand() { updateServiceProgramConsulCommand && updateServiceProgramNomadCommand && updateServiceProgramVaultCommand; }
updateServiceProgramConsulCommand() { forAllHosts updateServiceProgram "consul"; }
updateServiceProgramNomadCommand() { forAllHosts updateServiceProgram "nomad"; }
updateServiceProgramVaultCommand() { forAllHosts updateServiceProgram "vault"; }

# updateServiceProgram PRODUCT HOST
updateServiceProgram()
{
	local product="$1" host="$2"
	
	header "Update $(ProperCase "$product") Service ($host)"

	# return if the product installation is not needed
	productInstallCheck "$product" "$host" || return; [[ ! $installNeeded ]] && return

	# install the product
	RunFunction "updateStart" "$product" && productInstallDo "$product" "$host" && RunFunction "updateEnd" "$product"
}

updateStartNomad() { nomadNodeDrainEnable "$host"; }
updateEndNomad() { nomadNodeDrainDisable "$host"; }

#
# service commands
#

serviceUsage() { echot "Usage: $(ScriptName) service config|IsServer|monitor|restart|start|stop $productUsage\nControl Hashi product services."; }

serviceCommand() { usage; }

serviceConfigUsage() { echot "Usage: $(ScriptName) service config $productUsage VAR\nReturn a service configuration variable."; }
serviceConfigCommand() { usage; }
serviceConfigArgs() { ScriptArgGet "varArg" "var" -- "$@"; }
serviceConfigConsulCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "consul"; }
serviceConfigNomadCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "nomad"; }
serviceConfigVaultCommand() { forAllHosts "serviceConfigVarGet" "$varArg" "vault"; }

serviceIsServerCommand() { usage; }
serviceIsServerConsulCommand() { forAllHosts "serviceIsServer" "consul"; }
serviceIsServerNomadCommand() { forAllHosts "serviceIsServer" "nomad"; }
serviceIsServerVaultCommand() { forAllHosts "serviceIsServer" "vault"; }

serviceMonitorCommand() { usage; }
serviceMonitorConsulCommand() { serviceMonitorDo "consul"; }
serviceMonitorNomadCommand() { serviceMonitorDo "nomad"; }
serviceMonitorVaultCommand() { serviceMonitorDo "vault"; }
serviceMonitorDo() { productInit "$1" && "$1" monitor; }

serviceRestartCommand() { usage; }
serviceRestartConsulCommand() { forAllHosts serviceRestart "consul"; }
serviceRestartNomadCommand() { forAllHosts serviceRestart "nomad"; }
serviceRestartVaultCommand() { forAllHosts serviceRestart "vault"; }

serviceStartCommand() { usage; }
serviceStartConsulCommand() { forAllHosts serviceStart "consul"; }
serviceStartNomadCommand() { forAllHosts serviceStart "nomad"; }
serviceStartVaultCommand() { forAllHosts serviceStart "vault"; }

serviceStopCommand() { usage; }
serviceStopConsulCommand() { forAllHosts serviceStop "consul"; }
serviceStopNomadCommand() { forAllHosts serviceStop "nomad"; }
serviceStopVaultCommand() { forAllHosts serviceStop "vault"; }

# service helper

# hostCopy PRODUCT HOST FILE - copy a service configuration file to the host destination directory with the correct permissions
serviceConfigCopy()
{
	local product="$1" host="$2" file="$3"; serviceVars "$product" || return
	local name="$(GetFileName "$file")" exists; productServiceConfigReturn && return

	serviceConfigCopyStart && LogFile2 "$file" && RunLog scp "$file" "$host:/tmp" && serviceConfigCopyEnd 
}

# serviceConfigCopyText PRODUCT HOST NAME TEXT - copy text to a service configuration file on the host
serviceConfigCopyText()
{
	local product="$1" host="$2" name="$3" text="$4"; serviceVars "$product" || return
	local exists; productServiceConfigReturn && return

	serviceConfigCopyStart && sshRun "$host" "cat <<-EOF > /tmp/$name
		$text
		EOF" && serviceConfigCopyEnd
}

productServiceConfigReturn()
{
	hostFileExists "$host" "$productConfigDir/$name" && exists="true"
	[[ $isServiceInstall && ! $force && $exists ]]
}

# serviceConfigCopyStart - start copying a service configuration file
serviceConfigCopyStart()
{
	# check if the configuration file alreadys exists
	[[ ! $force && $exists ]] && { ScriptErr "configuration file '$name' already exists, use --force to overwrite"; return 1; }
	
	# logging
	hilight "Copying '$name' to $host:$productConfigDir..."
}

# serviceConfigCopyEnd - finish copying a service configuration file
serviceConfigCopyEnd()
{
	local dest="$productConfigDir/$name"

	# move and set permissions on the configuration file
	RunLog scriptRun "$host" "$(cat <<-EOF
		sudo mv "/tmp/$name" "$dest" || exit
		sudo chmod 600 "$dest" || exit
		sudo chown "$user" "$dest" || exit
		sudo chgrp "$user" "$dest" || exit
		EOF
	)"
}

# serviceConfigDelete PRODUCT FILE HOST - delete a service configuration file on the host
serviceConfigDelete()
{
	local product="$1" file="$2" host="$3"; serviceVars "$product" || return
	local dest="$productConfigDir/$file"

	RunLog scriptRun "$host" "$(cat <<-EOF
		[[ ! -f "$dest" ]] && exit 0
		sudo rm "$dest"
		EOF
	)"
}

# serviceConfigVarGet VAR PRODUCT HOST - get a variable from the product configuration file, return error if the variable does not exist
serviceConfigVarGet() 
{
	local var="$1" product="$2" host="$3"; serviceVars "$product" || return;
	scriptRun "$host" "grep \"[ ]*$var[ ]*=[ ]*\" \"$productConfigFile\"" | tr -s " " | cut -d"=" -f2 | RemoveCarriageReturn | RemoveSpace | RemoveQuotes
}

# serviceIsServer PRODUCT HOST - return true if HOST is a PRODUCT server, otherwise return false
serviceIsServer()
{
	local product="$1" host="$2"; hostCheck "$host" || return
	local check="bootstrap_expect"; [[ "$product" == "vault" ]] && check="ui"
	serviceConfigVarGet "$check" "$product" "$host" > /dev/null && echo "true" || echo "false"
}

# serviceRemove PRODUCT HOST - remove the service from the host
serviceRemove()
{
	local product="$1"; serviceVars "$product" || return
	local host="$2"; hostCheck "$host" || return 0
	
	scriptRun "$host" "$(cat <<-EOF

		# delete service
		if [[ -f "$productServiceFile" ]]; then
			echo "Deleting the service..."
			sudo systemctl stop "$product" || exit
			sudo systemctl disable "$product" || exit
			sudo rm -f "$productServiceFile" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl reset-failed || exit
		fi

		# remove certificates
		if [[ -f "$certStoreCa" || -f "$certStoreCaAuto" ]]; then
			echo "Removing automatic CA certificate..."
			sudo rm -f "$certStoreCa" "$certStoreCaAuto" || exit
			sudo update-ca-certificates || return
		fi

		printf "cleaning..."
		getent passwd "$product" >&/dev/null && { printf "user..."; sudo userdel "$product" >& /dev/null; }
		getent group "$product" >&/dev/null && { printf "group..."; sudo groupdel "$product" >& /dev/null; }
		[[ -d "/etc/$product.d" ]] && { printf "configuration..."; sudo rm -fr "/etc/$product.d"; }
		[[ -d "/opt/$product" ]] && { printf "data..."; sudo rm -fr "/opt/$product"; }
		[[ "$removeProgram" && -f "$binDir/$product" ]] && { printf "program..."; sudo rm -f "$binDir/$product"; }

		[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && { printf "tempory files..."; sudo rm -fr "/tmp/hashi."*; }
		[[ -d "/tmp/consul-test" ]] && sudo rmdir "/tmp/consul-test"

		echo "done"

		EOF
	)"
}

# serviceRestart PRODUCT HOST
serviceRestart() 
{
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudo systemctl restart "$product" --no-block || exit"; 
}

serviceStart() 
{
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudo systemctl start "$product" --no-block || exit"; 
}

serviceStop() 
{
	local product="$1" host="$2"
	RunLog scriptRun "$host" "sudo systemctl stop "$product" --no-block || exit"; 
}

serviceVars()
{
	local product="$1"; certInit "$product" || return
	
	# variables
	program="$(FindInPath "$product")" || return
	user="$product"; [[ "$product" == "nomad" ]] && user="root"; # many Nomad jobs require running as root

	# directories	
	productConfigDir="/etc/$product.d" 
	productDataDir="/opt/$product"

	# configuration
	productConfigFileBase="01_$product.hcl"
	productConfigFile="$productConfigDir/$productConfigFileBase"
	productServiceFile="/etc/systemd/system/$product.service"
	productServiceEnvFile="/etc/systemd/system/$product.env"
}

#
# vault commands
#

vaultUsage() { echot "\
Usage: $(ScriptName) vault api|environment|status|token|unseal
Vault commands.

	unseal			unseal the vault using keys from the credential store"; }

vaultCommand() { usage; }
vaultEnvironmentCommand() { productEnvironment "$product"; }

#
# vault api command
#

vaultApiUsage() { echot "Usage: $(ScriptName) vault api [check|list|put] PATH -- [curl arguments]\nCall the Consul API.  For example:\nhashi vault api /sys/health"; }
vaultApiArgStart() { unset path; }
vaultApiArgs() { [[ "$command" == "vaultApiCheck" ]] && return; ScriptArgGet "path" -- "$@"; }

vaultApiCommand() { vaultApi "$path" "${otherArgs[@]}"; }
vaultApi() { RunLog curl --silent --show-error --header "X-Vault-Token: $VAULT_TOKEN" "$VAULT_ADDR/v1/$(RemoveTrim "$1" "/")" "${@:2}"; }

vaultApiListCommand() { vaultApiList "$path" "${otherArgs[@]}"; }
vaultApiList() { vaultApi "$@" --request LIST; }

vaultApiPutCommand() { vaultApiPut "$path" "${otherArgs[@]}"; }
vaultApiPut() { vaultApi "$@" --request PUT; }

vaultApiCheckCommand() { vaultApiCheck; }
vaultApiCheck()
{
	# check host
	local host="$(productVarGet "SERVER")"
	! IsAvailable "$host" && { [[ ! $quiet ]] && ScriptErr "vault server $host is not available"; return 1; }

	# check port
	local port="$(GetUriPort "$(productVarGet "ADDR")")"
	! IsAvailablePort "$host" "$port" && { [[ ! $quiet ]] && ScriptErr "vault server $host is not available on port $port"; return 1; }	

	# check api
	[[ "$(vaultApi "/sys/health" 2> /dev/null | jq '.initialized')" == "true" ]]  && return

	# API is not available
	[[ ! $quiet ]] && { ScriptErr "the vault API at $(productVarGet "ADDR") is not available"; vaultApi "/sys/health"; return 1; }

	return 0
}

#
# vault seal command
#

vaultSealCommand()
{
	local active="$(resolve active.vault)"
	local standby="$(resolve standby.vault)"
	
	header "Vault Seal"
	vaultSeal "$active" && vaultSeal "$standby"
}

vaultSeal()
{
	local host="$1"

	[[ ! $host ]] && return
	echo "Sealing Vault host $host..."
	productInit "vault" "$host" || return
	RunLog vault operator seal || return
}

#
# vault status command
#

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	echo "Active Node            $(resolve active.vault)"
	echo "Standby Node           $(resolve standby.vault)"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac

}

#
# vault token command
#

vaultTokenCommand()
{
	for accessor in $(vault list auth/token/accessors | tail +3); do
		header "$accessor"
		vault token lookup -accessor "$accessor"
	done
}

#
# vault unseal command
#

vaultUnsealCommand()
{
	local host hosts key; vaultHostsGet || return

	for host in "${hosts[@]}"; do
		header "Vault Unseal ($host)"
		productInit "vault" "$host" || return

		vaultIsUnsealed && { echo "Vault on $host is already unsealed"; continue; }

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credGet "key$n")" || return
			RunLog vault operator unseal "$key" || return
		done

	done
}

# vault helper

# vaultHostsGet - set the hosts array to all the Vault hosts
vaultHostsGet()
{
	local json

	# get the hosts from Consul if possible
	if productIsInstalled "consul" && json="$(resolveApi "vault")"; then
		IFS=$'\n' hosts=( $( echo "$json" | jq -r '.[].ServiceAddress') )
	fi
	
	# get the hosts from configuration 
	[[ ! $hosts ]] && { getHosts "VaultServers" || return; }

	# no hosts found
	[[ "${#hosts[@]}" == "0" ]] && { ScriptErr "no Vault hosts found"; return 1; }

	return 0
}

vaultIsUnsealed() { vault status | grep -q '^Sealed[ ]*false$'; }

# vaultTokenSetRemote - set the Vault token on a remote host
vaultTokenSetRemote()
{	
	local product="vault"; productInit "$product" || return

	# return if the Vault token is already set on the remote host
	local host; host="$(configServer)" || return
	local token; token="$(sshRunInteractive "$host" credential get "$(credPath)" token --queit "${globalArgs[@]}")" || return
	[[ "$token" == "$VAULT_TOKEN" ]] && return

	sshRunInteractive "$host" credential set "$(credPath)" token "$VAULT_TOKEN" "${globalArgs[@]}" || return
}

# vaultTokenGetRemote - get the Vault token from a remote host if needed
vaultTokenGetRemote()
{
	# return if we have a Vault token
	local product="vault"; { [[ $VAULT_TOKEN ]] || credExists "token"; } && return
	
	# get the token from the host
	local host token; host="$(configServer)" || return
	echo "Getting the Vault token from $host..."
	! IsLocalHost "$host" && token="$(sshRunInteractive "$host" credential get "$(credPath)" token "${globalArgs[@]}")"
	
	# unable to get the token
	if [[ ! $token ]]; then
		ScriptErr "The Vault token does not exist in the local credential manager on $(configServer) at path $(credPath)"
		return 1
	fi

	# got a token
	export VAULT_TOKEN="$token"
}

#
# certificate helper
#

# certDirLocal PRODUCT - return the local certificate directory for CLI certificates, /opt/hashi/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT if present,
#   otherwise use /opt/PRODUCT/cert (when using the CLI on Hashi servers)
certDirLocal()
{
	local product="$1"
	local dir="$(certDirSuffix "$product" "/opt/hashi")"

	if [[ -d "$dir" ]]; then echo "$dir"
	elif [[ -d "$(certDirService "$product")" ]]; then echo "$(certDirService "$product")"
	else { [[ ! $quiet ]] && ScriptErr "unable to find the $product local certificate directory '/opt/hashi/certificate' or '/opt/$product/cert'"; return 1; }
	fi
}

# certDirPrivate - the root private certificate directory from the --encrypt option or certificateDir configuration
certDirPrivate()
{	
	# private encryption directory specified on command line
	[[ -d "$encrypt" ]] && { echo "$encrypt"; return; }

	# mount encrypted private certificate directory
	local device="$(configGet "CertificateDevice")"
	local dir="$(configGet "CertificateDir")"
	local fullDir="$certVolume/$dir"

	# return if not found
	if [[ ! $device || ! $dir ]]; then
		[[ ! $quiet ]] && ScriptErr "unable to locate the private certificate directory"
		return 1
	fi 

	# return if mounted
	if [[ -d "$fullDir" ]]; then
		echo "$fullDir"
		return
	fi

	# mount
	local ext="$(GetFileExtension "$device")"
	case "$ext" in

		hc) 
			! VeraCrypt IsInstalled && { [[ ! $quiet ]] && ScriptErr "unable to mount certificate device '$device' (VeraCrypt not installed)"; return 1; }
			fullDir="$(RunLog VeraCrypt mount "$device" p --dir "$dir")" || return 1
			;;

		*)
			[[ ! $quiet ]] && ScriptErr "unable to mount certificate device '$device' (type $ext not supported)"
			return 1
			;;

	esac

	[[ ! -d "$fullDir" ]] && { [[ ! $quiet ]] && ScriptErr "certificate directory '$dir' is missing on '$(FileToDesc "$device")'"; return 1; }

	echo "$fullDir"
}

# certDirPublic - return the public certificate directory from an installation file server
certDirPublic() { findInstallFile --quiet "other/HashiCorp" && return "${PIPESTATUS[0]}"; }

# certDirService PRODUCT - return the product service certificate directory
certDirService() { echo "/opt/$1/cert"; }

# certDirSuffix PRODUCT DIR - add certificate suffix to DIR: DIR/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT
certDirSuffix()
{ 
	local product="$1"; shift; 	GetArgs; [[ ! $1 ]] && return 1
	echo "$(RemoveTrailingSlash "$1")/certificate/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
}

# certDirUnmountPrivate - unmount the private certificate directory if mounted.  Directory is changed in case we are in the private certificate directory.
certDirUnmountPrivate()
{
	[[ ! -e "$certVolume" ]] && return
	cd && VeraCrypt unmount "$(GetFileName "$certVolume")"
}

# certExists DIR FILES - return 0 if all certificate files exist in the certificate directory
certExists()
{	
	local file dir="$PWD"; [[ -d "$1" ]] && { dir="$1"; shift; }

	for file in "$@"; do
		[[ ! -f "$dir/$file" ]] && return 1
	done

	return 0
}

# certInit PRODUCT- initialize certificate variables for the specified product
certInit()
{
	local product="$1"; [[ ! $product ]] && MissingOperand "product"

	log2 "initializing $product certificates..."


	# certificates
	ca="$product-ca.pem"
	caLocal="$ca" # CA to use for access to the local server
	caKey="$product-ca-key.pem"	
	certCli=$product-cli.pem
	certCliKey=$product-cli-key.pem
	certClient=$product-client.pem
	certClientKey=$product-client-key.pem
	certServer=$product-server.pem
	certServerKey=$product-server-key.pem

	# other variables
	certDirService="$(certDirService "$product")"
	certDirStore="/usr/local/share/ca-certificates"
	certStoreCa="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$ca").crt"

	# consul clients use an automatic CA
	unset caAuto certStoreCaAuto	
	if [[ "$product" == "consul" ]]; then
		caAuto="$product-ca-auto.pem"
		certStoreCaAuto="$certDirStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$caAuto").crt"
		isClient && caLocal="$caAuto"
	fi

	return 0
}

# certPublicExists PRODUCT - return true if the public certificate directory for the specified product exists
certPublicExists() { quiet="true" certPublicFind "$1" > /dev/null; }

# certPublicFind PRODUCT - find public certificates
certPublicFind()
{
	local dir product="$1"; certInit "$product" || return
	quiet="true" certPublicCheck "$PWD" && return 																					# check current directory (makeCertCd was called)
	dir="$(certDirPublic | certDirSuffix "$product")" && certPublicCheck "$dir" && return 	# check public directory
	dir="$(certDirPrivate | certDirSuffix "$product")" && certPublicCheck "$dir" && return 	# check private certificate directory
}

certPublicCheck() { [[ -d "$1" ]] || return; certValidate "$1" "$ca" "$certCli" "$certCliKey" && echo "$dir"; }

certStoreInstall()
{
	hilight "Installing '$(GetFileName "$1")' into the operating system certificate store..."
	RunPlatform certStoreInstall "$1" "$2";
}

certStoreInstallMac()
{
	sudoc security add-trusted-cert -d -r trustRoot -k "/Library/Keychains/System.keychain" "$1"
}

certStoreInstallDebian()
{
	local src="$1" dest="$2"

	[[ ! -d "$(GetFilePath "$dest")" ]] && return
	[[ -f "$dest" && ! $force ]] && return
	
	sudo cp "$src" "$dest" || return
	sudo update-ca-certificates || return
}

certStoreInstallWin()
{
	local src="$1"
	local file="$(PlatformTmp)/$(GetFileName "$src")"
	cp "$src" "$file" || return
	RunScript --elevate "${globalArgs[@]}" -- certutil.exe -addstore root "$(utw "$file")" || return
	rm "$file" || return
}

# certValidate DIR FILES - show an error if a certificate does not exist in the directory
certValidate()
{
	local file dir="$PWD"; [[ -d "$1" ]] && { dir="$1"; shift; }

	for file in "$@"; do 
		if [[ ! -f "$dir/$file" ]]; then
			[[ ! $quiet ]] && EchoErr "$(ProperCase "$product") certificate $file does not exist in '$(FileToDesc "$dir")'"
			return 1
		fi
	done

	return 0
}

#
# credential helper
#

credDelete() { RunLog credential rm "$(credPath)" "$@" "${globalArgs[@]}"; }
credExists() { test="" RunLog credential exists "$(credPath)" "$@" "${globalArgs[@]}"; }
credGet() { test="" RunLog credential get "$(credPath)" "$@" "${globalArgs[@]}"; }

credPath()
{
	local path="$(configGet "credentialPath")" product="${1:-$product}"

	if [[ "$path" ]]; then
		echo "$(RemoveTrailingSlash "$path")/$product"
	else
		echo "/hashi/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
	fi
}

# credSet KEY VALUE
credSet()
{
	log1 "Setting $(credPath) $1 credential to $2..."
	RunLog credential set "$(credPath)" "$@" "${globalArgs[@]}" || return
}

#
# host helper
#

# hostCheck HOST - validate the host argument is set and the host is available
hostCheck()
{
	local host="$1"
	[[ ! $host ]] && MissingOperand "host"
	! IsAvailable "$host" && { [[ ! $quiet ]] && EchoErr "$host is not available"; return 1; }
	return 0
}

# hostFqdn HOST - get and validate the host fully qualified DNS name
hostFqdn()
{
	local host="$1"

	hostCheck "$host" || return
	HasDnsSuffix "$host" && { ScriptErr "host '$host' should not have a DNS suffix"; return 1; }

	local fqdn expectedFqdn="$host.$domain"

	fqdn="$(DnsResolve "$host")" || return; [[ "$fqdn" != "$expectedFqdn" ]] && { ScriptErr "host '$host' fully qualified DNS name is '$fqdn' but '$expectedFqdn' was expected"; return 1; }

	echo "$expectedFqdn"
}

hostCleanup()
{
	local host="$1"; hostCheck "$host" || return 0

	scriptRun "$host" "$(cat <<-EOF
			printf "cleaning..."
			[[ \$(find "$TEMP" -maxdepth 1 -name "hashi.*") ]] && printf "." && sudo rm -fr "$TEMP/hashi."*
			[[ -d "$TEMP/consul-test" ]] && printf "." && rmdir "$TEMP/consul-test"
			printf "." && rm -f "$TEMP/hashi.service."*
			echo "done"
			EOF
	)"
}

# hostFileExists HOST FILE - return true if the file exists on the host
hostFileExists()
{
	local host="$1" file="$2"
	scriptRun "$host" "[[ -f \"$file\" ]]"
}

#
# product helper
#

productTokenStatus() { local token="${1:-$(productVarGet "TOKEN")}"; [[ $token ]] && echo "true" || echo "${RED}false${RESET}"; }

# productEnvironment [PRODUCT] [HOST] - show the environment variables for the specified product
productEnvironment()
{
	local product="${1:-$product}" host="$2" certInit "$product" || return

	# variables
	local certDir; certDir="$(quiet="true" certDirLocal "$product")"
	local encrypt; [[ -d "$certDir" ]] && encrypt="true"
	local port; port="$(productGetPort "$product" "$(protocol)")"
	local server; server="$(productGetServer "$product" "$host")" || return
	local url="$(protocol)://$server:$port"
	
	# use the automatic certificate authority if connecting to a consul client
	if [[ "$product" == "consul" ]]; then

		# connecting to the local host
		if IsLocalHost "$server"; then
			[[ -f "$certDirService/$caAuto" ]] && ca="$caAuto" # only clients have the automatic certificate present
		elif [[ "$(typeCheck "$server")" == "client" ]]; then
			ca="$caAuto"
		fi

	fi

	# validate certificates
	certs && [[ ! $suppressErrors ]] && { certValidate "$certDir" "$ca" "$certCli" "$certCliKey" || return; }

	# arguments
	local args="-http-addr=$url"
	certs && args+=" -ca-file=$certDir/$ca -client-cert=$certDir/$certCli -client-key=$certDir/$certCliKey"

	# standard configuration
	cat <<-EOF
		export $(productVar "CONFIG")="$configPrefix"
		export $(productVar "DOMAIN")="$baseDomain"
		export $(productVar "SERVER")="$server"
		export $(productVar "ADDR")="$url"
		export $(productVar "ARGS")="$args"
	EOF

	# certificate configuration
	if certs; then
		cat <<-EOF
			export $(productVar "CACERT")="$certDir/$ca"
			export $(productVar "CLIENT_CERT")="$certDir/$certCli"
			export $(productVar "CLIENT_KEY")="$certDir/$certCliKey"
		EOF
	else
		cat <<-EOF
			export $(productVar "CACERT")=""
			export $(productVar "CLIENT_CERT")=""
			export $(productVar "CLIENT_KEY")=""
		EOF
	fi

	# get the token if not already set, i.e. if cached value, if Nomad sets the VAULT_TOKEN use it, etc.
	local tokenVar tokenVal
	tokenVar="$(productVar "TOKEN")"
	tokenVal="$(productVarGet "TOKEN")"

	if [[ $forceEnvironment || ! $tokenVal ]] && [[ ! $noToken ]]; then
		local exclude=(); [[ ! $VAULT_TOKEN ]] && exclude=( "--exclude-managers=vault" ) # prevent recursion	
		tokenVal="$(credGet "token" "${exclude[@]}")" || return
	fi
	[[ $tokenVal ]] && echo "export $tokenVar=\"$tokenVal\""

	log2 "productEnvironment: product='$product' token='$(productTokenStatus "$tokenVal")' args='$args'"
	return 0
}

# productGetPort PRODUCT http|https - get the primary port for the specified product
productGetPort()
{
	local product="$1" protocol="$2"
	declare -n port="${product}${protocol^}Port"
	echo "$port"
}

# productGetServer PRODUCT [HOST] - get the server for the product
productGetServer()
{
	local product="$1" host="$2"
	local server; server="$(productGetServerDo)" || return

	[[ ! $server ]] && { ScriptErr "unable to find a $product server for the '$configDesc' configuration"; return 1; }

	# return server - use 127.0.0.1 or the fully qualified DNS name (to match the certificate)
	IsLocalHost "$server" && echo "127.0.0.1" || DnsResolve "$server"
}

productGetServerDo()
{
	# use the passed host
	[[ $host ]] && { echo "$host"; return; }

	# use the --api argument
	[[ $api ]] && { echo "$api"; return; }

	# use the first host specified by the --host or --servers arguments
	if [[ $hostArg || $servers ]]; then
		local hosts; getHosts "${servers[@]}" || return
		echo "${hosts[0]}"; return
	fi

	# use the <product>_SERVER environment variable if it is valid
	if [[ ! $force && $(productVarGet "SERVER") ]]; then
		server="$(productVarGet "SERVER")"
		DnsResolve --quiet "$server" >& /dev/null && { echo "$server"; return; }
	fi

	# use the local host for the server if the product service is running
	if [[ "$product" != @(nomad) ]] && [[ -f "/etc/systemd/system/$product.service" ]] && IsProcessRunning "$product" && service running "$product"; then
		echo "127.0.0.1"; return
	fi

	# use DNS to resolve the service	
	if server="$(GetServer "$product" --quiet)"; then
		echo $server; return
	fi

	# use consul to resolve the server for the product
	if [[ "$product" != "consul" ]] && server="$(quiet="true" productResolve "$product")"; then
		echo $server; return
	fi

	# use the first server specified in bootstrap-config.sh
	echo "$(configServer)"
}

# productInit PRODUCT [HOST] - enable product for use  on host in this script
productInit()
{
	local product="$1" host="$2"; [[ ! $product ]] && MissingOperand "product"

	log2 "productInit: initializing $product"

	! productIsInstalled "$1" && { EchoErr "$product is not installed"; return 1; }

	initConfig "$product" || return
	certInit "$product" || return
	ScriptEval productEnvironment "$product" "$host" || return
}

# productInstall PRODUCT HOST
productInstall()
{
	local product="$1" host="$2"

	# return if the product installation is not needed
	productInstallCheck "$product" "$host" || return
	[[ ! $installNeeded ]] && return

	# install the product
	productInstallDo "$product" "$host"
}

# productInstallCheck PRODUCT HOST - exports installDir, installFile, and installNeeded
productInstallCheck()
{
	local product="$1" host="$2"; hostCheck "$host" || return
	local fileExists currentVersion newVersion

	installNeeded="true"

	# location the installation directory
	installDir="$(findInstallFile "other/HashiCorp/$product")" || return

	# determine if the product is installed
	if IsLocalHost "$host"; then
		installFile="$(os executable find "$installDir")" || return
		! $force && InPath "$product" && fileExists="true"
		what="$installFile"
	else
		[[ ! $force ]] && sshRun "$host" "[[ -f \"$binDir/$product\" ]]" && fileExists="true"
		what="$host"
	fi

	# check the versions
	if [[ ! $force && $fileExists ]]; then
		currentVersion="$(productVersion "$product")" || return
		newVersion="$(productVersion "$product" "$what")" || return
		[[ "$currentVersion" == "$newVersion" ]] && installNeeded=""
	fi

	return 0
}

# productInstallDo PRODUCT HOST - requires that productInstallCheck is called first
productInstallDo()
{
	local product="$1" host="$2"
	
	hilight "Installing $product ($host)..."

	# local install
	if IsLocalHost "$host"; then
		local user="root" group="root"
		IsPlatform mac && group="wheel"
		IsPlatform qnap && { user="admin"; group="administrators"; }
		sudoc ${G}install -o "$user" -g "$group" -m 755 -T "$installFile" "$binDir/$product" || return
		return
	fi

	# determine the host architecture	
	printf "$host architecture..."
	local machine="$(sshRun "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm";;
		*) machine="amd64";; 
	esac
	printf "$machine..."

	# find the program
	local file="$(find "$installDir" -maxdepth 1 -type f  -name "$product*_linux_$machine" | sort --numeric-sort | tail -1)"
	[[ ! -f "$file" ]] && { echo; ScriptErr "unable to find the $product program"; return 1; };
	echo "$(GetFileName "$file")"

	# copy the program to the host
	scp "$file" "$host:/tmp/$product" || return

	# update the program on the host
	local productServiceFile="/etc/systemd/system/$product.service"

	scriptRun "$host" "$(cat <<-EOF
		[[ -f "$productServiceFile" ]] && { printf "stopping service..."; sudo systemctl stop "$product" || exit; echo "done"; }
		sudo cp "/tmp/$product" "$binDir" || exit
		[[ -f "$productServiceFile" ]] && { printf "starting service..."; sudo systemctl start "$product" --no-block || exit; echo "done";  }
		exit 0
		EOF
	)" || return

}

# productInstallCerts PRODUCT - copies certificates locally for command line use, creates certDirLocal
productInstallCerts()
{
	local product="$1"; certInit "$product" || return
	local src; src="$(certPublicFind "$product")" || return
	local dest="$(certDirSuffix "$product" "/opt/hashi")" # always install certificates to /opt/hashi 

	[[ -f "$dest/$ca" && ! $force ]] && return	

	hilight "Installing ${product^} certificates..."
	sudoc ${G}mkdir --parents "$dest" || return
	sudo cp "$src/$ca" "$src/$certCli" "$src/$certCliKey" "$dest" || return
	[[ -f "$src/$caAuto" ]] && { sudo cp "$src/$caAuto" "$dest" || return; }
	sudo chmod +r "$dest/"* || return

	certStoreInstall "$src/$ca" "$certStoreCa" || return
	[[ -f "$src/$caAuto" ]] && { certStoreInstall "$src/$caAuto" "$certStoreCaAuto" || return; }
		
	return 0
}

productIsInstalled() { [[ $(FindInPath "${1:-$product}") ]]; }

# productResolve PRODUCT - resolve the host name for the specified product
productResolve()
{
	local product="$1"
	local name="$product"; [[ "$product" == "vault" ]] && name="active.vault"
	resolve "$name"
}

# productVar VAR - get the environment variable name
productVar()
{
	local var="${1^^}"
	local http; [[ "$product" == "consul" && "$var" == @(ADDR|TOKEN) ]] && http="HTTP_";
	echo "${product^^}_${http}${var}"; 
}

# productVarGet VAR - get a product variable from the environment
productVarGet()
{
	local var="$1"
	local -n v="$(productVar "$var")"
	echo "$v"
}

# productVarSet VAR VALUE - set a product environent variable 
productVarSet()
{
	local var="$1" value="$2"
	local -n v="$(productVar "$var")"
	v="$value"
}

# productVersion PRODUCT WHAT - show the versionof the specified product
productVersion()
{
	local product="$1" what="${2:-$HOSTNAME}" desc version

	if [[ -f "$what" ]]; then
		# use the standard download file format (PRODUCT_VERSION_PLATFORM_ARCHITECURE) if possible as running Go programs on network shares from Windows can fail
		local file="$(GetFileName "$what")"
		[[ "$(GetWord "$file" 1 _)" == "$product" ]] && version="$(GetWord "$file" 2 _)" || version="$("$what" --version)" 
		desc="$(FileToDesc "$what")"

	elif IsLocalHost "$what"; then
		version="$($product --version | productVersionFilter)"
		desc="local"

	else
		version="$(sshRun $host -- $product --version | productVersionFilter)"
		desc="$what"
	fi
	
	log1 "$product version ($desc) is $version"
	echo "$version"
}

productVersionFilter() { head -1 | cut -d" " -f 2 | RemoveFront v; }
	
#
# helper
#

certs() { [[ $encrypt ]]; } # true if certificates are being used
doHashi() { hashi "$@" $force $test "${configFileArg[@]}" "${configPrefixArg[@]}" "${otherArgs[@]}" "${globalArgs[@]}"; }
isClient() { [[ "$type" == "client" ]]; }
isServer() { [[ "$type" == "server" ]]; }
sshRun() { SshAgentConf --quiet "${globalArgs[@]}" && RunLog ssh "$@"; }
sshRunInteractive() { SshAgentConf --quiet "${globalArgs[@]}" && RunLog SshHelper "$1" --interactive --pseudo-terminal "${globalArgs[@]}" -- "${@:2}"; }
protocol() { certs && echo "https" || echo "http"; }
whatArgGet() { ScriptOptGet "whatArg" "what" "$@"; StringToArray "${whatArg,,}" "," whatArg; }
whatCheck() { [[ ! $whatArg ]] && return 0; local w; for w in "$@"; do IsInArray "$w" whatArg && return; done; return 1; }
whatCheckConfig() { local c; for c in $configWhat; do whatCheck "$c" && return; done; return 1; }

# configFileValidate FILE - return true and the type of the file if thefile is a valid HashiCorp configuration file
configFileValidate()
{
	local type="$(GetFileExtension "$file")"
	[[ ! "$type" == @(hcl|json) ]] && { ScriptErr "Specified file /`$file/` is not a valid HashiCorp configuration file"; return 1; }
	echo "$type"
}

copyDirRemote()
{
	local dir="$1" host="$2"
	IsLocalHost "$host" && return
	hilight "Copying files to $host..."
	scp -r "$dir" "$host:/$dir"
}
copyFile()
{
	local file="$1" dest="$2"
	[[ -f "$dest/$file" && ! $force ]] && return	
	RunLog cp "$file" "$dest"
}

encryptOptGet() { ScriptOptGet --check "encrypt" "$@" && ScriptCheckDir "$encrypt" || encrypt="true"; }

findInstallFile()
{
	i check || return # cache the installation directory
	FindInstallFile "$@"
}

# forAllHosts COMMAND [ARGS...] - run a command for all hosts
forAllHosts()
{
	local host hosts; getHosts || return

	for host in "${hosts[@]}"; do
		"$@" "$host" || return
	done
}

# getDnsServer - get an available consul server for DNS queries on port 8600
getDnsServer()
{
	local server="$(productGetServer "consul")"
	log1 "found consul consul server '$server'"
	[[ ! $server ]] && { [[ ! $quiet ]] && ScriptErr "no consul server found"; return 1; }
	! IsAvailablePort "$server" 8600 && { [[ ! $quiet ]] && ScriptErr "consul server $server port 8600 is not available"; return 1; }
	echo "$server"
}

# getHosts [HOSTS]
getHosts() 
{
	local h="${hostArg,,}"

	# use the hostArg if specified
	if [[ $h ]]; then

		# all servers
		if [[ "$h" == "all" ]]; then
			StringToArray "$(configServers)" "," "hosts"

		# clients or servers
		elif [[ "$h" == @(clients|servers) ]]; then
			configGetArray "$h" hosts
		
		# ordered server
		elif [[ "$h" == @(1|2|3|4|5|6|first|second|third|fourth|fifth|sixth) ]]; then
			local servers; configGetArray "servers"
			local clients; configGetArray "clients"
			local hosts=(); ArrayAppend hosts servers clients

			[[ "$h" == @(1|first) ]] && hosts=( "${hosts[0]}" )
			[[ "$h" == @(2|second) ]] && hosts=( "${hosts[1]}" )
			[[ "$h" == @(3|third) ]] && hosts=( "${hosts[2]}" )
			[[ "$h" == @(4|fourth) ]] && hosts=( "${hosts[3]}" )
			[[ "$h" == @(5|fifth) ]] && hosts=( "${hosts[4]}" )
			[[ "$h" == @(6|sixth) ]] && hosts=( "${hosts[5]}" )

		# comma separated lists of hosts
		else 
			StringToArray "$hostArg" "," hosts
		fi

	# use all hosts from configuration
	elif [[ $# == 1 && "$1" == "all" ]]; then
		StringToArray "$(configServers)" "," "hosts"
		
	# use the specicified configuration variable (clients, servers, etc.)
	elif [[ $# == 1 && $(configGet "$1") ]] ; then
		configGetArray "$1" "hosts"
	
	# use the passed servers	
	else
		hosts=( "${@}" )
	fi

	[[ ! $hosts ]] && MissingOperand "host"

	return 0
}

# initConfig [PRODUCT] - initialize configuration variables configPrefix (i.e. test) and configDesc (i.e. prod, test).
#   If configPrefix is empty, this is a production configuration with description prod.
initConfig()
{
	local product="$1"

	# set the configuration prefix from the environment variable if it has not been set
	! IsVar configPrefix && [[ $product ]] && { configPrefix="$(productVarGet "CONFIG")"; } 

	# set configuration prefix aliases
	[[ "${configPrefix,,}" == "prod" ]] && configPrefix=""

	# set configuration description
	configDesc="${configPrefix:-prod}"

	return 0
}

policyDownload()
{
	local url="$1"	
	local install; install="$(FindInstallFile other/HashiCorp/acl)" || return
	local dest="$install/$(GetFileName "$url")"

	[[ ! -f "$dest" ]] && { curl "$url" --silent --show-error --location --output "$dest" || return; }
	echo "$dest"
}

removeDir()
{
	local dir="$1"
	[[ ! $dir || ! -d "$dir" || "$(DirCount "$dir")" == 0 ]] && return
	echo "Deleting '$(FileToDesc "$dir")'..."
	RunLog sudoc DelDir --contents "$dir"
}

scriptCertStore()
{
	local dest="$1"

	cat <<-EOF
		if [[ -f "$dest/$ca" ]] && [[ ! -f "$certStoreCa" || "$force" ]]; then
			echo "Installing CA certificate..."
			sudo cp "$dest/$ca" "$certStoreCa" || exit
			sudo update-ca-certificates || exit
		fi

		if [[ "$caAuto" && -f "$dest/$caAuto" ]] && [[ ! -f "$certStoreCaAuto" || "$force" ]]; then
			echo "Installing automatic CA certificate..."
			sudo cp "$destDirService/$caAuto" "$certStoreCaAuto" || exit
			sudo update-ca-certificates || exit
		fi
	EOF
}

scriptCleanup() 
{
	cat <<-EOF
		printf "Cleaning up..."; rm -fr "$tmpDir"; echo done
	EOF
}	

# scriptRun "$host" SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local host="$1" script="$2" functions="$(FindInPath function.sh | GetFullPath)"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		  sudo() { sudoc "\$@"; }
		fi

		$script
		EOF
	)"

	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		DISPLAY="" sshRun -q -X -t "$host" "$script"
	fi
}

# serviceDnsName NAME - append the full Consul service DNS name to name, i.e. NAME -> NAME.service.hagerman.butare.net
serviceDnsName() { echo "$1.$(configGet "DnsDomain").$domain"; }

# serviceDnsNameShort NAME - append the short Consul service DNS name to name (without the datacenter), i.e. NAME -> NAME.service.butare.net
serviceDnsNameShort() { echo "$1.$(configGet "DnsDomain").$baseDomain"; }

tmpDirCreate()
{
	local dir; dir="$(${G}mktemp -d -t "hashi.XXXXXXXXXX")" || return
	(( verboseLevel > 2 )) && EchoWrap "Using temporary directory $(FileToDesc "$dir")"
	echo "$dir"
}

# typeCheck HOST
typeCheck()
{
	local host="$1" type="client"

	# resolve IP address to a hostname
	IsIpAddress "$host" && { host="$(DnsResolve "$host")" || return; }

	# check the HOSTNAME for the local host
	IsLocalHost "$host" && host="$HOSTNAME"

	# remove the DNS suffix from the hostname
	host="$(RemoveDnsSuffix "$1")" 

	# --assume-server was specified
	if [[ $assumeServer ]]; then
		type="server"

	# host is in the --servers argument
	elif IsArray servers && IsInArray "$host" servers; then
		type="server"

	# host is in the servers configuration
	else
		local servers; ! IsArray servers && configGetArray "servers"
		IsInArray "$host" servers && type="server"

	fi

	log1 "$host type is a $type"
	echo "$type"
}

ScriptRun "$@"
#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

run() {	init && args "$@" && initFinal && "${command}Command"; }

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [COMMAND]...
Helper commands for HashiCorp consul, nomad, and vault products.

Common commands:
	cleanup|install|remove|update
	cert							create certificates
	config						configure all products
	lookup|resolve		lookup or resolve a service
	PRODUCT|all				commands for a product or all products
	status						show status for all products
	ui								start the hashi-ui server and launch it

Common options:
	-cf, --config-file			configuration file to use in place og bootstrap-config.sh
	-cp, --config-prefix		configuration prefix to use, i.e. hashiPREFIXServers
	-f,  --force						force the operation
	-H,  --host HOST				host for the command
			 --product-server		server for product communication
	-t,  --test							do not make changes
	-v,  --verbose					show additional status"
}

args()
{
	local args=()
	unset configFile configFileArg configPrefix configPrefixArg force hostArg hostArgOrig productServer test testEcho verbose

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do
		case "$1" in
			-cf|--config-file|-cf=*|--config-file=*) ScriptOptGet "configFile" "config-file" "$@"; ScriptCheckFile "$configFile"; configFileArg=(--config-file "$configFile");;
			-cp|--config-prefix|-cp=*|--config-prefix=*) ScriptOptGet "configPrefix" "config-prefix" "$@"; configPrefixArg=(--config-prefix "$configPrefix");;
			-f|--force) force="--force";;
			-h|--help) usage 0;;
			-H|--host|-H=*|--host=*) ScriptOptGet hostArg host "$@"; hostArgOrig="$hostArg";;
			--product-server|--product-server=*) ScriptOptGet productServer product-server "$@";;
			-t|--test) test="--test"; testEcho="echo";;
			-v|--verbose) verbose="--verbose";;
			--) shift; otherArgs+=("$@"); set --; break;;
			*) ScriptOpt "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"

	(( $# == 0 )) && return || usage
}

#
# configuration
#

init()
{
	products=( consul nomad vault )
	productUsage="consul|nomad|vault"
	binDir="/usr/local/bin"

	certOptUsage="-e, --encrypt DIR			directory for PKI certificates, if specified TLS will be enabled"
}

initFinal()
{
	# basic configuration
	datacenter="$(ConfigGet "workgroup")"
	baseDomain="$(ConfigGet "baseDomain")"
	domain="$(ConfigGet "domain")"
	product=""; IsInArray "${commandNames[0]}" products && [[ "${commandNames[1]}" != "config" ]] && product="${commandNames[0]}"

	# port configuration
	consulHttpPort="8500" consulHttpsPort="8501"
	nomadHttpPort="4646" nomadHttpsPort="$nomadHttpPort"
	vaultHttpPort="8200" vaultHttpsPort="$vaultHttpPort"

	# product configuration
	productInitAll "$product" || return

	# logging
	[[ $encrypt && $verbose ]] && echo "Certificates are in $(FileToDesc "$encrypt")"

	return 0
}

#
# Commands
#

cleanupCommand()
{
	local hosts; getHosts "localhost" || return

	for host in "${hosts[@]}"; do
		header "Cleanup ($host)"
		hostCleanup "$host" || return
	done
}

statusCommand()
{
	local product

	{
		hilight "product-ui-token-config-domain-certificates"

		for product in "${products[@]}"; do			

			! productIsInstalled "$product" && continue

			local token="false"; [[ $(productVarGet "TOKEN") ]] && token="true"
			local prefix="$(productVarGet "CONFIG")"; prefix="${prefix:-prod}"
			local certDir="$(productVarGet "CACERT" | GetFilePath | FileToDesc)"
			echo "$product-$(productVarGet "ADDR")-$token-$prefix-$(productVarGet "DOMAIN")-$certDir"

		done

	} | column -c $(tput cols) -t -s- -n
}

uiCommand()
{
	local product

	productInit "consul" || return; certInit || return	
	export CONSUL_ENABLE="true"
	export CONSUL_ADDR="$(productGetAddress "$product")"
	export CONSUL_ACL_TOKEN="$(credGet token)"
	export CONSUL_HTTP_SSL="true"
	export CONSUL_CACERT="$certDir/$ca"
	export CONSUL_CLIENT_CERT="$certDir/$certCli"
	export CONSUL_CLIENT_KEY="$certDir/$certCliKey"

	productInit "nomad" || return; certInit || return
	export NOMAD_ENABLE="true"
	export NOMAD_ADDR="$(productGetAddress "$product")"
	export NOMAD_ACL_TOKEN="$(credGet token)"
	export NOMAD_HTTP_SSL="true"
	export NOMAD_CACERT="$certDir/$ca)"
	export NOMAD_CLIENT_CERT="$certDir/$certCli"
	export NOMAD_CLIENT_KEY="$certDir/$certCliKey"

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

#
# Certificate Commands
#

certUsage()
{
	echot "Usage: $(ScriptName) cert copy|info|make

	copy		copy public certificates
	make		make certificates
	status	show certificate status

	$certOptUsage"
}

certArgStart() { unset encrypt; }

certOpt()
{
	case "$1" in
		-e|--encrypt|-e=*|--encrypt=*) encryptOptGet "$@";;
		*) return 1;;
	esac
}

certCommand() { usage; }

#
# Certificate Copy Command
#

certCopyUsage() { echot "\
Usage: $(ScriptName) cert copy [all|consul|nomad](all)
Copy public certificates to the public installation location.

	-e, --encrypt DIR			directory for PKI certificates"; }

certCopyArgEnd() { [[ ! $encrypt ]] && MissingOption "encrypt"; return 0; }
certCopyCommand() { certCopyAllCommand; }
certCopyAllCommand() { certCopyConsulCommand && certCopyNomadCommand; }
certCopyConsulCommand() { certCopyPublic "consul"; }
certCopyNomadCommand() { certCopyPublic "nomad"; }

certCopyPublic()
{
	local product="$1"; certInit "$product" || return
	local dest; dest="$(certDirPublic)" || return
	local file files=( "$ca" "$certCli" "$certCliKey" ); [[ $caAuto ]] && files+=( "$caAuto" )

	[[ "$certDir" == "$certDirPublic" ]] && return

	certValidate "${files[@]}" || return
	for file in "${files[@]}"; do copyFile "$certDir/$file" "$dest" || return; done
}

#
# Certificate Make Command
#

certMakeUsage() { echot "\
Usage: $(ScriptName) cert make all|consul|nomad
Create certificates required for HashiCorp products.

	-e, --encrypt DIR			directory for PKI certificates"; }

certMakeArgEnd() { [[ ! $encrypt ]] && MissingOption "encrypt"; return 0; }
certMakeCommand() { usage; }
certMakeAllCommand() { certMakeConsulCommand && certMakeNomadCommand; }
certMakeConsulCommand() { certMake "consul"; }
certMakeNomadCommand() { certMake "nomad"; }

certMake()
{
	local product="$1"; certInit || return

	# validate the encryption option was specified
	[[ ! $encrypt ]] && MissingOption "encrypt"

	# validate the the private certificate directory
	certValidateDir "$certDirPrefix" || return	
	sudoc mkdir --parents "$certDir" || return

	# create the product certificates
	RunFunction "cert" "${product}Make"
}

certMakeStart() { hilight "$1"; cd "$certDir"; }

# Make Consul certificates

certMakeConsul()
{
	# install consul to create certificates
	! InPath "consul" && { inst "consul" || return; }

	# create the certificates
	certMakeConsulCa || return
	certMakeConsulCli || return
}

certMakeConsulCa()
{
	certExist "$ca" "$caKey" && return
	certMakeStart "Creating the certificate authority for $baseDomain..."

	# create the cert
	consul tls ca create \
		-domain="$baseDomain" \
		-name-constraint || return # name constraint required for HTTPS GUI

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

# certMakeConsulCaAuto - get the auto generated Consul certficate authority.   This CA
# is used on Consul clients and is needed on the Consul client to access the Consul API
# from other programs like Nomad, curl, or wget.
certMakeConsulCaAuto()
{
	certValidate "$ca" || return
	certExist "$caAuto" && return
	certMakeStart "Getting the automatic certificate authority..."

	! InPath "consul-k8s" && { inst "consul-k8s" || return; }

	consul-k8s get-consul-client-ca \
		--server-addr "$(productGetServer "consul")" \
		--server-port "$consulHttpsPort" \
		--ca-file="$ca" \
		--output-file "$caAuto" || return
}

certMakeConsulCli()
{
	certValidate "$ca" "$caKey" && return
	certExist "$certCli" "$certCliKey" && return
	certMakeStart "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return

	popd > /dev/null || return
}

certMakeConsulServer()
{
	local cert="$1" key="$2" host="$3"

	certValidate "$ca" "$caKey" && return
	certExist "$cert" "$key" && return
	certMakeStart "Creating the $host server certificate..."

	# remove any existing temporary certs
	rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

	# create the cert
	consul tls cert create -server \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-additional-ipaddress="$(GetIpAddress "$host")" \
		-additional-dnsname="$(os name "$host")" \
		-node="$host" || return

	# rename the temporary cert
	mv "$datacenter-server-$baseDomain-0.pem" "$cert" || return
	mv "$datacenter-server-$baseDomain-0-key.pem" "$key" || return
}

# Make Nomad certificates

certMakeNomad()
{
	# install cfssl to create certificates
	! InPath "cfssl" && { inst "cfssl" || return; }

	# create certificates
	certMakeNomadCa || return
	certMakeNomadServer || return
	certMakeNomadClient || return
	certMakeNomadCli || return
}

certMakeNomadCa()
{
	certExist "$ca" "$caKey" && return
	certMakeStart "Creating the Nomad certificate authority..."
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca
}

certMakeNomadCli()
{
	certValidate "$ca" "$caKey" && return
	certExist "$certCli" "$certCliKey" && return
	certMakeStart "Creating the Nomad CLI certificate..."
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-cli
}

certMakeNomadClient()
{
	certValidate "$ca" "$caKey" && return
	certExist "$certClient" "$certClientKey" && return
	certMakeStart "Creating the Nomad client certificate..."
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -profile=client - | cfssljson -bare nomad-client
}

certMakeNomadServer()
{
	certValidate "$ca" "$caKey" && return
	certExist "$certServer" "$certServerKey" && return
	certMakeStart "Creating the Nomad server certificate..."

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > "cfssl.json" || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(ArrayDelimit joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | cfssl gencert -ca="$ca" -ca-key="$caKey" -config="cfssl.json" -hostname="$hosts" - | cfssljson -bare "nomad-server"
}

#
# Certificate Status Command
#

certStatusUsage() 
{ 
	echot "\
Usage: $(ScriptName) cert copy [all|consul|nomad](all)
Show certificate status.

	-m, --make																		make the certificate directory
	-t, --type local|private|public|any](any)			type of certificate directory"
}

certStatusCommand() { certStatusAllCommand; }
certStatusAllCommand() { certStatusConsulCommand && certStatusNomadCommand; }
certStatusConsulCommand() { certStatus "consul"; }
certStatusNomadCommand() { certStatus "nomad"; }

certStatus()
{
	local product="$1"

	certInit || return
	certValidateDir "$certDir" || return

	echo "${product^} certificates are located in '$certDir'"; echo

	{
		hilight "type:file:present"
		echo "CA:$ca:$(certStatusPresent "$ca")"
		[[ $caAuto ]] && echo "Auto CA:$caAuto:$(certStatusPresent "$caAuto")"
		echo "CA Key:$caKey:$(certStatusPresent "$caKey")"
		echo "CLI:$certCli:$(certStatusPresent "$certCli")"
		echo "CLI Key:$caKey:$(certStatusPresent "$certCliKey")"

		# in the prive certifice directory consul uses client and server certificates specific to the host
		if [[ "$product" != "consul" || ! $encrypt ]]; then
			echo "Client:$certClient:$(certStatusPresent "$certClient")"
			echo "Client Key:$certClientKey:$(certStatusPresent "$certClientKey")"
			echo "Server:$certServer:$(certStatusPresent "$certServer")"
			echo "Server Key:$certServerKey:$(certStatusPresent "$certServerKey")"
		fi

	} | column -c $(tput cols) -t -s: -n

	echo
}

certStatusPresent() { [[ -f "$certDir/$1" ]] && echo "true" || echo ""; }

#
# Install Command
#

installUsage() { echot "\
Usage: $(ScriptName) install all|cli|$productUsage
Install a HashiCorp product.

	-c, --clients	HOSTS		comma separated list of clients to install
	-s, --server HOSTS		comma separated list of servers to install
	-j, --join HOSTS			comma separated list of hosts to join to, defaults to servers
	$certOptUsage
	-w, --what=C1[,C2...] components to install
													components: acl cert program service
													Nomad: VaultIntegration
													Vault: seals"; }

installArgStart() { clients=() servers=() join=() encrypt="" force=""; }

installOpt()
{
	case "$1" in
		-c|--clients|-c=*|--clients=*) ScriptOptGet "clients" "$@"; StringToArray "$clients" "," clients;;
		-s|--servers|-s=*|--servers=*) ScriptOptGet "servers" "$@"; StringToArray "$1" "," servers;;
		-j|--join|-j=*|--join=*) ScriptOptGet "join" "$@"; StringToArray "$1" "," join;;
		-e|--encrypt|-e=*|--encrypt=*) encryptOptGet "$@";;
		-w|--what|-w=*|--what=*) ScriptOptGet "what" "$@"; StringToArray "${what,,}" "," what;;
		*) return 1;;
	esac
}

installCommand() { usage; }
installAllCommand() { installConsulCommand && installVaultCommand && installNomadCommand; }

#
# Install CLI Command
#

installCliUsage() {	echot "\
Usage: $(ScriptName) install cli all|$productUsage
Install a HashiCorp product for command line access."; }

installCliCommand() { installCliAllCommand; }
installCliConsulCommand() { installCli "consul"; }
installCliNomadCommand() { installCli "nomad"; }
installCliVaultCommand() { installCli "vault" && vaultTokenCheck; }

installCliAllCommand()
{
	local product

	for product in "${products[@]}"; do
		installCliDo "$product" || return
	done
}

installCliDo() 
{ 
	[[ $hostArg || $servers || $clients ]] && { EchoErr "CLI can only be installed locally"; return 1; }
	installCli "$@" || return
}

installCli() { productInstall "$1" "localhost" && productInstallCerts "$1"; }

#
# Install Consul Command
#

installConsulCommand()
{ 
	installCommon "consul" || return

	# configuration
	local -A options serverOptions guiOptions 
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	options=(
		[domain]="$baseDomain"
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[client_addr]="0.0.0.0"
		[bind_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[retry_join]="[ $(ArrayShow join ", ") ]"
		[leave_on_terminate]="true"
		[telemetry]="{ disable_compat_1.9 = true }"
		[acl]="$(cat <<-EOF
			{ 
			  enabled = true
			  default_policy = "allow"
			  enable_token_persistence=true
			}
			EOF
		)"
	)

	serverOptions=(
		[server]="true"
		[bootstrap_expect]="${#join[@]}"
		[advertise_addr]='{{ GetInterfaceIP \"eth0\" }}'
	)

	commonEncryptOptions=(
		[addresses]='{ https = "0.0.0.0" }'
		[ports]="{ http = -1, https = $consulHttpsPort }"
		[verify_incoming]="false"
		[verify_incoming_rpc]="true"
		[verify_outgoing]="true"
		[verify_server_hostname]="true"
	)

	clientEncryptOptions=(
		[ca_file]="$certDirServer/$ca"
		[auto_encrypt]="{ tls = true }"
	)

	serverEncryptOptions=(
		[ca_file]="$certDirServer/$ca"
		[cert_file]="$certDirServer/$certServer"
		[key_file]="$certDirServer/$certServerKey"
		[auto_encrypt]="{ allow_tls = true }"
	)

	guiOptions=( [ui_config]="{ enabled = true }" )

	# install
	installDo || return
}

installConsulCommon()
{
	# service
	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$program agent -config-dir=$productConfigDir"
	serviceKillSignal="SIGTERM"
}

installConsulClient() { installConsulAutoCa; }

installConsulServer() 
{ 
	installConsulCertServer || return
	ArrayAppend o serverOptions guiOptions || return
}

installConsulAutoCa()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$caAuto" "$tmpDir/cert" || return	
}

installConsulCertServer()
{	
	[[ ! $encrypt ]] && return

	local cert="consul-server-$host.pem"
	local key="consul-server-$host-key.pem"

	certMakeConsulServer "$cert" "$key" "$host" || return

	cp "$certDir/$cert" "$tmpDir/cert/$certServer" || return
	cp "$certDir/$key" "$tmpDir/cert/$certServerKey" || return
}

installConsulServerFinal()
{
	if [[ $encrypt && ! -f "$certDir/$caAuto" ]] && installComponentCheck "cert"; then
		header "Automatic Certificate"
		certMakeConsulCaAuto || return
	fi

	installAcl || return
}

installConsulFinal() { installConsulAgentAcl; }

installConsulAgentAcl()
{
	! installComponentCheck "acl" && return

	header "Add Tokens"

	productConfig "consul" || return

	# create the default policy and token (for DNS resolution)	
	local name="dns-requests"
	local defaultToken policy="$(cat <<-EOF
		node_prefix "" {
		  policy = "read"
		}
		service_prefix "" {
		  policy = "read"
		}
		EOF
	)"
	consulAclCreate "dns-requests" "$policy" || return
	defaultToken="$(consulAclTokenGet "$name")" || return

	# create the host specific policies
	for host in server "${servers[@]}" client "${clients[@]}"; do

		# set server type
		[[ "$host" == @(client|server) ]] && { type="$host"; continue; }

		# continue if the default policy is already deny
		[[ "$(installConsulConfigGet "default_policy")" == "deny" ]] && continue
		
		# create the ACL policy for the host
		local token policy="$(cat <<-EOF
			node "$host" {
			  policy = "write"
			}		
			EOF
		)"
		name="agent-$host"
		consulAclCreate "$name" "$policy" || return
		token="$(consulAclTokenGet "$name")" || return

		# update the token on the agent
		hilight "Updating the ACL configuration on $host..."

		local args; args="-http-addr=$(productGetAddress "$product" "127.0.0.1")" || return	
		[[ $encrypt ]] && args+=" -ca-file=\"$certDirServer/$caLocal\" -client-cert=\"$certDirServer/$certCli\" -client-key=\"$certDirServer/$certCliKey\""

		scriptRun "$(cat <<-EOF
			export CONSUL_HTTP_TOKEN=$CONSUL_HTTP_TOKEN
			consul acl set-agent-token $args agent "$token" || exit
			consul acl set-agent-token $args default "$defaultToken" || exit
			EOF
		)"

	done

	# update default ACL policy
	for host in "${servers[@]}" "${clients[@]}"; do
		
		# continue if the default policy is already deny
		[[ "$(installConsulConfigGet "default_policy")" == "deny" ]] && continue

		hilight "Updating the default ACL policy on $host..."

		scriptRun "$(cat <<-EOF
			sudo sed -i 's/default_policy = "allow"/default_policy = "deny"/' "$productConfigFile" || return
			sudo systemctl restart "$product" --no-block || exit
			EOF
		)"

	done

}

# installConsulConfigGet VAR - get a variable from the Consul configuration file
installConsulConfigGet() 
{
	scriptRun "grep \"$1[ ]*=[ ]*\" \"$productConfigFile\"" | tr -s " " | cut -d"=" -f2 | RemoveCarriageReturn | RemoveSpace | RemoveQuotes
}

#
# Install Nomad Command
#

installNomadCommand()
{
	installCommon "nomad" || return

	# configuration
	local -A options clientOptions serverOptions guiOptions
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 
	local token; token="$(product="consul" credGetIfExists "token")"; [[ ! $token ]] && { ScriptErr "unable to get a Consul token for Nomad"; return 1; }
	local port; port="$(productGetPort "consul")" || return

	options=( 
		[datacenter]="$datacenter"
		[data_dir]="/opt/$product"
		[acl]="{ enabled = true }"
		[consul]="{
	token = \"$token\"
	address = \"127.0.0.1:$port\"
}"
	)

	serverOptions=(
		[server]="{
	enabled = true
	bootstrap_expect = "${#join[@]}"
}"
	)

	commonEncryptOptions=()

	clientOptions=(
		[client]="{
	enabled = true 
}"
	)

	clientEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$certDirServer/$ca\"
	cert_file = \"$certDirServer/$certClient\"
	key_file = \"$certDirServer/$certClientKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	serverEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$certDirServer/$ca\"
	cert_file = \"$certDirServer/$certServer\"
	key_file = \"$certDirServer/$certServerKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	# install
	installDo || return
}

installNomadCommon()
{ 
	# service - many Nomad jobs require running as root
	user="root"

	# encryption
	if [[ $encrypt ]]; then

		# nomad uses consul certificates
		certInit "consul" || return 
	
		# create the service environment file
		cat > "$tmpDir/$product.env" <<-EOF
			CONSUL_HTTP_SSL=true
			CONSUL_CACERT=$certDirServer/$caLocal)
			CONSUL_CLIENT_CERT=$certDirServer/$certServer
			CONSUL_CLIENT_KEY=$certDirServer/$certServerKey
		EOF

		# return to the nomad certificate configuration
		certInit "nomad" || return

	fi

	return 0
}

installNomadClient()
{
	installNomadCertClient || return
	ArrayAppend o clientOptions || return
}

installNomadCertClient()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$ca" "$certDir/$certClient" "$certDir/$certClientKey" "$tmpDir/cert" || return
}

installNomadServer()
{
	installNomadCertServer || return
	ArrayAppend o serverOptions clientOptions || return
}

installNomadCertServer()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$ca" "$certDir/$certServer" "$certDir/$certServerKey" "$tmpDir/cert" || return
}

installNomadServerFinal() { installAcl; }

installNomadFinal() { initNomadVaultIntegration; }

initNomadVaultIntegration()
{
	! installComponentCheck "vaultintegration" && return	
	! InPath vault && { echo "Vault is not installed, skipping nomad vault integration"; return; }

	productConfig "vault" || return

	local tmpDir="$(tmpDirCreate)" || return
	pushd "$tmpDir" >& /dev/null || return

	# add the nomad-cluster policy to Vault
	if ! vault policy list | grep -q "^nomad-server$"; then
		hilight "Adding the nomad-cluster policy to Vault..."
		curl https://nomadproject.io/data/vault/nomad-server-policy.hcl -O -s -L || return
		vault policy write nomad-server nomad-server-policy.hcl || return
	fi

	# add the nomad-cluster role to Vault
	if ! vault list "/auth/token/roles" |& grep -q "^nomad-cluster$"; then
		hilight "Adding the nomad-cluster role to Vault..."
		curl https://nomadproject.io/data/vault/nomad-cluster-role.json -O -s -L || return
		vault write /auth/token/roles/nomad-cluster @nomad-cluster-role.json || return
	fi

	popd >& /dev/null || return
	
	# grant the nomad-cluster role permission to required secrets
	if ! vault policy list | grep -q "^nomad-cluster$"; then
		hilight "Granting the nomad-cluster role permission in Vault..."
		local policy="$(cat <<-EOF
			path "secret/*" {
			  capabilities = ["read"]
			}
			EOF
		)"
		echo "$policy" | vault policy write nomad-cluster - || return
	fi

	# create a token for nomad to access vault
	local token="$(vault token create -policy nomad-server -orphan -format=json | jq '.auth.client_token' | RemoveQuotes)" || return

	# add vault integration configuration to nomad
	local file="$tmpDir/02_vault.hcl"

	certInit "consul" || return

	cat > "$file" <<-EOF
		vault {
		  enabled          = true
		  ca_file          = "$certDirServer/$caLocal"
		  cert_file        = "$certDirServer/$certCli"
		  key_file         = "$certDirServer/$certCliKey"
		  address          = "https://127.0.0.1:$vaultHttpsPort"
		  create_from_role = "nomad-cluster"
		  token            = "$token"
		}
	EOF

	if [[ $test ]]; then
		header "$(ProperCase "$product") Configuration ($(GetFileName "$file"))"
		cat "$file" || return
	fi

	# copy the vault configuration files
	productInit "nomad" || return
	for host in "${servers[@]}" "${clients[@]}"; do
		hostCopy "$file" "$productConfigDir" || return
	done

	# install vault client for nomad jobs
	for host in "${servers[@]}" "${clients[@]}"; do
		productInstall "vault" "$host" || return
	done

	# cleanup
	rm -fr "$tmpDir"

	return 0
}

#
# Install Vault Command
#

installVaultCommand()
{
	installCommon "vault" || return

	# configuration
	local -A options clientOptions serverOptions guiOptions
	local token; token="$(product="consul" credGetIfExists "token")" || return; [[ ! $token ]] && { ScriptErr "unable to get a Consul token for Vault"; return 1; }
	local port; port="$(productGetPort "consul")" || return

	# configuration
	options=(
		[listener]="\"tcp\" $(cat <<-EOF
			{ 
			  address = "0.0.0.0:$vaultHttpsPort"
			  tls_cert_file = "$certDirServer/$certServer"
			  tls_key_file = "$certDirServer/$certServerKey"
			}
			EOF
		)"

		[storage]="\"consul\" $(cat <<-EOF
			{
				token = "$token"
			  path = "vault/"
			  address = "127.0.0.1:$port"
			  scheme = "https"
			  tls_ca_file = "$certDirServer/$ca"
			  tls_cert_file = "$certDirServer/$certCli"
			  tls_key_file = "$certDirServer/$certCliKey"
			}
			EOF
		)"

		[service_registration]="\"consul\" $(cat <<-EOF
				{
					token = "$token"
				  address="127.0.0.1:$port"
				  scheme="https"
				  tls_ca_file = "$certDirServer/$ca"
				  tls_cert_file = "$certDirServer/$certCli"
				  tls_key_file = "$certDirServer/$certCliKey"
				}
			EOF
		)"
	)

	guiOptions=( [ui]="true" )

	# install
	installDo || return
}

installVaultCommon()
{
	# options
	o[api_addr]="https://$hostFqdn:$vaultHttpsPort"

	# service
	execStart="$program server -config=$productConfigDir"
	serviceLimit+=$'\n'"LimitMEMLOCK=infinity"
}

installVaultServer() { ArrayAppend o guiOptions || return; }

installVaultServerFinal()
{
	installVaultAcl || return; 

	# enable the "secret" secret engine, the default path for the credential script
	if ! vault secrets list | grep -q "^secret"; then
		header "Vault Configuration"
		vault secrets enable -path=secret kv-v2 || return
	fi

	return 0
}

installVaultAcl()
{
	! installComponentCheck "acl" && return

	header "Install Vault ACL"
	local product; productInit "vault"; productConfig "$product" || return

	# generate the unseal keys
	local n key result s seals; seals="$(vault operator init 2>&1)"; result="$?"
	echo "$seals" | grep -q "Vault is already initialized" && return
	(( result != 0 )) && { EchoErr "$seals"; return 1; }

	# show the seal keys
	hilight "Store the following vault unseal keys in a secure location:"
	echo "$seals"

	# store the root token
	declare token; token="$(echo "$seals" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credSet "token" "$token" || return
	export VAULT_TOKEN="$token"

	# store the seal keys
	IFS=$'\n' seals=( $(echo "$seals" | grep "Unseal Key") )
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credSet "key$n" "$key" || return
	done

	# store the initial vault key on the first vault servers local credential manager
	vaultTokenSetRemote || return

	# unseal the vault
	vaultUnsealCommand || return
}

#
# Lookup Command
#

lookupUsage() { echot "Usage: $(ScriptName) lookup NAME
Lookup all information about consul service using nslookup.
.service.<domain> is appended to the specified name."; }

lookupArgStart() { name=""; }

lookupArgs() { ScriptArgGet "name" -- "$@"; shift; }

lookupCommand()
{
	local server="$(productGetServer "consul")"
	name+=".service.$domain"
	productInit "consul" || return
	[[ $verbose ]] && HilightErr "Using Consul server at $server"
	! IsAvailablePort "$server" 8600 && { EchoErr "$name port 8600 is not available"; return 1; }
	nslookup -port=8600 -type=a -norecurse "$name" "$server"
}

#
# Remove Command
#

removeUsage() { echot "\
Usage: $(ScriptName) remove all|$productUsage
Remove a HashiCorp product configuration and data.

	-p, --program		also remove the HashiCorp program"; }

removeArgStart() { unset program yes; }

removeOpt()
{
	case "$1" in
		-p|--program) program="true";;
		-y|--yes) yes="true";;
		*) return 1;;
	esac
}

removeCommand() { usage; }
removeAllCommand() { removeDo "vault" && removeDo "nomad" && removeDo "consul"; }
removeConsulCommand() { removeDo "consul"; }
removeNomadCommand() { removeDo "nomad"; }
removeVaultCommand() { removeDo "vault"; }

removeDo()
{
	local product="$1" host hosts; getHosts || return

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To permanently remove all $product configuration, data, and programs on $baseDomain $configDesc\n       hosts $(ArrayDelimit hosts " "), --force and --yes are required"
	 return 1
	fi

	for host in "${hosts[@]}"; do
		header "Remove $(ProperCase "$product") ($host)"
		productRemove "$product" "$host" || return
	done
}

#
# Resolve Command
#

resolveUsage() { echot "Usage: $(ScriptName) resolve [-a|--all] NAME[.service]
Resolve a service in consul to an IP address or canonical name.
If all is not specified the first IP address is returned.
.service.<domain> is appended to the specified name."; }

resolveArgStart() { all=""; name=""; }

resolveOpt()
{
	case "$1" in
		-a|--all) all="true";;
		*) return 1;;
	esac
}

resolveArgs() { ScriptArgGet "name" -- "$@"; shift; }

resolveCommand()
{
	local filter=(head -1); [[ $all ]] && { filter=(cat); }

	local result; result="$(lookupCommand)" || return

	if [[ "$result" =~ .*canonical\ name.* ]]; then
		printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//' | "${filter[@]}"
	else
		printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace | "${filter[@]}"
	fi

	return "${PIPESTATUS[0]}"
}

#
# Test Command
#

testUsage() { echot "usage: $(ScriptName) test clean|environment|install all|$productUsage"; }
testArgStart() { what="all"; configPrefix="test"; }
testArgs() { [[ "$1" != @(all|$productUsage) ]] && return; what="$1"; (( ++shift )); }
testCommand() { testHashi; }

testEnvironmentCommand() { configEnvironmentCommand; }
testInstallCommand() { testHashi install $what; }

testCleanCommand()
{
	testHashi config nuke $what --force --yes || return
	testHashi remove $what -H="$(ArrayDelimit hashiHosts),localhost" --force --yes || return
}

testHashi() { doHashi "$@" --config-prefix=test "${configFileArg[@]}"; }

#
# Update Command
#

updateUsage() { echot "usage: $(ScriptName) program all|$productUsage"; }
updateCommand() { usage; }
updateAllCommand() { updateDo "vault" && updateDo "nomad" && updateDo "consul"; }
updateConsulCommand() { updateDo "consul"; }
updateNomadCommand() { updateDo "nomad"; }
updateVaultCommand() { updateDo "vault"; }

updateDo()
{
	local product="$1" host hosts; getHosts "${hashiHosts[@]}" || return
	
	for host in "${hosts[@]}"; do
		header "Update $(ProperCase "$product") ($host)"
		productInstall "$product" "$host" || return
	done
}

#
# Install Helper
#

installCertCheck() { [[ $encrypt ]] && installComponentCheck "cert"; }
installCertMake() { ! installCertCheck && return; certMake "$product"; }
installCertPublic() { ! installCertCheck && return; certCopyPublic "$product"; }
installComponentCheck() { [[ ! $what ]] && return 0; IsInArray "$1" what; }

installCommon()
{
	declare -g product="$1" certDir 
	declare -Ag commonOptions

	# initialize
	productInit "$product" || return
	certInit || return

	# directories	
	productConfigDir="/etc/$product.d" 
	productDataDir="/opt/$product"

	# configuration files
	productConfigFileBase="01_$product.hcl"
	productConfigFile="$productConfigDir/$productConfigFileBase"
	productServiceFile="/etc/systemd/system/$product.service"
	productServiceEnvFile="/etc/systemd/system/$product.env"

	# general
	tmpDirTemplate="hashi.XXXXXXXXXX"
	program="$(FindInPath "$product")" || return
	user="$product"
	commonOptions=( [log_level]="Info" )

	# add clients and servers from hostArg
	local host hosts=(); StringToArray "$hostArg" "," hosts; 
	for host in "${hosts[@]}"; do
			IsInArray "$host" hashiServers && servers+=( "$host" ) || clients+=( "$host" )
	done
	unset hostArg

	# set clients and servers defaults
	if [[ ! $clients && ! $servers ]]; then
		if [[ "$product" == "vault" ]]; then
			clients=( )
			servers=( "${vaultServers[@]}" ) 
		else
			clients=( "${hashiClients[@]}" ) 
			servers=( "${hashiServers[@]}" )
		fi
	fi

	# join servers	
	[[ ! $join ]] && join=( "${hashiServers[@]}" )
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(os name "$h")" ); done

	if [[ $verbose ]]; then
		printf "clients: "; ArrayShow clients
		printf "servers: "; ArrayShow servers
		printf "join: "; ArrayShow join
	fi
	
	return 0
}
	
installDo()
{
	local result tmpDir="$(tmpDirCreate)" || return

	installCertMake || return
	installProgram || return
	installServiceServers || return
	installClientCerts || return
	installServerFinal || return
	installServiceClients || return
	installFinal || return
	installCertPublic || return

	rm -fr "$tmpDir"
	unset servers clients; hostArg="$hostArgOrig"

	return 0
}

installClientCerts()
{
	! installCertCheck && return
	productInstallCerts "$product"
}

installProgram()
{
	! installComponentCheck "program" && return

	for host in localhost "${servers[@]}" "${clients[@]}"; do
		productInstall "$product" "$host" || return
	done
}

installServiceServers()
{
	! installComponentCheck "service" && return

	for host in "${servers[@]}"; do
		installServiceHost "server" "$host" || return
	done
}

installServiceClients()
{
	! installComponentCheck "service" && return

	for host in "${clients[@]}"; do
		installServiceHost "client" "$host" || return
	done
}

installServiceHost()
{
	local type="$1" host="$2"
	local f hostFqdn scriptFinal
	local -A o
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local serviceLimit="LimitNOFILE=infinity"$'\n'"LimitNPROC=infinity"
	local execStart="$program agent -config=$productConfigDir"
	local execReload="/bin/kill --signal HUP \$MAINPID"
	local exectStop=""
	local serviceKillSignal="SIGINT"

	# host information
	hostFqdn="$(os name "$host")" || return
	host="$(RemoveDnsSuffix "$hostFqdn")"

	# header
	header "Install $(ProperCase "$product") $(ProperCase "$type") Service ($host)"

	# prepare temporary directory
	DelDir --contents "$tmpDir" || return
	mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return		

	# copy certificates
	[[ $encrypt ]] && { FileCommand cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$tmpDir/cert" || return; }

	# service
	printf "" > "$tmpDir/$product.env"

	# options - other options added in installPRODUCTServer or installPRODUCTClient
	o=( ); ArrayAppend o commonOptions options || return

	[[ "$encrypt" ]] && IsDeclared commonEncryptOptions && { ArrayAppend o "commonEncryptOptions" || return; }
	[[ "$encrypt" ]] && IsDeclared ${type}EncryptOptions && { ArrayAppend o "${type}EncryptOptions" || return; }

	RunFunction "install" "${product}Common"
	RunFunction "install" "${product}$(ProperCase "$type")" || return

	# create the configuration files
	installConfigHcl o > "$tmpDir/config/$productConfigFileBase" || return
	installConfigService > "$tmpDir/$product.service" || return

	# copy the files to the remote host
	if ! IsLocalHost "$host"; then
		hilight "Copying files to $host..."
		scp -r "$tmpDir" "$host:/$tmpDir" || return
	fi

	# run the installation script - use only standard commands
	hilight "Running installation..."
	scriptRun "$(cat <<-EOF

		# user
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudo useradd -r -d "$productConfigDir" -s "/bin/false" "$user" || exit
		fi

		# directories
		if ! [[ -d "$cert" && -d "$productConfigDir" && -d "$productDataDir" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudo install -o "$user" -g "$user" -m 755 -d "$cert" "$productConfigDir" "$productDataDir" || exit
		fi

		# files

		if [[ \$(sudo ls -A "$tmpDir/data") ]] && [[ ! \$(sudo ls -A "$productDataDir") || "$force" ]]; then
		  echo "Copying data files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$productDataDir" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/config") ]] && [[ ! -f "$productConfigDir/$productConfigFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$productConfigDir" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/cert") ]] && [[ ! \$(sudo ls -A "$cert") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$cert" "$tmpDir/cert/"* || exit
		fi

		if [[ -f "$certDirServer/$ca" ]] && [[ ! -f "$certStoreCa" || "$force" ]]; then
			echo "Installing CA certificate..."
			sudo cp "$certDirServer/$ca" "$certStoreCa" || exit
			sudo update-ca-certificates || exit
		fi

		if [[ $caAuto && -f "$certDirServer/$caAuto" ]] && [[ ! -f "$certStoreCaAuto" || "$force" ]]; then
			echo "Installing automatic CA certificate..."
			sudo cp "$certDirServer/$caAuto" "$certStoreCaAuto" || exit
			sudo update-ca-certificates || exit
		fi

		# service		

		if [[ -f "$productServiceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudo systemctl stop "$product" || exit
		fi

		if [[ ! -f "$productServiceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudo cp "$tmpDir/$product.service" "$tmpDir/$product.env" "/etc/systemd/system" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl enable "$product" || exit
			sudo systemctl start "$product" --no-block || exit
		fi

		$scriptFinal

		# cleanup
		printf "Cleaning up..."; rm -fr "$tmpDir"; echo done

		exit 0

		EOF
	)" || return

	if [[ $test ]]; then
		header "$(ProperCase "$product") Configuration ($(GetFileName "$productConfigFileBase"))"
		cat "$tmpDir/config/$productConfigFileBase" || return

		header "Service Configuration"
		cat "$tmpDir/$product.service" || return
	fi

	return 0
}

installServerFinal()
{	
	[[ ! $servers ]] && return
	RunFunction "install" "${product}ServerFinal"
}

installAcl()
{
	! installComponentCheck "acl" && return

	header "Install $(ProperCase "$product") ACL"
	productConfig "$product" || return

	# generate the bootstrap token
	local header text
	local alreadyCreated="ACL bootstrap already done"; [[ "$product" == "consul" ]] && alreadyCreated="ACL bootstrap no longer allowed"
	local waitingForNodes="The ACL system is currently in legacy mode."
	
	# try up to 30 times to get the bootstrap text
	for (( i = 0; i < 30; i++ )); do
		text="$($product acl bootstrap 2>&1)" && break
		echo "$text" | grep -q "$alreadyCreated" && return
		echo "$text" | grep -q "$waitingForNodes" &&
			{ [[ $header ]] && printf "." || printf "bootstrap..."; header="true"; sleep 1; continue; }
		EchoErr "$text"; return 1
	done
	[[ $header ]] && echo
	echo "$text" | grep -q "$waitingForNodes" && { EchoErr "$text"; return 1; }
	
	# show the full bootstrap text
	hilight "Store the following bootstrap token in a secure location:"
	echo "$text"

	# get and store the token
	local secretId="Secret ID"; [[ "$product" == "consul" ]] && secretId="SecretID"
	local sep="="; [[ "$product" == "consul" ]] && sep=":"
	local token="$(echo "$text" | grep "$secretId" | cut -d$sep -f 2 | RemoveSpace)"
	[[ ! $token ]] && { ScriptErr "unable to determine the bootstrap token"; return 1; }
	credSet "token" "$token" || return

	productVarSet "TOKEN" "$token" || return
	[[ $verbose ]] && { echo "Updated environment variable $(productVar "TOKEN") to $(productVarGet "TOKEN")..."; }

	return 0
}

# installConfigHcl - turn the passed array variables into an HCL script
installConfigHcl()
{
	local key var

	for var in "$@"; do
		local -n config="$var"

		for key in "${!config[@]}"; do

			local equal=" =" quote="true" v="${config[$key]}"
			local fc="${v:0:1}" sc="${v:1:1}" # first and second characters

			# example: addresses { https = "0.0.0.0" }
			[[ "$fc" == "{" && "$sc" != "{" ]] && quote="" equal=""

			# example: retry_join = [ "pi3", "pi4" ]
			[[ "$fc" == "[" ]] && quote=""

			# listener "tcp" { address = "0.0.0.0:8200", tls_disable = 1 }
			[[ "$fc" == "\"" ]] && quote="" equal=""

			# boolean, example: server = true			
			[[ "$v" == @(true|false) ]] && quote=""

			# integer, example: bootstrap_expect = 2
			IsInteger "$v" && quote=""

			[[ $quote ]] && echo "$key$equal \"${config[$key]}\"" || echo "$key$equal ${config[$key]}"

		done

	done
}

installConfigService()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$product")
		Documentation=https://www.hashicorp.com/products/$product
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$productConfigFile
		StartLimitIntervalSec=10
		StartLimitBurst=3

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$productServiceEnvFile
		KillMode=process
		KillSignal=$serviceKillSignal
		Restart=on-failure
		RestartSec=2
		TasksMax=infinity
		$serviceLimit

		[Install]
		WantedBy=multi-user.target
	EOF
}

installFinal() { RunFunction "install" "${product}Final" || return; }

#
# All Commands
#

allUsage() { echot "\
Usage: $(ScriptName) all environment|status
Commands for all products."; }

allCommand() { usage; }

allEnvironmentCommand() { configEnvironmentAll; }

allStatusCommand()
{
	local product

	for product in "${products[@]}"; do
		header "$(ProperCase "$product") Status"
		${product}StatusCommand || return
	done
}

#
# Config Commands
#

configUsage() { echot "\
Usage: $(ScriptName) config [get|set|nuke|show](show)
Configure products.

	get VAR			get configuration variable
	nuke				delete all local and remote configuration
	set 				set configuration
	environment	set environment variables"; }

configCommand() { usage; }

# Config Environment Commands

configEnvironmentUsage() { echot "\
Usage: $(ScriptName) config environment [all|$productUsage|test|reset](all)
Set environment variables.   These commands should be called with ScriptEval
so the current environmnet is updated."; }

configEnvironmentCommand() { configEnvironmentAll; }
configEnvironmentAllCommand() { configEnvironmentAll; }
configEnvironmentResetCommand() { echo "unset CONSUL_HTTP_TOKEN VAULT_TOKEN NOMAD_TOKEN"; }
configEnvironmentTestCommand() { doHashi test environment; }

configEnvironmentConsulCommand() { configEnvironmentDo "consul"; }
configEnvironmentNomadCommand() { configEnvironmentDo "nomad"; }
configEnvironmentVaultCommand() { configEnvironmentDo "vault"; }

configEnvironmentAll()
{
	# initialize consul for product lookups
	productIsInstalled "consul" && { configEnvironmentCheckForce "consul"; productConfig "consul" || return; }

	local product
	for product in "${products[@]}"; do		
		! productIsInstalled "$product" && continue
		configEnvironmentDo "$product" || return; echo
	done
}

configEnvironmentDo() { configEnvironmentCheckForce "$1" && productEnvironment "$1"; }

configEnvironmentCheckForce() 
{
	local product="$1"
	[[ $force ]] && return
	[[ "$configPrefix" == "$(productVarGet "CONFIG")" && "$baseDomain" == "$(productVarGet "DOMAIN")" ]] && return; 
	[[ $verbose ]] && EchoErr "$product environment check fill be forced (configPrefix=$configPrefix $(productVar "CONFIG")=$(productVarGet "CONFIG")  baseDomain=$baseDomain $(productVar "DOMAIN")=$(productVarGet "DOMAIN")"
	force="--force"
}

# Config Get Command

configGetUsage() { echot "\
Usage: $(ScriptName) config get VAR
Get a configuration variable."; }

configGetArgStart() { unset varName; }
configGetArgs() { ScriptArgGet "varName" "var" -- "$@"; shift; }
configGetCommand() { configGet "$varName"; }

# configGet VAR
configGet()
{
	ConfigInit "$configFile" || return
	ConfigGet "hashi$(UpperCaseFirst "$configPrefix")$(UpperCaseFirst "$1")"
}

# Config Nuke Commands

configNukeUsage() { echot "\
Usage: $(ScriptName) config nuke all|$productUsage
Delete all local and remote configuration"; }

configNukeArgStart() { unset yes; }

configNukeOpt() 
{
	case "$1" in
		-y|--yes) yes="true";;
		*) return 1
	esac
}

configNukeCommand() { usage; }
configNukeAllCommand() { nukeDo "vault" && nukeDo "nomad" && nukeDo "consul"; }
configNukeConsulCommand() { nukeDo "consul"; }
configNukeNomadCommand() { nukeDo "nomad"; }
configNukeVaultCommand() { nukeDo "vault"; }

nukeDo()
{
	local product="$1"

	if [[ ! $force || ! $yes ]]; then
	 ScriptErr "To permanently deletes all local and remote configuration and certificates\n       for $baseDomain $configDesc, --force and --yes are required"
	 return 1
	fi

	header "Nuke $(ProperCase "$product") Configuration"

	if [[ "$product" == "vault" ]]; then
		echo "Removing Vault data from Consul..."
	  $testEcho consul kv delete -recurse "vault/"
	fi

	credDelete "all" || return

	nukeDir "$(certDirLocal)" || return
	nukeDir "$(certDirPrivate)" || return
	nukeDir "$(certDirPublic)" || return
}

nukeDir()
{
	local dir="$1"
	[[ ! $dir || ! -d "$dir" || "$(DirCount "$dir")" == 0 ]] && return
	echo "Deleting '$(FileToDesc "$dir")'..."
	$testEcho sudo DelDir --contents "$dir"
}

# Config Set Command

configSetUsage() { echot "\
Usage: $(ScriptName) config local|remote
Set configuration.

	local			set the local configuration
	remote		set the remote configuration"; }

configSetCommand() { usage; }

configSetLocalCommand()
{	
	local product; productInitAll "vault"	|| return

	# return if configuration is set
	[[ ! $force ]] && credential exists consul token $verbose && return

	# set local configuration
	vaultTokenCheck || return
	configMirror "vault" "local" || return
}

configSetRemoteCommand()
{
	local product; productInitAll "vault" || return

	# return if configuration is set
	[[ ! $force ]] && credential --manager=vault exists consul token $verbose && return

	# set remote configuration
	configMirror "local" "vault" || return
	vaultTokenSetRemote || return
}

configMirror()
{
	local from="$1" to="$2" product

	for product in "${products[@]}"; do
		credential mirror --from="$from" --to="$to" "$(credPath "$product")" --force $verbose || return
	done
}

#
# Consul Command
#

consulUsage() { echot "\
Usage: $(ScriptName) consul acl|backup|environment|restore|service|status
Consul commands."; }

consulCommand() { usage; }
consulBackupCommand() { consul snapshot save "$(GetDateStampNext "consul.$domain" "snap")"; }
consulEnvironmentCommand() { productEnvironment "$product"; }
consulStatusCommand() { consul members; }

# Consul ACL Command

consulAclUsage() { echot "\
Usage: $(ScriptName) consul acl create
Consul ACL commands."; }

consulAclCommand() { usage; }

# Consul ACL Create Command

consulAclCreateUsage() { echot "\
Usage: $(ScriptName) consul acl create [NAME] [DEFINITION]
Create a Consul ACL."; }

consulAclCreateArgStart() { unset name def; }

consulAclCreateArgs()
{
	ScriptArgGet "name" -- "$@"; shift
	ScriptArgGet "def" -- "$@"; shift
}

consulAclCreateCommand() { consulAclCreate "$name" "$def"; }

# Consul ACL Token Command

consulAclTokenUsage() { echot "\
Usage: $(ScriptName) consul acl token [get|delete] [NAME]
Manage Consul ACL tokens."; }

consulAclTokenArgStart() { unset name; }
consulAclTokenArgs() { ScriptArgGet "name" -- "$@"; shift; }
consulAclTokenCommand() { consulAclTokenGetCommand; }
consulAclTokenGetCommand() { consulAclTokenGet "$name"; }
consulAclTokenDeleteCommand() { consulAclTokenGet "$name"; }

# Consul ACL Helper

# consulAclCreate NAME DEF - create an ACL with the specified name and definition.   Return a token for the policy.
consulAclCreate()
{
	local name="$1" def="$2"
	consulAclPolicyCreate "$name" "$def" || return
	consulAclTokenCreate "$name" || return
}

# consulAclPolicyExists NAME - return true if the specified policy exists
consulAclPolicyExists()
{
	local name="$1"
	[[ "$(consul acl policy list -format=json | jq ".[] | select(.Name == \"$1\").Name" | RemoveQuotes)" == "$name" ]]
}

# consulAclPolicyCreate NAME DEF - create a policy with the specified name and definition
consulAclPolicyCreate()
{
	local name="$1" def="$2"
	[[ ! $force ]] && consulAclPolicyExists "$name" && return
	consulAclPolicyDelete "$name" || return

	hilight "Creatning ACL policy $name..."
	[[ $test ]] && { printf "${GREEN}create policy $name:${RESET}\n%s\n" "$(cat)"; return; }
	echo "$def" | consul acl policy create -name "$name" -rules -
}

# consulAclPolicyDelete NAME - delete the specified policy
consulAclPolicyDelete()
{
	local name="$1"
	! consulAclPolicyExists "$name" && return

	hilight "Deleting ACL policy $name..."
	[[ $test ]] && { hilight "delete policy $name"; return; }
	consul acl policy delete -name "$name"
}

# consulAclTokenGet DESC - get the token Secret ID with the specified description
consulAclTokenGet()
{
	local desc="$1"
	! consulAclTokenExists "$1" && { ScriptErr "token '$desc' does not exists"; return 1; }
	consul acl token read -id "$(consulAclTokenId "$desc")" | grep "SecretID" | cut -d: -f 2 | RemoveSpace
}

# cosulTokenExists NAME - return true if the tokenexists
consulAclTokenExists()
{
	local name="$1"
	[[ "$(consul acl token list -format=json | jq ".[] | select(.Description == \"$name\").Description" | RemoveQuotes)" == "$desc" ]]
}

# consulAclTokenId NAME - get the token ID
consulAclTokenId()
{
	local name="$1"
	consul acl token list -format=json | jq ".[] | select(.Description == \"$name\").AccessorID" | RemoveQuotes
}

# consulAclTokenCreate DESC POLICY - create a token with the specified description that has the permission to the specified policy
consulAclTokenCreate()
{
	local desc="$1" policy="${2:-$1}"
	[[ ! $force ]] && consulAclTokenExists "$desc" && return	
	consulAclTokenDelete "$desc" || return

	hilight "Creating ACL token $desc for policy $policy..."
	[[ $test ]] && { hilight "create token $desc for policy $policy"; return; }
	consul acl token create -description "$1" -policy-name "$policy"
}

# consulAclTokenDelete DESC - delete the token with the specified description
consulAclTokenDelete()
{
	local desc="$1"
	! consulAclTokenExists "$desc" && return

	hilight "Deleting ACL token $desc..."
	[[ $test ]] && { hilight "delete token $desc"; return; }
	consul acl token delete -id "$(consulAclTokenId "$desc")"
}

#
# Consul Service
#

consulServiceInit() { unset file; }

consulServiceUsage() { echot "\
Usage: $(ScriptName) consul service register|deregister FILE
Consul service commands."; }

consulServiceArgs() { ScriptArgGet "file" -- "$@"; ScriptCheckFile "$file"; shift; }

consulServiceCommand() { usage; }

consulServiceRegisterCommand()
{
	# get the service ID
	local id type; type="$(validateConfigFile "$file")" || return
	if [[ "$type" == "json" ]]; then
		id="$(cat "$file" | jq ".service.name" | RemoveQuotes)"
	else
		id="$(cat "$file" | grep "name =" | head -1 | cut -d= -f2 | RemoveSpace | RemoveQuotes)"
	fi
	[[ ! $id ]] && { ScriptErr "Unable to determine the service id in '$file'"; return 1; }

	# create the service ACL policy
	local name="service-$id"
	local policy="$(cat <<-EOF
		service "$id" {
		  policy = "write"
		}
		EOF
	)"	
	consulAclCreate "$name" "$policy" || return

	# register the service
	local token="$(consulAclTokenGet "$name")" || return
	local f; f="$(mktemp -t "hashi.service.XXXX.hcl")" || return
	if [[ "$type" == "json" ]]; then
		cat "$file" | sed "s/\"token\": \".*\"/\"token\" = \"$token\"/" > "$f" || return
	else
		cat "$file" | sed "s/token = \".*\"/token = \"$token\"/" > "$f" || return
	fi
	[[ $test ]] && { cat "$f"; return; }
	consul services register "$f" || return

	# cleanup
	rm -f "$f"	

	return 0
}


# -id|FILE
consulServiceDeregister() { consul services deregister; }

#
# Nomad Commands
#

nomadUsage() { echot "\
Usage: $(ScriptName) nomad environment|job|status
Nomad commands."; }

nomadCommand() { usage; }
nomadEnvironmentCommand() { productEnvironment "$product"; }
nomadStatusCommand() { nomad node status; }

#
# Nomad Job Commands
#

nomadJobUsage() { echot "\
Usage: $(ScriptName) nomad job NAME
Nomad job commands.

	force	NAME		force a periodic job to start
	log	NAME			show the log for a periodic job
	status [NAME]	status of all running jobs or the specified job"; }

nomadJobArgs()
{
	job="$1"; shift; ((++shift))
	[[ ! $job && "${commandNames[2]}" != @(|status) ]] && usage
	return 0
}

nomadJobCommand() {	nomadJobStatusCommand; }

# nomad job status 

nomadJobStatusCommand() 
{
	if [[ $job ]]; then
		nomadGetAllocId || return
		nomad alloc status "$allocId"
	else
		nomad job status | grep -v dead
	fi
}

# nomnd job force

nomadJobForceUsage() { echot "\
Usage: $(ScriptName) nomad job force NAME
Force the the specified periodic job to start.

	-l|--log 	follow the job log after starting it"; }

nomadJobForceArgStart() { log=""; }

nomadJobForceOpt() 
{
	case "$1" in
		-l|--log) log="true";;
		*) return 1
	esac
}

nomadJobForceCommand()
{
	nomad job periodic force "$job" || return

	if [[ $log ]]; then 
		local follow="true"
		nomadJobLogCommand || return
	fi

	return 0
}

# nomad job log

nomadJobLogUsage() { echot "\
Usage: $(ScriptName) nomad job log NAME
Show the log for the specified periodic job.

	-f|--follow 	follow the log output"; }

nomadJobLogArgStart() { follow=""; }

nomadJobLogOpt() 
{
	case "$1" in
		-f|--follow) follow="true";;
		*) return 1
	esac
}

nomadJobLogCommand()
{
	nomadGetAllocId || return
	
	if [[ $follow ]]; then
		nomad alloc logs -f "$allocId" &
		nomad alloc logs -stderr -f "$allocId"
	else		
		header "Standard Output"; nomad alloc logs "$allocId"
		header "Standard Error"; nomad alloc logs -stderr "$allocId"
	fi		
}

# nomad helper

nomadGetJobId()
{ 
	jobId="$(nomad job status "$job" |& tail -1 |& cut -d" " -f1)"
	[[ "$jobId" =~ $job/periodic-.* ]] && return
	ScriptErr "Unknown job '$job'"; exit 1
}

nomadGetAllocId()
{
	[[ ! $jobId ]] && { nomadGetJobId || return; }
	allocId="$(nomad job status "$jobId" |& tail -1 |& cut -d" " -f1)"
	[[ "${#allocId}" == "8" ]] && return
	ScriptErr "No allocations for job '$job'"; exit 1
}

#
# Vault Commands
#

vaultUsage() { echot "\
Usage: $(ScriptName) vault environment|status|unseal
Vault commands.

	unseal			unseal the vault using keys from the credential store"; }

vaultCommand() { usage; }
vaultEnvironmentCommand() { productEnvironment "$product"; }
vaultSealCommand() { vault operator seal; }

vaultStatusCommand()
{
	local result

	vault status; status="$?"

	echo "Active Node            $(hashi resolve active.vault)"
	echo "Standby Node           $(hashi resolve standby.vault)"

	case "$status" in
		2) hilight "The vault is sealed";;
		*) return "$status";;
	esac

}

vaultUnsealCommand()
{
	local host hosts key; getHosts "${vaultServers[@]}" || return

	# unseal each host
	for host in "${hosts[@]}"; do
		header "$host"
		productConfig vault "$host" || return

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credGet "key$n")"
			if [[ $key ]]; then
				vault operator unseal "$key" || return
			else
				echo "key $n does not exist in the credential store"
			fi
		done

	done
}

vaultTokenHost() { local hosts; getHosts "${vaultServers[@]}"; echo "${hosts[0]}"; }
vaultTokenSetRemote() { ssh -q -t "$(vaultTokenHost)" bash -i credential set "$(credPath vault)" token "$1" $verbose; }

vaultTokenCheck()
{
	[[ $VAULT_TOKEN && ! $force ]] && return

	local host="$(vaultTokenHost)"; IsLocalHost "$host" && return

	[[ $verbose ]] && EchoErr "Getting Vault token from $host..."
	local token; token="$(ssh -q -t "$host" bash -i credential get "$(credPath vault)" token $verbose)"
	[[ ! $token ]] && { ScriptErr "The Vault token does not exist in the local credential manager on $(vaultTokenHost) at path $(credPath vault)"; return 1; }
	export VAULT_TOKEN="$token"
}

#
# Certificate Helper
#

certInit()
{
	[[ $verbose ]] && EchoErr "Initializing $product certificates..."

	# vault uses consul certificates
	local product="$product"; [[ "$product" == "vault" ]] && product="consul"

	certDirPrefix="$(certDirLocal)"; [[ $encrypt ]] && certDirPrefix="$(certDirPrivate)"
	certDir="$(certDirInit "$certDirPrefix")"
	certDirServer="/opt/$product/cert"	

	ca="$product-ca.pem"
	caLocal="$ca" # CA to use for access to the local server
	caKey="$product-ca-key.pem"	
	certCli=$product-cli.pem
	certCliKey=$product-cli-key.pem
	certClient=$product-client.pem
	certClientKey=$product-client-key.pem
	certServer=$product-server.pem
	certServerKey=$product-server-key.pem

	certStore="/usr/local/share/ca-certificates"
	certStoreCa="$certStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$ca").crt"

	# consul clients use an automatic CA
	unset caAuto certStoreCaAuto	
	if [[ "$product" == "consul" ]]; then
		caAuto="$product-ca-auto.pem"
		certStoreCaAuto="$certStore/$domain-$configDesc-$(GetFileNameWithoutExtension "$caAuto").crt"
		[[ "$type" == "client" ]] && caLocal="$caAuto"
	fi

	return 0
}

# certDirInit DIR - add certificate suffix to DIR: DIR/certificate/DOMAIN[/CONFIG_PREFIX]/PRODUCT
certDirInit() { GetArgs; echo "$(RemoveTrailingSlash "$1")/certificate/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"; }

# certDirLocal - certificate directory for command line clients (not servers)
certDirLocal() { echo "/opt/hashi"; }

# certDirPublic - directory for public certificates
certDirPublic() { findInstallFile --quiet "other/HashiCorp"; }

# certDirPrivate - directory for private certificates
certDirPrivate() 
{
	if [[ $encrypt && "$encrypt" != "find" ]]; then echo "$encrypt"							# encrypt argument
	elif [[ $(configGet "certificateDir") ]]; then configGet "certificateDir"		# configuration
	else return 1
	fi
}

# certExist FILES - return 0 if all certificate files exist in the certificate directory
certExist()
{ 
	local file
	for file in "$@"; do
		[[ ! -f "$certDir/$file" ]] && return 1
	done
}

certStoreInstall()
{
	local src="$1" dest="$2"
	[[ ! -d "$certStore" ]] && return
	[[ ! $force && -f "$certDir/$src" ]] && return

	hilight "Installing $src in the certificate store..."
	sudo cp "$certDir/$src" "$dest" || return
	sudo update-ca-certificates || return
}

certStoreWinInstall()
{
	local src="$1"

	! IsPlatform win && return
	
	hilight "Installing $src in the Windows certificate store..."
	local file="$ADATA/Temp/$src"
	cp "$certDir/$src" "$file" || return
	RunScript --elevate "$verbose" -- certutil.exe -addstore root "$(utw "$file")" || return
	rm "$file" || return
}

# certValidate FILES - show an error if a certificate does not exist in the certificate directory
certValidate()
{
	local file
	for file in "$@"; do 
		if [[ ! -f "$certDir/$file" ]]; then
			EchoErr "$(ProperCase "$product") certificate $file does not exist in '$(FileToDesc "$certDir")'"
			return 1
		fi
	done
}

certValidateDir() { [[ -d "$1" ]] && return 0; EchoErr "Certificate directory '$1' does not exist"; return 1; }

#
# Credential Helper
#

credPath()
{
	local path="$(configGet "credentialPath")" product="${1:-$product}"

	if [[ "$path" ]]; then
		echo "$(RemoveTrailingSlash "$path")/$product"
	else
		echo "/hashi/$baseDomain$(RemoveTrailingSlash "/$configPrefix")/$product"
	fi
}

credDelete() { $testEcho credential delete "$(credPath)" "$@" $verbose; }
credExists() { credential exists "$(credPath)" "$@" $verbose; }
credGet() { credential get "$(credPath)" "$@" $verbose; }
credGets() { credential gets "$(credPath)" "$@" $verbose; }
credGetIfExists() { credExists "$@" --quiet && credGet "$@" --quiet; }

credSet()
{
	[[ $verbose ]] && echo "Setting $(credPath) $1 credential to $2..."
	$testEcho credential set "$(credPath)" "$@" $verbose || return
}

#
# Host Helper
#

hostCheck()
{
	local host="$1"
	[[ ! $host ]] && MissingOperand "host"
	! IsAvailable "$host" && { EchoErr "$host is not available"; return 1; }
	return 0
}

hostCleanup()
{
	local host="$1"; hostCheck "$host" || return 0

	scriptRun "$(cat <<-EOF
			printf "cleaning..."
			[[ \$(find "$TEMP" -maxdepth 1 -name "hashi.*") ]] && printf "." && sudo rm -fr "$TEMP/hashi."*
			[[ -d "$TEMP/consul-test" ]] && printf "." && rmdir "$TEMP/consul-test"
			printf "." && rm -f "$TEMP/hashi.service."*
			echo "done"
			EOF
	)"
}

# hostCopy "FILE" "DEST" - copy file to the host destination directory withthe correct permissions
hostCopy()
{
	local file="$1" dest="$2"
	local name="$(GetFileName "$file")"

	hilight "Copying files to $host..."
	scp "$file" "$host:/tmp" || return

	scriptRun "$(cat <<-EOF
		sudo mv "/tmp/$name" "$dest" || exit
		sudo chmod 755 "$dest/$name" || exit
		sudo chown "$user" "$dest/$name" || exit
		sudo chgrp "$user" "$dest/$name" || exit
		EOF
	)"
}

#
# Product Helper
#

productInit() { [[ $verbose ]] && EchoErr "Initializing $1..."; product="$1"; }

productInitAll()
{
	productInit "$1"

	# if the configuration prefix has not been set use the product CONFIG environment variable
	! IsVar configPrefix && [[ $product ]] && { configPrefix="$(productVarGet "CONFIG")"; } 

	# configuration prefix aliases
	[[ "${configPrefix,,}" == "prod" ]] && configPrefix=""

	# configuration description
	configDesc="${configPrefix:-prod}"

	# default servers and clients which depend on the configuration prefix being set
	hashiServers=(); StringToArray "$(configGet "servers")" "," hashiServers
	hashiClients=(); StringToArray "$(configGet "clients")" "," hashiClients
	vaultServers=(); StringToArray "$(configGet "vaultServers")" "," vaultServers
	hashiHosts=(); ArrayAppend --remove-dups hashiHosts hashiServers hashiClients vaultServers

	# host aliases
	[[ "${hostArg,,}" == "first" ]] && hostArg="${hashiServers[0]}"
	[[ "${hostArg,,}" == "second" ]] && hostArg="${hashiServers[1]}"
	[[ "${hostArg,,}" == "third" ]] && hostArg="${hashiServers[2]}"

	# product configuration
	[[ $product ]] && { productConfig "$product" || return; }

	return 0
}

productCheck()
{
	local product="$1"; [[ ! $product ]] && MissingOperand "product"
	! productIsInstalled "$1" && { EchoErr "$product is not installed"; return 1; }
	return 0
}

# productConfig PRODUCT [HOST] - set the configuration variables for the specified product, which enables use of
# the the product in this script
productConfig()
{
	local product="$1" host="$2"

	# validate product
	productCheck "$1" || return

	# logging
	if [[ $verbose ]]; then
		local desc; [[ $host ]] && desc=" for $host"
		HilightErr "Getting $product configuration$desc..."
		productEnvironment "$product" "$host" || return
	fi

	# set product configuration variables
	ScriptEval productEnvironment "$product" "$host" || return

	# logging
	if [[ $verbose ]]; then
		local token="$(productVarGet "TOKEN")" desc="no token"; [[ $token ]] && desc="token $token"
		HilightErr "Using $product server at $(productVarGet "ADDR") with $desc"
	fi

}

# productEnvironment PRODUCT [HOST] - show the environment variables for the specified product
productEnvironment()
{
	local product="$1" host="$2"

	productCheck "$product" || return
	productInit "$product" || return
	certInit || return
	[[ ! -d "$certDirLocal" && -d "$certDirServer" ]] && certDir="$certDirServer"
	
	# variables
	local server; server="$(productGetServer "$product" "$host")" || return
	local url; url="$(productGetAddress "$product" "$server")" || return	

	# local hosts use the automatic certificate authority
	IsLocalHost "$server" && [[ -f "$certDirServer/$caAuto" ]] && ca="$caAuto"
	
	# validate certificates
	[[ -d "$certDir" ]] && { certValidate "$ca" "$certCli" "$certCliKey" || return; }

	# arguments
	local args="-http-addr=$url"
	[[ -d "$certDir" ]] && args+=" -ca-file=$ca -client-cert=$certDir/$certCli -client-key=$certDir/$certCliKey"

	# standard configuration
	cat <<-EOF
		export $(productVar "CONFIG")="$configPrefix"
		export $(productVar "DOMAIN")="$baseDomain"
		export $(productVar "SERVER")="$server"
		export $(productVar "ADDR")="$url"
		export $(productVar "ARGS")="$args"
	EOF

	# certificate configuration
	if [[ -f "$certDir/$certCli" ]]; then
		certValidate "$certCli"
		cat <<-EOF
			export $(productVar "CACERT")="$certDir/$ca"
			export $(productVar "CLIENT_CERT")="$certDir/$certCli"
			export $(productVar "CLIENT_KEY")="$certDir/$certCliKey"
		EOF
	fi

	# token configuration - set if not already set, i.e. nomad can set the VAULT_TOKEN
	local token tokenVar tokenVal
	tokenVar="$(productVar "TOKEN")"
	tokenVal="$(productVarGet "TOKEN")"
	if [[ $force || ! $tokenVal ]]; then
		local exclude=(); [[ "$product" == "vault" ]] && exclude=( "--exclude-managers=vault" ) # prevent recursion	
		[[ "$CREDENTIAL_MANAGER" == @(remote|v|vault) ]] && export CREDENTIAL_MANAGER="local"
		tokenVal="$(credGets "token" "${exclude[@]}" --quiet)" || tokenVal=""
	fi
	[[ $tokenVal ]] && echo "export $tokenVar=\"$tokenVal\""

	return 0
}

# productGetAddress PRODUCT [SERVER] [PORT] - get the communication URL for the product
productGetAddress()
{
	local product="$1"
	local server="$2"; [[ ! $server ]] && server="$(productGetServer "$product")"
	local port="$3"; [[ ! $port ]] && port="$(productGetPort "$product")"
	useHttps && echo "https://$server:$port" || echo "http://$server:$port"
}

# productGetPort PRODUCT - get the primary port for the specified product
productGetPort()
{
	local p="$1"
	declare -n port; useHttps && port="${p}HttpsPort" || port="${p}HttpPort"
	echo "$port"
}

# productGetServer PRODUCT [HOST] - get the server for the product
productGetServer()
{
	local product="$1" host="$2" server
	local resolve="$product"; [[ "$product" == "vault" ]] && resolve="active.vault"

	# use the passed host
	if [[ $host ]]; then
		server="$host"

	# product-server argument
	elif [[ $productServer ]]; then
		server="$productServer"

	# arguments: use the host specified by the --host, --servers, or -clients arguments
	elif [[ $hostArg || $servers ]]; then
		local hosts; getHosts "${servers[@]}" || return
		server="${hosts[0]}"

	# use the <product>_SERVER environment variable
	elif [[ ! $force && $(productVarGet "SERVER") ]]; then
		server="$(productVarGet "SERVER")"

	# use the local host for the server if the product service is running
	elif [[ "$product" != @(nomad) ]] && [[ -f $productServiceFile ]] && IsProcessRunning "$product" && service running "$product"; then
		server="127.0.0.1"

	# use consul to resolve the server for the product
	elif [[ "$product" != "consul" ]] && server="$(hashi resolve "$resolve" 2>&1)"; then		
		:

	# use the first server specified in bootstrap-config.sh
	else
		local servers="$hashiServers"; [[ "$product" == "vault" ]] && servers="${vaultServers[@]}"
		server="$(GetWord "$hashiServers" 1)"

	fi

	# return server - use 127.0.0.1 or the fully qualified DNS name to match the certificate
	IsLocalHost "$server" && echo "127.0.0.1" || DnsResolve "$server"
}

productInstall()
{
	local product; productInit "$1" || return
	local host="$2"; hostCheck "$host" || return
	local installDir="$(findInstallFile "other/HashiCorp/$product")" || return		

	# local install
	if IsLocalHost "$host"; then
		header "Install $(ProperCase "$product") Program (local)"
		local file="$(os executable find "$installDir")" || return
		InPath "$product" && [[ "$(productVersion "$product")" == "$(productVersion "$product" "$file")" ]] && return	
		sudoc cp "$file" "$binDir/$product"; return		
		return 0
	fi

	local dest="$binDir/$product"

	# header
	header "Install $(ProperCase "$product") Program ($host)"

	# version check
	ssh "$host" "[[ -f \"$dest\" ]]" && [[ "$(productVersion "$product")" == "$(productVersion "$product" "$host")" ]] && return

	# determine the host architecture
	printf "$host architecture..."
	local machine="$(ssh "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm"; [[ "$product" == "consul" ]] && machine="armhfv6";;
		*) machine="amd64";; 
	esac
	printf "$machine..."

	# find the program
	printf "program..."
	local file="$(find "$installDir" -maxdepth 1 -type f  -name "$product*_linux_$machine" | tail -1)"
	[[ ! -f "$file" ]] && { echo; ScriptErr "unable to find the $product program"; return 1; };
	echo "$(GetFileName "$file")"

	# copy the program
	scp "$file" "$host:/tmp/$product" || return

	scriptRun "$(cat <<-EOF
		[[ -f "$productServiceFile" ]] && { printf "stopping service..."; sudo systemctl stop "$product" || exit; echo "done"; }
		sudo cp "/tmp/$product" "$binDir" || exit
		[[ -f "$productServiceFile" ]] && { printf "starting service..."; sudo systemctl start "$product" --no-block || exit; echo "done";  }
		exit 0
		EOF
	)"
}

productInstallCerts()
{
	local product="$1"; certInit || return
	local dest="$(certDirLocal | certDirInit)"

	[[ ! $encrypt ]] && return
	
	# return if already installed
	[[ -f "$dest/$ca" && ! $force ]] && return	

	# ensure the certificates exist
	certValidate "$ca" "$certCli" "$certCliKey" || return

	printf "${GREEN}Installing $product certificates...${RESET}"
	sudoc mkdir --parents "$dest" || return
	sudo cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$dest" || return
	sudo chmod +r "$dest/"* || return
	hilight "done"

	certStoreWinInstall "$ca" || return
	certStoreInstall "$ca" "$certStoreCaAuto" || return
	certStoreInstall "$caAuto" "$certStoreCaAuto" || return

	return 0
}

productIsInstalled() { [[ $(FindInPath "$1") ]]; }

productRemove()
{
	local product="$1"; productInit "$1" || return
	local host="$2"; hostCheck "$host" || return 0
	
	scriptRun "$(cat <<-EOF

		# delete service
		if [[ -f "$productServiceFile" ]]; then
			echo "Deleting the service..."
			sudo systemctl stop "$product" || exit
			sudo systemctl disable "$product" || exit
			sudo rm -f "$productServiceFile" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl reset-failed || exit
		fi

		# remove certificates
		if [[ -f "$certStoreCa" ]]; then
			echo "Removing automatic CA certificate..."
			sudo rm "$certStoreCa" || exit
			sudo update-ca-certificates || return
		fi

		printf "cleaning..."
		getent passwd "$product" >&/dev/null && { printf "user..."; sudo userdel "$product" >& /dev/null; }
		getent group "$product" >&/dev/null && { printf "group..."; sudo groupdel "$product" >& /dev/null; }
		[[ -d "/etc/$product.d" ]] && { printf "configuration..."; sudo rm -fr "/etc/$product.d"; }
		[[ -d "/opt/$product" ]] && { printf "data..."; sudo rm -fr "/opt/$product"; }
		[[ "$program" && -f "$binDir/$product" ]] && { printf "program..."; sudo rm -f "$binDir/$product"; }

		[[ \$(find /tmp -maxdepth 1 -name "hashi.*") ]] && { printf "tempory files..."; sudo rm -fr "/tmp/hashi."*; }
		[[ -d "/tmp/consul-test" ]] && sudo rmdir "/tmp/consul-test"

		echo "done"

		EOF
	)"
}

# productVar VAR - get the environment variable name
productVar()
{
	local var="${1^^}"
	local http; [[ "$product" == "consul" && "$var" == @(ADDR|TOKEN) ]] && http="HTTP_";
	echo "${product^^}_${http}${var}"; 
}

# productVarGet VAR - get a product variable from the environment
productVarGet()
{
	local var="$1"
	local -n v="$(productVar "$var")"
	echo "$v"
}

# productVarSet VAR VALUE - set a product environent variable 
productVarSet()
{
	local var="$1" value="$2"
	local -n v="$(productVar "$var")"
	v="$value"
}

# productVersion PRODUCT WHAT - show the versionof the specified product
productVersion()
{
	local product="$1" what="${2:-$HOSTNAME}" desc version

	if [[ -f "$what" ]]; then
		# use the standard download file format (PRODUCT_VERSION_PLATFORM_ARCHITECURE) if possible as running Go programs on network shares from Windows can fail
		local file="$(GetFileName "$what")"
		[[ "$(GetWord "$file" 1 _)" == "$product" ]] && version="$(GetWord "$file" 2 _)" || version="$("$what" --version)" 
		desc="$(FileToDesc "$what")"

	elif IsLocalHost "$what"; then
		version="$($product --version | productVersionFilter)"
		desc="local"

	else
		version="$(ssh $host -- $product --version) | productVersionFilter"
		desc="$what"
	fi
	
	[[ $verbose ]] && EchoErr "$product version ($desc) is $version"
	echo "$version"
}

productVersionFilter() { head -1 | cut -d" " -f 2 | RemoveFront v; }
	
#
# helper
#

doHashi() { hashi "$@" $force $test $verbose "${configFileArg[@]}" "${configPrefixArg[@]}" "${otherArgs[@]}"; }
tmpDirCreate() { mktemp -d -t "$tmpDirTemplate"; }
useHttps() { [[ $encrypt || -d "$certDir" ]]; } # use HTTPS during installation ($encrypt) and client configuration (cert directory exists)

copyFile()
{
	local file="$1" dest="$2"
	
	# return if the file exists
	[[ -f "$dest/$file" && ! $force ]] && return	

	# copy the file
	echo "Copying $(GetFileName "$file")..."
	$testEcho cp "$file" "$dest"
}

encryptOptGet()
{
	ScriptOptGet --check "encrypt" "$@" && { ScriptCheckDir "$encrypt"; return; }
	encrypt="find" # find later to ensure configPrefix is defined if needed	
}

findInstallFile()
{
	i check || return # cache the installation directory
	FindInstallFile "$@"
}

getHosts() 
{
	if [[ $hostArg ]]; then
		StringToArray "$hostArg" "," hosts
	else
		hosts=( "${@}" )
	fi

	[[ ! $hosts ]] && MissingOperand "host"
	return 0
}

# scriptRun SCRIPT - run the specified script locally over over ssh
scriptRun()
{
	local functions="$(FindInPath function.sh | GetFullPath)" script="$1"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		  sudo() { sudoc "\$@"; }
		fi

		$script
		EOF
	)"

	[[ $test ]] && { printf "%s\n" "$script"; return; }

	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		DISPLAY="" ssh -q -X -t "$host" "$script"
	fi
}

# validateConfigFile FILE - return false if the specified file is not a valid HashiCorp configuration file.
validateConfigFile()
{
	local type="$(GetFileExtension "$file")"
	[[ ! "$type" == @(hcl|json) ]] && { ScriptErr "Specified file /`$file/` is not a valid HashiCorp configuration file"; return 1; }
	echo "$type"
}

run "$@"

#!/usr/bin/env bash
. function.sh || exit
. bootstrap-config.sh || exit

run() {	init && args "$@" && ${command}Command "${args[@]}"; }

init()
{
	products=( consul nomad vault )
	datacenter="$workgroup"

	consulHttpPort="8500"
	consulHttpsPort="8501"
	nomadHttpPort="4646"
	nomadHttpsPort="4646"
	vaultHttpPort="8200"
	vaultHttpsPort="8200"
}

usage()
{
	echot "\
usage: $(ScriptName) COMMAND

	config						display the configuration variables
	ui								start the hashi-ui server and launch it

	install|remove [PRODUCT]		install or remove a product
		PRODUCT can be cli|consul|nomad|vault

	lookup|resolve 		get the first or all hosts
		[all] [NAME[.service]]
	unseal 		unseal the vault for the specified hosts

--host [HOST|all](found) - comma separated list of hosts to unseal

	-h, --host HOST		use the specified host
	-f, --force				force installation
	-t, --test				do not make changes	


	"
	exit ${1:-1}
}

args()
{
	unset force hostArg test

	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-f|--force) force="--force";;
			-h|--help) usage 0;;
			-h|--host) [[ ! $2 ]] && IsOption "$2" && usage 1; hostArg="$2"; shift;;
			-t|--test) test="--test";;
			*)
				! IsOption "$1" && [[ ! $command ]] && { CheckCommand "$1"; command="${1,,}"; shift; continue; }
				[[ "$command" == @(install|lookup|remove|resolve) ]] && break
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $command ]] && { usage; }

	args=("$@")
}

#
# configuration
#

configCommon()
{
	local name="$1"

	# directories	
	config="/etc/$name.d" 
	data="/opt/$name"
		
	# configuration files
	configFileBase="01_$name.hcl"
	configFile="$config/$configFileBase"
	serviceFile="/etc/systemd/system/$name.service"
	serviceEnvFile="/etc/systemd/system/$name.env"
}

configCert()
{
	local name="$1"; [[ "$name" == "vault" ]] && name="consul" # vault uses consul certificates

	certDir="$encrypt/$name"	# source (private) certificate directory
	cert="/opt/$name/cert" 		# public (program) certificate directory

	ca="$name-ca.pem"
	caKey="$name-ca-key.pem"
	certCli=$name-cli.pem
	certCliKey=$name-cli-key.pem
	certClient=$name-client.pem
	certClientKey=$name-client-key.pem
	certServer=$name-server.pem
	certServerKey=$name-server-key.pem
}

configInstall()
{
	local name="$1"

	# ensure the CLI program exists locally
	! InPath "$name" && { inst "$name" || return; }

	# general
	tmpDirTemplate="hashi.XXXXXXXXXX"
	executable="$(FindInPath "$name")" || return
	user="$name"
	commonOptions=( [log_level]="Info" )

	# clients and server defaults
	[[ "$name" == "vault" && ! $servers ]] && { servers=( "${vaultServers[@]}" ); }
	[[ ! $clients && ! $servers ]] && { clients=( "${hashiClients[@]}" ) servers=( "${hashiServers[@]}" ); }

	# join servers
	[[ ! $join ]] && join=( "${servers[@]}" )
	[[ ! $join ]] && join=( "${hashiServers[@]}" )
	joinFqdn=(); local h; for h in "${join[@]}"; do joinFqdn+=( "$(os hostname "$h")" ); done
	
	return 0
}

#
# Commands
#

configCommand()
{
	(( $# != 0 )) && usage 1

	for name in "${products[@]}"; do
		configCommon "$name" || return
		configCert "$name" || return

		local args="" url="$(getUrl "$name")"

		[[ -f "$cert/$certCli" ]] && args+=" -ca-file=$cert/$ca -client-cert=$cert/$certCli -client-key=$cert/$certCliKey"

		local http=""; [[ "$name" == "consul" ]] && http="HTTP_"

		cat <<-EOF
			export ${name^^}_${http}ADDR="$url"
			export ${name^^}_ARGS="-http-addr=$url$args"
		EOF

		[[ -f "$cert/$certCli" ]] &&
			cat <<-EOF
				export ${name^^}_CACERT="$cert/$ca"
				export ${name^^}_CLIENT_CERT="$cert/$certCli"
				export ${name^^}_CLIENT_KEY="$cert/$certCliKey"
			EOF

		local token; token="$(getToken "$name")" && echo "export ${name^^}_${http}TOKEN=\"$token\""

		echo

	done
}

lookupCommand()
{
	local name="$1"; [[ ! $name ]] && usage 1

	! HasDnsSuffix "$name" && name+=".service"
	name+=".$domain"

	configCommon "consul" || return
	nslookup -port=8600 -type=a -norecurse "$name" "$(getServer "consul")"
}

resolveCommand()
{
	local all="head -1"; [[ "$1" == "all" ]] && { all="cat"; shift; }

	local result="$(lookupCommand "$@")" || return

	if [[ "$result" =~ .*canonical\ name.* ]]; then
		printf "$result" | tail +4 | grep "canonical name =" | cut -d= -f2 | RemoveSpace | sed 's/.$//' | $all
	else
		printf "$result" | tail +4 | grep "^Address:" | cut -d: -f2 | RemoveSpace | $all
	fi

	return "${PIPESTATUS[0]}"
}

uiCommand()
{
	local product

	product="consul"
	configCommon "$product" || return
	configCert "$product" || return
	export CONSUL_ENABLE="true"
	export CONSUL_ADDR="$(getUrl "$product")"
	export CONSUL_ACL_TOKEN="$(credential get "$product" token)"
	export CONSUL_HTTP_SSL="true"
	export CONSUL_CACERT="$cert/$ca"
	export CONSUL_CLIENT_CERT="$cert/$certCli"
	export CONSUL_CLIENT_KEY="$cert/$certCliKey"

	product="nomad"
	configCommon "$product" || return
	configCert "$product" || return
	export NOMAD_ENABLE="true"
	export NOMAD_ADDR="$(getUrl "$product")"
	export NOMAD_ACL_TOKEN="$(credential get "$product" token)"
	export NOMAD_HTTP_SSL="true"
	export NOMAD_CACERT="$cert/$ca"
	export NOMAD_CLIENT_CERT="$cert/$certCli"
	export NOMAD_CLIENT_KEY="$cert/$certCliKey"

	hashi-ui-linux-amd64 &
	start "http://$(GetIpAddress):3000"
}

unsealCommand()
{
	local host hosts=() key

	# get the vault hosts
	if [[ ! $hostArg ]]; then
		hosts=( "${vaultServers[@]}" )
	else
		StringToArray "$hostArg" "," hosts
	fi

	# unseal each host
	for host in "${hosts[@]}"; do
		header "$host"
		eval "$(hashi config --host "$host")"

		for n in 1 2 3; do
			hilight "Unsealing $host with key $n..."
			key="$(credential get vault key$n)"
			if [[ $key ]]; then
				vault operator unseal "$key" || return
			else
				echo "key $n does not exist in the credential store"
			fi
		done

	done
}

#
# Install Commands
#

installUsage()
{
	echot "\
usage: $(ScriptName) install cli|consul|nomad|vault

	If no hosts are specified use hosts from bootstrap-config.sh.

	-c, --clients	HOSTS					comma separated list of clients to install
	-s, --server HOSTS					comma separated list of servers to install
	-j, --join HOSTS						comma separated list of hosts to join to, defaults to servers
	-cert, --certificates DIR		directory for PKI certificates, if specified TLS will be enabled"
	exit ${1:-1}
}

installCommand()
{
	local command name clients=() servers=() join=()
	local encrypt certDir
	local -A commonOptions

	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-h|--help) installUsage 0;;
			-c|--clients) [[ ! $2 ]] && usage 0; shift; StringToArray "$1" "," clients;;
			-s|--servers) [[ ! $2 ]] && usage 0; shift; StringToArray "$1" "," servers;;
			-j|--join) [[ ! $2 ]] && usage 0; shift; StringToArray "$1" "," join;;
			-cert|--certificates) encrypt="$2"; shift;;
			*)
				! IsOption "$1" && [[ ! $command ]] && { CheckSubCommand "install" "$1"; name="$1"; shift; continue; }
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $command ]] && { usage; }

	# run other installation commands
	[[ "$name" == @(cli) ]] && { $command; return; }

	# configuration variables
	configCommon "$name" || return
	configCert "$name" || return
	configInstall "$name" || return

	# temporary files
	local result tmpDir="$(mktemp -d -t "$tmpDirTemplate")" || return

	# run the command
	$command; result="$?"

	# cleanup
	[[ ! $test ]] && { rm -fr "$tmpDir"; ssh "$host" rm -fr "$tmpDir"; }
	return "$result"
}

installCliCommand()
{
	for name in "${products[@]}"; do

		{ [[ $force ]] || ! InPath "$name"; } && { inst $force "$name" || return; }

		configCert "$name" || return
		if [[ $encrypt ]] && { [[ $force || ! -f "$cert/$ca" ]]; }; then
			printf "Installing $name certificates..."
			sudoc mkdir --parents "$cert" || return
			sudoc cp "$certDir/$ca" "$certDir/$name-cli"* "$cert" || return
			echo "done"
		fi

	done

	return 0
}

#
# Install Consul Command
#

installConsulCommand()
{ 
	# configuration
	local -A options serverOptions guiOptions 
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	options=(
		[domain]="$baseDomain"
		[datacenter]="$datacenter"
		[data_dir]="/opt/$name"
		[client_addr]="0.0.0.0"
		[bind_addr]='{{ GetInterfaceIP \"eth0\" }}'
		[retry_join]="[ $(ShowArray join ", ") ]"
		[acl]="$(cat <<-EOF
			{ 
			  enabled = true
			  default_policy = "allow"
			  enable_token_persistence=true
			}
			EOF
		)"
	)

	serverOptions=(
		[server]="true"
		[bootstrap_expect]="${#join[@]}"
		[advertise_addr]='{{ GetInterfaceIP \"eth0\" }}'
	)

	commonEncryptOptions=(
		[addresses]='{ https = "0.0.0.0" }'
		[ports]="{ http = -1, https = $consulHttpsPort }"
		[verify_incoming]="false"
		[verify_incoming_rpc]="true"
		[verify_outgoing]="true"
		[verify_server_hostname]="true"
	)

	clientEncryptOptions=(
		[ca_file]="$cert/$ca"
		[auto_encrypt]="{ tls = true }"
	)

	serverEncryptOptions=(
		[ca_file]="$cert/$ca"
		[cert_file]="$cert/$certServer"
		[key_file]="$cert/$certServerKey"
		[auto_encrypt]="{ allow_tls = true }"
	)

	guiOptions=( [ui]="true" )

	# install
	installAll || return
}

installConsulCommon()
{
	# service
	local cliArgs="$(cat <<-EOF
-http-addr="https://127.0.0.1:8501" \
-ca-file="$cert/$ca" \
-client-cert="$cert/$certCli" \
-client-key="$cert/$certCliKey"
	EOF
	)"

	serviceType="notify"
	networkTarget="Requires=network-online.target"
	execStart="$executable agent -config-dir=$config"
	execReload="$executable reload $cliArgs"
	execStop="$executable leave $cliArgs"
}

installConsulServer() 
{ 
	consulCertServerCopy || return
	AppendArray o serverOptions guiOptions
}

installConsulClient()
{
	consulCertClientCopy || return
}

consulCertInit()
{
	# certificates are created using consul
	! InPath "consul" && { inst "consul" || return; }

	pushd "$certDir" > /dev/null || return

	# create the CA and CLI certificates
	consulCertCaMake || return
	consulCertCliMake || return

	popd > /dev/null || return
}

consulCertCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the certificate authority for $baseDomain..."

	# create the cert
	consul tls ca create \
		-domain="$baseDomain" \
		-name-constraint || return # name constraint required for HTTPS GUI

	# rename the cert
	mv "$baseDomain-agent-ca.pem" "$ca" || return
	mv "$baseDomain-agent-ca-key.pem" "$caKey" || return
}

# consulCertClientGet - get the auto generated consul client certficate authority
# which is needed by other clients like nomad
consulCertClientCopy()
{
	[[ ! $encrypt ]] && return

	local f="$certDir/$certClient"

	if [[ ! -f "$f" ]]; then

		! InPath "consul-k8s" && { inst "consul-k8s" || return; }
	
		consul-k8s get-consul-client-ca \
			--server-addr "$(getServer "consul")" \
			--server-port "$consulHttpsPort" \
			--ca-file="$certDir/$ca" \
			--output-file "$f" || return

	fi
		
	cp "$certDir/$certClient" "$tmpDir/cert" || return
}

consulCertCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the CLI certificates..."

	# remove any existing temporary certs
	rm -f "$datacenter-cli-$baseDomain-"?".pem" "$datacenter-cli-$baseDomain-"?"-key.pem" || return

	# create the cert
	consul tls cert create -cli \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" || return

	# rename the temporary cert
	mv "$datacenter-cli-$baseDomain-0.pem" "$certCli" || return
	mv "$datacenter-cli-$baseDomain-0-key.pem" "$certCliKey" || return
}

consulCertServerCopy()
{	
	[[ ! $encrypt ]] && return

	local c="consul-server-$host.pem"
	local k="consul-server-$host-key.pem"

	consulCertServerMake "$c" "$k" || return

	cp "$certDir/$c" "$tmpDir/cert/$certServer" || return
	cp "$certDir/$k" "$tmpDir/cert/$certServerKey" || return
}

consulCertServerMake()
{
	local c="$1" k="$2"

	certExist "$c" "$k" && return

	hilight "Creating the $host server certificate..."

	# move to the certificate directory
	pushd "$certDir" >& /dev/null || return

	# remove any existing temporary certs
	rm -f "$datacenter-server-$baseDomain-?.pem" "$datacenter-server-$baseDomain-?-key.pem" || return

	# create the cert
	consul tls cert create -server \
		-dc="$datacenter" \
		-domain="$baseDomain" \
		-ca="$ca" \
		-key="$caKey" \
		-additional-ipaddress="$(GetIpAddress "$host")" \
		-additional-dnsname="$hostFqdn" \
		-node="$host" || return

	# rename the temporary cert
	mv "$datacenter-server-$baseDomain-0.pem" "$c" || return
	mv "$datacenter-server-$baseDomain-0-key.pem" "$k" || return

	popd >& /dev/null || return
}

#
# Install Nomad Command
#

installNomadCommand()
{
	# configuration
	local -A options clientOptions serverOptions guiOptions
	local -A commonEncryptOptions clientEncryptOptions serverEncryptOptions 

	local token="$(getConsulTokenConfig)"

	options=( 
		[datacenter]="$datacenter"
		[data_dir]="/opt/$name"
		[acl]="{ enabled = true }"
		[consul]="{$token
        address = \"127.0.0.1:$(getPort "consul")\"
}"
	)

	serverOptions=(
		[server]="{
	enabled = true
	bootstrap_expect = "${#join[@]}"
}"
	)

	clientOptions=(
		[client]="{
	enabled = true 
}"
	)

	clientEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certClient\"
	key_file = \"$cert/$certClientKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	serverEncryptOptions=(
		[tls]="{ 
	http = true
	rpc = true
	ca_file = \"$cert/$ca\"
	cert_file = \"$cert/$certServer\"
	key_file = \"$cert/$certServerKey\"
	verify_server_hostname = false
	verify_https_client = false
}"
	)

	# install
	installAll || return
}

installNomadCommon()
{ 
	[[ ! $encrypt ]] && return

	# set the certificate configuration to consul
	configCert "consul" || return

	local caCert="$ca"

	# get the auto generated consul client certificate
	[[ "$type" == "client" ]] && caCert="$certClient"
	
	# create the service environment file
	cat > "$tmpDir/$name.env" <<-EOF
		CONSUL_HTTP_SSL=true
		CONSUL_CACERT=$cert/$caCert
		CONSUL_CLIENT_CERT=$cert/$certServer
		CONSUL_CLIENT_KEY=$cert/$certServerKey
	EOF

	# return the nomad certificate configuration
	configCert "nomad" || return
}

installNomadServer()
{
	certServerCopy || return
	AppendArray o serverOptions clientOptions
}

installNomadClient()
{
	certClientCopy || return
	AppendArray o clientOptions
}

nomadCertInit()
{
	# certificates are created using consul
	! InPath "cfssl" && { inst "cfssl" || return; }

	pushd "$certDir" >& /dev/null || return

	# create the CA and CLI certificates
	nomadCertCaMake || return
	nomadCertServerMake || return
	nomadCertClientMake || return
	nomadCertCliMake || return

	popd >& /dev/null || return
}

nomadCertCaMake()
{
	certExist "$ca" "$caKey" && return

	hilight "Creating the nomad certificate authority..."
	cfssl print-defaults csr | cfssl gencert -initca - | cfssljson -bare nomad-ca || return
}

nomadCertServerMake()
{
	certExist "$certServer" "$certServerKey" && return

	hilight "Creating the server certificate..."

	# create the cfssl configuration file
	[[ ! -f "cfssl.json" ]] && { cat <<-EOF > cfssl.json || return; }
		{
		    "signing": {
		        "default": {
		            "expiry": "87600h",
		            "usages": [
		                "signing",
		                "key encipherment",
		                "server auth",
		                "client auth"
		            ]
		        }
		    }
		}
	EOF

	# add the nomad servers to the certificate
	local h="$(DelimitArray "," joinFqdn)"; [[ $h ]] && h+=","
	local hosts="${h}server.global.nomad,localhost,127.0.0.1"

	# create the certificate
	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -config=cfssl.json -hostname="$hosts" - | \
		cfssljson -bare nomad-server || return
}

nomadCertClientMake()
{
	certExist "$certClient" "$certClientKey" && return

	hilight "Creating the client certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-client || return
}

nomadCertCliMake()
{
	certExist "$certCli" "$certCliKey" && return

	hilight "Creating the CLI certificate..."

	echo '{}' | \
		cfssl gencert -ca=nomad-ca.pem -ca-key=nomad-ca-key.pem -profile=client - | \
		cfssljson -bare nomad-cli
}

#
# Install Vault
#

installVaultCommand()
{
	# configuration
	local -A options clientOptions serverOptions guiOptions

	local token="$(getConsulTokenConfig)"

	# configuration
	options=(
		[listener]="\"tcp\" $(cat <<-EOF
			{ 
			  address = "0.0.0.0:8200"
			  tls_cert_file = "$cert/$certServer"
			  tls_key_file = "$cert/$certServerKey"
			}
			EOF
		)"

		[storage]="\"consul\" $(cat <<-EOF
			{$token
			  path = "vault/"
			  address = "127.0.0.1:8501"
			  scheme = "https"
			  tls_ca_file = "$cert/$ca"
			  tls_cert_file = "$cert/$certCli"
			  tls_key_file = "$cert/$certCliKey"
			}
			EOF
		)"

		[service_registration]="\"consul\" $(cat <<-EOF
				{$token
				  address="127.0.0.1:8501"
				  scheme="https"
				  tls_ca_file = "$cert/$ca"
				  tls_cert_file = "$cert/$certCli"
				  tls_key_file = "$cert/$certCliKey"
				}
			EOF
		)"
	)

	guiOptions=( [ui]="true" )

	# install and initialize
	installAll || return
	vaultInit || return
}

installVaultCommon()
{
	# options
	o[api_addr]="https://$hostFqdn:8200"

	# service
	execStart="$executable server -config=$config"

	# script
	scriptFinal="$(cat <<-EOF
		echo "Configuring vault..."

		# allow memory locking without elevation (so don't need to run as root)
		sudo setcap cap_ipc_lock=+ep "$executable" || return
		EOF
	)"
}

installVaultServer() { AppendArray o guiOptions; }

vaultInit()
{
	eval "$(hashi config --host "$(GetWord "$servers" 1)")"

	# generate the unseal keys
	local n key s seals; seals="$(vault operator init 2>&1)" || return 0

	IFS=$'\n' seals=( $(echo "$seals" | grep "Unseal Key") )
	for s in "${seals[@]}"; do
		n="$(echo "$s" | cut -d: -f1 | cut -d" " -f 3)"
		key="$(echo "$s" | cut -d: -f2 | RemoveSpace)"
		credential set vault "key$n" "$key"
	done

	declare token; token="$(cat "/tmp/a.txt" | grep "Initial Root Token" | cut -d: -f 2 | RemoveSpace)" || return 0
	credential set vault token "$token"

	# show the full seal text
	header "Vault Seal"
	hilight "Store the following Vault seals in a secure location:"
	echo "$seals"

	# check if the seals were stored correctly
	if [[ "$(credential get vault token)" != "$token" ]]; then
		EchoErr "unable to store the Vault root token and possibly the Vault seals in the credential store"
		return 1
	fi

	return 0
}

#
# Remove Command
#

removeUsage()
{
	echot "usage: $(ScriptName) remove consul|nomad|vault [HOST1 ...](localhost)"
	exit ${1:-1}
}

removeCommand()
{
	local command="" hosts=() name

	# parse arguments
	while (( $# != 0 )); do
		case "$1" in "") : ;;
			-h|--help) removeUsage 0;;
			*)
				! IsOption "$1" && [[ ! $command ]] && { CheckSubCommand "remove" "$1"; name="$1"; shift; continue; }
				! IsOption "$@" && { hosts+=( "$1" ); shift; continue; }
				removeUsage 1
		esac
		shift
	done

	# check arguments
	[[ ! $command ]] && { usage; }
	[[ ! $hosts ]] && hosts=( "localhost" )

	# configuration variables
	configCommon "$name" || return

	# remove
	removeDo "${hosts[@]}" || return
}

removeConsulCommand() { :; }
removeNomadCommand() { :; }
removeVaultCommand() { :; }

#
# Certificate Helper
#

certExist() { [[ -f "$certDir/$1" && -f "$certDir/$2" ]]; }

certInit()
{
	[[ ! $encrypt ]] && return

	# create the certificate directory
	[[ ! -d "$certDir" ]] && { mkdir --parents "$certDir" || return; }

	# product specific certificate initialization
	RunFunction "${name}CertInit"
}

certServerCopy()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$certServer" "$certDir/$certServerKey" "$tmpDir/cert" || return
}

certClientCopy()
{
	[[ ! $encrypt ]] && return
	cp "$certDir/$certClient" "$certDir/$certClientKey" "$tmpDir/cert" || return
}

#
# install Helper
#

installAll()
{
	local f hostFqdn hostIp type scriptFinal
	local -A o

	# certificate initialization
	certInit || return

	# service
	local networkTarget="Wants=network-online.target"
	local serviceType="simple"
	local execStart="$executable agent -config=$config"
	local execReload="/bin/kill -HUP"
	local exectStop=""

	# install servers
	for host in "${servers[@]}"; do
		type="server"
		installInit || return
		RunFunction "install$(ProperCase "$name")Server" || return
		installPerform || return
	done

	# install clients
	for host in "${clients[@]}"; do
		type="client"
		installInit || return
		RunFunction "install$(ProperCase "$name")Client" || return
		installPerform || return
	done

	installAcl || return
}

installInit()
{
	scriptFinal=""

	# host information
	hostFqdn="$(os hostname "$host")" || return # host fully qualified domain name
	host="$(RemoveDnsSuffix "$hostFqdn")"
	hostIp="$(GetIpAddress "$hostFqdn")"

	# header
	header "Install $(ProperCase "$name") $(ProperCase "$type") ($host)"

	# prepare temporary directory
	DelDir --contents "$tmpDir" || return
	mkdir --parents "$tmpDir/cert" "$tmpDir/data" "$tmpDir/config" || return		

	# copy executable
	! IsLocalHost "$host" && { installExecutable || return; }

	# copy certificates
	[[ $encrypt ]] && { FileCommand cp "$certDir/$ca" "$certDir/$certCli" "$certDir/$certCliKey" "$tmpDir/cert" || return; }

	# service
	printf "" > "$tmpDir/$name.env"

	# options - other options added in installPRODUCTServer or installPRODUCTClient
	o=( ); AppendArray o commonOptions options
	[[ "$encrypt" ]] && IsDeclared commonEncryptOptions && AppendArray o commonEncryptOptions
	[[ "$encrypt" ]] && IsDeclared ${type}EncryptOptions && AppendArray o ${type}EncryptOptions

	RunFunction "install$(ProperCase "$name")Common"
}

installPerform()
{
	# create the configuration files
	installConfigHcl o > "$tmpDir/config/$configFileBase" || return
	installConfigService > "$tmpDir/$name.service" || return

	# copy the files to the remote host
	if ! IsLocalHost "$host"; then
		hilight "Copying files to $host..."
		scp -r "$tmpDir" "$host:/$tmpDir" || return
	fi

	# run the installation script - use only standard commands
	hilight "Running installation..."
	scriptRun "$(cat <<-EOF

		# user
		if ! getent passwd "$user" >& /dev/null; then
		  echo "Creating user $user..."
		  sudo useradd -r -d "$config" -s "/bin/false" "$user" || exit
		fi

		# stop the service
		if [[ -f "$serviceFile" && "$force" ]]; then
			echo "Stopping the service..."
			sudo systemctl stop "$name" || exit
		fi

		# executable
		if [[ ! -f "$executable" || "$force" ]]; then
		  echo "Copying executable..."
		  sudo cp "$tmpDir/$name" "$executable" || exit
		fi

		# directories
		if ! [[ -d "$cert" && -d "$config" && -d "$data" ]] || [[ "$force" ]]; then
		  echo "Creating directories..."
		  sudo install -o "$user" -g "$user" -m 755 -d "$cert" "$config" "$data" || exit
		fi

		# copy files
		if [[ \$(sudo ls -A "$tmpDir/data") ]] && [[ ! \$(sudo ls -A "$data") || "$force" ]]; then
		  echo "Copying data files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$data" "$tmpDir/data/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/config") ]] && [[ ! -f "$config/$configFileBase" || "$force" ]]; then
		  echo "Copying configuration files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$config" "$tmpDir/config/"* || exit
		fi

		if [[ \$(sudo ls -A "$tmpDir/cert") ]] && [[ ! \$(sudo ls -A "$cert") || "$force" ]]; then
		  echo "Copying certificate files..."
		  sudo install -o "$user" -g "$user" -m 755 -t "$cert" "$tmpDir/cert/"* || exit
		fi

		# service		
		if [[ ! -f "$serviceFile" || "$force" ]]; then
			echo "Creating service files..."
			sudo cp "$tmpDir/$name.service" "$tmpDir/$name.env" "/etc/systemd/system" || exit
			sudo systemctl daemon-reload || exit
			sudo systemctl enable "$name" || exit
			sudo systemctl start "$name" || exit
		fi

		$scriptFinal

		# cleanup
		echo "Cleaning up..."
		rm -fr "/tmp/$name.tmp"

		exit 0

		EOF
	)"

}

installAcl()
{
	eval "$(hashi config --host "$(GetWord "$servers" 1)")"

	# generate the bootstrap token
	local token; token="$($name acl bootstrap 2>&1)" || return 0
	local secret="$(echo "$token" | grep "Secret ID" | cut -d= -f 2 | RemoveSpace)" 

	# store the bootstrap token in the credential store
	[[ $secret ]] && credential set "$name" token "$secret"

	# show the full bootstrap text
	header "$name Bootstrap Token"
	hilight "Store the following bootstrap token in a secure location:"
	echo "$token"

	# check if the bootstrap token was stored correctly
	if [[ ! $secret || "$(credential get "$name" token)" != "$secret" ]]; then
		EchoErr "unable to store the bootstrap token in the credential store"
		return 1
	fi

	return 0
}


# installConfigHcl - turn the passed array variables into an HCL script
installConfigHcl()
{
	local key var

	for var in "$@"; do
		local -n config="$var"

		for key in "${!config[@]}"; do

			local equal=" =" quote="true" v="${config[$key]}"
			local fc="${v:0:1}" sc="${v:1:1}" # first and second characters

			# example: addresses { https = "0.0.0.0" }
			[[ "$fc" == "{" && "$sc" != "{" ]] && quote="" equal=""

			# example: retry_join = [ "pi3", "pi4" ]
			[[ "$fc" == "[" ]] && quote=""

			# listener "tcp" { address = "0.0.0.0:8200", tls_disable = 1 }
			[[ "$fc" == "\"" ]] && quote="" equal=""

			# boolean, example: server = true			
			[[ "$v" == @(true|false) ]] && quote=""

			# integer, example: bootstrap_expect = 2
			IsInteger "$v" && quote=""

			[[ $quote ]] && echo "$key$equal \"${config[$key]}\"" || echo "$key$equal ${config[$key]}"

		done

	done
}

installConfigService()
{
	local exec="ExecStart=$execStart"
	[[ $execReload ]] && exec+=$'\n'"ExecReload=$execReload"
	[[ $execStop ]] && exec+=$'\n'"ExecStop=$execStop"

	cat <<-EOF
		[Unit]
		Description="HashiCorp $(ProperCase "$name")
		Documentation=https://www.hashicorp.com/products/$name
		$networkTarget
		After=network-online.target
		ConditionFileNotEmpty=$configFile

		[Service]
		Type=$serviceType
		User=$user
		Group=$user
		$exec
		EnvironmentFile=$serviceEnvFile
		KillMode=process
		KillSignal=SIGINT
		Restart=on-failure
		RestartSec=2
		StartLimitBurst=3
		StartLimitIntervalSec=10
		LimitNOFILE=infinity
		LimitNPROC=infinity
		TasksMax=infinity

		[Install]
		WantedBy=multi-user.target
	EOF
}

installExecutable()
{
	local file machine

	# check if the executable is present on the host
	[[ ! $force ]] && ssh "$host" "[[ -f \"$executable\" ]]" && return

	printf "Executable..."	

	# find the installation directory
	file="$(FindInstallFile "other/HashiCorp/$name")" || return;
	printf "install..."

	# determine the host architecture
	machine="$(ssh "$host" "uname -m")" || return
	case "$machine" in
		aarch64) machine="arm64";;
		armv7l) machine="arm"; [[ "$name" == "consul" ]] && machine="armhfv6";;
		*) machine="amd64";; esac
	printf "$machine..."

	# find the executable
	file="$(find "$file" -name "$name_*_linux_$machine" | tail -1)"
	[[ ! -f "$file" ]] && { ScriptErr "unable to find the $name executable file"; return 1; };
	printf "$(GetFileName "$file")..."

	# copy the executable
	cp "$file" "$tmpDir/$name" || return
	echo "copied"
}

#
# remove helper
#

removeDo()
{
	for host in "$@"; do
		header "Remove $(ProperCase "$name") ($host)"
		removeCommon || return
		$command "$@" || return
	done
}

removeCommon()
{
	scriptRun "$(cat <<-EOF

		# delete service
		if [[ -f "$serviceFile" ]]; then
			echo "Deleting the service..."
			sudo systemctl stop "$name" || exit
			sudo systemctl disable "$name" || exit
			sudo rm -f "$serviceFile" || return
			sudo systemctl daemon-reload || return
			sudo systemctl reset-failed || return
		fi

		printf "cleaning..."

		printf "user..."
		sudo userdel "$name"
		sudo userdel "$name" >& /dev/null

		printf "configuration..."; 
		sudo rm -fr "/etc/$name.d" || return

		printf "data..."; 
		sudo rm -fr "/opt/$name" || return

		printf "executable..."; 
		sudo rm -f "/usr/local/bin/$name" || return

		printf "temporary files..."; 
		sudo rm -f "/tmp/$name."* || return

		echo "done"

		EOF
	)"
}

#
# helper
#

# getPort PRODUCT - get the primary port for the specified product
getPort()
{
	local p="$1"
	declare -n port

	if [[ -d "$cert" ]]; then
		port="${p}HttpsPort"
		echo "$port"
	else
		port="${p}HttpPort"
		echo "$port"
	fi
}

# getServer PRODUCT - get the server for the product
getServer()
{
	local p="$1"

	# use the hostArg
	if [[ $hostArg ]]; then
		IsLocalHost "$hostArg" && echo "127.0.0.1" || AddDnsSuffix "$hostArg" "$domain" 
		return
	fi

	if [[ -f $serviceFile ]] && IsProcessRunning $name && service running "$p"; then
		echo "127.0.0.1"
	else
		AddDnsSuffix "$(GetWord "$hashiServers" 1)" "$domain"
	fi
}

# getToken PRODUCT - get the authentication token for the product
getToken() { credential get "$1" token; }

# getConsulTokenConfig - get the consul token configuration text
getConsulTokenConfig()
{
	local token="$(getToken "consul")"
	token="$(getToken "consul")" && token=$'\n'"  token = \"$token\""
	echo "$token"
}

# getUrl PRODUCT - get the communication URL for the product
getUrl()
{
	local p="$1"

	if [[ -d "$cert" ]]; then
		echo "https://$(getServer "$p"):$(getPort "$p")"
	else
		echo "http://$(getServer "$p"):$(getPort "$p")"
	fi
}

scriptRun()
{
	local functions="$(FindInPath function.sh | GetFullPath)" script="$1"

	script="$(cat <<-EOF

		if [[ -f "$functions" ]]; then 
		  . "$functions" || exit
		  sudo() { sudoc "\$@"; }
		fi

		$script
		EOF
	)"

	[[ $test ]] && { printf "%s\n" "$script"; return; }

	if IsLocalHost "$host"; then
		bash -c "$script"
	else
		# DISPLAY="" - disable warning "Warning: No xauth data; using fake authentication data for X11 forwarding."
		# -X - enable X11 forwardining for credential store access
		# -t - allocate a pseudo-terminal to allow the sudo password to be entered on the terminal if needed
		DISPLAY="" ssh -X -t "$host" "$script"
	fi
}

run "$@"

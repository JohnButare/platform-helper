#!/usr/bin/env bash
. app.sh || exit

usage() 
{	
	echot "
usage: code changes|checkout|clone|commit|log|status|update PROJECTS
	changes         exit status is 0 if there are changes
  log FILE				display the SVN log for the specified file
  switch PROJECTS [-v|--version VERSION](master)
  -g, --gui		use the GUI command
	-s, --svn		use SVN instead of GIT"
	exit $1
}

args()
{
	unset -v command gui projects svn 
	version="master"

	while (( $# != 0 )); do
		case "$1" in
			-g|--gui) gui="true";;
			-s|--svn) svn="true";;
			-v|--version) version="$2"; shift;;
			-h|--help) usage 0;;
			IsInstalled) command="IsInstalled";;
			*)
				[[ ! $command ]] && { ! IsFunction "${1,,}Command" && usage 1; command="${1,,}"; shift; continue; }

				if [[ "$command" == @(log) ]]; then
					file="$1"; shift
					[[ ! -f "$file" ]] && { EchoErr "code: cannot access `$file`: No such file"; return 1; }
				else
					local project="$1" projectDir="$CODE/$1"; projects+=( "$project" )					
					[[ "$command" == @(clone)  && ! -d "$projectDir" ]] && { mkdir --parents "$projectDir" || return; }
					[[ ! -d "$projectDir" ]] && { EchoErr "code: cannot access \`$project\`: Project does not exist"; return 1; }
				fi;;
		esac
		shift
	done
	[[ ! $command ]] && MissingOperand "COMMAND"
	[[ $command == @(log) && ! $file ]] && MissingOperand "FILE"

	args=( "$@" )
}

init()
{ 
	gitRepository="github.intel.com/csis"
	svnRepository="azscsistfs001.amr.corp.intel.com:8443"
}

run() 
{	
	args "$@" || return; init || return; 
	
	if [[ "$command" == @(log) ]]; then
		${command}Command "${args[@]}"; return
	fi

	[[ ! $projects ]] && MissingOperand "PROJECTS"; shift
	for project in "${projects[@]}"; do
		projectDir="$CODE/$project"
		[[ "$command" != "clone" && ! -d "$projectDir/.git" ]] && svn="true"
		${command}Command "${args[@]}" || return
	done
}

svn() { builtin cd "$projectDir" || return; TortoiseSVN svn "$@"; }
svng() { builtin cd "$projectDir" || return; TortoiseSVN gui /path:"$projectDir" "$@"; }
gitc() { builtin cd "$projectDir" || return; git "$@"; }
gitg() { builtin cd "$projectDir" || return; command GitHelper gui "$@"; }
gittg() { builtin cd "$projectDir" || return; command GitHelper tgui "$@"; }

logCommand() 
{ 
	[[ $svn ]] && { TortoiseSVN gui /command:log /path:"$file"; return; }
}

statusCommand() 
{ 
	echo "************ $project Status ************"
	[[ $svn ]] && { svn status; return; }
	gitc status
}

revertCommand()
{ 
	echo "************ Reverting $project ************"
	[[ $svn ]] && { svng /command:revert; return; }
	[[ $gui ]] && { gitg commit; return; } 
	gitc reset --hard;
}

changesCommand() 
{ 
	if [[ $svn ]]; then
		[[ "$(svn status)" != "" ]]
	else
		[[ "$(gitc status --porcelain)" != "" ]]
	fi
}

commitCommand() 
{ 
	echo "************ Committing $project ************"
	! code changes "$project" && { echo "no changes"; return 0; }
	echo "changes present..."
	[[ $svn ]] && { svng /command:commit; return; }
	gitg
}

cloneCommand()
{ 
	echo "************ Cloning $project ************"

	if [[ $svn && $gui ]]; then
		TortoiseSVN gui /command:checkout /url:"https://$svnRepository/svn/$project/trunk/" /path:"$projectDir"
	elif [[ $svn ]]; then
		svn co "https://$svnRepository/svn/$project/trunk/" "$projectDir"
	else
		[[ ! -d "$projectDir/.git" ]] && { gitc clone "https://$gitRepository/$project" "$projectDir" || return; }
		GitHelper hide "$projectDir" || return
	fi
	return 0
}

updateCommand()
{ 
	echo "************ Updating $project ************"
	[[ $svn ]] && { svn update | grep -v "Updating '.':" ; return; }
	integrationResetAll || return

	gitc up || return
}

branchExist() { gitc rev-parse --verify $1 >& /dev/null; }

integrationResetAll()
{
	local branch
	for branch in Continuous Test Pre-Production; do
		integrationReset $branch || return;
	done
	return 0
}

integrationReset() 
{ 
	local branch=$1

	branchExist $branch || return 0

	local localSha="$(gitc show-ref --verify refs/heads/$branch | cut -f1 -d" ")"
	local remoteSha="$(gitc show-ref --verify refs/remotes/origin/$branch | cut -f1 -d" ")"
	[[ "$localSha" == "$remoteSha" ]] && return 0

	local currentBranch="$(gitc symbolic-ref -q HEAD | cut -d"/" -f 3)"

	echo "Reseting $branch..."
	[[ "$currentBranch" != "$branch" ]] && { gitc checkout $branch || return; }
	gitc reset --hard origin/$branch || return
	[[ "$currentBranch" != "$branch" ]] && { gitc checkout $currentBranch || return; }
}

checkoutCommand()
{
	[[ $svn ]] && { svnCheckoutCommand; return; }
	gitc checkout "$version"
}

svnCheckoutCommand()
{
	if [[ "$version" == @(trunk|master) ]]; then
		echo "Switching $project to trunk..."
		TortoiseSVN svn switch "^/trunk" "$projectDir"
	else
		echo "Switching $project to branch $version..."
		TortoiseSVN svn switch "^/branches/$version" "$projectDir"
	fi
}

run "$@"
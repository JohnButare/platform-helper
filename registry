#!/usr/bin/env bash
. function.sh

run() {	 init || return; args "$@" || return; ${command}Command "${args[@]}"; }

init() 
{
	unset key value data dataType
	bits="64"
	title="Registry Editor"

	program32="$WINDIR/syswow64/RegEdit.exe"
	program64="$WINDIR/RegEdit.exe"

	reg32="$WINDIR/syswow64/reg.exe"
	reg64="$WINDIR/system32/reg.exe"
}

usage()
{
	echot "\
usage: registry [32|64] COMMAND
	KEY 						KEY/
	VALUE						KEY/VALUE
	KEY ALIAS				HKCR|HKCU|HKU|HKCC|run|RunOnce|urun
 	TYPE 						REG_SZ|REG_MULTI_SZ|REG_EXPAND_SZ|REG_DWORD|REG_QWORD|REG_BINARY|REG_NONE

  edit KEY 											edit the specified registry key using regedit
  exist|get|delete KEY|VALUE		delete or query the specified registry key
  export KEY FILE 							export regitry key to file
  import FILE										import registry entries from a file
  IsKey KEY											check if key is a registry key
  reg			 											run 32 or 64 bit version of reg.exe
  register|unregister FILE 			register or unregister the registry entries in a DLL											
  set KEY [TYPE](REG_SZ) DATA"
	exit $1
}

args()
{
	unset file

	originalArgs=( "$@" ) 

	while [ "$1" != "" ]; do
		case "${1,,}" in
			32|64) bits="$1";;
			-h|--help) usage 0;;
			IsKey) command="IsKey";;
			*)
				IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				if ! IsOption "$1" ]]; then
					[[ ! $key && "$command" == @(delete|exist|get|set|IsKey) ]] && { GetKeyValueArg "$@" || return; shift; continue; }
					[[ ! $key && "$command" == @(edit|export) ]] && { GetKeyArg "$@" || return; shift; continue; }
					[[ ! $key && "$command" == @(register|unregister) ]] && { GetFileArg "$@" || return; shift; continue; }
					[[ "$command" == "set" ]] && { { GetDataType "$@" || GetData "$@"; } && { shift; continue; }; }
				fi
				[[ "$command" == @(export|import|reg) ]] && break
				UnknownOption "$1"
		esac
		shift
	done
	[[ ! $command ]] && { MissingOperand "command"; }
	args=( "$@" )
	EvalVar program$bits program
	EvalVar reg$bits reg
}

closeCommand()
{
	! IsTaskRunning $program && return 0
	WinSetState --close "$title"
}

deleteCommand()
{
	! existCommand && return 0; # return if the registry key is already deleted
	! IsElevated && { elevate RunScript --pause-error registry "${originalArgs[@]}"; return; }
	"$reg" delete "$wkey" "${value[@]}" /f >& /dev/null
}

editCommand()
{
	[[ ! $key ]] && { start --elevate "$program"; return; }
	
	# Start the registry program manually so the correct key is opened (x64 key or x86 virtual key)
	start --elevate "$program" || return
	start --elevate RegJump "$wkey"
}

existCommand() { "$reg" query "$wkey" "${value[@]}" >& /dev/null; }

exportCommand()
{
	local file="$1"; shift
	[[ ! $key ]] && { MissingOperand "KEY"; }
	[[ ! file ]] && { MissingOperand "FILE"; }
	[[ $# != 0 ]]	&& usage 1
	RunScriptElevated "\"$program\" /e \"$(utw "$file")\" '$wkey'"
}

getCommand()
{
	if [[ $value ]]; then
		result="$( "$reg" query "$wkey" "${value[@]}" 2>&1 )" || return
		echo "$result" | sed -n '3p' | cut -d" " -f 13-
	else
		"$reg" query "$wkey" | tr '\\' '/' | RemoveCarriageReturn
	fi
}

importCommand()
{	
	local file="$1"; shift; [[ ! file ]] && { MissingOperand "FILE"; }
	[[ ! -f "$file" ]] && { EchoErr "registry: cannot access \"$file\": No such file or directory"; return 1; }
	[[ $# != 0 ]]	&& usage 1

	# import from a temporary file on a Windows drive - in Windows build 20201.1000 elevated program cannot access WSL files
	local tmpFile="$(mktemp --tmpdir="$LOCALAPPDATA/Temp")" || return
	cp "$file" "$tmpFile" || return

	local result
	RunScriptElevated "\"$program\" /s \"$(utw "$tmpFile")\""
	result="$?"

	rm -f "$tmpFile"
	return "$result"
}

regCommand() { "$reg" "$@"; }
registerCommand() { elevate regsvr32.exe /s \"$(utw "$file")\"; }
unregisterCommand() { elevate regsvr32.exe /s /u \"$(utw "$file")\"; }

setCommand()
{
	! IsElevated && { elevate RunScript --pause-error registry "${originalArgs[@]}"; return; }
	"$reg" add "$wkey" "${value[@]}" "${dataType[@]}" /f "${data[@]}" #2>&1 
}

#
# Helper Functions
#

GetData()
{
	[[ $data ]] && return 1
	data=(/d "$1") || data=()
}

GetDataType()
{
	[[ $dataType || "$1" != +(REG_SZ|REG_MULTI_SZ|REG_EXPAND_SZ|REG_DWORD|REG_QWORD|REG_BINARY|REG_NONE) ]] && return 1
	dataType=( /t "$1" )
}

GetFileArg()
{
	[[ $# == 0 ]] && MissingOperand "file"
	file="$1"
	[[ ! -f "$file" ]] && { EchoErr "$file does not exist"; return 1; }
	return 0
}

GetKeyArg()
{
	[[ $# == 0 ]] && MissingOperand "key"
	key="$(BackToForwardSlash "$1")" # make sure arguments are in POSIX (forward slash) format (/)
	MapKeyAlias "$key"
}

GetKeyValueArg()
{
	[[ $# == 0 ]] && MissingOperand "key"
	local keyValue="$(BackToForwardSlash "$1")" # make sure arguments are in POSIX format (forward slash) format (/)

	MapKeyAlias "${keyValue%*/*}" # remove value - text after last forward slash

	# get the value after the last /
	value="${keyValue##*/}" # get value - text before last forward slash
	[[ "$value" == "$keyValue" ]] && value=""	
	if [[ "$value" == "(Default)" ]]; then
		value=( /v "" )
	elif [[ $value ]]; then
		value=( /v "$value" )
	else
		unset value
	fi
}

IsKeyCommand()
{
	local validPrefixes=( HKCR HKCU HKLM HKU HKCC HKEY_CLASSES_ROOT HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS HKEY_CURRENT_CONFIG )
	prefix="${key%%/*}"
	IsInArray "$prefix" validPrefixes
}

MapKeyAlias()
{
	key="$1"

	case "$key" in
		run) key="HKLM/Software/Microsoft/Windows/CurrentVersion/Run";;
		RunOnce) key="HKLM/Software/Microsoft/Windows/CurrentVersion/RunOnce";;
		urun) key="HKCU/Software/Microsoft/Windows/CurrentVersion/Run";;
	esac

	key="${key/#HKCR/HKEY_CLASSES_ROOT}"
	key="${key/#HKCU/HKEY_CURRENT_USER}"
	key="${key/#HKLM/HKEY_LOCAL_MACHINE}"
	key="${key/#HKU/HKEY_USERS}"
	key="${key/#HKCC/HKEY_CURRENT_CONFIG}"

	key="${key}/" # key in POSIX format (/)
	wkey="${key////\\}" # key in Windows format (\)
}

[[ "$PLATFORM" != "win" ]] && exit 0
run "$@"

#!/usr/bin/env bash
. script.sh || exit

usage() {	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... config|connect|regenerate
Additional SSH commands."; }

init() { defaultCommand="connect"; }
argStart() { unset -v file force; }

#
# Config Command
#

configUsage() {	echot "Usage: $(ScriptName) config check|diff|edit|get|sync\nSSH configuration configuration."; }
configCommand() { usage; }
configEditCommand() { TextEdit ~/.ssh/config; }

#
# config check command
#

configCheckUsage() {	echot "Usage: $(ScriptName) config check HOST\nReturn true if HOST matches an entry in ~/.ssh/config."; }
configCheckArgs() { ScriptArgGet "host" -- "$@"; }
configCheckCommand() { configCheck "$host"; }

configCheck() 
{
	local hostFull="$1" host="$(GetSshHost "$1")" defaultFull default="DEFAULT_CONFIG"
	defaultFull="${hostFull/$host/$default}"

	# if the SSH configuration changes a value other than the host, return 0 (host in SSH config)
	[[ "$(ssh -G "$defaultFull" | grep -i -v "^hostname ${default}$")" != "$(ssh -G "$hostFull" | grep -i -v "^hostname ${host}$")" ]] && return 0

	 # if the host is unchanged return 1 (host not in SSH config)
	ssh -G "$hostFull" | grep -i "^hostname ${host}$" >& /dev/null && return 1

	# the host is changed, return 0 (host is in SSH config)
	return 0
}

#
# config diff command
#

configDiffUsage() {	echot "Usage: $(ScriptName) config diff HOST\n.Show the changes for the host in ~/.ssh/config."; }
configDiffArgs() { ScriptArgGet "host" -- "$@"; }
configDiffCommand() { configDiff "$host"; }

configDiff() 
{
	local hostFull="$1" host="$(GetSshHost "$1")" defaultFull default="DEFAULT_CONFIG"
	defaultFull="${hostFull/$host/$default}"

	ssh -G "$defaultFull" | grep -i -v "^hostname ${default}$" > "/tmp/default.txt"
	ssh -G "$hostFull" | grep -i -v "^hostname ${host}$" > "/tmp/$host.txt"

	merge "/tmp/default.txt" "/tmp/$host.txt"
}

#
# config get command
#

configGetUsage() {	echot "Usage: $(ScriptName) config get HOST VALUE\nReturn the SSH configuration value for HOST from the SSH configuration."; }
configGetArgStart() { host="" value=""; }
configGetArgs() { ScriptArgGet "host" -- "$@"; shift; ScriptArgGet "value" -- "$@"; shift; }
configGetCommand() { configGet "$host" "$value"; }

configGet() { local host="$1" value="$2"; ssh -G "$host" | grep "^$value " | head -1 | cut -d" " -f2; }

#
# config sync command
#

configSyncUsage() {	echot "Usage: $(ScriptName) config sync HOST|root...
Synronize SSH configuration with the specified host.

	-do,	--dest-older	assume destination configuration is older than the source configuration
	-so,	--src-older		assume local configuration is older than the destination configuration"; }

configSyncArgStart() { unset -v hosts method; }

configSyncOpt() 
{
	case "$1" in
		-do|--dest-older|--destination-older) method="--dest-older";;
		-so|--src-older|--source-older) method="--src-older";;
		*) return 1
	esac
}

configSyncArgs() {  hosts=( "$@" ); shift="$#"; }

configSyncCommand() { local host; for host in "${hosts[@]}"; do configSyncHost "$host" || return; done; }

configSyncRootCommand() { sudo cp ~/.ssh/{authorized_keys,config,environment,id_ed25519,id_ed25519.pub,known_hosts} ~root/.ssh; }

configSyncHost()
{
	local host="$1"
	local args=(-confirmbigdel -ignore 'Name .*_sync.txt' -ignore 'Name environment'); [[ $noPrompt ]] && args+=(-batch)
	
	# do not sync the source
	IsLocalHost "$host" && return 

	# initialize
	SshAgentConf "${globalArgs[@]}" || return

	# sync
	local src="$HOME/.ssh"
	local dest=""ssh://$host/.ssh""
	[[ "$method" == "--src-older" ]] && args+=(-force "$dest")
	[[ "$method" == "--dest-older" ]] && args+=(-force "$src")
	RunLog unison "${args[@]}" "$src" "$dest"  || return
}

#
# Connect Command
#

connectUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) connect HOST
Connect to a HOST using SSH.

	-a, --all							resolve host using all methods (DNS, MDNS)
	-c, --commands CMDS		bash commands to run
	-f, --function				define functions
	-i, --interactive			start an interactive shell
	-m, --mosh						connecting using mosh
	-p, --password				supply password if needed
	-t, --pseudo-terminal allocate a pseudo terminal;;
	-T, --trust						trust host identification ignoring possible security issues
	-x, --x-forwarding  	connect with X forwarding
	-w, --wait						wait for SSH to become available"
}

connectUsageVerbose()
{
	ScriptUsageEcho "
Environment options:
			--borg						send BorgBackup environment variables
			--credential			send credential environment variables
			--hashi						send HashiCorp environment variables"
}

connectArgStart() { unset -v all borg commandsArg credential functions hashi interactive mosh password pseudoTerminal trust wait x; unset host; }

connectOpt() 
{
	case "$1" in
		-a|--all) all="--resolve-all";;
		   --borg) borg="--borg";;
		-c|--commands) ScriptOptGet "commandsArg" "commands" "$@";;
		   --credential) credential="--credential";;
		-f|--function) functions="--functions";;
		   --hashi) hashi="--hashi";;
		-i|--interactive) interactive="-i";;
		-m|--mosh) mosh="--mosh";;
		-p|--password) ScriptOptGet "password" "$@";;
		-t|--pseudo-terminal) pseudoTerminal="-t";;
		-T|--trust) trust="--trust";;
		-x|--x-forwarding) x="--x-forwarding";;
		-w|--wait) wait="--wait";;
		*) return 1
	esac
}

connectArgs() 
{
	ScriptArgGet "host" -- "$@"; shift
	otherArgs=( "$@" "${otherArgs[@]}" ); (( shift+=$# )); true
}

connectCommand()
{	
	# SSH Agent
	SshAgentConf "${globalArgs[@]}" || return

	# parse host, format USER@HOST:PORT
	local port user
	port="$(GetSshPort "$host")" 
	user="$(GetSshUser "$host")"
	host="$(GetSshHost "$host")"

	# connect to the IP unless the host is in ~/.ssh/config to use additional name resolution methods such as MDNS
	local hostOrig="$host" inSshConfig="yes" ip
	if ! configCheck "$host"; then
		ip="$(GetIpAddress $all --vm "$host" $quiet)" || return
		host="$ip" inSshConfig="no"
	fi
	
	# get the port from configuration if none was specified so we can check if host is available
	[[ ! $port ]] && { port="$(configGet "$host" "port")" || return; }

	# logging
	[[ $verbose ]] && log1 "inSshConfig=$inSshConfig host=${ip:-$(configGet "$host" "hostname")} hostOrig=$hostOrig port=$port user=${user:-$(configGet "$host" "user")}"

	# wait for SSH to become available if needed
	if [[ $wait ]]; then
		[[ ! $port ]] && { port="$(portCommand)" || return; }
		WaitForPort "$host" "$port" || return

	# the host is not available on the specified port
	elif [[ $port ]] && ! IsAvailablePort "$host" "$port"; then
		local desc="$hostOrig"; [[ $ip ]] && desc+=" ($ip)"
		EchoErr "ssh: $desc is not responding on port $port"
		return 1
	fi

	# arguments
	local args=() quietArg
	[[ $borg ]] && args+=("-o" SendEnv="BORG_*")
	[[ $credential ]] && args+=("-o" SendEnv="CREDENTIAL_*")
	[[ $credential && "$CREDENTIAL_MANAGER" == "vault" ]] && args+=("-o" SendEnv="VAULT_*")
	[[ $hashi ]] && args+=("-o" SendEnv="CONSUL_* NOMAD_* VAULT_*")
	[[ $user ]] && args+=("$user@$host") || args+=("$host")
	[[ $port ]] && args+=(-p "$port")
	
	if [[ $commandsArg ]]; then
		args+=(-- bash $interactive -c "\"$commandsArg\"" "${otherArgs[@]}")
	elif [[ $interactive && $otherArgs ]]; then
		args+=(-- bash -i "${otherArgs[@]}")
	elif [[ $functions ]]; then
		args+=(". function.sh;" "${otherArgs[@]}")
	else
		args+=("${otherArgs[@]}")
	fi

	set -- "${args[@]}"

	# WSL 1 does not support X sockets over ssh and requires localhost
	IsPlatform wsl1 && export DISPLAY="localhost:0"
	
	# get the command
	local command
	if [[ $mosh ]]; then
		command="mosh"
	elif [[ ! $x ]]; then
		command="ssh"
	elif IsPlatform mac,wsl2; then # WSL2 and macOS XQuartz requires trusted X11 forwarding (X programs are trusted to use all X features on the host)
		command="ssh -Y"
	else # for everything else, use untrusted X Forwarding, where X programs are not trusted to use all X features on the host
		command="ssh -X"
	fi

	# add SSH arguments
	if [[ "$command" != "mosh" ]]; then

		# supress warnings
		[[ ! $verbose ]] && command+=" -q"

		# verbosity - don't allow if sending credentials, otherwise reduce verbosity by 1 to reduce noise
		[[ ! $borg && ! $credential && ! hashi ]] && (( verboseLevel > 1 )) && command+=" -$(StringRepeat v $((verboseLevel - 1)))"			

		# other
		[[ $pseudoTerminal ]] && command+=" $pseudoTerminal"
		[[ $trust ]] && command+=" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
	fi

	# logging
	log1 "command: $command $@"
	[[ $test ]] && return

	# connect
	local result
	if [[ "$password" ]]; then
		command="spawn -noecho $command "$@"; expect \"password:\"; send \"$password\r\"; interact"
		expect -c "$command"
	else
		$command "$@"
	fi
	result="$?"
	
	# display SSH error (exit status 255) if supressed with -q
	(( result == 255 )) && [[ $quietArg ]] && ScriptErr "SSH error occurred\nTry again with 'SshHelper --verbose' for more detail"

	return "$result"

}

#
# Permission Command
#

permissionUsage() {	echot "Usage: $(ScriptName) permission USER\nFix SSH permissions for user."; }
permissionArgStart() { user=""; }
permissionArgs() { ScriptArgGet "user" -- "$@"; shift; }

permissionCommand()
{	
	sudo bash -l <<-EOF # does not work with sudoc
		sudo find "$USERS/$user/.ssh" | ${G}xargs chown $user || exit
		sudo find "$USERS/$user/.ssh" | sudo ${G}xargs chgrp "$user" || exit
		sudo chmod 700 "$USERS/$user/.ssh" || exit

		[[ -f "$USERS/$user/.ssh/config" ]] && sudo chmod 700 "$USERS/$user/.ssh/config" || exit
		[[ -f "$USERS/$user/.ssh/authorized_keys" ]] && sudo chmod 700 "$USERS/$user/.ssh/authorized_keys" || exit
		[[ -f "$USERS/$user/.ssh/id_rsa" ]] && sudo chmod 700 "$USERS/$user/.ssh/id_rsa" || exit
		[[ -f "$USERS/$user/.ssh/id_ed25519" ]] && sudo chmod 700 "$USERS/$user/.ssh/id_ed25519" || exit

		exit 0
	EOF
}

#
# regenerate command
#

regenerateUsage() { echot "Usage: $(ScriptName) regenerate [check|duplicate]\nRegenerate SSH host keys."; }
regenerateArgStart() { hostKey="/etc/ssh/ssh_host_ecdsa_key.pub"; }

regenerateCommand()
{
	# check if another hosts uses the SSH host key in ~/.ssh/known_hosts
	local duplicate; duplicate="$(regenerateDuplicate)" || return
	[[ -f "$hostKey" && "$duplicate" == "false" && ! $force ]] && return 0

	# check if user really wants to regenerate the SSH host keys
	if [[ ! $noPrompt ]]; then
		! ask 'Regenerate SSH host keys' --default-response n && return
	fi

	# regenerate the SSH host keys
	sudo rm -f /etc/ssh/ssh_host_* && sudo ssh-keygen -A
}

#
# regenerate check command
#

regenerateCheckUsage() { echot "Usage: $(ScriptName) regenerate \nCheck which hosts use SSH host keys."; }
regenerateCheckCommand() { regenerateCheck; }

regenerateCheck()
{
	[[ ! -f "$hostKey" ]] && return
	grep "$(sudo cat "$hostKey" | cut -d" " -f2)" "$HOME/.ssh/known_hosts"
}

#
# regenerate duplicate command
#

regenerateDuplicateUsage() { echot "Usage: $(ScriptName) regenerate \nReturn true if the SSH host key is used by another host and false if not."; }
regenerateDuplicateCommand() { regenerateDuplicate; }

regenerateDuplicate()
{
	# get the number of hosts using this hosts SSH host key from the ~/.ssh/known_hosts file
	local count; count="$(regenerateCheck | wc -l)"
	! IsInteger "$count" && return 1

	# more than one hosts are using this hosts SSH host key
	(( count > 1 )) && { echo "true"; return; }

	# no hosts are using the SSH host key
	(( count == 0 )) && { echo "false"; return; }

	# check if the one host using 
	local host; host="$(regenerateCheck | cut -d" " -f1 | cut -d"," -f1)" || return 2
	[[ ! $host ]] && return 1
	IsLocalHost "$host" && echo "false" || echo "true"
}

ScriptRun "$@"

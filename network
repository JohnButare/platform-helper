#!/usr/bin/env bash
. script.sh || exit

usage() {	ScriptUsage "$1" "Usage: network adapter|current|cache|center|dns|find|internet|name|profile|proxy|run|vpn|workgroup"; exit $1; }

init() 
{
	defaultCommand="center"

	wpadFile="/var/www/html/autoproxy/wpad.dat"
	
	adapterKey='HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Networkâ€‹'
	profileKey='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles/'

	proxyVars="http_proxy,https_proxy,ftp_proxy,HTTP_PROXY,HTTPS_PROXY,FTP_PROXY"
	noProxyVars="no_proxy,NO_PROXY"	
	allProxyVars="$proxyVars,$noProxyVars"
	aptFile="/etc/apt/apt.conf.d/proxy"	
}

#
# commands
#

runCommand() { ssh "$1" 'source /etc/profile; '"${@:2}"''; }
centerCommand() {	start control /name Microsoft.NetworkAndSharingCenter; }
cacheCommand() { IsAvailable "$1" || return; net use '\\'$1'\ipc$' >& /dev/null; }
nameCommand() { registry edit 'HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles'; }

#
# Adapter Commands
#

adapterUsage() { echot "Usage: $(ScriptName) adapter edit|list|name
Network adapter commands."; }

adapterCommand() { usage; }

adapterEditCommand() { registry edit "$adapterKey"; }

adapterListCommand()
{
	! IsElevated && { RunScript --elevate network adapter list "$@"; return; }
	powershell.exe Get-NetAdapter | RemoveCarriageReturn | RemoveEmptyLines | tail -n +3
}

adapterNameArgs()
{
	ScriptArgGet "old" -- "$@"; shift
	ScriptArgGet "new" -- "$@"; shift
}

adapterNameCommand()
{ 
	! IsElevated && { RunScript --elevate -- network adapter name "$old" "$new"; return; }
	powershell.exe Rename-NetAdapter -Name \"$old\" -NewName \"$new\"
}

#
# Current Commands
#

currentUsage()
{
	echot "Usage: $(ScriptName) current [find|name|status|servers|update](name)
Current network commands.

	find			find the network we are currently on
	server		find the first active server
	servers		list all servers for the current network
	status		status of the current network
	update		update network settings for the network we are currently on

	-b,	--brief		show brief status messages (for use with app script)"
}

currentArgStart() { unset -v brief; }

currentOpt()
{
	case "$1" in
		-b|--brief) brief="--brief";;
		*) return 1;;
	esac
}

currentCommand() { currentNameCommand; }
currentNameCommand() { name; }
currentStatusCommand() { printf "network=$(name)\nfile=$(UpdateGet "FileServer")\nproxy=$(UpdateGet "ProxyServer")\n"; }

#
# Current Find Command
#

currentFindCommand()
{
	local network; printf "network..."; network="$(findNetwork)" || return 
	local fileServer; printf "file..."; fileServer="$(findServer "$network" "file" --service="smb" $brief "${globalArgs[@]}")" || { EchoErr "none"; }
	local proxyServer; printf "proxy..."; proxyServer="$(findServer "$network" "proxy" $brief "${globalArgs[@]}")" || { EchoErr "none"; }
	printf "found network=$network\nfound file server=$fileServer\nfound proxy server=$proxyServer\n";
}

#
# Current Server Command
#

currentServerUsage()
{ 
	echot "Usage: $(ScriptName) current server TYPE
Return the first server of the specified type for the current network.

	-s, --service	the service to check if one is not specified, see 'network find --help'"
}

currentServerArgStart() { unset -v service type; }

currentServerOpt()
{
	case "$1" in
		-s|--service|-s=*|--service=*) ScriptOptGet "service" "$@"; service="--service=$service";;
		*) return 1;;
	esac
}

currentServerArgs() { ScriptArgGet "type" -- "$@"; shift; }
currentServerCommand() { local name; name="$(name)" || return; findServer "$name" "$type" "$service"; }

#
# Current Servers Command
#

currentServersUsage()
{
	echot "Usage: $(ScriptName) current servers TYPE
Return all servers of the specified type for the current network."
}

currentServersArgStart() { unset -v type; }
currentServersArgs() { ScriptArgGet "type" -- "$@"; shift; }
currentServersCommand() { local name; name="$(name)" || return; getServers "$name" "$type"; }

#
# Current Update Command
#

currentUpdateCommand()
{
	# get existing configuration
	local existingNetwork="$(UpdateGet "network")"  existingFileServer="$(UpdateGet "FileServer")" existingProxyServer="$(UpdateGet "ProxyServer")"

	# determine current network configuration
	local network
	doLog && { hilight "Determining network..."; echo "Existing network is ${existingNetwork:-unknown}"; }
	doLog && printf "network..."; network="$(findNetwork $brief)" || return

	# update resolv.conf - ensures name resolution is working to find other servers
	local resolvConf="$DATA/setup/resolv.conf.$network"
	{ ! IsPlatform wsl || [[ ! -f "$resolvConf" ]]; } && unset resolvConf
	if [[ $resolvConf ]] && ! cmp --quiet "$resolvConf" "/etc/resolv.conf"; then
		sudoc cp "$resolvConf" "/etc/resolv.conf" || return
	fi

	# find servers
	local fileServer; doLog && printf "file..."; fileServer="$(findServer "$network" file --service=smb $brief "${globalArgs[@]}")"
	local proxyServer; doLog && printf "proxy..."; proxyServer="$(findServer "$network" proxy $brief "${globalArgs[@]}")"

	# return if no changes are required
	[[ ! $force && "$network" == "$existingNetwork" && "$fileServer" == "$existingFileServer" && "$proxyServer" == "$existingProxyServer" ]] && return

	# update network configuration
	doLog && hilight "Setting the network to $network..."
	[[ $brief ]] && printf "network..."

	# save network
	UpdateSet "network" "$network" || return

	# save file server
	UpdateSet "FileServer" "$fileServer" || return

	# save proxy server
	UpdateSet "ProxyServer" "$proxyServer" || return
	if [[ $proxyServer ]]; then
		network proxy apt --enable "${globalArgs[@]}" || return
		ScriptEval network proxy vars --enable || return
	else
		network proxy apt --disable "${globalArgs[@]}" || return
		ScriptEval network proxy vars --disable || return
	fi

	# status
	if doLog; then
		network current status "${globalArgs[@]}" || return
		network proxy --status "${globalArgs[@]}" || return
	fi

	return 0
}

# findNetwork - find the first active network from the networks specified in the networks configuration variabke 
findNetwork()
{
	local networkIndex networks=(); StringToArray "$(ConfigGet "networks")" "," networks
	networkIndex="$(network find --service=dns "${networks[@]}" "${globalArgs[@]}" $brief)" || { echo "external"; return; }
	GetSshUser "${networks[$networkIndex]}" # return the name of the network (before @)
}

# findServer NETWORK TYPE SERVICE - find the first server of the specified type for the specified network  
findServer()
{
	local network="$1" type="$2" service="$3"

	# get servers of the specified type
	local serverIndex servers=(); StringToArray "$(getServers "$network" "$type")" "," servers

	# no servers defined
	if [[ ! $servers ]]; then
		doLog && EchoErr "no $type services defined for '$network' network"
		return 1
	fi

	# find an active server
	serverIndex="$(network find "${servers[@]}" $service $brief "${globalArgs[@]}")" || return

	# return HOST:SERVICE of the server (DESCRIPTION@HOST:SERVICE)
	RemoveBefore "${servers[$serverIndex]}" "@" 
}

#
# find commands
#

findUsage()
{
	echot "Usage: $(ScriptName) find SERVER [SERVER...]
Find the first server that exposes a specific service.  Returns the zero based index of the found server.

- SERVER format is [DESCRIPTION@]HOST_OR_IP[:SERVICE], i.e. hagerman:10.10.10:DNS
- DESCRIPTION is used for information messages while checking
- SERVICE is a numeric port or one of
		PING - performs a UDP ping
		DNS - checks port 53 and performs a DNS lookup
  	NFS - checks port 111
  	SMB - checks port 445
  	SSH - checks port 22, or the port the port defined in the SSH configuration for the host

	-b,	--brief		show brief status messages
	-s, --service	the service to use if one is not specified, defaults to PING
	-u, --udp			check the port using UDP instead of TCP"
}

findArgStart() { unset -v brief; check="IsAvailable" defaultService="PING"; }

findOpt()
{
	case "$1" in
		-b|--brief) brief="--brief";;
		-s|--service|-s=*|--service=*) ScriptOptGet "defaultService" "service" "$@";;
		-u|--udp) check="IsAvailablePortUdp";;
		*) return 1;;
	esac
}

findArgs()
{
	(( $# == 0 )) && { MissingOperand "server"; return 1; }
	servers=( "$@" ); (( shift+=$# ))
}

findCommand()
{
	[[ ! $brief && ! $quiet ]] && PrintErr "checking..."

	local server i="0"
	for server in "${servers[@]}"
	do
		# parse the server: DESCRIPTION@HOST_OR_IP:SERVICE
		local host="$(GetSshHost "$server")"
		local service="$(GetSshPort "$server")"; service="${service:-$defaultService}"; service="${service,,}"
		local description="$(GetSshUser "$server")"; description="${description:-$host}"; [[ "$description" != "$host" && $verbose ]] && description="$description ($host)"

		# check for a valid service
		! IsInteger "$service" && [[ "$service" != @(dns|ping|nfs|smb|ssh) ]] && { ScriptErr "'$service' is not a valid service"; return 1; }

		# logging
		if [[ $verbose ]]; then
			PrintErr "$description..."
			IsAvailable "$host" && PrintErr "available..."
			PrintErr "$service..."
		elif [[ ! $brief && ! $quiet ]]; then
			PrintErr "$description..."
		fi

		# check the service
		if findCheck "$host" "$service" "$description"; then
			[[ ! $brief && ! $quiet ]] && EchoErr "found"
			echo "$i"
			return 0
		fi
		
		(( ++i ))
	done
 
	[[ ! $brief && ! $quiet ]] && EchoErr "none available"
	return 1
}

findCheck()
{
	local host="$1" service="$2" description="$3"

	# port number aliases
	case "$service" in
		nfs) service="111";;
		smb) service="445";;
		ssh) service="$(SshHelper config "$host" port)";;
	esac

	case "$service" in
		dns) IsAvailablePort "$host" 53 && dig @$host bogus +time=1 +tries=1 >& /dev/null;;
		ping) IsAvailable "$host";;
		*) "$check" "$host" "$service";;
	esac
}

#
# DNS Commands
#

dnsUsage() { echot "Usage: $(ScriptName) adapter edit|list|name
Network adapter commands."; }

dnsCommand() { dnsFlushCommand; }

dnsFlushCommand() 
{ 
	case "$PLATFORM" in
		linux) sudoc systemd-resolve --flush-caches;;
		mac) sudoc killall -HUP mDNSResponder;;
		win) ipconfig /flushdns;;
	esac
}

#
# Internet Commands
#

internetUsage() { echot "Usage: $(ScriptName) internet [address|detail|host|provider](provider) [PORT|active]
Internet commands.  If no port is specified lookup our current active internet address.
If a numeric port is specified, lookup the internet address for the specified WAN port (usually 1 or 2).

	address						get the internet address
	host							get the hostname
	provider [short]	get the provider name"
}

internetArgs()
{
	[[ $1 ]] && { ScriptArgGet --integer "port" -- "$@"; }
	return 0
}

internetCommand() { internetProviderCommand; }

internetAddressCommand() 
{
	[[ ! $port ]] && { getActiveIp; return; }

	# get internet IP address using the UniFi Controller API
	if UniFiController IsAvailable --quiet; then
		local devices; getDevices && getIp; return
	fi

	# get internet IP address using the router's ifconfig command
	local interface
	case "$port" in
		1) interface="eth2";; # Comcast
		2) interface="ppp1";; # Century Link
		*) ScriptErr "port '$port' is not valid"; return 1;;
	esac

	ssh router ifconfig "$interface" |& grep "^[ ]*inet addr:" | tr -s " " | cut -d" " -f 3 | cut -d: -f 2
}

internetDetailCommand()
{
	[[ ! $port ]] && port="1"

	local devices; getDevices || return
	local isActive; [[ "$(getIp)" == "$(getActiveIp)" ]] && isActive="true"

	echo "hostname="$(DnsResolve "$(getIp)")
	echo "address="$(getIp)
	echo "active=$([[ $isActive ]] && echo "true" || echo "false")"

	header "Geographic Information"
	local geoPort; [[ "$port" == "2" ]] && geoPort="2"
	echo "$devices" | jq '.data[] | select(.name == "router").geo_info.WAN'$geoPort''

	if [[ $isActive ]]; then
		header "Speedtest Status"
	 	cat device.json | jq '.data[] | select(.name == "router")."speedtest-status"'
	 fi
}


internetHostCommand()
{
	local address; address="$(internetAddressCommand)" || return
	DnsResolve "$address"
}

internetProviderCommand()
{
	local address; address="$(internetAddressCommand)" || return
	whois "$address" | grep "OrgTechName" | head -1 | cut -d: -f2 | RemoveSpaceFront
}

internetProviderShortCommand() { internetProviderCommand | GetWord - 1 | LowerCase; }

getActiveIp() { nslookup myip.opendns.com resolver1.opendns.com | grep Address | grep -v 53 | cut -d: -f2 | RemoveSpace; }
getDevices() { devices="$(UniFiController api "/stat/device")"; }
getIp() { echo "$devices" | jq '.data[] | select(.name == "router").wan'$port'.ip' | RemoveQuotes; }

#
# Profile Commands
#

profileUsage() { echot "Usage: $(ScriptName) profile edit|list|set
Network profile commands."; }

profileArgStart() { IsPlatform win && return; EchoErr "network: profile is only implemented for Windows"; return 1; }
profileCommand() { profileListCommand; }

profileEditCommand() { registry edit "$profileKey"; }

profileListCommand()
{
	! IsElevated && { RunScript --elevate network profile list "$@"; return; }

	local IFS=$'\n' name type category

	for key in $(registry get "$profileKey"); do
		name="$(registry get "$key/ProfileName" | RemoveCarriageReturn)"
		type="$(registry get "$key/NameType" | RemoveCarriageReturn)"
		category="$(registry get "$key/Category" | RemoveCarriageReturn)"

		case "$type" in
			0x6) type="Wired";;
			0x17) type="VPN";;
			0x47) type="Wireless";;
			0xF3) type="Mobile Broadband";;
		esac

		case "$category" in
			0x0) category="public";;
			0x1) category="private";;
			0x2) category="work";;
		esac

		echo "$name: $category $type"
	done
}

profileSetArgs() { ScriptArgGet "name" -- "$@"; shift; }

# profile set - if there is only one network profile, set it's name and make it a private network
profileSetCommand()
{
	! IsElevated && { RunScript --elevate network profile set "$name"; pause; return; }

	local numProfiles="$(registry get "$profileKey" | RemoveEmptyLines | wc -l)"

	(( $numProfiles > 1 )) && { EchoErr "Cannot set the profile if more than one exists"; return 1; }

	local key="$(registry get "$profileKey" | RemoveEmptyLines | head -1)"
	registry set "$key/ProfileName" REG_SZ "$name" || return
	registry set "$key/Category" REG_DWORD "1" || return # private
}

#
# VPN Commands
#

vpnUsage() { echot "Usage: $(ScriptName) workgroup on|off|status
VPN commands."; }

vpnArgStart() { IsPlatform win && return; EchoErr "network: VPN is only implemented for Windows"; return 1; }
vpnCommand() { vpnStatusCommand; }
vpnStatusCommand() { rasdial.exe; }

vpnOnCommand()
{
	rasdial.exe "vpn-$(ConfigGet "network")" "$USER" "$(credential get secure default)" || return
	currentUpdateCommand || return
}

vpnOffCommand()
{
	rasdial.exe "vpn-$(ConfigGet "network")" /disconnect || return
	currentUpdateCommand || return
}

#
# Workgroup Commands
#

workgroupUsage() { echot "Usage: $(ScriptName) workgroup name|set
SAMBA workgroup commands."; }

workgroupCommand() { workgroupNameCommand; }

workgroupNameCommand()
{ 
	if IsPlatform win; then
		net.exe config workstation | grep "Workstation domain" | RemoveCarriageReturn | awk '{ print $3; }'
	elif [[ -f "/etc/samba/smb.conf" ]]; then
		cat "/etc/samba/smb.conf" | grep -i "^[ 	]*workgroup[ 	]*=[ 	s]*" | cut -d "=" -f 2 | sed 's/ //g'
 	else
		echo "unknown"
	fi 
}

workgroupSetArgs() { [[ $1 ]] && ScriptArgGet "new" -- "$@"; return 0; }

workgroupSetCommand()
{
	local current="$(network workgroup name)"
	[[ ! $new ]] && { read -p "Enter new workgroup: " new; echo; }

	[[ ! $force && "$current" == "$new" ]] && return

	echo "The current workgroup is $current, setting the workgroup to $new..."

	if [[ -f "/etc/samba/smb.conf" ]]; then
		sudoc sed -i "s/^[        ]*workgroup[    ]*=.*$/workgroup = ${new}/" "/etc/samba/smb.conf" || return
	fi

	if IsPlatform win; then
		elevate RunScript --pause-error powershell Add-computer -WorkgroupName "$new" || return
	fi
	
	return 0
}

#
# proxy commands
#

proxyUsage()
{ 
	echot "Usage: $(ScriptName) proxy [all|apt|vars](all)
Network proxy server commands.

	-e, --enable
	-d, --disable
	-s, --status"
}

proxyArgStart() { unset action; }

proxyOpt() 
{
	case "$1" in
		-d|--disable) action="disable";;
		-e|--enable) action="enable";;
		-s|--status) action="status";;
		*) return 1
	esac
}

proxyCommand() { proxyAllCommand; }

# all
proxyAllCommand() { [[ ! $action ]] && action="status"; proxyAll${action^}; }
proxyAllDisable() { proxyAptDisable && proxyVarsDisable; }
proxyAllEnable() { proxyAptEnable && proxyVarsEnable; }

proxyAllStatus()
{
	if [[ $verbose ]]; then
		header "Proxy Variables"; proxyVarsStatus
		isAptInstalled && { header "APT Proxy"; proxyAptStatus; }
	else
		echo "proxy variables=$(proxyVarsStatus)"
		isAptInstalled && echo "apt proxy=$(proxyAptStatus)"
	fi

	return 0
}

# apt
proxyAptCommand() { [[ ! $action ]] && action="status"; proxyApt${action^}; }
proxyAptDisable() { [[ ! -f "$aptFile" ]] && return; sudo rm "$aptFile"; }

proxyAptStatus()
{
	! isAptInstalled && return

	if [[ -f "$aptFile" ]]; then
		[[ $verbose ]] && cat "$aptFile" || echo "enabled"
	else
		echo "disabled"
	fi
}

proxyAptEnable()
{
	! isAptInstalled && return

	local proxyServer="$(UpdateGet "ProxyServer")"
	
	[[ ! $force ]] && [[ -f "$aptFile" ]] && grep -q "$proxyServer" "$aptFile" && return

	local r; [[ $brief || $quiet ]] && r="RunQuiet"
	echo "Acquire::http::Proxy \"http://$proxyServer\";
Acquire::https::Proxy \"http://$proxyServer\";" | $r sudo tee "$aptFile"
}

# wpad
proxyWpadCommand() { [[ ! $action ]] && action="status"; proxyWpad${action^}; }
proxyWpadEnable() { proxyWpadConfigure "enable"; }
proxyWpadDisable() { proxyWpadConfigure "disable"; }

proxyWpadStatus()
{
	local server; IFS=$'\n' servers=( $(GetServers "web") ) || return
	for server in "${servers[@]}"; do
		printf "$server: "
		ssh "$server" cat "$wpadFile" | grep "PROXY" > /dev/null && echo "enabled" || echo "disabled"; 
	done
}

proxyWpadConfigure()
{
	local operation="$1"
	local src="$CLOUD/network/system/proxy/wpad.dat.$operation"

	# check for configuration file
	[[ ! -f "$src" ]] && { ScriptErr "WPAD configuration file '$src' does not exist"; return 1; }

	# copy the configuration file to each web server
	local server; IFS=$'\n' servers=( $(GetServers "web") ) || return
	for server in "${servers[@]}"; do
		printf "$server: "
		local dest="//$server/admin$wpadFile"
		local dir; dir="$(unc mount "$(GetFilePath "$dest")")" || return
		cp "$src" "$dir/"$(GetFileName "$dest") || return
		unc unmount "$dest" || return
		echo "${operation}d"
	done
}

# vars

proxyVarsUsage()
{ 
	echot "Usage: $(ScriptName) proxy vars
Configure shell proxy variables.

	-e, --enable		set variables if a proxy server is specified, otherwise unset them
	-d, --disable		unset proxy vasriables
	-s, --status		show the status of the proxy variables"
}

proxyVarsCommand() { [[ ! $action ]] && action="enable"; proxyVars${action^}; }
proxyVarsDisable() { proxyVarsShow; }
proxyVarsEnable() { proxyVarsShow "$(UpdateGet "ProxyServer")"; }

# proxyVarsShow [server] - show proxy variables, if server is not specified proxy variables are unset
proxyVarsShow()
{
	local proxyServer="$1"

	if [[ $proxyServer ]]; then
		echo "export {$proxyVars}=\"http://$proxyServer\"; eval export {$noProxyVars}=\"$(ConfigGet "noProxy")\""
	else
		echo "unset {$allProxyVars}"
	fi
}

proxyVarsStatus()
{
	if (( $(export | grep -i 'proxy=\"http' | wc -l) > 1 )); then
		if [[ $verbose ]]; then
			export | grep "$(echo "$allProxyVars=" | sed 's/,/=\\|/g')"
		else
			echo "enabled"
		fi
	else
		echo "disabled"
	fi
}

#
# helper
#

doLog() { [[ ! $brief && ! $quiet ]]; } # return true if output should be logged

# name - return the current network name
name()
{ 
	# return the cached network name if exists
	local name; name="$(UpdateGet "network")" || return; 
	[[ $name ]] && { echo "$name"; return; }

	# no network name identified, try and update it
	network current update --quiet || return
	name="$(UpdateGet "network")" || return; 
	[[ $name ]] && { echo "$name"; return; }

	# unable to identify the network
	ScriptErr "unable to identify the current network"
	return 1
}

# getServers NETWORK TYPE - get servers of the specified type for the specified network from configuration, 
# i.e "getServers hagerman file" would look for the hagermanFileServers configuration variable
getServers()
{
	local network="$1" type="$2"
	ConfigGet "${network}$(UpperCaseFirst "$type")Servers"
}

isAptInstalled() { [[ -d "/etc/apt" ]]; }

ScriptRun "$@"

#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) adapter|current|cache|center|dns|domain|find|gui|hosts|internet|ip|profile|proxy|run|service|timeout|vars|vpn|watch|workgroup
Network commands."
}

init() 
{
	defaultCommand="center"

	wpadFile="/srv/apache-web/htdocs/autoproxy/wpad.dat"
	
	adapterKey='HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Network???'
	profileKey='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles/'

	proxyVars="http_proxy,https_proxy,ftp_proxy,HTTP_PROXY,HTTPS_PROXY,FTP_PROXY"
	noProxyVars="no_proxy,NO_PROXY"	
	allProxyVars="$proxyVars,$noProxyVars"
	aptFile="/etc/apt/apt.conf.d/proxy"	
}

#
# commands
#

runCommand() { ssh "$1" 'source /etc/profile; '"${@:2}"''; }
centerCommand() {	start control /name Microsoft.NetworkAndSharingCenter; }
cacheCommand() { IsAvailable "$1" || return; net use '\\'$1'\ipc$' >& /dev/null; }
guiCommand() { ! IsPlatform win && return; rundll32.exe shell32.dll,Control_RunDLL ncpa.cpl; }

#
# adapter commands
#

adapterUsage() { echot "Usage: $(ScriptName) adapter [edit|exists|list|name|vars](list)\nNetwork adapter commands."; }
adapterCommand() { adapterListCommand; }

adapterEditCommand() { registry edit "$adapterKey"; }

adapterExistsUsage() { echot "Usage: $(ScriptName) adapter exists\nReturn true if the network adapter exists."; }
adapterExistsArgs() { ScriptArgGet "name" -- "$@"; }
adapterExistsCommand() { adapterCheck "$name"; }

#
# adapter list command
#

adapterListUsage() { echot "Usage: $(ScriptName) adapter list [detail]\nList network adapters."; }
adapterListCommand() { adapterList; }

adapterList()
{
	! IsPlatform win && return

	# format "Ethernet adapter NAME:" and "Wireless LAN adapter NAME:"
	ipconfig.exe /all | RemoveCarriageReturn |
		grep "^[A-Z].* adapter " |					# include adapter names
		sed 's/.* adapter //' |							# remove text up to " adapter "
		grep -v "Local Area Connection*" | 	# ignore wireless hotspots with the name "Local Area Connection" - https://superuser.com/questions/1580417/what-is-microsoft-wi-fi-direct-virtual-adapter-used-for
		cut -d":" -f1 | sort
}

#
# adapter list detail command
#

adapterListDetailUsage() { echot "Usage: $(ScriptName) adapter list detail [NAME]\nList network adapter detail."; }
adapterListDetailArgs() { [[ ! $1 ]] && return; ScriptArgGet "name" -- "$@"; }
adapterListDetailCommand() { if [[ $name ]]; then adapterListDetail "$name"; else adapterListDetailAll; fi; }

# adapterListDetail NAME - list detail for the specific network adapter
adapterListDetail()
{
	local name="$1"; adapterCheck "$name" || return

	ipconfig.exe /all | RemoveCarriageReturn |
		sed -n '/^[A-Z].* adapter '"$name"':/,/[A-Z].* adapter /p' |	# get text between NAME and next adapter 
		grep --extended-regexp --invert-match "^[A-Z].* adapter" | 	# remove adapter lines
		grep "\S" |																									# remove empty lines
		sed 's/^[ ]*//g' |																					# remove leading spaces
		sed 's/\. //g' | tr -s " " | sed 's/[ ]*:[ ]*/=/g'					# make key=value pairs
}

# adapterListDetailAll - list detailed information for all network adapters
adapterListDetailAll()
{
	! IsPlatform win && return
	powershell.exe Get-NetAdapter | RemoveCarriageReturn | RemoveEmptyLines | ${G}tail --lines=+3
}

#
# adapter name command
#

adapterNameArgs()
{
	ScriptArgGet "old" -- "$@"; shift
	ScriptArgGet "new" -- "$@"; shift
}

adapterNameCommand()
{ 
	! IsElevated && { RunScript --elevate -- network adapter name "$old" "$new"; return; }
	powershell.exe Rename-NetAdapter -Name \"$old\" -NewName \"$new\"
}

#
# adapter vars command
#

adapterVarsUsage()
{
	echot "Usage: $(ScriptName) adapter vars NAME|show
Return network adapter information in variables.

	-a,	--all			add all information (slower)"
}

adapterVarsArgStart() { unset -v all; ipVarsArgStart && vars=(name description linkSpeed ifIndex linkStatus "${vars[@]}" defaultGateway mac); }
adapterVarsArgs() { [[ "${commandNames[2]}" == "show" ]] && return; ScriptArgGet "name" -- "$@"; }
adapterVarsCommand() { adapterVars "$name"; }
adapterVarsShowCommand() { echo -n "${vars[@]}"; }

adapterVarsOpt()
{
	case "$1" in
		-a|--all) all="--all";;
		*) return 1;;
	esac
}

# adapterVars NAME - return adapter information in variables
adapterVars()
{
	local name="$1" description linkSpeed ifIndex linkStatus cidr ip mask network broadcast defaultGateway mac

	# validate adapter
	adapterCheck "$name" || return

	# get information
	info="$(adapterListDetail "$name")"

	# adapter
	local description; description="$(echo "$info" | grep "^Description=" | cut -d"=" -f2-)"

	if [[ $all ]]; then
		allInfo="$(adapterListDetailAll | grep "^$name " | cut -c 72- | tr -s " " | RemoveSpaceFront)"
		linkStatus="$(echo "$allInfo" | cut -d" " -f2 | LowerCase)"
		ifIndex="$(echo "$allInfo" | cut -d" " -f1)"
		linkSpeed="$(echo "$allInfo" | cut -d" " -f4-)"
	else
		ifIndex="$(route.exe print | grep "...$description" | cut -d"." -f1 | RemoveSpace)"
	fi

	# IPv4
	ip="$(echo "$info" | grep "^IPv4 Address=" | cut -d"=" -f2 | cut -d'(' -f1)"
	mask="$(echo "$info" | grep "^Subnet Mask=" | cut -d"=" -f2)"
	defaultGateway="$(echo "$info" | grep "^Default Gateway=" | cut -d"=" -f2)"
	setIpVars "$ip" "$mask" || return

	# other
	mac="$(echo "$info" | grep "^Physical Address=" | cut -d"=" -f2 | tr '-' ':' | LowerCase)"

	ScriptReturn "${vars[@]}"
}

# adapterCheck NAME - return true if the adapter exists
adapterCheck()
{
	local name="$1"
	adapterList | grep --quiet "^${name}$" && return
	ScriptErrQuiet "adapter '$name' does not exist"
	return 1
} 

#
# current commands
#

currentUsage() { echot "Usage: $(ScriptName) current [all|find|name [cached]|status|server|servers|update](all)\nCurrent network commands."; }
currentCommand() { currentAllCommand; }
currentNameUsage() { echot "Usage: $(ScriptName) current name [cached]\nThe name of the current network.  Returns a cached value within specified intervals  unless --force is specified."; }
currentNameCommand() { name; }
currentNameCachedUsage() { echot "Usage: $(ScriptName) current name cached\nThe cached name of the current network."; }
currentNameCachedCommand() { nameCached; }
currentStatusUsage() { echot "Usage: $(ScriptName) current all\nStatus of the current network."; }
currentStatusCommand() { printf "network=$(name)\nproxy=$( [[ "$(getProxyServer)" == "" ]] && echo "none" || echo "$(getProxyServer)" )\ntimeout=$(AvailableTimeoutGet) ms\n"; }

# common options

currentUsageOther() { currentUsageBrief; currentUsageTimeout; }
currentArgStartOther() { currentArgStartBrief && currentArgStartTimeout; }
currentOptOther() { currentOptBrief "$@" || currentOptTimeout "$@"; }

currentUsageBrief() { EchoWrap "	-b,	--brief		show brief status messages (for use with app script)"; }
currentArgStartBrief() { unset -v brief; }
currentOptBrief() { [[ "$1" == @(-b|--brief) ]] || return; brief="--brief"; }

currentUsageTimeout() { EchoWrap "	-t, --timeout	$(ScriptOptTimeoutUsage)"; }
currentArgStartTimeout() { ScriptOptTimeoutArgStart; }
currentOptTimeout() { [[ "$1" =~ --timeout|--timeout=*|-t|-t=* ]] || return; ScriptOptTimeout "$@"; }

#
# Current All Command
#

currentAllUsage() { echot "Usage: $(ScriptName) current all\nFind all networks we are currently on."; }

currentAllCommand()
{
	local network networks=(); StringToArray "$(ConfigGet "networks")" "," networks
	local current="$(RunLog network find --all --service=dns "${networks[@]}" "${globalArgs[@]}" --quiet)" || { echo "external"; return; }

	# format - remove suffix after @
	local name names=()
	local host hosts; IFS=$'\n' ArrayMake hosts "$current"
	for host in "${hosts[@]}"; do
		name="$(GetSshUser "$host")" # name of the network (before @)		
		! IsInArray "$name" names && names+=("$name") 
	done

	ArrayDelimit names " "
}

#
# current find command
#

currentFindUsage() { echot "Usage: $(ScriptName) current find\nFind the primary network.\n\n$(currentUsageOther)"; }
currentFindArgStart() { currentArgStartOther; }
currentFindOpt() { currentOptOther "$@"; }
currentFindCommand() { findNetwork; }

#
# current server command
#

currentServerUsage()
{ 
	ScriptUsageEcho "Usage: $(ScriptName) current server TYPE
Find the first available server for the current network, i.e. network 'network current server wireguard --service=wg' find the first available WireGuard from the list of servers in bootstrap-config.sh <domain>WireguardServers.

$(currentUsageOther)
	-s, --service	the service used to validate the server, defaults to ping, see 'network find --help'"
}

currentServerArgStart() { unset -v service; currentArgStartOther; }

currentServerOpt()
{
	currentOptOther "$@" && return
	case "$1" in
		-s|--service|-s=*|--service=*) ScriptOptGet "service" "$@"; service="--service=$service";;
		*) return 1;;
	esac
}

currentServerArgs() { ScriptArgGet "type" -- "$@"; shift; }
currentServerCommand() { local name; name="$(name)" || return; findServer "$name" "$type" "$service"; }

#
# current servers command
#

currentServersUsage()
{
	echot "Usage: $(ScriptName) current servers TYPE
Return all servers of the specified type for the current network, i.e. 'network current servers dns' returns all of the DNS servers in bootstrap-config.sh <domain>DnsServers."
}

currentServersArgStart() { unset -v type; }
currentServersArgs() { ScriptArgGet "type" -- "$@"; shift; }
currentServersCommand() { local name; name="$(name)" || return; getServersFromConfig "$name" "$type"; }

#
# current update command
#

currentUpdateUsage() { echot "Usage: $(ScriptName) current all\nUpdate network settings for the current networks.\n\n$(currentUsageOther)"; }
currentUpdateArgStart() { currentArgStartOther; }
currentUpdateOpt() { currentOptOther "$@"; }

currentUpdateCommand()
{
	# return if recently updates
	local cache="network-current-update"; ! UpdateNeeded "$cache" && return

	# get cached network configuration
	local existingNetwork="$(UpdateGet "network")" existingGateway="$(UpdateGet "network_gateway")" existingProxyServer="$(UpdateGet "ProxyServer")"

	# return if current network has not changed and is valid
	local gateway; gateway="$(GetDefaultGateway --force)" || return

	if [[ ! $force && "$existingGateway" == "$gateway" ]]; then
		local dnsServer; dnsServer="$(GetDnsServers | cut -d" " -f1)"

		if validateNetwork "$existingNetwork" "$dnsServer"; then
			updateDns "$existingNetwork" || return
			doLog && echo "Current network '$existingNetwork' has not changed"
			UpdateDone "$cache"
			return 0
		fi			

		doLog && echo "The DNS server '$dnsServer' for the current network '$existingNetwork' is not valid"
	fi

	# determine current network configuration
	local network
	doLog && { hilight "Determining network..."; echo "Existing network is ${existingNetwork:-unknown}"; }
	doLog && printf "network..."; network="$(findNetwork)" || return

	# update network configuration if needed
	if [[ $force || "$network" != "$existingNetwork" || "$gateway" != "$existingGateway" ]]; then
		doLog && hilight "Configuring the network for '$network'..."
		[[ $brief ]] && printf "network."
		UpdateSet "network" "$network" || return
		UpdateSet "network_gateway" "$gateway" || return
	fi

	# update resolv.conf - ensures name resolution is working so we can find other servers
	updateDns "$network" || return

	# find proxy servers
	local proxyServer
	if canProxy; then 
		doLog && printf "proxy..."; proxyServer="$(findProxyServer "$network")" || return
		doLog && { [[ $proxyServer ]] && echo "available" || echo "none"; }
	fi

	# return if no changes are required
	[[ ! $force && "$network" == "$existingNetwork" && "$proxyServer" == "$existingProxyServer" ]] && return

	# save proxy server
	UpdateSet "ProxyServer" "$proxyServer" || return
	if [[ $proxyServer ]]; then
		network proxy apt --enable "${globalArgs[@]}" || return
		ScriptEval network proxy vars --enable || return
	else
		network proxy apt --disable "${globalArgs[@]}" || return
		ScriptEval network proxy vars --disable || return
	fi

	# status
	if doLog; then
		hilight "Network status..."
		force= currentStatusCommand || return
		[[ $(getProxyServer) ]] && { network proxy --status "${globalArgs[@]}" || return; }
	fi

	UpdateDone "$cache"
}

# updateDns NETWORK
updateDns() {	RunPlatform updateDns "$1" && updateHosts "$1"; }

# updateDnsWsl NETWORK - update /etc/resolv.conf for the current network
updateDnsWsl()
{
	local network="$1"
	local src="$DATA/setup/resolv.conf.$network" dest="/etc/resolv.conf"
	[[ ! -f "$src" ]] && src="$DATA/setup/resolv.conf.external"
	[[ ! -f "$src" ]] && return
	cmp --quiet "$src" "$dest" >& /dev/null && return

	# update
	[[ $brief ]] && printf "resolv.conf."
	log1 "copying '$src' to '$dest'"
	sudoc cp "$src" "$dest"
}

# updateDnsMac NETWORK - update /etc/resolver/custom for the current network
updateDnsMac()
{
	local network="$1"
	local src="$DATA/setup/$network.resolver" dest="/etc/resolver/custom"
	! [[ -f "$src" ]] && { sudoc rm -f "$dest"; return 0; }
	cmp --quiet "$src" "$dest" >& /dev/null && return

	# update	
	[[ $brief ]] && printf "resolver."
	sudoc ${G}mkdir --parents "/etc/resolver" && sudoc cp "$src" "$dest"
}

# updateHosts NETWORK - update /etc/hosts for the current network
updateHosts()
{
	local network="$1"
	local src="$DATA/setup/hosts.$network" dest="/etc/hosts"

	# no hosts file for the current network - restore original /etc/hosts
	if [[ ! -f "$src" ]]; then
		[[ -f "$dest.orig" ]] && ! cmp --quiet "$dest.orig" "$dest" && { sudoc cp "$dest.orig" "$dest" || return; }
		return 0
	fi

	# current network hosts are already in /etc/hosts
	[[ ! $force ]] && qgrep --ignore-case "^# $network" "$dest" && return

	# backup original /etc/hosts file if needed
	[[ ! -f "$dest.orig" ]] && { sudoc cp "$dest" "$dest.orig" || return; }

	# add hosts for this network
	[[ $brief ]] && printf "hosts."
	{ echo; cat "$src"; } | sudoc ${G}tee --append "$dest" > /dev/null
}

# findNetwork - find the first active network from the networks specified in the networks configuration variabke 
findNetwork()
{
	local network networks=(); StringToArray "$(ConfigGet "networks")" "," networks
	network="$(RunLog network find --service=dns --timeout=$timeout $brief "${networks[@]}" "${globalArgs[@]}")" || { echo "external"; return; }
	GetSshUser "$network" # return the name of the network (before @)
}

findProxyServer()
{
	local network="$1"
	local server="$(ConfigGet "${network}ProxyServer")"; [[ ! $server ]] && return
	IsAvailablePort "$server" $timeout && curl --silent -x "http://$server" "http://httpbin.org/ip" |& jq > /dev/null && echo "$server"
}

# findServer NETWORK TYPE SERVICE - find the first server of the specified type for the specified network  
findServer()
{
	local network="$1" type="$2" service="$3"

	# get servers of the specified type
	local server servers=(); StringToArray "$(getServersFromConfig "$network" "$type")" "," servers

	# no servers defined
	if [[ ! $servers ]]; then
		doLog && EchoErr "no '$type' services defined for '$network' network"
		return 1
	fi

	# find an active server
	server="$(RunLog network find "${servers[@]}" $brief $service "${globalArgs[@]}")" || return

	# return HOST:SERVICE of the server (DESCRIPTION@HOST:SERVICE)
	RemoveBefore "$server" "@" 
}

# validateNetwork NETWORK DNS_SERVER - validate the DNS server is correct for the network
validateNetwork()
{
	local network="$1" dnsServer="$2"
	local networks=(); StringToArray "$(ConfigGet "networks")" "," networks	# array of network:DNS_IP

	# if the DNS server is not in the list of known networks, the network must be external
	! IsInArray --wild ".*@$dnsServer" networks && { [[ "$network" == "external" ]]; return; }

	# the DNS server is the list of known networks, so network@DNS_IP must be in the list of known networks
	IsInArray --wild "$network@$dnsServer.*" networks
}

#
# DNS commands
#

dnsUsage() { echot "Usage: $(ScriptName) adapter edit|list|name
Network adapter commands."; }

dnsCommand() { dnsFlushCommand; }

dnsFlushCommand() 
{ 
	case "$PLATFORM_OS" in
		linux) sudoc systemd-resolve --flush-caches;;
		mac) sudoc killall -HUP mDNSResponder;;
		win) ipconfig /flushdns;;
	esac
}

#
# domain commands
#

domainUsage() { echot "Usage: $(ScriptName) domain [dns|name|joined](name)
Domain commands."; }

domainCommand() { domainNameCommand; }

#
# domain dns commands
#

domainDnsUsage() { echot "Usage: $(ScriptName) domain dns\nReturn the DNS name of the domain."; }
domainDnsCommand() { RunPlatform "domainDns"; }
domainDnsMac() { dsconfigad -show | grep "^Active Directory Domain" | cut -d"=" -f2 | RemoveSpaceTrim; }
domainDnsWin() { cmd.exe /c 'echo %USERDNSDOMAIN%' 2> /dev/null | RemoveCarriageReturn | RemoveNewline | LowerCase; }

#
# domain name commands
#

domainNameUsage() { echot "Usage: $(ScriptName) domain name\nReturn the name of the domain."; }

domainNameCommand()
{ 
	local domain; domain="$(RunPlatform domainName)" || return
	{ [[ ! $domain ]] || IsLocalHost "$domain"; } && domain="$(ConfigGet "defaultDomain")"
	echo "$domain"
}

domainNameMac() { domainDnsMac | GetWord - 2 .; return 0; }
domainNameWin() { cmd.exe /c 'echo %USERDOMAIN%' 2> /dev/null | RemoveCarriageReturn | RemoveNewline | LowerCase; }

#
# domain joined commands
#

domainJoinedUsage() { echot "Usage: $(ScriptName) domain joined\nReturn true if we are joined to a domain."; }
domainJoinedCommand() { RunPlatform domainJoined; }
domainJoinedMac() { [[ $(domainNameMac) ]]; }
domainJoinedWin() { ! IsLocalHost "$(domainNameWin)"; }

#
# find commands
#

findUsage()
{
	echot "Usage: $(ScriptName) find SERVER [SERVER...]
Find servers that exposes a specific service.

- SERVER format is [DESCRIPTION@]HOST_OR_IP[:SERVICE], i.e. hagerman:10.10.10:DNS
- DESCRIPTION is used for information messages while checking
- SERVICE is a numeric port, or one of:
		ping - performs a UDP ping
		dns - checks port 53 and performs a DNS lookup
  	nfs - checks port 111
  	smb - checks port 445
  	ssh - checks port 22, or the port the port defined in the SSH configuration for the host
  	wg - checks the WireGuard UDP port for the current network, defaults to 51820

	-a,	--all			find all servers instead of the first
	-b,	--brief		show brief status messages
	-s, --service	the service to use if one is not specified, defaults to PING
	-t, --timeout $(ScriptOptTimeoutUsage)
	-u, --udp			check the port using UDP instead of TCP"
}

findArgStart() { unset -v all brief; check="IsAvailablePort" defaultService="PING"; ScriptOptTimeoutArgStart; }

findOpt()
{
	case "$1" in
		--all|-a) all="--all";;
		--brief|-b) brief="--brief";;
		--service|--service=*|-s|-s=*) ScriptOptGet "defaultService" "service" "$@";;
		--timeout|--timeout=*|-t|-t=*) ScriptOptTimeout "$@";;
		--udp|-u) check="IsAvailablePortUdp";;
		*) return 1;;
	esac
}

findArgs()
{
	(( $# == 0 )) && { MissingOperand "server"; return 1; }
	servers=( "$@" ); (( shift+=$# )); return 0;
}

findCommand()
{
	[[ ! $brief && ! $quiet ]] && PrintErr "checking..."

	local server descriptions=() results=()

	# look for available server
	log1 "looking for servers: $(ArrayShow servers)"
	for server in "${servers[@]}"
	do
		local host service description; parseServer $server || return

		# add the host to the description if verbose logging
		[[ "$description" != "$host" && $verbose ]] && description="$description ($host)"
		
		# already checked this server
		IsInArray "$description" descriptions && continue

		# check for a valid service
		! IsInteger "$service" && [[ "$service" != @(dns|ping|nfs|smb|ssh|wg) ]] && { ScriptErr "'$service' is not a valid service"; return 1; }

		# logging
		if [[ $verbose ]]; then
			PrintErr "$description..."
			IsAvailable "$host" $timeout && PrintErr "available..."
			PrintErr "$service..."
		elif doLog; then
			PrintErr "$description..."
		fi

		# check the service
		if findCheck "$host" "$service" "$description"; then
			doLog && PrintErr "found"
			descriptions+=($description) results+=($server)
			[[ ! $all ]] && { doLog && EchoErr; echo "$server"; return 0; }
			doLog && PrintErr "..."
		fi
		
	done
 
	# status
 	if [[ $results ]]; then
 		doLog && EchoErrEnd "done"	
 		ArrayDelimit results $'\n'
 	else
		doLog && EchoErrEnd "none available"	
		return 1
	fi
}

findCheck()
{
	local host="$1" service="$2" description="$3"
	local ip; ip="$(GetIpAddress "$host")" || return

	# port number aliases
	case "$service" in
		nfs) service="111";;
		smb) service="445";;
		ssh) service="$(SshHelper config get "$host" port)";;
	esac

	case "$service" in
		dns) 
			IsAvailablePort "$ip" 53 $timeout || return
			InPath dig && { dig @$host bogus +time=2 +tries=1 >& /dev/null || return; } # some DNS servers require 2
			return 0
			;;

		ping)
			IsAvailable "$ip" $timeout
			;;

		wg)
				local port="$(ConfigGetCurrent WireguardPort)"; [[ ! $port ]] && port="51820"
				IsAvailablePortUdp "$host" "$port" $timeout
				;;

		*) 
			"$check" "$host" "$service"
			;;
			
	esac
}

#
# hosts command
#

hostsUsage() { EchoWrap "Usage: $(ScriptName) hosts [--wsl]
Edit the local system hosts file."; }

hostsArgStart() { unset -v wsl; }

hostsOpt() 
{
	case "$1" in
		-w|--wsl) wsl="true";;
		*) return 1
	esac
}

hostsCommand()
{
	local file="/etc/hosts"; IsPlatform win && [[ ! $wsl ]] && file="$WIN_ROOT/Windows/system32/Drivers/etc/hosts"
	sudoe "$file"
}

#
# internet command
#

internetUsage() { echot "Usage: $(ScriptName) internet address|detail|host|provider [PORT|active]
Internet commands.  If no port is specified lookup our current active internet address.
If a numeric port is specified, lookup the internet address for the specified WAN port (usually 1 or 2).

	address						get the internet address
	host							get the hostname
	provider [short]	get the provider name"
}

internetArgs()
{
	[[ $1 ]] && { ScriptArgGet --integer "port" -- "$@"; }
	return 0
}

internetCommand() { usage; }

internetAddressCommand() 
{
	[[ ! $port ]] && { getActiveIp; return; }

	# get internet IP address using the UniFi Controller API
	if UniFiController ApiAvailable --quiet; then
		local devices; getDevices && getIp; return
	fi

	# get internet IP address using the router's ifconfig command
	local interface
	case "$port" in
		1) interface="eth2";; # WAN 1, Comcast
		2) interface="ppp1";; # WAN 2, Century Link
		*) ScriptErr "port '$port' is not valid"; return 1;;
	esac

	RunLog SshHelper connect router -- ifconfig "$interface" |& grep "^[ ]*inet addr:" | tr -s " " | cut -d" " -f 3 | cut -d: -f 2
}

internetDetailCommand()
{
	[[ ! $port ]] && port="1"

	local devices; getDevices || return
	local isActive; [[ "$(getIp)" == "$(getActiveIp)" ]] && isActive="true"

	header "Basic Information"
	echo "hostname="$(DnsResolve "$(getIp)")
	echo "address="$(getIp)
	echo "active=$([[ $isActive ]] && echo "true" || echo "false")"

	header "Geographic Information"
	local geoPort; [[ "$port" == "2" ]] && geoPort="2"
	echo "$devices" | jq '.data[] | select(.name == "router").geo_info.WAN'$geoPort''

	if [[ $isActive ]]; then
		header "Speedtest Status"
	 	echo "$devices" | jq '.data[] | select(.name == "router")."speedtest-status"'
	 fi
}

internetHostCommand()
{
	local address; address="$(internetAddressCommand)" || return
	DnsResolve "$address"
}

internetProviderCommand()
{
	local address; address="$(internetAddressCommand)" || return
	whois "$address" | grep "OrgTechName" | head -1 | cut -d: -f2 | RemoveSpaceFront
}

internetProviderShortCommand() { internetProviderCommand | GetWord - 1 | LowerCase; }

getActiveIp() { curl --silent https://myipv4.p1.opendns.com/get_my_ip | jq '.ip' | RemoveQuotes; }
getDevices() { devices="$(UniFiController api "/stat/device")"; }
getIp() { echo "$devices" | jq '.data[] | select(.name == "router").wan'$port'.ip' | RemoveQuotes; }

#
# ip commands
#

ipUsage() { echot "Usage: $(ScriptName) ip broadcast|cidr|mask|network|vars\nIP address commands."; }
ipCommand() { usage; }

ipBroadcastUsage() { echot "Usage: $(ScriptName) ip broadcast [IP MASK]|CIDR\nGet the broadcast (last) address for the IP.  CIDR format is IP/N."; }
ipBroadcastArgs() { ScriptArgGet "ip" -- "$@"; shift; [[ ! $1 ]] && return; ScriptArgGet "mask" -- "$@"; }
ipBroadcastCommand() { getBroadcast "$ip" "$mask"; }

ipMaskUsage() { echot "Usage: $(ScriptName) ip mask N\nGet the subnet mask for a subnet with N network bits."; }
ipMaskArgs() { ScriptArgGet "n" -- "$@"; }

ipNetworkUsage() { echot "Usage: $(ScriptName) ip network [IP MASK]|CIDR\nGet the network (first) address for the IP.  CIDR format is IP/N."; }
ipNetworkArgs() { ScriptArgGet "ip" -- "$@"; shift; [[ ! $1 ]] && return; ScriptArgGet "mask" -- "$@"; }
ipNetworkCommand() { getNetwork "$ip" "$mask"; }

#
# IP CIDR commands
#

ipCidrUsage() { echot "Usage: $(ScriptName) ip cidr make|split\nIP CIDR commands."; }
ipCidrCommand() { usage; }

ipCidrMakeArgs() { ScriptArgGet "ip" -- "$@"; shift; ScriptArgGet "mask" -- "$@"; }
ipCidrMakeUsage() { echot "Usage: $(ScriptName) ip cidr make IP MASK\nMake a CIDR (IP/N) from the IP address and subnet mask."; }
ipCidrMakeCommand() { cidrMake "$ip" "$mask"; }

ipCidrSplitArgs() { ScriptArgGet "cidr" -- "$@"; }
ipCidrSplitUsage() { echot "Usage: $(ScriptName) ip cidr split CIDR\nSplit a CIDR (IP/N) and return the IP address and subnet mask."; }
ipCidrSplitCommand() { cidrSplit "$cidr"; }

# isCidr CIDR - return true if CIDR is a CIDR (IP/N)
isCidr() { [[ "$1" =~ / ]]; }

# cidrMake IP MASK - make a CIDR (IP/N) from an IP address and subnet mask
cidrMake()
{
	local ip="$1" mask="$2"; log1 "ip=$ip mask=$mask"
	echo "$ip/$(maskToN "$mask")"
}

# cidrSplit CIDR - split a CIDR (IP/N) to an IP address and subnet mask, sets ip and mask variables
cidrSplit()
{
	local cidr="$1"
	local ip="$(GetWord "$cidr" 1 "/")" n="$(GetWord "$cidr" 2 "/")" mask
	{ ! IsIpAddress "$ip" || ! IsInteger "$n"; } && { ScriptErrQuiet "'$cidr' is not a valid CIDR (IP/N)"; return 1; }
	mask="$(nToMask "$n")"
	log1 "ip=$ip mask=$mask"
	ScriptReturn ip mask
}

#
# IP vars command
#

ipVarsUsage() { echot "Usage: $(ScriptName) ip vars show|[IP MASK]|CIDR\nGet the CIDR, ip, mask, broadcast, and network for the IP.  CIDR format is IP/N."; }
ipVarsArgStart() { vars=(cidr ip mask network broadcast); }
ipVarsArgs() { [[ "${commandNames[2]}" == "show" ]] && return; ScriptArgGet "ip" -- "$@"; shift; [[ ! $1 ]] && return; ScriptArgGet "mask" -- "$@"; }
ipVarsShowCommand() { echo -n "${vars[@]}"; }
ipVarsCommand() { local cidr network broadcast; setIpVars "$ip" "$mask" && ScriptReturn "${vars[@]}"; }

#
# IP helper
#

# getIpArgs [IP MASK]|CIDR - sets ip and mask variables
getIpArgs()
{
	ip="$1" mask="$2"
	isCidr "$ip" && { ScriptEval cidrSplit "$ip"; return; }
	! IsIpAddress "$ip" && { ScriptErr "'$ip' is not a valid IP address"; return 1; }	
	! IsIpAddress "$mask" && { ScriptErr "'$mask' is not a valid subnet mask"; return 1; }
	return 0
}

# getBroadcast [IP MASK]|CIDR - 192.0.2.0/24 => 192.0.2.255
getBroadcast()
{
	local ip mask; getIpArgs "$@" || return
  local addr="$(ipToInt "$ip")"
  local mask=$((0xffffffff << (32 - $(maskToN "$mask")))); shift
  intToIp "$((addr | ~mask))"
}

# getNetwork [IP MASK]|CIDR - 192.0.2.0/24 => 192.0.2.0
getNetwork()
{
	local ip mask; getIpArgs "$@" || return
  local addr=$(ipToInt "$ip"); shift
  local mask=$((0xffffffff << (32 - $(maskToN "$mask")))); shift
  intToIp $((addr & mask))
}

intToIp()
{
  local ui32="$1" ip n
  for n in 1 2 3 4; do
      ip="$((ui32 & 0xff))${ip:+.}$ip"
      ui32="$((ui32 >> 8))"
  done
  echo "$ip"
}

ipToInt()
{
  local a b c d
  { IFS=. read a b c d; } <<< "$1"
  echo "$(((((((a << 8) | b) << 8) | c) << 8) | d))"
}

maskToN()
{
	local mask="$1"
	local i="$(ipToInt "$mask")" n=0

	while (( i > 0)); do
  	: $(( n+=i&1, i>>=1 ))
	done

	echo "$n"
}

# nToMask N - 24 => 255.255.255.0
nToMask()
{
  local mask="$((0xffffffff << (32 - "$1")))"
  intToIp "$mask"
}

# setIpVars IP MASL
setIpVars()
{
	local ip="$1" mask="$2"
	cidr="$(cidrMake "$ip" "$mask")" || return
	network="$(getNetwork "$ip" "$mask")" || return
	broadcast="$(getBroadcast "$ip" "$mask")" || return
}

#
# profile commands
#

profileUsage() { echot "Usage: $(ScriptName) profile edit|list|set
Network profile commands."; }

profileArgStart() { IsPlatform win && return; EchoErr "network: profile is only implemented for Windows"; return 1; }
profileCommand() { profileListCommand; }

profileEditCommand() { registry edit "$profileKey"; }

profileListCommand()
{
	! IsElevated && { RunScript --elevate network profile list "$@"; return; }

	local key keys name type category; IFS=$'\n' ArrayMake keys "$(registry get "$profileKey")"
	for key in "${keys[@]}"; do
		name="$(registry get "$key/ProfileName" | RemoveCarriageReturn)"
		type="$(registry get "$key/NameType" | RemoveCarriageReturn)"
		category="$(registry get "$key/Category" | RemoveCarriageReturn)"

		case "$type" in
			0x6) type="Wired";;
			0x17) type="VPN";;
			0x47) type="Wireless";;
			0xF3) type="Mobile Broadband";;
		esac

		case "$category" in
			0x0) category="public";;
			0x1) category="private";;
			0x2) category="work";;
		esac

		echo "$name: $category $type"
	done
}

profileSetArgs() { ScriptArgGet "name" -- "$@"; shift; }

# profile set - if there is only one network profile, set it's name and make it a private network
profileSetCommand()
{
	! IsElevated && { RunScript --elevate network profile set "$name"; pause; return; }

	local numProfiles="$(registry get "$profileKey" | RemoveEmptyLines | wc -l)"

	(( $numProfiles > 1 )) && { EchoErr "Cannot set the profile if more than one exists"; return 1; }

	local key="$(registry get "$profileKey" | RemoveEmptyLines | head -1)"
	registry set "$key/ProfileName" REG_SZ "$name" || return
	registry set "$key/Category" REG_DWORD "1" || return # private
}

#
# proxy commands
#

proxyUsage()
{ 
	echot "Usage: $(ScriptName) proxy [all|apt|vars](all)
Network proxy server commands.

	-e, --enable
	-d, --disable
	-s, --status"
}

proxyArgStart() { unset action; }

proxyOpt() 
{
	case "$1" in
		-d|--disable) action="disable";;
		-e|--enable) action="enable";;
		-s|--status) action="status";;
		*) return 1
	esac
}

proxyCommand() { proxyAllCommand; }

# all
proxyAllCommand() { [[ ! $action ]] && action="status"; proxyAll${action^}; }
proxyAllDisable() { proxyAptDisable && proxyVarsDisable; }
proxyAllEnable() { proxyAptEnable && proxyVarsEnable; }

proxyAllStatus()
{
	if [[ $verbose ]]; then
		header "Proxy Variables"; proxyVarsStatus
		isAptInstalled && { header "APT Proxy"; proxyAptStatus; }
	else
		echo "proxy variables=$(proxyVarsStatus)"
		isAptInstalled && echo "apt proxy=$(proxyAptStatus)"
	fi

	return 0
}

# apt
proxyAptCommand() { [[ ! $action ]] && action="status"; proxyApt${action^}; }
proxyAptDisable() { [[ ! -f "$aptFile" ]] && return; sudoc rm "$aptFile"; }

proxyAptStatus()
{
	! isAptInstalled && return

	if [[ -f "$aptFile" ]]; then
		[[ $verbose ]] && cat "$aptFile" || echo "enabled"
	else
		echo "disabled"
	fi
}

proxyAptEnable()
{	
	# disable APT proxy if cannot get an APT proxy server
	local proxyServer; proxyServer="$(getProxyServerApt)" || { proxyAptDisable; return; }

	# return if APT proxy is already enabled
	[[ ! $force ]] && [[ -f "$aptFile" ]] && grep -q "$proxyServer" "$aptFile" && return

	# set APT proxy server
	echo "Acquire::http::Proxy \"http://$proxyServer\";
Acquire::https::Proxy \"http://$proxyServer\";" | RunSilent sudoc tee "$aptFile"
}

# wpad
proxyWpadCommand() { [[ ! $action ]] && action="status"; proxyWpad${action^}; }
proxyWpadEnable() { proxyWpadConfigure "enable"; }
proxyWpadDisable() { proxyWpadConfigure "disable"; }

proxyWpadStatus()
{
	local host hosts; IFS=$'\n' ArrayMakeC hosts GetServers nomad-client || return
	for host in localhost "${hosts[@]}"; do
		printf "$(GetHostname "$host"): "
		RunLog RunScript "${globalArgs[@]}" --ssh "$host" "$(cat <<-EOF
			if [[ ! -f "$wpadFile" ]]; then echo "missing"
			elif grep --quiet "PROXY" "$wpadFile"; then echo "enabled"
			elif grep --quiet "DIRECT" "$wpadFile"; then echo "disabled"
			else echo "invalid"
			fi
				EOF
			)" || return
	done
}

proxyWpadConfigure()
{
	local operation="$1"
	local src="$(CloudGet "$HOME/$(ConfigGet "confDir")/proxy/wpad.dat.$operation")"

	# validate
	[[ ! -f "$src" ]] && { ScriptErr "WPAD configuration file '$src' does not exist"; return 1; }
	[[ ! -f "$wpadFile" ]] && { ScriptErr "local web deployment directory does not exist"; return 1; }

	# deploy
	cp "$src" "$wpadFile" && inst ApacheSync
}

# vars

proxyVarsUsage()
{ 
	echot "Usage: $(ScriptName) proxy vars
Configure shell proxy variables.

	-e, --enable		set variables if a proxy server is specified, otherwise unset them
	-d, --disable		unset proxy vasriables
	-s, --status		show the status of the proxy variables"
}

proxyVarsCommand() { [[ ! $action ]] && action="enable"; proxyVars${action^}; }
proxyVarsDisable() { proxyVarsShow; }
proxyVarsEnable() { proxyVarsShow "$(getProxyServer)"; }

# proxyVarsShow [server] - show proxy variables for the specified server, if server is not specified proxy variables are unset
proxyVarsShow()
{
	local proxyServer="$1"

	if [[ $proxyServer ]]; then
		echo "export {$proxyVars}=\"http://$proxyServer\"; eval export {$noProxyVars}=\"$(ConfigGetCurrent "NoProxy")\""
	else
		echo "unset {$allProxyVars}"
	fi
}

proxyVarsStatus()
{
	if (( $(export | grep -i 'proxy=\"http' | wc -l) > 1 )); then
		if [[ $verbose ]]; then
			export | grep "$(echo "$allProxyVars=" | sed 's/,/=\\|/g')"
		else
			echo "enabled"
		fi
	else
		echo "disabled"
	fi
}

#
# vars commands
#

varsUsage() { echot "Usage: $(ScriptName) vars [dns|proxy] [-u|--update]\nVariable commands."; }
varsArgStart() { unset -v update; }
varsOpt() { [[ "$1" == @(--update|-u) ]] || return; update="--update"; }
varsArgEnd() { [[ ! $update ]] && return; quiet="--quiet" currentUpdateCommand; }

varsCommand()
{
	local NETWORK="$(UpdateGetForce "network")" NETWORK_GATEWAY="$(UpdateGetForce "network_gateway")"
	ScriptReturn "NETWORK" "NETWORK_GATEWAY"
}

varsUsage() { echot "Usage: $(ScriptName) vars dns [NETWORK|domain]\nShow DNS variable for the specified or current network."; }

varsDnsArgStart() { unset -v network; }
varsDnsArgs() {	[[ ! $1 ]] && return; ScriptArgGet "network" -- "$@"; }

varsDnsCommand()
{
	# network
	if [[ ! $network ]]; then network="$(nameCached)"
	elif [[ "${network,,}" == "domain" ]]; then network="$(GetDomain)"
	fi

	# variables
	local NETWORK_DNS_BASE_DOMAIN="$(ConfigGet "${network}DnsBaseDomain")"
	local NETWORK_DNS_DOMAIN="$(ConfigGet "${network}DnsDomain")"
	local NETWORK_DNS1="$(ConfigGet "${network}Dns1")"
	local NETWORK_DNS2="$(ConfigGet "${network}Dns2")"
	local NETWORK_DNS_SEARCH="$(ConfigGet "${network}DnsSearch")"
	ScriptReturn "NETWORK_DNS_BASE_DOMAIN" "NETWORK_DNS_DOMAIN" "NETWORK_DNS1" "NETWORK_DNS2" "NETWORK_DNS_SEARCH"
}

varsProxyUsage() { echot "Usage: $(ScriptName) vars proxy\nShow current proxy server variables."; }
varsProxyCommand() { proxyVarsEnable; }

#
# VPN vommands
#

vpnUsage() { echot "Usage: $(ScriptName) workgroup on|off|status
VPN commands."; }

vpnArgStart()
{
	IsPlatform win || { EchoErr "network: VPN is only implemented for Windows"; return 1; }
	gp="$P/Palo Alto Networks/GlobalProtect/PanGPA.exe"
	wg="$P/WireGuard/wireguard.exe"
}

vpnCommand() { vpnStatusCommand; }

vpnStatusCommand()
{
	if [[ -f "$gp" ]]; then
		"$gp"
	elif [[ -f "$wg" ]]; then
		"$wg"
	else
		rasdial.exe
	fi
}

vpnOnCommand()
{	
	if [[ -f "$gp" ]]; then
		"$gp"
	elif [[ -f "$wg" ]]; then
		elevate RunScript start "$wg" /installtunnelservice "$P/WireGuard/Data/Configurations/$HOSTNAME.conf.dpapi"
	else
		rasdial.exe "vpn-$(ConfigGet "network")" "$USER" "$(credential get secure default)" || return
	fi
	currentUpdateCommand || return
}

vpnOffCommand()
{
	if [[ -f "$gp" ]]; then
		"$gp"
	elif [[ -f "$wg" ]]; then
		elevate "$wg" /uninstalltunnelservice "$HOSTNAME"
	else
		rasdial.exe "vpn-$(ConfigGet "network")" /disconnect || return
	fi
	currentUpdateCommand || return
}

#
# timeout commands
#

timeoutUsage() { echot "Usage: $(ScriptName) current timeout [get|set](get)\nGet or set the network host timeout."; }
timeoutCommand() { timeoutGetCommand; }
timeoutGetCommand() { [[ $quiet ]] && return; echo "The network host timeout is $(AvailableTimeoutGet) milliseconds."; }

timeoutArgStart() { unset -v timeout; timeoutDefault="$(ConfigGet "hostTimeout")"; }
timeoutSetUsage() { echot "Usage: $(ScriptName) current timeout set TIMEOUT|default\nSet the network host timeout to the specified number of milliseconds, or to the default ($timeoutDefault)."; }
timeoutSetArgs() { [[ "${1,,}" == "default" ]] && { timeout="$timeoutDefault"; ((++shift)); return; } ; ScriptArgGet --integer "timeout" -- "$@"; }
timeoutSetCommand() { doLog && echo "Setting the availablility timeout to $timeout."; AvailableTimeoutSet $timeout; }

#
# service commands
#

serviceUsage() { echot "Usage: $(ScriptName) service current list
macOS network service commands."; }

serviceArgStart() { unset -v detail; }

serviceOpt()
{
	case "$1" in
		-d|--detail) detail="--detail";;
		*) return 1;;
	esac
}

serviceCommand() { usage; }

serviceCurrentUsage()
{
	echot "Usage: $(ScriptName) service current
List the connected network services.  Services are listed in the preferred order (the order of use).
	
	-d,	--detail			show detailed information in the format service|interface|mac"
}

serviceCurrentCommand()
{
	serviceCurrent | uniq && return
	ScriptErr "unable to find the current network service"
	return 1
}

serviceCurrent()
{
	local gotService

	while read -r line; do

		# get the service and network interface
    local service=$(echo "$line" | awk -F  "(, )|(: )|[)]" '{print $2}')
    local interface=$(echo "$line" | awk -F  "(, )|(: )|[)]" '{print $4}')
    [[ ! $interface ]] && continue

    # get interface detail
    interfaceDetail="$(ifconfig "$interface" 2>/dev/null)"
    ! echo "$interfaceDetail" | ${G}grep --quiet 'status: active' && continue

    # show the service information
    gotService="true"
    mac=$(echo "$interfaceDetail" | awk '/ether/{print $2}')
    [[ $detail ]] && echo "$service|$interface|$mac" || echo "$service"

	done <<< "$(networksetup -listnetworkserviceorder | grep 'Hardware Port')"

	[[ $gotService ]]
}

serviceListUsage()
{
	echot "Usage: $(ScriptName) service list
List all network services.  Services are listed in the preferred order (the order of use).  Inactive services have a * prefix.

	-d,	--detail			show detailed information in the format service|nameservers"
}

serviceListCommand()
{
	[[ $detail ]] && { serviceListDetail; return; }
	networksetup -listallnetworkservices | ${G}tail --lines=+2
}

serviceListDetail()
{
	local service services; IFS=$'\n' ArrayMakeC services network service list || return
	for service in "${services[@]}"; do
		service="$(echo "$service" | ${G}sed 's/^*//')"
		local dns="$(networksetup -getdnsservers "$service" |& grep -v "^There aren" | grep -v "disabled")"
		echo "$service:${dns:-empty}"
	done
}

#
# watch commands
#

watchUsage() { echot "Usage: $(ScriptName) watch\nWatch for network changes."; }

watchCommand()
{
	local configuredNetwork currentNetwork

	ip monitor address |\
	while read line; do
		[[ "$line" =~ "inet " ]] || continue

		header "Network Change"		
		line="$(echo "$line" | tr -s " ")"
		log3 "line=$line"

		# get action (up or down)
		local action="$(echo "$line" | cut -d" " -f1)"
		[[ "$action" == "Deleted" ]] && action="down" line="$(echo "$line" | cut -d" " -f2-)" || action="up"

		# get IP
		local ip="$(echo "$line" | cut -d" " -f4 | cut -d"/" -f1)"

		# get adapter
		local adapter="$(echo "$line" | cut -d" " -f2)"
		IsPlatform win && { adapter="$(GetAdapterName "$ip")" || adapter="$(echo "$line" | cut -d" " -f2)"; }

		echo "Adapter $adapter has gone $action with IP address $ip"

		# update network
		if currentNetwork="$(network current find)"; then
			configuredNetwork="$(NetworkCurrent)"
			log3 "configuredNetwork='$configuredNetwork' currentNetwork='$currentNetwork'"
			if [[ "$configuredNetwork" != "$currentNetwork" ]]; then
				echo "The network has changed from '$configuredNetwork' to '$currentNetwork'..."
				NetworkCurrentUpdate --force || ScriptErr "unable to update the current network"
			fi
		else
			ScriptErr "unable to get current networks"
		fi
		oldNetworks="$newNetworks"

	done
}

#
# workgroup commands
#

workgroupUsage() { echot "Usage: $(ScriptName) workgroup name|set\nSAMBA workgroup commands."; }
workgroupCommand() { workgroupNameCommand; }

workgroupNameCommand()
{ 
	if IsPlatform win; then
		net.exe config workstation | grep "Workstation domain" | RemoveCarriageReturn | awk '{ print $3; }'
	elif [[ -f "/etc/samba/smb.conf" ]]; then
		cat "/etc/samba/smb.conf" | grep -i "^[ 	]*workgroup[ 	]*=[ 	s]*" | cut -d "=" -f 2 | sed 's/ //g'
 	else
		echo "unknown"
	fi 
}

workgroupSetArgs() { [[ $1 ]] && ScriptArgGet "new" -- "$@"; return 0; }

workgroupSetCommand()
{
	local current="$(network workgroup name)"
	[[ ! $new ]] && { read -p "Enter new workgroup: " new; echo; }

	[[ ! $force && "$current" == "$new" ]] && return

	echo "The current workgroup is $current, setting the workgroup to $new..."

	if [[ -f "/etc/samba/smb.conf" ]]; then
		sudoc sed -i "s/^[        ]*workgroup[    ]*=.*$/workgroup = ${new}/" "/etc/samba/smb.conf" || return
	fi

	if IsPlatform win; then
		RunLog RunScript --elevate --pause-error -- powershell.exe Add-computer -WorkgroupName "$new" || return
	fi
	
	return 0
}

#
# helper
#

doLog() { [[ ! $brief && ! $quiet ]]; } # return true if output should be logged
domain() { UpdateGetForce "network_domain"; }
getProxyServer() { canProxy && UpdateGetForce "ProxyServer"; }
getProxyServerApt() { canProxyApt && UpdateGetForce "ProxyServer"; }
canProxyApt() { canProxy && isAptInstalled && ! grep --quiet "$(GetNetworkDnsBaseDomain)" "/etc/apt/sources.list"; } # canProxyApt - APT proxy not needed if using an internally hosted source

# name - return the current network name
name()
{ 
	# return the cached network name if exists
	local name; name="$(UpdateGet "network")" && [[ $name ]] && { echo "$name"; return; }

	# no network name identified, try and update it
	network current update --quiet || return
	name="$(UpdateGet "network")" && [[ $name ]] && { echo "$name"; return; }

	# unable to identify the network
	ScriptErr "unable to identify the current network"
	return 1
}

nameCached() { UpdateGetForce "network"; }

# canProxy - return true if we can use a proxy on the current network 
canProxy()
{
	# no proxy needed for external.  Other checks can include
	# - hostname: "$HOSTNAME" != "<host name>"
	# - domain: "$(domain)" != "<domain name>"
	# - "$(GetDnsSearch)" != "<DNS search sufix>"
	[[ "$(nameCached)" != "external" ]]
}

# getServersFromConfig NETWORK TYPE - get servers of the specified type for the specified network from configuration, 
# i.e "getServers hagerman lb" would look for the hagermanLbServers configuration variable
getServersFromConfig()
{
	local network="$1" type="$2"
	ConfigGet "${network}$(UpperCaseFirst "$type")Servers"
}

isAptInstalled() { [[ -d "/etc/apt" ]]; }

# defaultService=PING parseServer SERVER - SERVER format is [DESCRIPTION@]HOST_OR_IP[:SERVICE], i.e. hagerman:10.10.10:DNS
parseServer()
{
	local server="$1"
	host="$(GetSshHost "$server")"
	service="$(GetSshPort "$server")"; service="${service:-$defaultService}"; service="${service,,}"
	description="$(GetSshUser "$server")"; description="${description:-$host}"
}

ScriptRun "$@"

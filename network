#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script color || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) adapter|conf|current|cache|center|dns|domain|find|gui|hosts|internet|ip|profile|proxy|run|service|timeout|validate|vars|vpn|watch|workgroup
Network commands."
}

init() 
{
	defaultCommand="center"

	wpadFile="/srv/apache-web/htdocs/autoproxy/wpad.dat"
	
	adapterKey='HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Network???'
	profileKey='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles/'

	proxyServerDefaultPort="3128"
	proxyVars="http_proxy,https_proxy,ftp_proxy,HTTP_PROXY,HTTPS_PROXY,FTP_PROXY"
	noProxyVars="no_proxy,NO_PROXY"	
	allProxyVars="$proxyVars,$noProxyVars"
	aptFile="/etc/apt/apt.conf.d/proxy"	

	checkUrl4="http://www.msftconnecttest.com/connecttest.txt"
	checkUrl6="http://ipv6.msftncsi.com/connecttest.txt"
	checkUrlResult="Microsoft Connect Test"

	networkCache="${NETWORK_CACHE:-network}" networkCacheOld="${NETWORK_CACHE_OLD:-network-old}"
}

#
# commands
#

runCommand() { ssh "$1" 'source /etc/profile; '"${@:2}"''; }
centerCommand() {	! IsPlatform win && return; start control.exe /name Microsoft.NetworkAndSharingCenter; }
cacheCommand() { IsAvailable "$1" || return; net use '\\'$1'\ipc$' >& /dev/null; }
guiCommand() { ! IsPlatform win && return; rundll32.exe shell32.dll,Control_RunDLL ncpa.cpl; }

#
# adapter commands
#

adapterUsage() { echot "Usage: $(ScriptName) adapter [edit|exists|list|name|vars](list)\nNetwork adapter commands."; }
adapterCommand() { adapterListCommand; }

adapterEditCommand() { registry edit "$adapterKey"; }

adapterExistsUsage() { echot "Usage: $(ScriptName) adapter exists\nReturn true if the network adapter exists."; }
adapterExistsArgs() { ScriptArgGet "name" -- "$@"; }
adapterExistsCommand() { adapterCheck "$name"; }

#
# adapter list command
#

adapterListUsage() { echot "Usage: $(ScriptName) adapter list [detail]\nList network adapters."; }
adapterListCommand() { adapterList; }

adapterList()
{
	! IsPlatform win && return

	# format "Ethernet adapter NAME:" and "Wireless LAN adapter NAME:"
	ipconfig.exe /all | RemoveCarriageReturn |
		grep "^[A-Z].* adapter " |					# include adapter names
		sed 's/.* adapter //' |							# remove text up to " adapter "
		grep -v "Local Area Connection*" | 	# ignore wireless hotspots with the name "Local Area Connection" - https://superuser.com/questions/1580417/what-is-microsoft-wi-fi-direct-virtual-adapter-used-for
		cut -d":" -f1 | sort
}

#
# adapter list detail command
#

adapterListDetailUsage() { echot "Usage: $(ScriptName) adapter list detail [NAME]\nList network adapter detail."; }
adapterListDetailArgs() { (( ! $# )) && return; ScriptArgGet "name" -- "$@"; }
adapterListDetailCommand() { if [[ $name ]]; then adapterListDetail "$name"; else adapterListDetailAll; fi; }

# adapterListDetail NAME - list detail for the specific network adapter
adapterListDetail()
{
	local name="$1"; adapterCheck "$name" || return

	ipconfig.exe /all | RemoveCarriageReturn |
		sed -n '/^[A-Z].* adapter '"$name"':/,/[A-Z].* adapter /p' |	# get text between NAME and next adapter 
		grep --extended-regexp --invert-match "^[A-Z].* adapter" | 	# remove adapter lines
		grep "\S" |																									# remove empty lines
		sed 's/^[ ]*//g' |																					# remove leading spaces
		sed 's/\. //g' | tr -s " " | sed 's/[ ]*:[ ]*/=/g'					# make key=value pairs
}

# adapterListDetailAll - list detailed information for all network adapters
adapterListDetailAll()
{
	! IsPlatform win && return
	powershell.exe Get-NetAdapter | RemoveCarriageReturn | RemoveEmptyLines | ${G}tail --lines=+3
}

#
# adapter name command
#

adapterNameArgs() { ScriptArgGet "old" -- "$@" && shift && ScriptArgGet "new" -- "$@"; }

adapterNameCommand()
{ 
	! IsElevated && { RunScript --elevate -- network adapter name "$old" "$new"; return; }
	powershell.exe Rename-NetAdapter -Name \"$old\" -NewName \"$new\"
}

#
# adapter vars command
#

adapterVarsUsage()
{
	echot "Usage: $(ScriptName) adapter vars NAME|show
Return network adapter information in variables.

	-a,	--all			add all information (slower)"
}

adapterVarsArgStart() { unset -v all; ipVarsArgStart && vars=(name description linkSpeed ifIndex linkStatus "${vars[@]}" defaultGateway mac); }
adapterVarsArgs() { [[ "${commandNames[2]}" == "show" ]] && return; ScriptArgGet "name" -- "$@"; }
adapterVarsCommand() { adapterVars "$name"; }
adapterVarsShowCommand() { echo -n "${vars[@]}"; }

adapterVarsOpt()
{
	case "$1" in
		-a|--all) all="--all";;
		*) return 1;;
	esac
}

# adapterVars NAME - return adapter information in variables
adapterVars()
{
	local name="$1" description linkSpeed ifIndex linkStatus cidr ip mask network broadcast defaultGateway mac

	# validate adapter
	adapterCheck "$name" || return

	# get information
	info="$(adapterListDetail "$name")"

	# adapter
	local description; description="$(echo "$info" | grep "^Description=" | cut -d"=" -f2-)"

	if [[ $all ]]; then
		allInfo="$(adapterListDetailAll | grep "^$name " | cut -c 72- | tr -s " " | RemoveSpaceFront)"
		linkStatus="$(echo "$allInfo" | cut -d" " -f2 | LowerCase)"
		ifIndex="$(echo "$allInfo" | cut -d" " -f1)"
		linkSpeed="$(echo "$allInfo" | cut -d" " -f4-)"
	else
		ifIndex="$(route.exe print | grep "...$description" | cut -d"." -f1 | RemoveSpace)"
	fi

	# IPv4
	ip="$(echo "$info" | grep "^IPv4 Address=" | cut -d"=" -f2 | cut -d'(' -f1)"
	mask="$(echo "$info" | grep "^Subnet Mask=" | cut -d"=" -f2)"
	defaultGateway="$(echo "$info" | grep "^Default Gateway=" | cut -d"=" -f2)"
	setIpVars "$ip" "$mask" || return

	# other
	mac="$(echo "$info" | grep "^Physical Address=" | cut -d"=" -f2 | tr '-' ':' | LowerCase)"

	ScriptReturn "${vars[@]}"
}

# adapterCheck NAME - return true if the adapter exists
adapterCheck()
{
	local name="$1"
	adapterList | grep --quiet "^${name}$" && return
	ScriptErrQuiet "adapter '$name' does not exist"
} 

#
# conf
#

confUsage() { echot "Usage: $(ScriptName) conf cloud-init|netplan|NetworkManager|status|systemd-networkd\nNetwork configuration."; }
confCommand() { usage; }

confStatusUsage() { echot "Usage: $(ScriptName) status\nShow installed network configuration methods.  Use --verbose for detailed information about each enabled network method."; }

confStatusCommand()
{
	# general
	if [[ $verbose ]]; then
		header "general"	
		os info -w=network --detail || return # | sed 's/network: //g' | sed 's/ //g' | sed 's/(IPv6/ (IPv6/'
	fi

	# programs
	local what
	for what in cloudInit netplan networkManager systemd-networkd; do
		if ${what}IsInstalled; then
			if [[ $verbose ]]; then
				${what}Status || return
			else
				${what}Desc || return
			fi
		fi
	done
}

#
# conf - cloud-init
#

confCloud-initUsage() { echot "Usage: $(ScriptName) conf cloud-init disable|enable|IsEnabled|IsInstalled|status\ncloud-init network configuration."; }
confCloud-initArgStart() { cloudInitVars; }
confCloud-initCommand() { usage; }
confCloud-initIsInstalledCommand() { cloudInitIsInstalled; }
confCloud-initIsEnabledCommand() { cloudInitIsEnabled; }
confCloud-initStatusCommand() { cloudInitStatus; }

confCloud-initDisableCommand()
{
	cloudInitValidate	|| return
	[[ ! -f "$disableFile" || $force ]] && { echo "network: {config: disabled}" | sudo ${G}tee "$disableFile" > /dev/null || return; }
	[[ -f "$enableFile" ]] && { sudoc rm "$enableFile" || return; }
	return 0
}

confCloud-initEnableCommand()
{
	cloudInitValidate	|| return
	
	if [[ ! -f "$enableFile" || $force ]]; then
		cat <<-EOF | sudoc ${G}tee "$enableFile" > /dev/null || return
			# This file is generated from information provided by the datasource.  Changes
			# to it will not persist across an instance reboot.  To disable cloud-init's
			# network configuration capabilities, write a file
			# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
			# network: {config: disabled}
			network:
			    ethernets:
			        eth0:
			            dhcp4: true
			            dhcp6: true
			            optional: true
			    version: 2
		EOF
	fi

  [[ -f "$disableFile" ]] && { sudoc rm "$disableFile" || return; }

	return 0
}

cloudInitDesc() { echo "cloud-init"; }
cloudInitIsInstalled() { cloudInitVars && [[ -d "$baseDir" ]]; }
cloudInitIsEnabled() { [[ ! -f "$disableFile" ]]; }
cloudInitValidate() { cloudInitIsInstalled && return; ScriptErrQuiet "cloud-init is not installed"; return 1; }
cloudInitVars() { baseDir="/etc/cloud"; enableFile="$baseDir/cloud.cfg.d/50-cloud-init.yaml" disableFile="$baseDir/cloud.cfg.d/99-disable-network-config.cfg"; }

cloudInitStatus()
{
	cloudInitValidate || return
	! cloudInitIsEnabled && return
	header "cloud-init"
	echo "  enabled=$(cloudInitIsEnabled && echo "true" || echo "false")"
}

#
# conf - Netplan
#

confNetplanUsage() { echot "Usage: $(ScriptName) conf netplan apply|dhcp|dynamic|edit|IsInstalled|renderer|static|status\nNetplan commands."; }
confNetplanArgStart() { netplanVars; }
confNetplanCommand() { usage; }
confNetplanApplyUsage() { echot "Usage: $(ScriptName) conf netplan apply\nApply the NetPlan configuration."; }
confNetplanApplyCommand() { sudoc netplan apply; }
confNetplanEditUsage() { echot "Usage: $(ScriptName) conf netplan edit\nEdit the network configuration file '$(GetFileName "$currentFile")'."; }
confNetplanEditCommand() { sudoc nano "$currentFile"; }
confNetplanRendererUsage() { echot "Usage: $(ScriptName) conf netplan renderer\nReturn the current network render, NetworkManager or networkd."; }
confNetplanRendererCommand() { netplanRenderer; }
confNetplanStatusCommand() { netplanStatus; }

confNetplanDhcpUsage() { echot "Usage: $(ScriptName) conf netplan dhcp enable|disable|status 4|6\nNetplan DHCP configuration."; }
confNetplanDhcpCommand() { usage; }
confNetplanDhcpEnableCommand() { usage; }
confNetplanDhcpStatusCommand() { netplanFileValidate && ListMake " " $(netplanDhcpDesc 4) $(netplanDhcpDesc 6); }
confNetplanDhcpEnable4Command() { netplanDhcpEnable 4; }
confNetplanDhcpEnable6Command() { netplanDhcpEnable 6; }
confNetplanDhcpDisableCommand() { usage; }
confNetplanDhcpDisable6Command() { netplanDhcpDisable 4; }
confNetplanDhcpDisable6Command() { netplanDhcpDisable 6; }

confNetplanMacArgStart() { unset -v generateMac; }

confNetplanMacOpt()
{
	case "$1" in
		--generate-mac|-gm) generateMac="--generate-mac";;
		*) return 1;;
	esac
}

confNetplanMacGet()
{
	if [[ $generateMac ]]; then
		MacGenerate
	else
		GetAdapterMacAddress "$interface"
	fi
}

# confNetplanMacWarning - display a warninmg if the MAC address is changed.   Return 0 to apply the change, non-zero otherwise.
confNetplanMacWarning()
{
	# return if the MAC address is not changed
	[[ ! $generateMac ]] && return

	# display the warning
	echo "MAC address has been changed to '$mac'.   Please update DHCP reservations before applying the change."

	# if not prompting do not apply the change
	if [[ $noPrompt ]]; then
		echo "To apply this change run 'netplan apply'.  This will disconnect the network."
		return 1
	fi

	# ask if we should apply the change
	ask "This will disconnect the network.  Do you want to make this change now"
}

confNetplanDynamicUsage() { echot "Usage: $(ScriptName) conf netplan dynamic\nConfigure a dynamic IP address."; }
confNetplanDynamicArgStart() { confNetplanMacArgStart "$@"; }
confNetplanDynamicOpt() { confNetplanMacOpt "$@"; }

confNetplanDynamicCommand()
{
	netplanValidate || return

	# return if no changes
	local file="$dynamicFile"
	[[ -f "$file" && ! $force && ! $generateMac ]] && return

	# get configuration
	local interface; interface="$(GetInterface)" || return
	local renderer; renderer="$(netplanRenderer)" || return
	local ipAddress6Token; ipAddress6Token="$(Ipv6Token "$ipAddress4")" || return
	local mac; mac="$(confNetplanMacGet)" || return

	# update configuration
	cat <<-EOF | sudoc ${G}tee "$file" > /dev/null || return
		network:
		  version: 2
		  ethernets:
		    $interface:
		      renderer: $renderer
		      match:
		        name: $interface # required for systemd-networkd
		      macaddress: $mac
		      dhcp4: true
		      dhcp6: true
		      ipv6-address-token: "$ipAddress6Token" # IPv4 address
	EOF
	sudo chmod go-r "$file" || return

	# cleanup and apply
	netplanCleanup "$staticFile" && netplanApply
}

confNetplanStaticUsage() { echot "Usage: $(ScriptName) conf netplan static\nConfigure a static IP address using the existing IP configuration."; }
confNetplanStaticArgStart() { confNetplanMacArgStart "$@"; }
confNetplanStaticOpt() { confNetplanMacOpt "$@"; }

confNetplanStaticCommand()
{
	netplanValidate || return

	# return if no changes
	local file="$staticFile"
	[[ -f "$file" && ! $force && ! $generateMac ]] && return

	# get configuration
	local renderer; renderer="$(netplanRenderer)" || return
	local defaultGatway; defaultGatway="$(GetDefaultGateway)" || return
	local dnsSearch; dnsSearch="$(GetDnsSearch "${globalArgs[@]}" | sed "s/ /,/g")" || return
	local dnsServers; dnsServers="$(GetDnsServers4 | sed "s/ /,/g")" || return
	local interface; interface="$(GetInterface)" || return
	local ipAddress4; ipAddress4="$(GetIpAddress4)" || return
	local subnetNumber; subnetNumber="$(GetSubnetNumber)" || return
	local ipAddress6Token; ipAddress6Token="$(Ipv6Token "$ipAddress4")" || return
	local mac; mac="$(confNetplanMacGet)" || return

	# validate IPv4
	! IsIpAddress4 "$defaultGatway" && { ScriptErr "the default gateway '$defaultGatway' is not a valid IPv4 address"; return 1; }
	! IsIpAddress4 "$ipAddress4" && { ScriptErr "the IPv4 address '$ipAddress4' is not a valid IPv4 address"; return 1; }
	! IsNumeric "$subnetNumber" && { ScriptErr "the subnet number '$subnetNumber' is not a valid IPv4 subnet number"; return 1; }

	# update configuration
	cat <<-EOF | sudoc ${G}tee "$file" > /dev/null || return
		network:
		  version: 2
		  ethernets:
		    $interface:
		      renderer: $renderer
		      match:
		        name: $interface # required for systemd-networkd
	        macaddress: $mac
		      dhcp4: false
		      dhcp6: true
		      ipv6-address-token: "$ipAddress6Token" # IPv4 address
		      addresses:
		        - $ipAddress4/$subnetNumber
		      routes:
		        - to: default
		          via: $defaultGatway
		      nameservers:
		          addresses: [$dnsServers]
		          search: [$dnsSearch]
	EOF
	sudo chmod go-r "$file" || return

	# cleanup and apply
	netplanCleanup "$dynamicFile" && netplanApply
}

netplanDesc() { echo "netplan"; }
netplanIsEnabled() { netplanIsInstalled; }
netplanIsInstalled() { netplanVars && InPath netplan; }
netplanValidate() { netplanIsInstalled && return; ScriptErrQuiet "Netplan is not installed"; return 1; }

# netplanCleanup [FILE] - cleanup old configuration
netplanCleanup()
{
	# cleanup old file
	local file="$1"
	[[ $file && -f "$file" ]] && { sudoc rm -f "$file" || return; }

	# disable old configuration files
	local file files=("$baseDir/01-network-manage-all.yaml" "$baseDir/50-cloud-init.yaml")
	for file in "${files[@]}"; do [[ -f "$file" ]] && { sudoc rm "$file" || return; }; done

	# disable cloud-init DHCP
	cloudInitIsInstalled && { network conf cloud-init disable || return; }

	return 0
}

netplanApply()
{
	# display a warning if the MAC will change and return if we are not applying it now
	confNetplanMacWarning || return 0

	# apply the change
	if [[ $noPrompt ]]; then
		sudoc netplan apply || return
	else
		sudoc netplan try || return
	fi
	
	sleep 2
}

netplanDhcp()
{
	if [[ -f "$staticFile" ]]; then printf "static"
	elif [[ -f "$dynamicFile" ]]; then printf "dynamic"
	else printf "unknown"
	fi
}

netplanDhcpDesc() { netplanDhcpGet "$1" && printf "dhcp$1"; return 0; }
netplanDhcpGet() { netplanFileValidate && sudoc cat "$currentFile" | grep "dhcp$1:" | head -1 | qgrep "true"; }
netplanDhcpEnable() { netplanFileValidate && sudoc sed -i "s/dhcp$1: false/dhcp$1: true/" "$currentFile"; }
netplanDhcpDisable() { netplanFileValidate && sudoc sed -i "s/dhcp$1: true/dhcp$1: false/" "$currentFile"; }

netplanFileValidate()
{
		netplanValidate && [[ -f "$currentFile" ]] && return
		ScriptErr "netplan is not configured properly ('$baseDir' is missing '$(GetFileName "$dynamicFile")' or '$(GetFileName "$staticFile")')" "$1"
}

netplanRenderer()
{
	if service running NetworkManager --quiet; then printf "NetworkManager"
	elif service running network-manager --quiet; then printf "NetworkManager"
	elif service running systemd-networkd --quiet; then printf "networkd"
	elif [[ $quiet ]]; then echo "unknown"
	else ScriptErrQuiet "could not find a Netplan renderer"; return 1
	fi
}

netplanStatus()
{
	netplanValidate || return
	! netplanIsEnabled && return
	header "Netplan"
	echo "renderer=$(quiet="--quiet" netplanRenderer)"
	echo "dhcp=$(netplanDhcp): $(confNetplanDhcpStatusCommand)"
}

netplanVars()
{
	baseDir="/etc/netplan"
	dynamicFile="$baseDir/01-network-manage-all-dynamic.yaml"
	staticFile="$baseDir/01-network-manage-all-static.yaml"

	if [[ -f "$dynamicFile" ]]; then currentFile="$dynamicFile"
	elif [[ -f "$staticFile" ]]; then currentFile="$staticFile"
	else currentFile=""
	fi
}

#
# conf NetworkManager commands
#

confNetworkmanagerUsage() { echot "Usage: $(ScriptName) conf NetworkManager IsEnabled|IsInstalled|status\nNetworkManager commands."; }
confNetworkmanagerCommand() { usage; }
confNetworkmanagerIsEnabledCommand() { networkManagerIsEnabled; }
confNetworkmanagerIsInstalledCommand() { networkManagerIsInstalled; }
confNetworkmanagerStatusCommand() { networkManagerStatus; }

networkManagerDesc() { echo "NetworkManager"; }
networkManagerIsEnabled() { networkManagerIsInstalled && { service running NetworkManager --quiet || service running network-manager --quiet; }; }
networkManagerIsInstalled() { InPath nmcli; }

networkManagerStatus()
{
	! networkManagerIsEnabled && return
	header "NetworkManager"
	sudoc nmcli connection show netplan-$(GetInterface) | grep -E "method|IP4|DHCP4|IP6|DHCP6" | grep -v -E "proxy|dhcp=|\.ROUTE\[" | sed 's/ //g' | sed 's/:/=/'
	return 0
}

#
# conf systemd-networkd commands
#

confSystemd-networkdUsage() { echot "Usage: $(ScriptName) conf systemd-networkd IsEnabled|IsInstalled|status\nsystemd-networkd commands."; }
confSystemd-networkdCommand() { usage; }
confSystemd-networkdIsEnabledCommand() { systemd-networkdIsEnabled; }
confSystemd-networkdIsInstalledCommand() { systemd-networkdIsInstalled; }
confSystemd-networkdStatusCommand() { systemd-networkdStatus; }

systemd-networkdDesc() { echo "systemd-networkd"; }
systemd-networkdIsEnabled() { systemd-networkdIsInstalled && service running systemd-networkd;  }
systemd-networkdIsInstalled() { ResolveCtlInstalled; }

systemd-networkdStatus()
{
	! systemd-networkdIsEnabled && return
	header "systemd-networkd"
	resolvectl status | grep -E "mode:" | tr -s " " | sed 's/^ //' | sed 's/: /=/'
	resolvectl status $(GetInterface) | grep -E "Current DNS Server|DNS Servers|DNS Domain" | tr -s " " | sed 's/^ //' | sed 's/: /=/'
	return 0
}

#
# current commands
#

currentUsage() { echot "Usage: $(ScriptName) current config|find|info|ls|status|update|validate\nCurrent network commands."; }
currentCommand() { usage; }
currentStatusUsage() { echot "Usage: $(ScriptName) current status\nStatus of the current network."; }
currentStatusCommand() { currentStatus; }
currentValidateUsage() { echot "Usage: $(ScriptName) current info name validate\nValidate a current network is configured."; }
currentValidateCommand() { nameValidate; }

currentStatus()
{
	echo "network=$(name)"
	echo "timeout=$(AvailableTimeoutGet) ms"
	hilight "Proxy status..."; proxyStatusCommand || return
}

currentPrefix()
{
	local prefix; prefix="$(ConfigGetCurrent "NetworkPrefix")"
	[[ $prefix ]] && { echo "$prefix"; return; }
	ScriptErr "unable to determine the IPv6 prefix for the current network"
}

currentPrefixLength()
{
	local prefix; prefix="$(ConfigGetCurrent "NetworkPrefixLength")"
	[[ $prefix ]] && { echo "$prefix"; return; }
	ScriptErr "unable to determine the IPv6 prefix length for the current network"
}

# common options

currentUsageOther() { currentUsageBrief; currentUsageConfig; currentUsageTimeout; }
currentArgStartOther() { currentArgStartBrief && currentArgStartConfig && currentArgStartTimeout; }
currentOptOther() { currentOptBrief "$@" || currentOptConfig "$@" || currentOptTimeout "$@"; }

currentUsageBrief() { EchoWrap "	-b,	--brief			show brief status messages (for use with app script)"; }
currentArgStartBrief() { unset -v brief; }
currentOptBrief() { [[ "$1" == @(-b|--brief) ]] || return; brief="--brief"; }

currentUsageConfig() { EchoWrap "	-c,	--config		update network configuration for hashi, python, proxy"; }
currentArgStartConfig() { unset -v config; }
currentOptConfig() { [[ "$1" == @(-c|--config) ]] || return; config="--config"; }

currentUsageTimeout() { EchoWrap "	-t, --timeout		$(ScriptOptTimeoutUsage)"; }
currentArgStartTimeout() { ScriptOptTimeoutArgStart; }
currentOptTimeout() { [[ "$1" =~ --timeout|--timeout=*|-t|-t=* ]] || return; ScriptOptTimeout "$@"; }

currentOptNetwork()
{
	case "$1" in
		-n|--network|-n=*|--network=*)
			ScriptOptGet "networkArg" "$@" || return
			networkArg="${networkArg,,}"
			currentLs | qgrep "^${networkArg}$" || { ScriptErr "'$networkArg' is not a valid network"; exit 1; }
			;;
		*) return 1;;
	esac
}

#
# current config command
#

currentConfigUsage() { echot "Usage: $(ScriptName) current config [dns|hashi|python|proxy|all](all)\nConfigure applications for the current network."; }
currentConfigArgEnd() { network="$(nameValidate)"; }
currentConfigCommand() { currentConfigAll "$network"; }
currentConfigDnsCommand() { updateDns "$network"; }
currentConfigHashiCommand() { updateHashi "$network"; }
currentConfigPythonCommand() { updatePython "$network"; }
currentConfigProxyCommand() { updateProxy "$network"; }

# currentConfig network - update configuration based on the new network
# - update DNS first to enable name resolution so we can find servers on the new network
currentConfigAll()
{
	local network="$1"
	doLog && header "Configuring '${network^}' Network"
	[[ $brief && ! $quiet ]] && printf "network."
	{ updateDns "$network" && updateHashi "$network" && updatePython "$network" && updateProxy "$network"; } || return
	doLog && { hilight "Network status..."; force= currentStatus || return; }
	return 0
}

# updateDns NETWORK
updateDns()
{
	local network="$1"
	doLog && hilight "Updating DNS for the '$network' network..."
	RunPlatform updateDns && updateHosts "$network"
}

# updateDnsWsl NETWORK - update /etc/resolv.conf for the current network
updateDnsWsl()
{
	local src="$DATA/setup/resolv.conf.$network" dest="/etc/resolv.conf"
	[[ ! -f "$src" ]] && src="$DATA/setup/resolv.conf.external"
	[[ ! -f "$src" ]] && return
	cmp --quiet "$src" "$dest" >& /dev/null && return

	# update
	[[ $brief ]] && printf "resolv.conf."
	[[ ! $quiet ]] && echo "Updating resolv.conf..."
	log1 "copying '$src' to '$dest'"
	sudoc cp "$src" "$dest"
}

# updateDnsMac NETWORK - update /etc/resolver/custom for the current network
updateDnsMac()
{
	local src="$DATA/setup/$network.resolver" dest="/etc/resolver/custom"
	! [[ -f "$src" ]] && { sudoc rm -f "$dest"; return 0; }
	cmp --quiet "$src" "$dest" >& /dev/null && return

	# update	
	[[ $brief ]] && printf "resolver."
	doLog && echo "Updating resolver..."
	sudoc ${G}mkdir --parents "/etc/resolver" && sudoc cp "$src" "$dest"
}

# updateHosts NETWORK - update /etc/hosts for the current network
updateHosts()
{
	local network="$1"
	local src="$DATA/setup/hosts.$network" dest="/etc/hosts"

	# no hosts file for the current network - restore original /etc/hosts
	if [[ ! -f "$src" ]]; then
		[[ -f "$dest.orig" ]] && ! cmp --quiet "$dest.orig" "$dest" && { sudoc cp "$dest.orig" "$dest" || return; }
		return 0
	fi

	# current network hosts are already in /etc/hosts
	[[ ! $force ]] && qgrep --ignore-case "^# $network" "$dest" && return

	# backup original /etc/hosts file if needed
	[[ ! -f "$dest.orig" ]] && { sudoc cp "$dest" "$dest.orig" || return; }

	# add hosts for this network
	[[ $brief ]] && printf "hosts."
	[[ ! $quiet ]] && echo "Updating hosts..."
	{ echo; cat "$src"; } | sudoc ${G}tee --append "$dest" > /dev/null
}

# updateHashi NETWORK - update HashiCorp tool configuration
updateHashi()
{
	local network="$1"
	doLog && hilight "Updating HashiCorp tools for the '$network' network..."
	HashiConf -ff "${globalArgs[@]}"
}

# updateProxy NETWORK
updateProxy()
{
	local network="$1"
	doLog && hilight "Updating proxy configuration for the '$network' network..."
	proxyUpdate || return
}

# updatePython NETWORK
updatePython()
{
	local network="$1"
	local src="$DATA/setup/pip.conf.$network" dest="$HOME/.config/pip/pip.conf"

	# src does not exists
	if [[ ! -f "$src" ]]; then
		[[ -f "$dest" ]] && { rm "$dest" || return; }
		return 0
	fi

	# return if src and dest are the same
	cmp --quiet "$src" "$dest" >& /dev/null && return

	# update
	[[ $brief ]] && printf "pip.conf."
	doLog && hilight "Updating Python for the '$network' network..."
	log1 "copying '$src' to '$dest'"
	local dir="$(GetFilePath "$dest")"; [[ ! -d "$dir" ]] && { ${G}mkdir --parents "$dir" || return; }
	cp "$src" "$dest" || return
}

#
# current find command
#

currentFindUsage() { echot "Usage: $(ScriptName) current find\nFind the primary network.\n\n$(currentUsageOther)"; }
currentFindArgStart() { currentArgStartOther; }
currentFindOpt() { currentOptOther "$@"; }
currentFindCommand() { findNetwork; }

#
# current info
#

currentInfoUsage() { echot "Usage: $(ScriptName) current info [domain|name|prefix](name)\nCurrent network information."; }
currentInfoCommand() { name; }
currentInfoDomainUsage() { echot "Usage: $(ScriptName) current info domain\nThe name of the current domain."; }
currentInfoDomainCommand() { GetDomainCached; }
currentInfoNameUsage() { echot "Usage: $(ScriptName) current info name [cached]\nThe name of the current network.  Returns a cached value within specified intervals unless --force is specified."; }
currentInfoNameCommand() { name; }
currentInfoNameCachedUsage() { echot "Usage: $(ScriptName) current info name cached\nThe cached name of the current network."; }
currentInfoNameCachedCommand() { nameCached; }
currentInfoPrefixUsage() { echot "Usage: $(ScriptName) current info prefix [length]\nIPv6 prefix of the current network."; }
currentInfoPrefixCommand() { currentPrefix; }
currentInfoPrefixLengthCommand() { currentPrefixLength; }

#
# current ls command
#

currentLsUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) current ls
List configured networks.

	-a,	--available			find all configured networks that are available"
}

currentLsArgStart() { unset -v available; }

currentLsOpt()
{
	case "$1" in
		--available|-a) available="--available";;
		*) return 1;;
	esac
}

currentLsCommand()
{
	[[ $available ]] && { currentLsAvailable; return; }
	currentLs
}

currentLs() { echo "external"; ConfigGet networks | sed 's/,/\n/g' | cut -d"@" -f1 | sort | uniq; }

currentLsAvailable()
{
	local network networks=(); StringToArray "$(ConfigGet "networks")" "," networks
	local current="$(RunLog network find --all --service=dns "${networks[@]}" "${globalArgs[@]}" --quiet)" || { echo "external"; return; }

	# format - remove suffix after @
	local name names=()
	local host hosts; IFS=$'\n' ArrayMake hosts "$current"
	for host in "${hosts[@]}"; do
		name="$(GetSshUser "$host")" # name of the network (before @)		
		! IsInArray "$name" names && names+=("$name") 
	done

	ArrayDelimit names " "
}

#
# current update command
#

currentUpdateUsage() { echot "Usage: $(ScriptName) current\nUpdate network settings for the current networks.\n\n$(currentUsageOther)"; }
currentUpdateArgStart() { unset -v networkArg; currentArgStartOther; }
currentUpdateOpt() { currentOptOther "$@" && return; currentOptNetwork "$@" && return; }

currentUpdateCommand()
{
	# get current network
	local network; network="$(UpdateGetForce "$networkCache")" || return
	local networkOld="${network:-unknown}"

	# network was specified 
	if [[ $networkArg ]]; then
		[[ ! $force && "$networkArg" == "$network" ]] && return # return if the new network if it is the same as the current network
		currentUpdateFinish "$networkArg" "$networkOld"; return # finish update
	fi

	# return if the network was recently updated and we pass quick checks
	if [[ ! $networkArg && $network ]] && ! UpdateNeeded "$networkCache" && updateCheckQuick; then
		return
	fi

	# check if the current network is the same (the default gateway is the same and the DNS server is valid)
	if [[ ! $force ]] && updateCheckGateway && updateCheckDns; then
		updateDns "$network" || return # ensure DNS configuration is correct
		doLog && echo "Current network '$network' has not changed"
		UpdateDone "$networkCache" || return
		return
	fi

	# network has changed - determine the new network configuration
	doLog && { header "Determining Network"; echo "Existing network is ${network:-unknown}"; }
	doLog && printf "network..."; network="$(findNetwork)" || return

	# finish update
	currentUpdateFinish "$network" "$networkOld"
}

currentUpdateFinish()
{
	local network="$1" networkOld="$2"

	# configure the new network if needed
	[[ $config ]] && { currentConfigAll "$network" || return; }

	# save the current and old networks
	local network="$1" networkOld="$2"; UpdateSet "$networkCacheOld" "$networkOld" && UpdateSet "$networkCache" "$network";	

}

# updateCheckDns - check if we have at least one DNS server that is valid for the current network
updateCheckDns()
{
	local server; servers=(); StringToArray "$(GetDnsServers)" " " servers
	for server in "${servers[@]}"; do
		validateDnsServer "$network" "$server" && return
	done
	doLog && echo "The DNS server '$server' for the current network '$network' is not valid"
	return 1
}

updateCheckGateway()
{
	local oldGateway; oldGateway="$(UpdateGetForce "network-gateway")" || return
	local gateway; gateway="$(GetDefaultGateway --force)" || return
	UpdateSet "network-gateway" "$gateway" || return
	[[ "$oldGateway" == "$gateway" ]] && return

	doLog && echo "The current gateway '$gateway' for the current network '$network' is not valid"
	return 1
}

updateCheckQuick() { RunPlatform updateCheckQuick; }
updateCheckQuickWsl() { [[ -f "/etc/resolv.conf" ]] && updateCheckDns; } # WSL resolv.conf is reset on WSL restart

# findNetwork - find the first active network from the networks specified in the networks configuration variable 
findNetwork()
{
	local network networks=(); StringToArray "$(ConfigGet "networks")" "," networks
	network="$(RunLog network find --service=dns --timeout=$timeout $brief "${networks[@]}" "${globalArgs[@]}")" || { echo "external"; return; }
	GetSshUser "$network" # return the name of the network (before @)
}

# validateDnsServer NETWORK SERVER - validate the DNS server is correct for the specified network
validateDnsServer()
{
	local network="$1" server="$2"
	local networks=(); StringToArray "$(ConfigGet "networks")" "," networks	# array of network:DNS_IP

	# check if the DNS server is an IP address
	if ! IsIpAddress "$server"; then
		log1 "the DNS server '$server' is not a valid IP address"
		return 1
	fi

	# if the DNS server is not in the list of known networks, the network must be external
	! IsInArray --wild ".*@$server" networks && { [[ "$network" == "external" ]]; return; }

	# the DNS server is the list of known networks, so network@DNS_IP must be in the list of known networks
	IsInArray --wild "$network@$server.*" networks
}

#
# DNS commands
#

dnsUsage() { echot "Usage: $(ScriptName) dns flush|prefer\nDNS commands."; }

dnsCommand() { usage; }

dnsFlushCommand() 
{ 
	case "$PLATFORM_OS" in
		linux) ! ResolveCtlInstalled && return; ResolveCtlValidate && resolvectl flush-caches;;
		mac) sudoc dscacheutil -flushcache && sudo killall -HUP mDNSResponder;;
		win) RunWin ipconfig.exe /flushdns >& /dev/null;;
	esac
}

#
# DNS prefer commands
#

dnsPreferUsage() { echot "Usage: os dns prefer ipv4|ipv6|status\nPrefer IPv4 or IPv6 DNS server.  Changes require 'service restart systemd-resolved'."; }
dnsPreferCommand() { usage; }

dnsPreferIpv4Command() { RunPlatform dnsPreferIpv4; }
dnsPreferIpv4Debian() { dnsPreferDebian ""; }

dnsPreferIpv6Command() { RunPlatform dnsPreferIpv6; }
dnsPreferIpv6Debian() { dnsPreferDebian "#"; }

dnsPreferDebianInit() { file="/etc/gai.conf" line="precedence ::ffff:0:0/96  100" lineQuoted="$(QuoteForwardslashes "$line")"; }

dnsPreferDebian()
{
	local want="$1" noWant; [[ "$want" == "" ]] && noWant="#"
	local file line lineQuoted; dnsPreferDebianInit
	qgrep "^${want}${line}$" "$file" && return
	sudoc sed -i 's/^'"$noWant$lineQuoted"'$/'"$want$lineQuoted"'/' "$file" && service restart systemd-resolved
}

dnsPreferStatusCommand() { RunPlatform dnsPreferStatus; }

dnsPreferStatusDebian()
{
	local file line lineQuoted; dnsPreferDebianInit
	qgrep "^${line}$" "$file" && echo "IPv4" || echo "IPv6"
}

#
# domain commands
#

domainUsage() { echot "Usage: $(ScriptName) domain [dns|name|joined](name)
Domain commands."; }

domainCommand() { domainNameCommand; }

#
# domain dns commands
#

domainDnsUsage() { echot "Usage: $(ScriptName) domain dns\nReturn the DNS name of the domain."; }
domainDnsCommand() { RunPlatformOs "domainDns"; }
domainDnsMac() { dsconfigad -show | grep "^Active Directory Domain" | cut -d"=" -f2 | RemoveSpaceTrim; }
domainDnsWin() { cmd.exe /c 'if defined USERDNSDOMAIN echo %USERDNSDOMAIN%' 2> /dev/null | RemoveCarriageReturn | RemoveNewline | LowerCase; }

#
# domain name commands
#

domainNameUsage() { echot "Usage: $(ScriptName) domain name\nReturn the name of the domain."; }

domainNameCommand()
{ 
	local domain; domain="$(RunPlatformOs domainName)" || return
	{ [[ ! $domain ]] || IsLocalHost "$domain"; } && domain="$(ConfigGet "defaultDomain")"
	echo "$domain"
}

domainNameMac() { domainDnsMac | GetWord - 2 .; return 0; }
domainNameWin() { RunWin cmd.exe /c 'if defined USERDOMAIN echo %USERDOMAIN%' 2> /dev/null | RemoveCarriageReturn | RemoveNewline | LowerCase; }

#
# domain joined commands
#

domainJoinedUsage() { echot "Usage: $(ScriptName) domain joined\nReturn true if we are joined to a domain."; }
domainJoinedCommand() { RunPlatformOs domainJoined; }
domainJoinedLinux() { return 1; }
domainJoinedMac() { [[ $(domainNameMac) ]]; }
domainJoinedWin() { ! IsLocalHost "$(domainNameWin)"; }

#
# find commands
#

findUsage()
{
	echot "Usage: $(ScriptName) find [SERVER...]
Find servers that exposes a specific service (simple service discovery).  Returns the server found.

- SERVER format is [DESCRIPTION@]HOST_OR_IP[:SERVICE][-DOMAIN], i.e. butare:10.10.10:DNS
- DESCRIPTION is used for information messages while checking
- SERVICE is a numeric port, or one of:
		ping - performs a UDP ping
		dns - checks port 53 and performs a DNS lookup
  	nfs - checks port 111
  	smb - checks port 445
  	ssh - checks port 22, or the port the port defined in the SSH configuration for the host
  	wg - checks the WireGuard UDP port for the current network, defaults to 51820
- DOMAIN: if specified only check the service if the system is in the specified domain

	-a,	--all				find all servers instead of the first
	-b,	--brief			show brief status messages
	-s, --service		the service to use if one is not specified, defaults to PING
	-t, --timeout 	$(ScriptOptTimeoutUsage)
	-T, --type TYPE	find the first available server for the type specified, i.e. 'network server wireguard --service=wg'
	-u, --udp				check the port using UDP instead of TCP"
}

findArgStart() { unset -v all brief; check="IsAvailablePort" defaultService="PING"; ScriptOptTimeoutArgStart; }

findOpt()
{
	case "$1" in
		--all|-a) all="--all";;
		--brief|-b) brief="--brief";;
		--service|--service=*|-s|-s=*) ScriptOptGet "defaultService" "service" "$@";;
		--timeout|--timeout=*|-t|-t=*) ScriptOptTimeout "$@";;
		--type|--type=*|-T|-T=*) ScriptOptGet "type" "$@";;
		--udp|-u) check="IsAvailablePortUdp";;
		*) return 1;;
	esac
}

findArgs() { servers=( "$@" ); (( shift+=$# )); return 0; }

findCommand(){ [[ $type ]] && { findType; return; }; findDo; }

findDo()
{	
	[[ ! $brief && ! $quiet ]] && PrintErr "checking..."

	local server descriptions=() results=()

	# look for available server
	log1 "looking for servers: $(ArrayShow servers)"

	for server in "${servers[@]}"; do
		local domain host service description; parseServer "$server" || return
		log3 "server=$server description=$description host=$host service=$service domain=$domain"

		# add the host to the description if verbose logging
		[[ "$description" != "$host" && $verbose ]] && description="$description ($host)"
		
		# already checked this server
		IsInArray "$description" descriptions && continue

		# check for a valid service
		isValidService "$service" || { ScriptErr "'$service' is not a valid service"; return; }
		
		# check domain
		if [[ $domain ]] && ! IsInDomain "$domain"; then
			log1 "system is not in domain '$domain'"
			continue
		fi

		# logging
		if [[ $verbose ]]; then
			PrintErr "$description..."
			IsAvailable "$host" $timeout && PrintErr "available..."
			PrintErr "$service..."
		elif doLog; then
			PrintErr "$description..."
		fi

		# check the service
		if findCheck "$host" "$service" "$description"; then
			doLog && PrintErr "found"
			descriptions+=($description) results+=($server)
			[[ ! $all ]] && { doLog && EchoErr; echo "$server"; return 0; }
			doLog && PrintErr "..."
		fi
		
	done
 
	# status
 	if [[ $results ]]; then
 		doLog && EchoErrEnd "done"	
 		ArrayDelimit results $'\n'
 	else
		doLog && EchoErrEnd "none available"	
		return 1
	fi
}

findCheck()
{
	local host="$1" service="$2" description="$3"
	local ip; ip="$(GetIpAddress "$host")" || return

	# port number aliases
	case "$service" in
		nfs) service="111";;
		smb) service="445";;
		ssh) service="$(SshHelper config get "$host" port)";;
	esac

	case "$service" in
		dns) 
			IsAvailablePort "$ip" 53 $timeout || return
			InPath dig && { dig @$host bogus +time=2 +tries=1 >& /dev/null || return; } # some DNS servers require 2
			return 0
			;;

		ping)
			IsAvailable "$ip" $timeout
			;;

		# WireGuard UDP port
		wg)
			local port="$(ConfigGetCurrent WireguardPort)"; [[ ! $port ]] && port="51820"
			IsAvailablePortUdp "$host" "$port" $timeout
			;;

		# numeric port (TCP, or UDP if the --udp option was specified)
		*) 
			"$check" "$host" "$service"
			;;
			
	esac
}

findType()
{
	local network="$(name)"

	# get servers of the specified type
	local server servers=(); StringToArray "$(ConfigGetCurrentServers "$type")" "," servers
	if [[ ! $servers ]]; then
		doLog && EchoErr "no '$type' services defined for '$network' network"
		return 1
	fi

	# find an active server
	server="$(findDo)" || return

	# return HOST:SERVICE of the server (DESCRIPTION@HOST:SERVICE)
	RemoveBefore "$server" "@" 
}

isValidService() { IsInteger "$1" || [[ "$1" == @(dns|ping|nfs|smb|ssh|wg) ]]; }

# parseServer SERVER - SERVER format is [DESCRIPTION@]HOST_OR_IP[:SERVICE][-DOMAIN], i.e. butare:10.10.10:DNS-butare
parseServer()
{
	local server="$1"

	# parse [DESCRIPTION@]HOST_OR_IP[:SERVICE-DOMAIN] - follows SSH name format
	host="$(GetSshHost "$server")"
	description="$(GetSshUser "$server")"; description="${description:-$host}"
	service="$(GetSshPort "$server")"; service="${service:-$defaultService}"; service="${service,,}"

	# parse [SERVICE]-[DOMAIN]
	local parts; StringToArray "$service" "-" parts
	service="${parts[0]}" domain="${parts[1]}"
}

#
# hosts command
#

hostsUsage() { EchoWrap "Usage: $(ScriptName) hosts [--wsl]
Edit the local system hosts file."; }

hostsArgStart() { unset -v wsl; }

hostsOpt() 
{
	case "$1" in
		-w|--wsl) wsl="true";;
		*) return 1
	esac
}

hostsCommand()
{
	local file="/etc/hosts"; IsPlatform win && [[ ! $wsl ]] && file="$WIN_ROOT/Windows/system32/Drivers/etc/hosts"
	sudoe "$file"
}

#
# internet command
#

internetUsage() { echot "Usage: $(ScriptName) internet address|detail|host|provider [PORT|active]
Internet commands.  If no port is specified lookup our current active internet address.
If a numeric port is specified, lookup the internet address for the specified WAN port (usually 1 or 2).

	address						get the internet address
	host							get the hostname
	provider [short]	get the provider name"
}

internetArgs()
{
	[[ $1 ]] && { ScriptArgGet --integer "port" -- "$@"; }
	return 0
}

internetCommand() { usage; }

internetAddressCommand() 
{
	[[ ! $port ]] && { getActiveIp; return; }

	# get internet IP address using the UniFi Controller API
	if UniFiController ApiAvailable --quiet; then
		local devices; getDevices && getIp; return
	fi

	# get internet IP address using the router's ifconfig command
	local interface
	case "$port" in
		1) interface="eth2";; # WAN 1, Comcast
		2) interface="ppp1";; # WAN 2, Century Link
		*) ScriptErr "port '$port' is not valid"; return 1;;
	esac

	RunLog SshHelper connect router -- ifconfig "$interface" |& grep "^[ ]*inet addr:" | tr -s " " | cut -d" " -f 3 | cut -d: -f 2
}

internetDetailCommand()
{
	[[ ! $port ]] && port="1"

	local devices; getDevices || return
	local isActive; [[ "$(getIp)" == "$(getActiveIp)" ]] && isActive="true"

	header "Basic Information"
	echo "hostname="$(DnsResolve "$(getIp)" "${globalArgs[@]}")
	echo "address="$(getIp)
	echo "active=$([[ $isActive ]] && echo "true" || echo "false")"

	header "Geographic Information"
	local geoPort; [[ "$port" == "2" ]] && geoPort="2"
	echo "$devices" | jq '.data[] | select(.name == "router").geo_info.WAN'$geoPort''

	if [[ $isActive ]]; then
		header "Speedtest Status"
	 	echo "$devices" | jq '.data[] | select(.name == "router")."speedtest-status"'
	 fi
}

internetHostCommand()
{
	local address; address="$(internetAddressCommand)" || return
	DnsResolve "$address" "${globalArgs[@]}"
}

internetProviderCommand()
{
	local address; address="$(internetAddressCommand)" || return
	whois "$address" | grep "OrgTechName" | head -1 | cut -d: -f2 | RemoveSpaceFront
}

internetProviderShortCommand() { internetProviderCommand | GetWord - 1 | LowerCase; }

getActiveIp() { curl --silent https://myipv4.p1.opendns.com/get_my_ip | jq '.ip' | RemoveQuotes; }
getDevices() { devices="$(UniFiController api "/stat/device")"; }
getIp() { echo "$devices" | jq '.data[] | select(.name == "router").wan'$port'.ip' | RemoveQuotes; }

#
# ip commands
#

ipUsage() { echot "Usage: $(ScriptName) ip broadcast|cidr|mask|network|vars\nIP address commands."; }
ipCommand() { usage; }

ipBroadcastUsage() { echot "Usage: $(ScriptName) ip broadcast [IP MASK]|CIDR\nGet the broadcast (last) address for the IP.  CIDR format is IP/N."; }
ipBroadcastArgs() { ScriptArgGet "ip" -- "$@" || return; shift; (( ! $# )) && return; ScriptArgGet "mask" -- "$@"; }
ipBroadcastCommand() { getBroadcast "$ip" "$mask"; }

ipMaskUsage() { echot "Usage: $(ScriptName) ip mask N\nGet the subnet mask for a subnet with N network bits."; }
ipMaskArgs() { ScriptArgGet "n" -- "$@"; }
ipMaskCommand() { nToMask "$n"; }

ipNetworkUsage() { echot "Usage: $(ScriptName) ip network [IP MASK]|CIDR\nGet the network (first) address for the IP.  CIDR format is IP/N."; }
ipNetworkArgs() { ScriptArgGet "ip" -- "$@" || return; shift; (( ! $# )) && return; ScriptArgGet "mask" -- "$@"; }
ipNetworkCommand() { getNetwork "$ip" "$mask"; }

#
# IP CIDR commands
#

ipCidrUsage() { echot "Usage: $(ScriptName) ip cidr make|split\nIP CIDR commands."; }
ipCidrCommand() { usage; }

ipCidrMakeUsage() { echot "Usage: $(ScriptName) ip cidr make [network] [IP MASK](current)\nMake a CIDR (IP/N) from the IP address and subnet mask."; }
ipCidrMakeArgs() { (( ! $# )) && { ip="$(GetIpAddress)" && mask="$(GetSubnetMask)"; return; }; ScriptArgGet "ip" -- "$@" && shift && ScriptArgGet "mask" -- "$@"; }
ipCidrMakeCommand() { cidrMake "$ip" "$mask"; }

ipCidrMakeNetworkUsage() { echot "Usage: $(ScriptName) ip cidr make network IP MASK\nMake a CIDR (IP/N) for the network (first) IP address of the IP and subnet mask."; }
ipCidrMakeNetworkCommand() { local networkIp; networkIp="$(getNetwork "$ip" "$mask")" && cidrMake "$networkIp" "$mask"; }

ipCidrSplitUsage() { echot "Usage: $(ScriptName) ip cidr split CIDR\nSplit a CIDR (IP/N) and return the IP address and subnet mask."; }
ipCidrSplitArgs() { ScriptArgGet "cidr" -- "$@"; }
ipCidrSplitCommand() { cidrSplit "$cidr"; }

# isCidr CIDR - return true if CIDR is a CIDR (IP/N)
isCidr() { [[ "$1" =~ / ]]; }

# cidrMake IP MASK - make a CIDR (IP/N) from an IP address and subnet mask
cidrMake()
{
	local ip="$1" mask="$2"; log1 "ip=$ip mask=$mask"
	echo "$ip/$(maskToN "$mask")"
}

# cidrSplit CIDR - split a CIDR (IP/N) to an IP address and subnet mask, sets ip and mask variables
cidrSplit()
{
	local cidr="$1"
	local ip="$(GetWord "$cidr" 1 "/")" n="$(GetWord "$cidr" 2 "/")" mask
	{ ! IsIpAddress4 "$ip" || ! IsInteger "$n"; } && { ScriptErrQuiet "'$cidr' is not a valid CIDR (IP/N)"; return 1; }
	mask="$(nToMask "$n")"
	log1 "ip=$ip mask=$mask"
	ScriptReturn ip mask
}

#
# IP vars command
#

ipVarsUsage() { echot "Usage: $(ScriptName) ip vars show|[IP MASK]|CIDR\nGet the CIDR, ip, mask, broadcast, and network for the IP.  CIDR format is IP/N."; }
ipVarsArgStart() { vars=(cidr ip mask network broadcast); }
ipVarsArgs() { [[ "${commandNames[2]}" == "show" ]] && return; ScriptArgGet "ip" -- "$@" || return; shift; (( ! $# )) && return; ScriptArgGet "mask" -- "$@"; }
ipVarsShowCommand() { echo -n "${vars[@]}"; }
ipVarsCommand() { local cidr network broadcast; setIpVars "$ip" "$mask" && ScriptReturn "${vars[@]}"; }

#
# IP helper
#

# getIpArgs [IP MASK]|CIDR - sets ip and mask variables
getIpArgs()
{
	ip="$1" mask="$2"
	isCidr "$ip" && { ScriptEval cidrSplit "$ip"; return; }
	! IsIpAddress4 "$ip" && { ScriptErr "'$ip' is not a valid IP address"; return 1; }	
	! IsIpAddress4 "$mask" && { ScriptErr "'$mask' is not a valid subnet mask"; return 1; }
	return 0
}

# getBroadcast [IP MASK]|CIDR - 192.0.2.0/24 => 192.0.2.255
getBroadcast()
{
	local ip mask; getIpArgs "$@" || return
  local addr="$(ipToInt "$ip")"
  local mask=$((0xffffffff << (32 - $(maskToN "$mask")))); shift
  intToIp "$((addr | ~mask))"
}

# getNetwork [IP MASK]|CIDR - 192.0.2.0/24 => 192.0.2.0
getNetwork()
{
	local ip mask; getIpArgs "$@" || return
  local addr=$(ipToInt "$ip"); shift
  local mask=$((0xffffffff << (32 - $(maskToN "$mask")))); shift
  intToIp $((addr & mask))
}

intToIp()
{
  local ui32="$1" ip n
  for n in 1 2 3 4; do
      ip="$((ui32 & 0xff))${ip:+.}$ip"
      ui32="$((ui32 >> 8))"
  done
  echo "$ip"
}

ipToInt()
{
  local a b c d
  { IFS=. read a b c d; } <<< "$1"
  echo "$(((((((a << 8) | b) << 8) | c) << 8) | d))"
}

maskToN()
{
	local mask="$1"
	local i="$(ipToInt "$mask")" n=0

	while (( i > 0)); do
  	: $(( n+=i&1, i>>=1 ))
	done

	echo "$n"
}

# nToMask N - 24 => 255.255.255.0
nToMask()
{
  local mask="$((0xffffffff << (32 - "$1")))"
  intToIp "$mask"
}

# setIpVars IP MASK
setIpVars()
{
	local ip="$1" mask="$2"
	cidr="$(cidrMake "$ip" "$mask")" || return
	network="$(getNetwork "$ip" "$mask")" || return
	broadcast="$(getBroadcast "$ip" "$mask")" || return
}

#
# profile commands
#

profileUsage() { echot "Usage: $(ScriptName) profile edit|list|set
Network profile commands."; }

profileArgStart() { IsPlatform win && return; EchoErr "network: profile is only implemented for Windows"; return 1; }
profileCommand() { profileListCommand; }

profileEditCommand() { registry edit "$profileKey"; }

profileListCommand()
{
	! IsElevated && { RunScript --elevate network profile list "$@"; return; }

	local key keys name type category; IFS=$'\n' ArrayMake keys "$(registry get "$profileKey")"
	for key in "${keys[@]}"; do
		name="$(registry get "$key/ProfileName" | RemoveCarriageReturn)"
		type="$(registry get "$key/NameType" | RemoveCarriageReturn)"
		category="$(registry get "$key/Category" | RemoveCarriageReturn)"

		case "$type" in
			0x6) type="Wired";;
			0x17) type="VPN";;
			0x47) type="Wireless";;
			0xF3) type="Mobile Broadband";;
		esac

		case "$category" in
			0x0) category="public";;
			0x1) category="private";;
			0x2) category="work";;
		esac

		echo "$name: $category $type"
	done
}

profileSetArgs() { ScriptArgGet "name" -- "$@" && shift; }

# profile set - if there is only one network profile, set it's name and make it a private network
profileSetCommand()
{
	! IsElevated && { RunScript --elevate network profile set "$name"; pause; return; }

	local numProfiles="$(registry get "$profileKey" | RemoveEmptyLines | wc -l)"

	(( $numProfiles > 1 )) && { EchoErr "Cannot set the profile if more than one exists"; return 1; }

	local key="$(registry get "$profileKey" | RemoveEmptyLines | head -1)"
	registry set "$key/ProfileName" REG_SZ "$name" || return
	registry set "$key/Category" REG_DWORD "1" || return # private
}

#
# proxy commands
#

proxyUsage()
{ 
	echot "Usage: $(ScriptName) proxy [check|config|server|status|update|validate](status)
Network proxy server commands."
}

proxyCommand() { proxyStatusCommand; }

proxyValidateUsage() { echot "Usage: $(ScriptName) proxy validate\nCheck the proxy server and enable or disable local configuration.  Useful if the proxy configuration is not in sync."; }
proxyValidateCommand() { proxyValidate "proxyConfigAll"; }
proxyValidate() { local command="$1"; proxyUpdate || return; proxyEnableValidate && command+="Enable" || command+="Disable"; "$command"; }

#
# proxy check command
#

proxyCheckUsage() { echot "Usage: $(ScriptName) proxy check [server]\nReturn true if the proxy server is needed on the current network and usable."; }
proxyCheckCommand() { proxyCheck; }

proxyCheck()
{
	local server="$1"; [[ ! $server ]] && server="$(proxyServerNetwork)"
	doLog && PrintErr "proxy...";

	# return if the proxy server is not specified
	[[ $server ]] || { doLog && PrintErr "${RED}not specified${RESET}"; return 1; }

	# return if the proxy server is not available
	IsAvailablePort "$server" $timeout || { doLog && EchoErrEnd "${RED}not available${RESET}"; return 1; }
	doLog && PrintErr "available..."

	# check proxy for IPv4 and IPv6
	proxyCheckStatus 4 "$server" && proxyCheckStatus 6 "$server" && { doLog && EchoErrEnd "working"; return 0; }
	doLog && EchoErrEnd "not working"; return 1
}

# proxyCheckStatus 4|6 SERVER - return true if IPv4|6 is supported on the server
proxyCheckStatus()
{
	local v="$1" server="$2"
	{ [[ "$v" == "6" ]] && IsDomainRestricted; } && return
	! IsIpvSupported $v && return
	doLog && PrintErr "IPv$v..."; proxyCheck$v "$server" && { doLog && PrintErr "ok..."; return 0; }
	doLog && PrintErr "${RED}fail${RESET}..."; return 1
}

# proxyCheck4|6 SERVER - return true  if the proxy server is working for IPv4|6 addresses
proxyCheck4() { proxyCheckDo "$1" "$checkUrl4"; }
proxyCheck6() { proxyCheckDo "$1" "$checkUrl6"; }

# proxyCheckDo SERVER URL - check URL at the proxy server 
# - timeout after 1 second, IPv6 check hangs if IPv6 is disabled at the gateway
proxyCheckDo()
{
	local server="http://$1" url="$2"
	log3 "checking proxy server '$server' using URL '$url', expecting result '$checkUrlResult' (waiting 1 second)"
	[[ "$(RunLog3 curl --silent --proxy "$server" --max-time 1 "$url")" == "$checkUrlResult" ]]
}

#
# proxy config commands
#

proxyConfigUsage()
{ 
	echot "Usage: $(ScriptName) proxy config [all|domain|apt|firefox|os|vars|wpad](all)
Configure applications for the current proxy server configuration.

$(currentUsageBrief)
	-e, --enable		enable the proxy server configuration
	-d, --disable		disable the proxy server configuration
	-s, --status		show the status of the proxy server configuration
	-v, --validate	check if the proxy server is usable and enable or disable the configuration"
}

proxyConfigArgStart() { unset action; currentArgStartBrief; }

proxyConfigOpt() 
{
	currentOptBrief "$@" && return
	case "$1" in
		-d|--disable) action="disable";;
		-e|--enable) action="enable";;
		-s|--status) action="status";;
		-V|--validate) action="validate";;
		*) return 1
	esac
}

proxyConfigCommand() { proxyConfigAllCommand; }

#
# proxy config all command
#

proxyConfigAllUsage() { echot "Usage: $(ScriptName) proxy all\Configure all applications for the current proxy configuration (APT, Firefox, npm, os, vars)."; }
proxyConfigAllCommand() { [[ ! $action ]] && action="status"; proxyConfigAll${action^}; }
proxyConfigAllDisable() { eval "$(proxyConfigVarsEnable)" && proxyConfigAptDisable && proxyConfigFirefoxDisable && proxyConfigNpmDisable && proxyConfigOsDisable && proxyConfigVarsDisable; }
proxyConfigAllEnable() { eval "$(proxyConfigVarsDisable)" && proxyConfigAptEnable && proxyConfigFirefoxEnable && proxyConfigNpmEnable && proxyConfigOsEnable && proxyConfigVarsEnable; }
proxyConfigAllValidate() { eval "$(proxyConfigVarsValidate)" && proxyConfigAptValidate && proxyConfigFirefoxValidate && proxyConfigNpmValidate && proxyConfigOsValidate && proxyConfigVarsValidate; }

proxyConfigAllStatus()
{
	if [[ $verbose ]]; then
		isAptInstalled && { printf "apt="; proxyConfigAptStatus; }
		printf "os="; proxyConfigOsStatus
		printf "variables="; verbose= proxyConfigVarsStatus
		firefoxValidate && { printf "firefox="; proxyConfigFirefoxStatus; }
	else
		isAptInstalled && echo "apt=$(proxyConfigAptStatus)"
		supportOsProxy && echo "os=$(proxyConfigOsStatus)"
		echo "variables=$(proxyConfigVarsStatus)"
		firefoxValidate && echo "firefox=$(proxyConfigFirefoxStatus)"
	fi

	return 0
}

#
# proxy config domain command
#

proxyConfigDomainUsage() { echot "Usage: $(ScriptName) proxy all\nSet proxy configuration required for the domain."; }
proxyConfigDomainCommand() { [[ ! $action ]] && action="status"; proxyConfigDomain${action^}; }
proxyConfigDomainEnable() { proxyConfigDomain "enable"; }
proxyConfigDomainDisable() { proxyConfigDomain "disable"; }
proxyConfigDomainStatus() { proxyConfigDomain "status"; }
proxyConfigDomainValidate() { proxyConfigDomain "validate"; }

# proxyConfigDomain enable|disable|statis|validate - configure proxy for current domain applications
proxyConfigDomain()
{
	local action="${1:-enable}" app apps=(); StringToArray "$(ConfigGet "$(GetDomain)ProxyApps")" "," apps
	for app in "${apps[@]}"; do
		local prefix; [[ "$app" == @(vars) ]] && prefix="ScriptEval"
		$prefix "proxyConfig${app^}${action^}" || return
	done
}

#
# proxy config apt command
#

proxyConfigAptUsage() { echot "Usage: $(ScriptName) proxy config apt\nConfigure APT proxy settings."; }
proxyConfigAptCommand() { [[ ! $action ]] && action="status"; proxyConfigApt${action^}; }
proxyConfigAptDisable() { { ! isAptInstalled || [[ ! -f "$aptFile" ]]; } && return; log1 "proxy disable APT"; sudoc rm "$aptFile"; }
proxyConfigAptValidate() { proxyValidate "proxyConfigApt"; }

proxyConfigAptStatus()
{
	! isAptInstalled && return
	[[ ! -f "$aptFile" ]] && { echo "disabled"; return; }
	echo "enabled"; [[ $verbose ]] && cat "$aptFile"; return 0;
}

proxyConfigAptEnable()
{	
	# return if APT is not installed
	! isAptInstalled && return

	# disable APT proxy if cannot enable the proxy server
	proxyEnableValidate || { proxyConfigAptDisable; return; }

	# return if APT proxy is already enabled
	local server="$(proxyServerGetApt)"
	[[ ! $force ]] && [[ -f "$aptFile" ]] && grep -q "$server" "$aptFile" && return

	# set APT proxy server
	log1 "proxy enable APT"
	echo "Acquire::http::Proxy \"http://$server\";
Acquire::https::Proxy \"http://$server\";" | sudoc tee "$aptFile" >& /dev/null
}

isAptInstalled() { [[ -d "/etc/apt" ]]; }

# isAptProxyNeeded - return true if we need to use an APT proxy
# - APT proxy is not needed if we are using internal sources (that are in our domain.)
isAptProxyNeeded()
{
	isProxyNeeded && isAptInstalled && ! grep --quiet "$(GetNetworkDnsBaseDomain)" "/etc/apt/sources.list"
}

#
# proxy config firefox command
#

proxyConfigFirefoxUsage() { echot "Usage: $(ScriptName) proxy config firefox\nConfigure Firefox proxy settings."; }
proxyConfigFirefoxCommand() { [[ ! $action ]] && action="status"; proxyConfigFirefox${action^}; }
proxyConfigFirefoxDisable() { ! firefoxValidate && return; log1 "proxy disable Firefox"; firefox config set "network.proxy.type" "0" "${globalArgs[@]}"; } # 0=none
proxyConfigFirefoxValidate() { ! firefoxValidate && return; proxyValidate "proxyConfigFirefox"; }

proxyConfigFirefoxEnable()
{
	! firefoxValidate && return

	# disable Firefox proxy if cannot enable the proxy server
	proxyEnableValidate || { proxyConfigFirefoxDisable; return; }

	# enable Firefox proxy - 4=auto
	log1 "proxy enable Firefox"; firefox config set "network.proxy.type" "4" "${globalArgs[@]}"; 
}

proxyConfigFirefoxStatus()
{
	! firefoxValidate && return

	# get Firefox proxy status
	local type; type="$(firefox config get "network.proxy.type" "${globalArgs[@]}")" || return
	[[ ! $type || "$type" == "0" ]] && echo "disabled" || echo "enabled"
	[[ ! $verbose ]] && return

	# type: 0=none, 4=Auto-detect proxy settings for this network, 5=Use system proxy settings
	printf "firefox network.proxy.type=$type"
	case "$type" in
		0) echo " (none)";;
		4) echo " (auto)";;
		""|5) echo " (system)";;
		default) echo " (unknown)";;
	esac
}

#
# proxy config npm command
#

proxyConfigNpmUsage() { echot "Usage: $(ScriptName) proxy config npm\nConfigure npm proxy settings."; }
proxyConfigNpmCommand() { [[ ! $action ]] && action="status"; proxyConfigNpm${action^}; }
proxyConfigNpmEnable() { ! npmValidate && return; log1 "proxy enable npm"; npm config set https-proxy "$HTTPS_PROXY" && npm config set proxy "$HTTPS_PROXY"; }
proxyConfigNpmDisable() { ! npmValidate && return; log1 "proxy disable npm"; npm config set https-proxy "" && npm config set proxy ""; }
proxyConfigNpmValidate() { ! npmValidate && return; proxyValidate "proxyConfigNpm"; }
proxyConfigNpmStatus() { ! NpmValidate && return; [[ $(network proxy get proxy) ]] && "enabled" || "disabled"; }

#
# proxy config os command
#

proxyConfigOsUsage() { echot "Usage: $(ScriptName) proxy config os\nConfigure Operating System proxy settings."; }
proxyConfigOsCommand() { [[ ! $action ]] && action="status"; proxyConfigOs${action^}; }
proxyConfigOsValidate() { proxyValidate "proxyConfigOs"; }

proxyConfigOsStatus() { RunPlatformOs proxyConfigOsStatus; }
proxyConfigOsStatusMac() { proxyConfigOsStatusMacDo "get" | cut -d":" -f2 | RemoveSpaceTrim | LowerCase; }

proxyConfigOsStatusWin()
{
	# determine if connections are being proxied
	local proxyUrl; proxyUrl="$(powershell '[System.Net.WebRequest]::DefaultWebProxy.GetProxy("'$checkUrl4'").AbsoluteUri' | RemoveCarriageReturn)" || return
	[[ "$checkUrl4" == "$proxyUrl" ]] && echo "disabled" || echo "enabled"
	[[ ! $verbose ]] && return

	# get configuration
	# - AutoDetect=Automatic proxy setup, Automatically detect settings=On
	# - AutoConfigIsEnabled=Automatic proxy setup, Use setup script, Edit..., Use setup script=On 
	# - ProxyIsEnabled=Manual proxy setup, Set up..., Use a proxy server=On
	local desc status; status="$(netsh.exe winhttp show advproxy | RemoveCarriageReturn)" || return	
	echo "$status" | grep "AutoDetect" | qgrep "true" && desc+="auto "
	echo "$status" | grep "AutoConfigIsEnabled" | qgrep "true" && desc+="script "
	echo "$status" | grep "ProxyIsEnabled" | qgrep "true" && desc+="manual "
	[[ ! $desc ]] && desc="disabled"
	echo "configuration: $(echo "$desc" | RemoveSpaceTrim)"
}

proxyConfigOsEnable()
{
	# disable OS proxy if cannot enable the proxy server
	proxyEnableValidate || { proxyConfigOsDisable; return; }

	# enable OS proxy
	log1 "proxy enable OS"; RunPlatformOs proxyConfigOsEnable
}

proxyConfigOsEnableMac() { proxyConfigOsStatusMacDo "set" "on"; }
proxyConfigOsEnableWin() { proxyConfigOsStatusWinDo "true" && winResetAutoProxy; }

proxyConfigOsDisable() { log1 "proxy disable OS"; RunPlatformOs proxyConfigOsDisable; }
proxyConfigOsDisableMac() { proxyConfigOsStatusMacDo "set" "off"; }
proxyConfigOsDisableWin() { proxyConfigOsStatusWinDo "false"; }

proxyConfigOsStatusMacDo()
{
	local service; service="$(network service current | ${G}head -1)" || return 
	RunLog2 sudoc networksetup ${1}proxyautodiscovery "$service" $2
} 

proxyConfigOsStatusWinDo()
{
	local result; result="$(RunScript --elevate -- netsh.exe winhttp set advproxy setting-scope=user settings="$(cat <<-EOF
			{\"Proxy\":\"\",\"ProxyBypass\":\"\",\"AutoconfigUrl\":\"\",\"AutoDetect\":$1}
			EOF
		)"
	)" || { ScriptErr "$result"; return 1; }

	log2 "$result"
	return 0
}

# winResetAutoProxy - force reload of autoproxy, reloads the Proxy Auto Configuration (PAC) file
winResetAutoProxy() { netsh.exe winhttp reset autoproxy >& /dev/null; } 

#
# proxy config vars command
#

proxyConfigVarsUsage() { echot "Usage: $(ScriptName) proxy config vars\nConfigure proxy variable settings."; }
proxyConfigVarsCommand() { [[ ! $action ]] && action="status"; proxyConfigVars${action^}; }
proxyConfigVarsDisable() { log1 "proxy disable vars"; echo "unset {$allProxyVars}"; }
proxyConfigVarsValidate() { proxyValidate "proxyConfigVars"; }

proxyConfigVarsEnable()
{
	# disable proxy vars if cannot enable the proxy server
	proxyEnableValidate || { proxyConfigVarsDisable; return; }

	# enable proxy vars
	log1 "proxy enable vars"
	local server="$(proxyServerGet)"
	echo "export {$proxyVars}=\"http://$server\"; eval export {$noProxyVars}=\"$(ConfigGetCurrent "NoProxy")\""
}

proxyConfigVarsStatus()
{
	if (( $(export | grep -i 'proxy=\"http' | wc -l) > 1 )); then
		if [[ $verbose ]]; then
			export | grep "$(echo "$allProxyVars=" | sed 's/,/=\\|/g')"
		else
			echo "enabled"
		fi
	else
		echo "disabled"
	fi
}

#
# proxy config WPAD command
#

proxyConfigWpadUsage() { echot "Usage: $(ScriptName) proxy config wpad\nConfigure Web Proxy Auto-Discovery proxy settings."; }
proxyConfigWpadCommand() { [[ ! $action ]] && action="status"; proxyConfigWpad${action^}; }
proxyConfigWpadEnable() { proxyConfigWpad "enable"; }
proxyConfigWpadDisable() { proxyConfigWpad "disable"; }
proxyConfigWpadValidate() { proxyValidate "proxyConfigWpad"; }

proxyConfigWpadStatus()
{
	! isWpadAvailable && return

	header "WPAD Status"	
	local host hosts; IFS=$'\n' ArrayMakeC hosts GetServers apache-web || return
	for host in localhost "${hosts[@]}"; do
		local file="$(wpadFileGet "$host")"

		# continue if not WPAD directory for localhost
		IsLocalHost "$host" && [[ ! -d $(GetFilePath "$file") ]] && continue

		# logging
		log2 "checking host '$host' file '$file'..."
		(( verboseLevel < 4 )) && printf "$(GetOsName "$host"): "

		# check host
		RunScript "${globalArgs[@]}" --ssh "$host" "$(cat <<-EOF
			if [[ ! -f "$file" ]]; then echo "disabled (wpad.dat missing)"
			elif grep --quiet "PROXY" "$file"; then echo "enabled"
			elif grep --quiet "DIRECT" "$file"; then echo "disabled"
			else echo "invalid (wpad.data is missing PROXY or DIRECT)"
			fi
				EOF
			)" || return
	done
}

proxyConfigWpad()
{
	! isWpadAvailable && return

	local operation="$1"
	local localFile="$(wpadFileGet)"
	local localDir="$(GetFilePath "$localFile")"
	local wpadFile="$HOME/$(ConfigGet "confDir")/proxy/wpad.dat.$operation"

	# validation
	[[ ! -f "$wpadFile" ]] && { ScriptErr "WPAD configuration file '$wpadFile' does not exist"; return 1; }
	[[ ! -d "$localDir" ]] && { ScriptErr "local web deployment directory '$(FileToDesc "$localDir")' does not exist"; return 1; }

	# download the WPAD configuration file
	[[ -f "$wpadFile" ]] && { CloudGet "$wpadFile" || return; }
	log1 "using the WPAD $operation file '$(FileToDesc "$wpadFile")'"

	# copy the new WPAD configuration file to the local file
	sudoc cp "$wpadFile" "$localFile" || return

	# syncrhonize the apache WPAD directories
	apache sync wpad "${globalArgs[@]}" || return

	RunPlatformOs proxyConfigWpadUpdate
}

proxyConfigWpadUpdateWin() { winResetAutoProxy; }

isWpadAvailable() { IsOnNetwork butare; }

#
# proxy server command
#

proxyServerUsage() { echot "Usage: $(ScriptName) proxy server [check|ls](ls)\nProxy server commands."; }
proxyServerCommand() { proxyServerLsCommand; }
proxyServerLsUsage() { echot "Usage: $(ScriptName) proxy server ls\nList active proxy servers."; }
proxyServerLsCommand() { GetAllServers "squid-proxy"; }

#
# proxy server check command
#

proxyServerCheckUsage() { echot "Usage: $(ScriptName) proxy server check [-4|-6] [server](-4)\nCheck proxy server."; }
proxyServerCheckArgStart() { unset -v server; ipv="4"; }
proxyServerCheckArgs() { (( ! $# )) && return; ScriptArgGet "server" -- "$@"; }

proxyServerCheckOpt()
{
	case "$1" in
		-4) ipv="4";;
		-6) ipv="6";;
		*) return 1;;
	esac
}

proxyServerCheckCommand()
{
	[[ ! $server ]] && { server="$(ConfigGetCurrent "ProxyServer")" || return; }
	local port="$(GetSshPort "$server")"; [[ ! $port ]] && server="$server:$proxyServerDefaultPort"
	proxyCheck$ipv "$server"
}

#
# proxy status command
#

proxyStatusUsage() { echot "Usage: $(ScriptName) proxy status [all|what|wpad]\nReturn the proxy server status and configuration"; }

proxyStatusCommand()
{
	local delimiter=" "; [[ $verbose ]] && delimiter="\n"
	[[ $verbose ]] && header "Proxy Server ($(nameCached) network)"

	# general status
	echo -e "$(nameCached) proxy: needed=$(isProxyNeeded && echo "yes" || echo "no")${delimiter}configured=$(isProxyConfigured && echo "yes" || echo "no")"
	
	# proxy server status
	local server="$(proxyServerNetwork)"
	if [[ $server ]]; then
		local desc="proxy=$server"		
		IsIpvSupported 4 && { desc+="${delimiter}IPv4="; proxyCheck4 "$server" && desc+="ok" || desc+="${RED}fail${RESET}"; }
		IsIpvSupported 6 && { desc+="${delimiter}IPv6="; proxyCheck6 "$server" && desc+="ok" || desc+="${RED}fail${RESET}"; }		
		echo -e "$desc"
	fi
		
	# local proxy configuration
	[[ $verbose ]] && header "Proxy Configuration ($(GetHostname))"
	proxyConfigAllStatus || return
	
	return 0
}

proxyStatusAllUsage() { echot "Usage: $(ScriptName) proxy status all\nReturn all proxy configuration (slow)."; }
proxyStatusAllCommand() { proxyStatusCommand && proxyStatusWhatCommand && proxyStatusWpadCommand; }

proxyStatusWhatUsage() { echot "Usage: $(ScriptName) proxy status what\nReturn the proxy server status and configuration from WhatIsMyProxy (slow)."; }

proxyStatusWhatCommand()
{
	local detail="$(curl --silent "http://www.whatismyproxy.com" | ${G}grep Via: | ${G}sed 's/.*Via//' | ${G}sed 's/<br.*//')"
	echo "detected server=$(echo "$detail" | cut -d" " -f3-4)"
}

proxyStatusWpadUsage() { echot "Usage: $(ScriptName) proxy status wpad\nReturn the Web Proxy Auto-Discovery (slow)."; }
proxyStatusWpadCommand() { proxyConfigWpadStatus; }

#
# proxy update command
#

proxyUpdateUsage()
{
	echot "Usage: $(ScriptName) proxy update 
If the proxy server is needed and usable on the current network, update the saved proxy network configuration."

$(currentUsageConfig)
}

proxyUpdateArgStart() { currentArgStartConfig; }
proxyUpdateOpt() { currentOptConfig "$@"; }
proxyUpdateCommand() { proxyUpdate; }

proxyUpdate()
{
	# get old and new proxy server, return if not change
	local oldProxyServer; oldProxyServer="$(UpdateGetForce "network-proxy-server")" || return
	local newProxyServer; isProxyNeeded && { newProxyServer="$(proxyServerNetwork)"; proxyCheck "$newProxyServer" || unset newProxyServer; }

	# return if no change
	[[ ! $force && "$newProxyServer" == "$oldProxyServer" ]] && return
	log2 "proxyUpdate: oldProxyServer='$oldProxyServer' newProxyServer='$newProxyServer'"
	
	# save new proxy server
	UpdateSet "network-proxy-server" "$newProxyServer" || return

	# configure domain applications for the new proxy server
	[[ ! $config ]] && return
	proxyConfigDomain || return
}

#
# proxy helper
#

# isProxyConfigured - proxy server configured
isProxyConfigured() { proxyServerGet >& /dev/null; }

# isProxyNeeded - return true if we need to use a proxy on the current network 
isProxyNeeded()
{
	# no proxy needed for external.  Other checks can include
	# - hostname: "$(GetHostname)" != "<host name>"
	# - domain: "$(domain)" != "<domain name>"
	# - "$(GetDnsSearch)" != "<DNS search sufix>"
	[[ "$(nameCached)" != "external" ]]
}

# proxyEnableValidate - return true if we can enable proxy configuration
proxyEnableValidate()
{
	! isProxyNeeded && { log2 "proxyEnableValidate: proxy server is not needed"; return 1; }
	! isProxyConfigured && { log2 "proxyEnableValidate: proxy server is not configured"; return 1; }
	return 0
}

proxyServerGet() { isProxyNeeded && EchoValidate "$(UpdateGetForce "network-proxy-server")"; }
proxyServerGetApt() { isAptProxyNeeded && EchoValidate "$(UpdateGetForce "network-proxy-server")"; }

# proxyServerNetwork - return the proxy server for the current network
proxyServerNetwork() { ConfigGet "$(nameCached)ProxyServer"; }

#
# validate commands
#

validateUsage()
{
	ScriptUsageEcho "Usage: $(ScriptName) network validate dns|dhcp
Validate the DHCP or DNS service is operational on the specified hosts.

	-4|-6 									use only IPv4 or IPv6
	-H, --host [HOST](all)	$(ScriptOptHostUsage)
	-w, --wait [N](10)			wait for the DNS or DHCP service for the specified number of seconds.  If not specified, defaults to $defaultWaitSeconds seconds"
}

validateArgStart()
{
	unset -v hostArg hostOpt ipv waitSeconds
	defaultWaitSeconds=0; IsPlatform win && ! NmapCanBroadcast && defaultWaitSeconds=2; # dhcptest.exe needs retries
	return 0
}

validateOpt() 
{
	ScriptOptHost "$@" && return

	case "$1" in
		-4) ipv="4";;
		-6) ipv="6";;
		--wait|--wait=*|-w|-w=*) waitSeconds=10; ScriptOptGet --optional --integer "waitSeconds" "wait-seconds" "$@";; 
		*) return 1
	esac
}

validateCommand() { validateAllCommand; }
validateDhcpCommand() { validateHosts "DHCP" $ipv; }
validateDnsCommand() { validateHosts "DNS" $ipv; }

# canValidate dhcp|dns - return true if can validate DHCP or DNS servers
canValidate() { canValidate$(ProperCase "$1"); }
canValidateDhcp() { RunPlatformOs canValidateDhcp || NmapCanBroadcast $quiet; }
canValidateDhcpWin() { InPath dhcptest.exe; }
canValidateDns() { return 0; }

# validateHosts dhcp|dns [4|6](both) - validate DHCP or DNS for the hosts
validateHosts()
{
	local what="$1" ipv="$2"

	canValidate "$what" || return
	printf "Validating ${what^^}..."

	local errors=0 host; [[ ! $hosts ]] && { GetHostsApp "$what" active || return; }
	for host in "${hosts[@]}"; do
		printf "$(RemoveDnsSuffix "$host")..."
		validateHost "$host" "$what" "$waitSeconds" "$ipv" || (( ++errors ))
	done
	echo "done"
	return $errors
}

# validateHost HOST dhcp|dns [WAIT_SECONDS] [4|6](both) - validate DNS or DHCP service on host
validateHost()
{
	local host="$1" what="$2" waitSeconds="${3:-0}" ipv="$4"

	! IsAvailable "$host" && { printf "${RED}not available${RESET}..."; return 1; }
		
	local i
	for (( i=0; i<=waitSeconds; ++i )); do
 		validate$(ProperCase "$what") "$host" $ipv && { printf "ok..."; return; }
 		if [[ $waitSeconds && "$i" < "$waitSeconds" ]]; then
 			read -n 1 -t 1 -s && { echo "${RED}cancelled${RESET}"; return 1; }
 			unset dhcpServerCache
			printf "."
		fi
	done

	printf "${RED}failed${RESET}..."
	return 1
}

# validateDhcp HOST [4|6](both) - validate a DHCPv4 or DHCPv6 server, or both
validateDhcp()
{
	local host="$1" ipv="$2"
	[[ $ipv ]] && { validateDhcp$ipv "$host"; return; }
	validateDhcp4 "$host" && validateDhcp6 "$host"; 
}

# validateDhcp4 HOST - validate a DHCPv4 server
validateDhcp4()
{
	if NmapCanBroadcast --quiet; then 
		[[ ! $dhcpServerCache ]] && dhcpServerCache="$(DhcpServers $quiet)"
		local host="$1"; local hostDns; hostDns="$(DnsResolve "$host" "${globalArgs[@]}")" || return
		echo "$dhcpServerCache" | qgrep "^${hostDns}$"

	elif IsPlatform win && InPath dhcptest.exe; then
		[[ ! $dhcpServerCache ]] && dhcpServerCache="$(dhcptest.exe --bind "$(GetAdapterIpAddress)" --query --wait --timeout 3 2>&1)"
		local ip; ip="$(GetIpAddress "$host")" || return		
		echo "$dhcpServerCache" | qgrep "^Received packet from $ip:"
	else
		ScriptErr "unable to validate DHCP v4 servers '$host'"
		return 1
	fi
}

# validateDhcp6 HOST - validate a DHCPv6 server
validateDhcp6() { :; }

# validateDns HOST [4|6](both) - validate DNS using IPv4 or IPv6, or both
validateDns()
{
	local host="$1" ipv="$2"
	[[ $ipv ]] && { validateDns$ipv "$host"; return; }
	validateDns4 "$host" && validateDns6 "$host"
}

# validateDns4 HOST - validate a DNS server using IPv4
validateDns4()
{
	local host="$1" name="router.$(GetDnsDomain)"; validateDnsCommon || return
	
	# forward lookup 
	nslookup "$name" "$host" >& /dev/null || { log2 "$host IPv4 forward lookup of router.$(GetDnsDomain) failed"; return 1; }

	# reverse lookup
	local ip; ip="$(DnsResolve "$name")" || return
	nslookup "$ip" "$host" >& /dev/null || { log2 "$host reverse lookup of 10.10.100.1 failed"; return 1; }
}

# validateDns6 HOST - validate a DNS server using IPv6
validateDns6()
{
	local host="$1" name="router.$(GetDnsDomain)"; validateDnsCommon || return

	# forward lookup
	# dig -6 -t AAAA +short "router.$(GetDnsDomain)" @host >& /dev/null || { log2 "$host IPv6 forward lookup of router.$(GetDnsDomain) failed"; return 1; }
	
	# reverse lookup
	# nslookup "10.10.100.1" "$host" >& /dev/null || { log2 "$host reverse lookup of 10.10.100.1 failed"; return 1; }
}

# validateDnsCommon - common validations for DNS servers 
validateDnsCommon()
{
	log2 "validating DNS server on '$host' by checking '$name' resolution (ipv=$ipv)"

	# check if the host is available
	HostAvailable "$host" || return

	# check if the DNS server is available on porty 53
	IsAvailablePort "$host" 53 || { log2 "$host is not availble on port 53"; return 1; }
}


#
# vars commands
#

varsUsage()
{
	ScriptUsageEcho "\
Usage: $(ScriptName) vars [dns|proxy]
Variable commands.

$(currentUsageBrief)
$(currentUsageConfig)
	-t, --timeout		$(ScriptOptTimeoutUsage), not used (pass through argument)
	-u, --update		update network settings for the current network"
}

varsArgStart() { unset -v update; currentArgStartOther; }

varsOpt()
{
	currentOptOther "$@" && return
	currentOptNetwork "$@" && return
	case "$1" in
		--update|-u) update="--update";;
		*) return 1
	esac
}

varsArgEnd()
{
	[[ ! $update ]] && return
	quiet="--quiet" currentUpdateCommand
}

varsCommand()
{
	local NETWORK="$(UpdateGetForce "$networkCache")" NETWORK_GATEWAY="$(UpdateGetForce "network-gateway")"
	ScriptReturn "NETWORK" "NETWORK_GATEWAY"
}

varsDnsUsage() { echot "Usage: $(ScriptName) vars dns [NETWORK|domain]\nShow DNS variable for the specified or current network."; }

varsDnsArgStart() { unset -v network; }
varsDnsArgs() { (( ! $# )) && return; ScriptArgGet "network" -- "$@"; }

varsDnsCommand()
{
	# network
	if [[ ! $network ]]; then network="$(nameCached)"
	elif [[ "${network,,}" == "domain" ]]; then network="$(GetDomain)"
	fi

	# variables
	local NETWORK_DNS_BASE_DOMAIN="$(ConfigGet "${network}DnsBaseDomain")"
	local NETWORK_DNS_DOMAIN="$(ConfigGet "${network}DnsDomain")"
	local NETWORK_DNS1="$(ConfigGet "${network}Dns1")"
	local NETWORK_DNS2="$(ConfigGet "${network}Dns2")"
	local NETWORK_DNS_SEARCH="$(ConfigGet "${network}DnsSearch")"
	ScriptReturn "NETWORK_DNS_BASE_DOMAIN" "NETWORK_DNS_DOMAIN" "NETWORK_DNS1" "NETWORK_DNS2" "NETWORK_DNS_SEARCH"
}

varsProxyUsage() { echot "Usage: $(ScriptName) vars proxy\nShow current proxy server variables."; }
varsProxyCommand() { proxyConfigVarsEnable; }

#
# VPN vommands
#

vpnUsage() { echot "Usage: $(ScriptName) vpn on|off|status\nVPN commands."; }

vpnArgStart()
{
	IsPlatform win || { EchoErr "network: VPN is only implemented for Windows"; return 1; }
	gp="$P/Palo Alto Networks/GlobalProtect/PanGPA.exe"
	wg="$P/WireGuard/wireguard.exe"
}

vpnCommand() { vpnStatusCommand; }

vpnHideCommand()
{	
	[[ -f "$gp" ]] && AutoHotKey IsInstalled && { AutoHotKey VpnRun hide; return; }
	return 0
}

vpnOnCommand()
{	
	if [[ -f "$gp" ]]; then
		AutoHotKey IsInstalled && { AutoHotKey VpnRun on; return; }
		"$gp"
	elif [[ -f "$wg" ]]; then
		elevate RunScript start "$wg" /installtunnelservice "$P/WireGuard/Data/Configurations/$(GetHostname).conf.dpapi"
	else
		rasdial.exe "vpn-$(ConfigGet "$networkCache")" "$USER" "$(credential get secure default)" || return
	fi
}

vpnOffCommand()
{
	if [[ -f "$gp" ]]; then
		AutoHotKey IsInstalled && { AutoHotKey VpnRun off; return; }
		"$gp"
	elif [[ -f "$wg" ]]; then
		elevate "$wg" /uninstalltunnelservice "$(GetHostname)"
	else
		rasdial.exe "vpn-$(ConfigGet "$networkCache")" /disconnect || return
	fi
}

vpnStatusCommand()
{
	if [[ -f "$gp" ]]; then
		"$gp"
	elif [[ -f "$wg" ]]; then
		"$wg"
	else
		rasdial.exe
	fi
}

#
# timeout commands
#

timeoutUsage() { echot "Usage: $(ScriptName) current timeout [get|set](get)\nGet or set the network host timeout."; }
timeoutCommand() { timeoutGetCommand; }
timeoutGetCommand() { [[ $quiet ]] && return; echo "The network host timeout is $(AvailableTimeoutGet) milliseconds."; }

timeoutArgStart() { unset -v timeout; timeoutDefault="$(ConfigGet "hostTimeout")"; }
timeoutSetUsage() { echot "Usage: $(ScriptName) current timeout set TIMEOUT|default\nSet the network host timeout to the specified number of milliseconds, or to the default ($timeoutDefault)."; }
timeoutSetArgs() { [[ "${1,,}" == "default" ]] && { timeout="$timeoutDefault"; ((++shift)); return; } ; ScriptArgGet --integer "timeout" -- "$@"; }
timeoutSetCommand() { doLog && echo "Setting the availablility timeout to $timeout."; AvailableTimeoutSet $timeout; }

#
# service commands
#

serviceUsage() { echot "Usage: $(ScriptName) service current list
macOS network service commands."; }

serviceArgStart() { unset -v detail; }

serviceOpt()
{
	case "$1" in
		-d|--detail) detail="--detail";;
		*) return 1;;
	esac
}

serviceCommand() { usage; }

serviceCurrentUsage()
{
	echot "Usage: $(ScriptName) service current
List the connected network services.  Services are listed in the preferred order (the order of use).
	
	-d,	--detail			show detailed information in the format service|interface|mac"
}

serviceCurrentCommand()
{
	serviceCurrent | uniq && return
	ScriptErr "unable to find the current network service"
	return 1
}

serviceCurrent()
{
	local gotService

	while read -r line; do

		# get the service and network interface
    local service=$(echo "$line" | awk -F  "(, )|(: )|[)]" '{print $2}')
    local interface=$(echo "$line" | awk -F  "(, )|(: )|[)]" '{print $4}')
    [[ ! $interface ]] && continue

    # get interface detail
    interfaceDetail="$(ifconfig "$interface" 2>/dev/null)"
    ! echo "$interfaceDetail" | ${G}grep --quiet 'status: active' && continue

    # show the service information
    gotService="true"
    mac=$(echo "$interfaceDetail" | awk '/ether/{print $2}')
    [[ $detail ]] && echo "$service|$interface|$mac" || echo "$service"

	done <<< "$(networksetup -listnetworkserviceorder | grep 'Hardware Port')"

	[[ $gotService ]]
}

serviceListUsage()
{
	echot "Usage: $(ScriptName) service list
List all network services.  Services are listed in the preferred order (the order of use).  Inactive services have a * prefix.

	-d,	--detail			show detailed information in the format service|nameservers"
}

serviceListCommand()
{
	! IsPlatform mac && return 0
	[[ $detail ]] && { serviceListDetail; return; }
	networksetup -listallnetworkservices | ${G}tail --lines=+2
}

serviceListDetail()
{
	! IsPlatform mac && return 0
	local service services; IFS=$'\n' ArrayMakeC services network service list || return
	for service in "${services[@]}"; do
		service="$(echo "$service" | ${G}sed 's/^*//')"
		local dns="$(networksetup -getdnsservers "$service" |& grep -v "^There aren" | grep -v "disabled")"
		echo "$service:${dns:-empty}"
	done
}

#
# watch commands
#

watchUsage() { echot "Usage: $(ScriptName) watch\nWatch for network changes."; }

watchCommand()
{
	local configuredNetwork currentNetwork

	# testing
	# while true; do
	# 	header "start"
	# 	NetworkCurrentUpdate --force -vvv || ScriptErr "unable to update the current network"
	# 	header "done"; sleep 5
	# done

	ip monitor address |\
	while read line; do
		[[ "$line" =~ "inet " ]] || continue

		header "Network Change"		
		line="$(echo "$line" | tr -s " ")"
		log3 "line=$line"

		# get action (up or down)
		local action="$(echo "$line" | cut -d" " -f1)"
		[[ "$action" == "Deleted" ]] && action="down" line="$(echo "$line" | cut -d" " -f2-)" || action="up"

		# get IP
		local ip="$(echo "$line" | cut -d" " -f4 | cut -d"/" -f1)"

		# get adapter
		local adapter="$(echo "$line" | cut -d" " -f2)"
		IsPlatform win && { adapter="$(GetAdapterName "$ip")" || adapter="$(echo "$line" | cut -d" " -f2)"; }

		echo "Adapter $adapter has gone $action with IP address $ip"

		# update network
		if currentNetwork="$(network current find)"; then
			configuredNetwork="$(NetworkCurrent)"
			log3 "configuredNetwork='$configuredNetwork' currentNetwork='$currentNetwork'"
			if [[ "$configuredNetwork" != "$currentNetwork" ]]; then
				echo "The network has changed from '$configuredNetwork' to '$currentNetwork'..."
				NetworkCurrentUpdate --config --force || ScriptErr "unable to update the current network"
			fi
		else
			ScriptErr "unable to get current networks"
		fi
		oldNetworks="$newNetworks"

	done
}

#
# workgroup commands
#

workgroupUsage() { echot "Usage: $(ScriptName) workgroup name|set\nSAMBA workgroup commands."; }
workgroupCommand() { workgroupNameCommand; }

workgroupNameCommand()
{ 
	if IsPlatform win; then
		net.exe config workstation | grep "Workstation domain" | RemoveCarriageReturn | awk '{ print $3; }'
	elif [[ -f "/etc/samba/smb.conf" ]]; then
		cat "/etc/samba/smb.conf" | grep -i "^[ 	]*workgroup[ 	]*=[ 	s]*" | cut -d "=" -f 2 | sed 's/ //g'
 	else
		echo "unknown"
	fi 
}

workgroupSetArgs() { (( ! $# )) && return; ScriptArgGet "new" -- "$@"; }

workgroupSetCommand()
{
	local current="$(network workgroup name)"
	[[ ! $new ]] && { read -p "Enter new workgroup: " new; echo; }

	[[ ! $force && "$current" == "$new" ]] && return

	echo "The current workgroup is $current, setting the workgroup to $new..."

	if [[ -f "/etc/samba/smb.conf" ]]; then
		sudoc sed -i "s/^[        ]*workgroup[    ]*=.*$/workgroup = ${new}/" "/etc/samba/smb.conf" || return
	fi

	if IsPlatform win; then
		RunLog RunScript --elevate --pause-error -- powershell.exe Add-computer -WorkgroupName "$new" || return
	fi
	
	return 0
}

#
# helper
#

doLog() { [[ ! $brief && ! $quiet ]]; } # return true if output should be logged
domain() { UpdateGetForce "network_domain"; }
firefoxValidate() { firefox IsInstalled && firefox profile dir exists; }
npmValidate() { InPath npm; }
wpadFileGet() { IsLocalHost "$1" && echo "$UDATA/sync${wpadFile}" || echo "$wpadFile"; } # wpadFileGet HOST - get the WPAD file for host
supportOsProxy() { IsPlatform mac,win; }

# name - return the current network name
name()
{ 
	# return the cached network name if exists
	local name; name="$(UpdateGet "$networkCache")" && [[ $name ]] && { echo "$name"; return; }

	# no network name identified, try and update it
	network current update --config --quiet "${globalArgs[@]}" || return
	name="$(force= UpdateGet "$networkCache")" && [[ $name ]] && { echo "$name"; return; }

	# unable to identify the network
	ScriptErr "unable to identify the current network"
	return 1
}

nameCached() { UpdateGetForce "$networkCache"; }

nameValidate()
{
	local name; name="$(UpdateGet "$networkCache")"
	[[ $name ]] && { [[ ! $quiet ]] && echo "$name"; return 0; }
	ScriptErrQuiet "the current network is not configured"
}

ScriptRun "$@"

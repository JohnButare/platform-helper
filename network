#!/usr/bin/env bash
. script.sh || exit

usage() {	ScriptUsage "$1" "Usage: network adapter|current|cache|center|dns|find|internet|name|profile|proxy|run|vpn|workgroup"; exit $1; }

init() 
{
	defaultCommand="center"

	noProxy="localhost,127.0.0.1,.$(ConfigGet "domain"),.releases.ubuntu.com"
	wpadServer="$(ConfigGet "web")" wpadFile="/share/Web/autoproxy/wpad.dat"

	adapterKey='HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Networkâ€‹'
	profileKey='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles/'
}


#
# commands
#

runCommand() { ssh "$1" 'source /etc/profile; '"${@:2}"''; }
centerCommand() {	start control /name Microsoft.NetworkAndSharingCenter; }
cacheCommand() { IsAvailable "$1" || return; net use '\\'$1'\ipc$' >& /dev/null; }
nameCommand() { registry edit 'HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles'; }

#
# Adapter Commands
#

adapterUsage() { echot "Usage: $(ScriptName) adapter edit|list|name
Network adapter commands."; }

adapterCommand() { usage; }

adapterEditCommand() { registry edit "$adapterKey"; }

adapterListCommand()
{
	! IsElevated && { RunScript --elevate network adapter list "$@"; return; }
	powershell.exe Get-NetAdapter | RemoveCarriageReturn | RemoveEmptyLines | tail -n +3
}

adapterNameArgs()
{
	ScriptArgGet "old" -- "$@"; shift
	ScriptArgGet "new" -- "$@"; shift
}

adapterNameCommand()
{ 
	! IsElevated && { RunScript --elevate -- network adapter name "$old" "$new"; return; }
	powershell.exe Rename-NetAdapter -Name \"$old\" -NewName \"$new\"
}

#
# Current Commands
#

currentUsage()
{
	echot "Usage: $(ScriptName) current [find|status|servers|update](status)
Current network commands.

	find			find the network we are currently on
	server		find the first active server
	servers		list all servers for the current network
	status		status of the current network
	update		update network settings for the network we are currently on

	-b,	--brief		show brief status messages"
}

currentArgStart() { unset -v brief; }

currentOpt()
{
	case "$1" in
		-b|--brief) brief="--brief";;
		*) return 1;;
	esac
}

currentCommand() { currentStatusCommand; }
currentStatusCommand() { printf "network=$(UpdateGet "network")\nfile=$(UpdateGet "FileServer")\nproxy=$(UpdateGet "ProxyServer")\n"; }

#
# Current Find Command
#

currentFindCommand()
{
	local network; printf "network..."; network="$(findNetwork)" || return 
	local fileServer; printf "file..."; fileServer="$(findServer "$network" "file" --service="smb" $brief "${globalArgs[@]}")" || { EchoErr "none"; }
	local proxyServer; printf "proxy..."; proxyServer="$(findServer "$network" "proxy" $brief "${globalArgs[@]}")" || { EchoErr "none"; }
	printf "found network=$network\nfound file server=$fileServer\nfound proxy server=$proxyServer\n";
}

#
# Current Server Command
#

currentServerUsage()
{ 
	echot "Usage: $(ScriptName) current server TYPE
Return the first server of the specified type for the current network.

	-s, --service	the service to check if one is not specified, see 'network find --help'"
}

currentServerArgStart() { unset -v service type; }

currentServerOpt()
{
	case "$1" in
		-s|--service|-s=*|--service=*) ScriptOptGet "service" "$@"; service="--service=$service";;
		*) return 1;;
	esac
}

currentServerArgs() { ScriptArgGet "type" -- "$@"; shift; }
currentServerCommand() { findServer "$(UpdateGet "network")" "$type" "$service"; }

#
# Current Servers Command
#

currentServersUsage()
{
	echot "Usage: $(ScriptName) current servers TYPE
Return all servers of the specified type for the current network."
}

currentServersArgStart() { unset -v type; }
currentServersArgs() { ScriptArgGet "type" -- "$@"; shift; }
currentServersCommand() { getServers "$(UpdateGet "network")" "$type"; }

#
# Current Update Command
#

currentUpdateCommand()
{
	# get existing configuration
	local existingNetwork="$(UpdateGet "network")"  existingFileServer="$(UpdateGet "FileServer")" existingProxyServer="$(UpdateGet "ProxyServer")"

	# determine current network configuration
	local network
	doLog && { hilight "Determining network..."; echo "Existing network is ${existingNetwork:-unknown}"; }
	doLog && printf "network..."; network="$(findNetwork $brief)" || return

	# update resolv.conf - ensures name resolution is working to find other servers
	local resolvConf="$DATA/setup/resolv.conf.$network"
	{ ! IsPlatform wsl || [[ ! -f "$resolvConf" ]]; } && unset resolvConf
	if [[ $resolvConfFile ]] && ! cmp --quiet "$resolvConf" "/etc/resolv.conf"; then
		sudoc cp "$resolvConfFile" "/etc/resolv.conf" || return
	fi

	# find servers
	local fileServer; doLog && printf "file..."; fileServer="$(findServer "$network" "file" --service="smb" $brief "${globalArgs[@]}")" || { EchoErr "none"; }
	local proxyServer; doLog && printf "proxy..."; proxyServer="$(findServer "$network" "proxy" $brief "${globalArgs[@]}")" || { EchoErr "none"; }

	# return if no changes are required
	[[ ! $force && "$network" == "$existingNetwork" && "$fileServer" == "$existingFileServer" && "$proxyServer" == "$existingProxyServer" ]] && return

	# update network configuration
	doLog && hilight "Setting the network to $network..."
	[[ $brief ]] && printf "network..."

	# save network
	UpdateSet "network" "$network" || return

	# save file server
	UpdateSet "FileServer" "$fileServer" || return

	# save proxy server
	UpdateSet "ProxyServer" "$proxyServer" || return
	local action="--enable"; [[ ! $proxyServer ]] && action="--disable"
	ScriptEval network proxy vars "$action" || return
	network proxy apt "$action" || return

	# status
	doLog && currentStatusCommand
	doLog && { network proxy --status "${globalArgs[@]}" || return; }

	return 0
}

# findNetwork - find the first active network from the networks specified in the networks configuration variabke 
findNetwork()
{
	local networkIndex networks=(); StringToArray "$(ConfigGet "networks")" "," networks
	networkIndex="$(network find --service=dns "${networks[@]}" "${globalArgs[@]}" $brief)" || { echo "external"; return; }
	GetSshUser "${networks[$networkIndex]}" # return the name of the network (before @)
}

# findServer NETWORK TYPE SERVICE - find the first server of the specified type for the specified network  
findServer()
{
	local network="$1" type="$2" service="$3"
	local serverIndex servers=(); StringToArray "$(getServers "$network" "$type")" "," servers
	[[ ! $servers ]] && return 1
	serverIndex="$(network find "${servers[@]}" $service $brief "${globalArgs[@]}")" || return
	RemoveBefore "${servers[$serverIndex]}" "@" # return HOST:SERVICE of the server (DESCRIPTION@HOST:SERVICE)
}

#
# find commands
#

findUsage()
{
	echot "Usage: $(ScriptName) find SERVER [SERVER...]
Find the first server that exposes a specific service.  Returns the zero based index of the found server.

- SERVER format is [DESCRIPTION@]HOST_OR_IP[:SERVICE], i.e. wiggin:10.10.10:DNS
- DESCRIPTION is used for information messages while checking
- SERVICE is a numeric port or one of
		PING - performs a UDP ping
		DNS - checks port 53 and performs a DNS lookup
  	NFS - checks port 111
  	SMB - checks port 445
  	SSH - checks port 22, or the port the port defined in the SSH configuration for the host

	-b,	--brief		show brief status messages
	-s, --service	the service to use if one is not specified, defaults to PING"
}

findArgStart() { unset -v brief; defaultService="PING"; }

findOpt()
{
	case "$1" in
		-b|--brief) brief="--brief";;
		-s|--service|-s=*|--service=*) ScriptOptGet "defaultService" "service" "$@";;
		*) return 1;;
	esac
}

findArgs()
{
	(( $# == 0 )) && { MissingOperand "server"; return 1; }
	servers=( "$@" ); (( shift+=$# ))
}

findCommand()
{
	[[ ! $brief && ! $quiet ]] && PrintErr "checking..."

	local server i="0"
	for server in "${servers[@]}"
	do
		# parse the server: DESCRIPTION@HOST_OR_IP:SERVICE
		local host="$(GetSshHost "$server")"
		local service="$(GetSshPort "$server")"; service="${service:-$defaultService}"; service="${service,,}"
		local description="$(GetSshUser "$server")"; description="${description:-$host}"; [[ "$description" != "$host" ]] && description="$description ($host)"

		# check for a valid service
		! IsInteger "$service" && [[ "$service" != @(dns|ping|nfs|smb|ssh) ]] && { ScriptErr "'$service' is not a valid service"; return 1; }

		# logging
		if [[ $verbose ]]; then
			PrintErr "$description..."
			IsAvailable "$host" && PrintErr "available..."
			PrintErr "$service..."
		elif [[ ! $brief && ! $quiet ]]; then
			PrintErr "$description..."
		fi

		# check the service
		if findCheck "$host" "$service" "$description"; then
			[[ ! $brief && ! $quiet ]] && EchoErr "found"
			echo "$i"
			return 0
		fi
		
		(( ++i ))
	done
 
	[[ ! $brief && ! $quiet ]] && EchoErr "none"
	return 1
}

findCheck()
{
	local host="$1" service="$2" description="$3"

	# port number aliases
	case "$service" in
		nfs) service="111";;
		smb) service="445";;
		ssh) service="$(SshHelper config "$host" port)";;
	esac

	case "$service" in
		dns) IsAvailablePort "$host" 53 && dig @$host bogus +time=1 +tries=1 >& /dev/null;;
		ping) IsAvailable "$host";;
		*) IsAvailablePort "$host" "$service";;
	esac
}

#
# DNS Commands
#

dnsUsage() { echot "Usage: $(ScriptName) adapter edit|list|name
Network adapter commands."; }

dnsCommand() { dnsFlushCommand; }

dnsFlushCommand() 
{ 
	case "$PLATFORM" in
		linux) sudoc systemd-resolve --flush-caches;;
		mac) sudoc killall -HUP mDNSResponder;;
		win) ipconfig /flushdns;;
	esac
}

#
# Internet Commands
#

internetUsage() { echot "Usage: $(ScriptName) internet address|provider [GATEWAY]
Internet commands.

	address						get the public internet address with the default or specified gateway
	provider [short]	get the internet provider name"
}

internetArgs()
{
	[[ $1 ]] && ScriptArgGet "gateway" -- "$@"
	return 0
}

internetCommand() { internetProviderCommand; }

internetAddressCommand() 
{
	if [[ ! $gateway ]]; then 
		nslookup myip.opendns.com resolver1.opendns.com | grep Address | grep -v 53 | cut -d: -f2 | RemoveSpace
		return
	fi

	# find the internet address for ther specified gateway
	# assumes the default gateway is a UniFi gateway named "router" 
	gateway="$(GetIpAddress "$gateway")"
	local dns; dns="$(GetIpAddress "resolver1.opendns.com")" || return

	# router password
	local password; password="$(credential get unifi admin)" || return

	# validation
	! IsAvailablePort router 22 && { ScriptErr "the router is not available"; return 1; }
	! InPath && { package sshpass || return; }

	# logging
	[[ $verbose ]] && ScriptErr "dns=$dns gateway=$gateway"

	# get the IP address for the specified gateway from the router by adding a static route
	echo "$password" | sshpass ssh router "$(cat <<-EOF
			sudo ip route add "$dns" via "$gateway"
			nslookup myip.opendns.com resolver1.opendns.com
			sudo ip route delete "$dns"
		EOF
	)" |& grep Address | grep -v 53 | cut -d: -f2 | RemoveSpace

}

internetProviderCommand()
{
	local address; address="$(internetAddressCommand)" || return
	whois "$address" | grep "OrgTechName" | head -1 | cut -d: -f2 | RemoveSpaceFront
}

internetProviderShortCommand() { internetProviderCommand | GetWord - 1 | LowerCase; }

#
# Profile Commands
#

profileUsage() { echot "Usage: $(ScriptName) profile edit|list|set
Network profile commands."; }

profileArgStart() { IsPlatform win && return; EchoErr "network: profile is only implemented for Windows"; return 1; }
profileCommand() { profileListCommand; }

profileEditCommand() { registry edit "$profileKey"; }

profileListCommand()
{
	! IsElevated && { RunScript --elevate network profile list "$@"; return; }

	local IFS=$'\n' name type category

	for key in $(registry get "$profileKey"); do
		name="$(registry get "$key/ProfileName" | RemoveCarriageReturn)"
		type="$(registry get "$key/NameType" | RemoveCarriageReturn)"
		category="$(registry get "$key/Category" | RemoveCarriageReturn)"

		case "$type" in
			0x6) type="Wired";;
			0x17) type="VPN";;
			0x47) type="Wireless";;
			0xF3) type="Mobile Broadband";;
		esac

		case "$category" in
			0x0) category="public";;
			0x1) category="private";;
			0x2) category="work";;
		esac

		echo "$name: $category $type"
	done
}

profileSetArgs() { ScriptArgGet "name" -- "$@"; shift; }

# profile set - if there is only one network profile, set it's name and make it a private network
profileSetCommand()
{
	! IsElevated && { RunScript --elevate network profile set "$name"; pause; return; }

	local numProfiles="$(registry get "$profileKey" | RemoveEmptyLines | wc -l)"

	(( $numProfiles > 1 )) && { EchoErr "Cannot set the profile if more than one exists"; return 1; }

	local key="$(registry get "$profileKey" | RemoveEmptyLines | head -1)"
	registry set "$key/ProfileName" REG_SZ "$name" || return
	registry set "$key/Category" REG_DWORD "1" || return # private
}

#
# VPN Commands
#

vpnUsage() { echot "Usage: $(ScriptName) workgroup on|off|status
VPN commands."; }

vpnArgStart() { IsPlatform win && return; EchoErr "network: VPN is only implemented for Windows"; return 1; }
vpnCommand() { vpnStatusCommand; }
vpnStatusCommand() { rasdial.exe; }

vpnOnCommand()
{
	rasdial.exe "vpn-$(ConfigGet "network")" "$USER" "$(credential get secure default)" || return
	currentUpdateCommand || return
}

vpnOffCommand()
{
	rasdial.exe "vpn-$(ConfigGet "network")" /disconnect || return
	currentUpdateCommand || return
}

#
# Workgroup Commands
#

workgroupUsage() { echot "Usage: $(ScriptName) workgroup name|set
SAMBA workgroup commands."; }

workgroupCommand() { workgroupNameCommand; }

workgroupNameCommand()
{ 
	if IsPlatform win; then
		net.exe config workstation | grep "Workstation domain" | RemoveCarriageReturn | awk '{ print $3; }'
	elif [[ -f "/etc/samba/smb.conf" ]]; then
		cat "/etc/samba/smb.conf" | grep -i "^[ 	]*workgroup[ 	]*=[ 	s]*" | cut -d "=" -f 2 | sed 's/ //g'
 	else
		echo "unknown"
	fi 
}

workgroupSetArgs() { [[ $1 ]] && ScriptArgGet "new" -- "$@"; return 0; }

workgroupSetCommand()
{
	local current="$(network workgroup name)"
	[[ ! $new ]] && { read -p "Enter new workgroup: " new; echo; }

	[[ ! $force && "$current" == "$new" ]] && return

	echo "The current workgroup is $current, setting the workgroup to $new..."

	if [[ -f "/etc/samba/smb.conf" ]]; then
		sudoc sed -i "s/^[        ]*workgroup[    ]*=.*$/workgroup = ${new}/" "/etc/samba/smb.conf" || return
	fi

	if IsPlatform win; then
		elevate RunScript --pause-error powershell Add-computer -WorkgroupName "$new" || return
	fi
	
	return 0
}

#
# proxy commands
#

proxyUsage()
{ 
	echot "Usage: $(ScriptName) proxy [apt|wpad|vars]
Network proxy server commands.

	-e, --enable
	-d, --disable
	-s, --status"
}

proxyArgStart()
{
	action="status"
	proxyVars="http_proxy,https_proxy,ftp_proxy,HTTP_PROXY,HTTPS_PROXY,FTP_PROXY"
	noProxyVars="no_proxy,NO_PROXY"	
	allVars="$proxyVars,$noProxyVars"
	aptFile="/etc/apt/apt.conf.d/proxy"	
}

proxyOpt() 
{
	case "$1" in
		-d|--disable) action="disable";;
		-e|--enable) action="enable";;
		-s|--status) action="status";;
		*) return 1
	esac
}

proxyArgs()
{
	[[ "$action" == "status" ]] && what="all" || what="vars"
	[[ "$1" =~ ^(apt|wpad|vars)$ ]] && { what="$1"; ((++shift)); }
	return 0
}

proxyCommand() { proxy${what^}${action^}; }

proxyAllStatus()
{
	if [[ $verbose ]]; then
		header "Proxy Variables"; proxyVarsStatus
		isAptInstalled && { header "APT Proxy"; proxyAptStatus; }
	else
		echo "proxy variables=$(proxyVarsStatus)"
		isAptInstalled && echo "apt proxy=$(proxyAptStatus)"
	fi

	return 0
}

proxyVarsEnable()
{
	local proxyServer="$(UpdateGet "ProxyServer")"
	[[ ! $proxyServer ]] && return
	echo "export {$proxyVars}=\"http://$proxyServer\"; eval export {$noProxyVars}=\"$noProxy\""
}

proxyVarsDisable() {	echo "unset {$allVars}; unset {$allVars}"; }

proxyVarsStatus()
{
	if (( $(export | grep -i 'proxy=\"http' | wc -l) > 1 )); then
		if [[ $verbose ]]; then
			export | grep "$(echo "$allVars=" | sed 's/,/=\\|/g')"
		else
			echo "enabled"
		fi
	else
		echo "disabled"
	fi
}

proxyAptEnable()
{
	 ! isAptInstalled && return

	local proxyServer="$(UpdateGet "ProxyServer")"
	
	[[ ! $force ]] && [[ -f "$aptFile" ]] && grep -q "$proxyServer" "$aptFile" && return

	echo "Acquire::http::Proxy \"http://$proxyServer\";
Acquire::https::Proxy \"http://$proxyServer\";" | sudo tee "$aptFile"
}

proxyAptDisable() { [[ ! -f "$aptFile" ]] && return; sudo rm "$aptFile"; }

proxyAptStatus()
{
	! isAptInstalled && return

	if [[ -f "$aptFile" ]]; then
		[[ $verbose ]] && cat "$aptFile" || echo "enabled"
	else
		echo "disabled"
	fi
}

proxyWpadEnable() { scp "$CLOUD/network/system/proxy/wpad.dat.enable" "$wpadServer:$wpadFile"; }
proxyWpadDisable() { scp "$CLOUD/network/system/proxy/wpad.dat.disable" "$wpadServer:$wpadFile"; }
proxyWpadStatus() { ssh $wpadServer cat "$wpadFile" | grep "PROXY" > /dev/null && echo "enabled" || echo "disabled"; }

#
# helper
#

# doLog - return true if output should be logged
doLog() { [[ ! $brief && ! $quiet ]]; }

# getServers NETWORK TYPE - get servers of the specified type for the specified network from configuration, 
# i.e getServers wiggin file would look for the wigginFileServers configuration variable
getServers()
{
	local network="$1" type="$2"
	ConfigGet "${network}$(UpperCaseFirst "$type")Servers"
}

isAptInstalled() { [[ -d "/etc/apt" ]]; }

ScriptRun "$@"

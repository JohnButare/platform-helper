#!/usr/bin/env bash
. function.sh

run() {	init; args "$@"; ${command}Command "${args[@]}"; }

init() 
{
	command='network'

	proxyServer="proxy.hagerman.butare.net" proxyPort="3128"
	noProxy="localhost,127.0.0.1,.hagerman.butare.net,.releases.ubuntu.com"
	wpadServer="nas3.hagerman.butare.net" wpadFile="/share/Web/autoproxy/wpad.dat"

	adapterKey='HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Networkâ€‹'
	profileKey='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles/'
	
	declare -Ag networks=( [wiggin]=192.168.100.10 [foo]=192.168.1.5 )
}

usage()
{
	echot "\
usage: network cache center dns name proxy run

	adapter edit|list|name 	network adapter commands
	dns flush 							dns commands
	profile edit|list|set 	network profile commands
	proxy [apt|wpad|vars] 
		-e, --enable
		-d, --disable
		-s, --status
	current name|update     current network commands
		update 								update network settings for the current network
	workgroup name|set 			SAMBA workgroup commands

	-f,  --force						force the change
	-q,  --quiet						minimize informational messages"
	exit $1
}

args()
{
	unset command force quiet

	while [ "$1" != "" ]; do
		case "$1" in
			-f|--force) force="true";;
			-h|--help) usage 0;;
			-q|--quiet) quiet="--quiet";;
			*) 
				[[ "$command" == @(adapter|cache|check|current|dns|profile|proxy|run|workgroup) ]] && break
				IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				UnknownOption "$1"
		esac
		shift
	done

	[[ ! $command ]] && { command="center"; }
	args=( "$@" )
}

#
# commands
#

runCommand() { ssh "$1" 'source /etc/profile; '"${@:2}"''; }
centerCommand() {	start control /name Microsoft.NetworkAndSharingCenter; }
cacheCommand() { IsAvailable "$1" || return; net use '\\'$1'\ipc$' >& /dev/null; }
nameCommand() { registry edit 'HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles'; }

#
# adapter commands
#

adapterCommand()
{
	command="List"
	[[ $# > 0 ]] && ProperCase "$1" s; IsFunction Adapter${s}Command && { command="$s"; shift; }
	Adapter${command}Command "$@"
}

AdapterEditCommand() { registry edit "$adapterKey"; }

AdapterListCommand()
{
	! IsElevated && { RunScript --elevate network adapter list "$@"; return; }
	powershell.exe Get-NetAdapter | RemoveCarriageReturn | RemoveEmptyLines | tail -n +3
}

AdapterNameCommand() # OLD NEW
{ 
	local old="$1"; [[ ! $old ]] && { MissingOperand "old name"; }
	local new="$2"; [[ ! $new ]] && { MissingOperand "new name"; }

	! IsElevated && { RunScript --elevate -- network adapter name "$@"; return; }
	powershell.exe Rename-NetAdapter -Name \"$old\" -NewName \"$new\"
}

#
# current network commands
#

currentCommand()
{
	command="Name"
	[[ $# > 0 ]] && ProperCase "$1" s; IsFunction Current${s}Command && { command="$s"; shift; }
	[[ $# != 0 ]] && usage
	Current${command}Command "$@"
}

CurrentNameCommand()
{
	network="external"

	for i in "${!networks[@]}"
	do
		local name="$i" ip="${networks[$i]}"
		[[ ! $quiet ]] && printf "Checking $name ($ip)..."
		if IsAvailable "$ip" && dig @$ip bogus +time=1 +tries=1 >& /dev/null; then
			[[ ! $quiet ]] && echo "found"
			network="$name"
			break
		fi 
	done
	[[ "$network" == "external" && ! $quiet ]] && echo "done"

	[[ $quiet ]] && echo "$network" || echo "The current network is $network"
}

CurrentUpdateCommand()
{
	local network

	CurrentNameCommand || return

	local file="$DATA/setup/resolv.conf.$network"
	if [[ ! -f "$file" ]]; then
		EchoErr "network: could not find a network configuration file for $network"
		return 1
	fi

	echo "Setting the network to $network"
	sudoc cp "$file" "/etc/resolv.conf"
}

#
# DNS commands
#

dnsCommand()
{
	command="Flush"
	[[ $# > 0 ]] && ProperCase "$1" s; IsFunction Dns${s}Command && { command="$s"; shift; }
	[[ $# != 0 ]] && usage
	Dns${command}Command "$@"
}

DnsFlushCommand() 
{ 
	case "$PLATFORM" in
		win) ipconfig /flushdns;;
		mac) sudo killall -HUP mDNSResponder;;
	esac
}

#
# profile commands -  - Windows network profiles
#

profileCommand()
{
	! IsPlatform win && { EchoErr "network: profile is only implemented for Windows"; return 1; }
	
	command="List"
	[[ $# > 0 ]] && ProperCase "$1" s; IsFunction Profile${s}Command && { command="$s"; shift; }
	Profile${command}Command "$@"
}

#
# Profile Commands
#

ProfileEditCommand() { registry edit "$profileKey"; }

ProfileListCommand()
{
	! IsElevated && { RunScript --elevate network profile list "$@"; return; }

	local IFS=$'\n' name type category

	for key in $(registry get "$profileKey"); do
		name="$(registry get "$key/ProfileName" | RemoveCarriageReturn)"
		type="$(registry get "$key/NameType" | RemoveCarriageReturn)"
		category="$(registry get "$key/Category" | RemoveCarriageReturn)"

		case "$type" in
			0x6) type="Wired";;
			0x17) type="VPN";;
			0x47) type="Wireless";;
			0xF3) type="Mobile Broadband";;
		esac

		case "$category" in
			0x0) category="public";;
			0x1) category="private";;
			0x2) category="work";;
		esac

		echo "$name: $category $type"
	done
}

# profile set NAME - if there is only one network profile, set it's name and make it a private network
ProfileSetCommand()
{
	! IsElevated && { RunScript --elevate network profile set "$@"; pause; return; }

	local name="$1"; [[ ! $name ]] && { MissingOperand "name"; }
	local numProfiles="$(registry get "$profileKey" | RemoveEmptyLines | wc -l)"

	(( $numProfiles > 1 )) && { EchoErr "Cannot set the profile if more than one exists"; return 1; }

	local key="$(registry get "$profileKey" | RemoveEmptyLines | head -1)"
	registry set "$key/ProfileName" REG_SZ "$name" || return
	registry set "$key/Category" REG_DWORD "1" || return # private
}

#
# workgroup commands
#

workgroupCommand()
{
	command="Name"
	[[ $# > 0 ]] && ProperCase "$1" s; IsFunction Workgroup${s}Command && { command="$s"; shift; }
	Workgroup${command}Command "$@"
}

WorkgroupNameCommand()
{ 
	if IsPlatform win; then
		net.exe config workstation | grep "Workstation domain" | RemoveCarriageReturn | awk '{ print $3; }'
	elif [[ -f "/etc/samba/smb.conf" ]]; then
		cat "/etc/samba/smb.conf" | grep -i "^[ 	]*workgroup[ 	]*=[ 	s]*" | cut -d "=" -f 2 | sed 's/ //g'
 	else
		echo "unknown"
	fi 
}

WorkgroupSetCommand()
{
	local new="$1" current="$(network workgroup name)"
	[[ ! $new ]] && { read -p "Enter new workgroup: " new; echo; }

	[[ ! $force && "$current" == "$new" ]] && return

	echo "The current workgroup is $current, setting the workgroup to $new..."

	if [[ -f "/etc/samba/smb.conf" ]]; then
		sudoc sed -i "s/^[        ]*workgroup[    ]*=.*$/workgroup = ${new}/" "/etc/samba/smb.conf" || return
	fi

	if IsPlatform win; then
		elevate RunScript --pause-error powershell Add-computer -WorkgroupName "$new" || return
	fi
	
	return 0
}

#
# proxy commands
#

proxyCommand()
{
	local proxy="$proxyServer:$proxyPort"
	local proxyVars="http_proxy,https_proxy,ftp_proxy,HTTP_PROXY,HTTPS_PROXY,FTP_PROXY"
	local noProxyVars="no_proxy,NO_PROXY"	
	local allVars="$proxyVars,$noProxyVars"
	local aptFile="/etc/apt/apt.conf.d/proxy"

	local command="Vars"
	[[ "$1" =~ ^(apt|wpad|vars)$ ]] && { command="$(ProperCase "$1")"; shift; }

	local subCommand
	case "$1" in
		-d|--disable) subCommand="Disable"; shift;;
		-e|--enable) subCommand="Enable"; shift;;
		-s|--status) subCommand="Status"; shift;;
	esac

	[[ $# != 0 ]] && UnknownOption "$1"

	Proxy${command}${subCommand}Command "$@"
}

ProxyVarsEnableCommand()
{
	! IsAvailable "$proxyServer" && { ProxyVarsDisableCommand; return; }
	echo "export {$proxyVars}=\"http://$proxy/\"; eval export {$noProxyVars}=\"$noProxy\""
}

ProxyVarsDisableCommand() {	echo "unset {$allVars}; unset {$allVars}"; }
ProxyVarsStatusCommand() { (( $(export | grep -i 'proxy=\"http' | wc -l) > 1 )) && echo "enabled" || echo "disabled"; }

ProxyAptEnableCommand()
{
	[[ -f "$aptFile" ]] && return
	echo "Acquire::http::Proxy \"http://$proxy\";
Acquire::https::Proxy \"http://$proxy\";" | sudo tee "$aptFile"
}

ProxyAptDisableCommand() { [[ -f "$aptFile" ]] && sudo rm "$aptFile"; }
ProxyAptStatusCommand() { [[ -f "$aptFile" ]] && echo "enabled" || echo "disabled"; }

ProxyWpadEnableCommand() { scp "$CLOUD/network/proxy/wpad.dat.enable" "$wpadServer:$wpadFile"; }
ProxyWpadDisableCommand() { scp "$CLOUD/network/proxy/wpad.dat.disable" "$wpadServer:$wpadFile"; }
ProxyWpadStatusCommand() { ssh $wpadServer cat "$wpadFile" | grep "PROXY" > /dev/null && echo "enabled" || echo "disabled"; }

run "$@"

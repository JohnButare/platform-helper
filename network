#!/usr/bin/env bash
. function.sh

run() {	init; args "$@"; ${command}Command "${args[@]}"; }

init() 
{
	command='network'

	proxyServer="proxy.hagerman.butare.net" proxyPort="3128"
	noProxy="localhost,127.0.0.1,.hagerman.butare.net,.releases.ubuntu.com"
	wpadServer="nas3.hagerman.butare.net" wpadFile="/share/Web/autoproxy/wpad.dat"

	adapterKey='HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Networkâ€‹'
	profileKey='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles/'
	
	declare -Ag networks=( [wiggin]=192.168.100.10 [foo]=192.168.1.5 )
}

usage()
{
	echot "\
usage: network cache center dns name proxy run update
	dns flush
	proxy [apt|wpad|vars] 
		-e, --enable
		-d, --disable
		-s, --status
	AdapterEdit|AdapterList|AdapterName - network adapters
	ProfileEdit|ProfileList|ProfileSet - network profiles
	workgroup|WorkgroupSet"
	exit $1
}

args()
{
	unset command
	while [ "$1" != "" ]; do
		case "$1" in
			-h|--help) usage 0;;
			AdapterEdit) command="adapterEdit";; AdapterList) command="adapterList";; AdapterName) command="adapterName";;
			ProfileEdit) command="profileEdit";; ProfileList) command="profileList";; ProfileSet) command="profileSet";;
			WorkgroupSet) command="workgroupSet";;
			*) 
				IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				[[ "$command" == @(cache|check|dns|proxy|run) ]] && break
				[[ "$command" == @(AdapterName|ProfileSet|WorkgroupSet) ]] && break
				UnknownOption "$1"
		esac
		shift
	done
	[[ ! $command ]] && { command="center"; }
	args=( "$@" )
}

runCommand() { ssh "$1" 'source /etc/profile; '"${@:2}"''; }
centerCommand() {	start control /name Microsoft.NetworkAndSharingCenter; }
cacheCommand() { IsAvailable "$1" || return; net use '\\'$1'\ipc$' >& /dev/null; }
nameCommand() { registry edit 'HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles'; }

updateCommand()
{
	local network="external"

	for i in "${!networks[@]}"
	do
		local name="$i" ip="${networks[$i]}"
		printf "Checking $name ($ip)..."
		if IsAvailable "$ip" && dig @$ip bogus +time=1 +tries=1 >& /dev/null; then
			echo "found"
			network="$name"
			break
		fi 
	done
	[[ "$network" == "external" ]] && echo "done"

	local file="$DATA/setup/resolv.conf.$network"
	if [[ ! -f "$file" ]]; then
		EchoErr "network: could not find a network configuration file for $network"
		return 1
	fi

	echo "Setting the network to $network"
	sudoc cp "$file" "/etc/resolv.conf"
}

#
# DNS Commands
#

dnsCommand()
{
	command="Flush"
	[[ $# > 0 ]] && ProperCase "$1" s; IsFunction Dns${s}Command && { command="$s"; shift; }
	[[ $# != 0 ]] && usage
	Dns${command}Command "$@"
}

DnsFlushCommand() 
{ 
	case "$PLATFORM" in
		win) ipconfig /flushdns;;
		mac) sudo killall -HUP mDNSResponder;;
	esac
}

#
# Workgroup Commands
#

workgroupCommand()
{ 
	if IsPlatform win; then
		net.exe config workstation | grep "Workstation domain" | RemoveCarriageReturn | awk '{ print $3; }'
	elif [[ -f "/etc/samba/smb.conf" ]]; then
		cat "/etc/samba/smb.conf" | grep -i "^[ 	]*workgroup[ 	]*=[ 	s]*" | cut -d "=" -f 2 | sed 's/ //g'
 	else
		echo "unknown"
	fi 
}

workgroupSetCommand()
{
	local newWorkgroup="$1"
	[[ ! $newWorkgroup ]] && { read -p "Enter new workgroup: " newWorkgroup; echo; }

	[[ "$(workgroupCommand)" == "$newWorkgroup" ]] && return

	echo "The current workgroup is $(workgroupCommand), setting the workgroup to $newWorkgroup..."

	if [[ -f "/etc/samba/smb.conf" ]]; then
		sudo sed -i "s/^[        ]*workgroup[    ]*=.*$/workgroup = ${newWorkgroup}/" "/etc/samba/smb.conf" || return
	fi

	if IsPlatform win; then
		elevate RunScript --pause-error powershell Add-computer -WorkgroupName "$newWorkgroup" || return
	fi
	
	return 0
}

#
# Adapter Commands - network adapters
#

adapterEditCommand() { registry edit "$adapterKey"; }

adapterListCommand()
{
	! IsElevated && { elevate RunScript --pause network AdapterList "$@"; return; }
	powershell.exe Get-NetAdapter | RemoveCarriageReturn | RemoveEmptyLines | tail -n +3
}

adapterNameCommand() # OLD NEW
{ 
	! IsElevated && { elevate RunScript --pause-error network AdapterName "$@"; pause; return; }

	local old="$1"; [[ ! $old ]] && { MissingOperand "old name"; }
	local new="$2"; [[ ! $new ]] && { MissingOperand "new name"; }

	powershell.exe Rename-NetAdapter -Name \"$old\" -NewName \"$new\"
}

#
# Profile Commands - Windows network profiles
#

profileEditCommand() { registry edit "$profileKey"; }

profileListCommand()
{
	! IsElevated && { elevate RunScript --pause network ProfileList "$@"; return; }

	local IFS=$'\n' name type category

	for key in $(registry get "$profileKey"); do
		name="$(registry get "$key/ProfileName" | RemoveCarriageReturn)"
		type="$(registry get "$key/NameType" | RemoveCarriageReturn)"
		category="$(registry get "$key/Category" | RemoveCarriageReturn)"

		case "$type" in
			0x6) type="Wired";;
			0x17) type="VPN";;
			0x47) type="Wireless";;
			0xF3) type="Mobile Broadband";;
		esac

		case "$category" in
			0x0) category="public";;
			0x1) category="private";;
			0x2) category="work";;
		esac

		echo "$name: $category $type"
	done
}

# profileSetCommand NAME - if there is only one network profile, set it's name and make it a private network
profileSetCommand()
{
	! IsElevated && { elevate RunScript --pause-error network ProfileSet "$@"; pause; return; }

	local name="$1"; [[ ! $name ]] && { MissingOperand "name"; }
	local numProfiles="$(registry get "$profileKey" | RemoveEmptyLines | wc -l)"

	(( $numProfiles > 1 )) && { EchoErr "Cannot set the profile if more than one exists"; return 1; }

	local key="$(registry get "$profileKey" | RemoveEmptyLines | head -1)"
	registry set "$key/ProfileName" REG_SZ "$name" || return
	registry set "$key/Category" REG_DWORD "1" || return # private
}

#
# Proxy Commands
#

proxyCommand()
{
	local proxy="$proxyServer:$proxyPort"
	local proxyVars="http_proxy,https_proxy,ftp_proxy,HTTP_PROXY,HTTPS_PROXY,FTP_PROXY"
	local noProxyVars="no_proxy,NO_PROXY"	
	local allVars="$proxyVars,$noProxyVars"
	local aptFile="/etc/apt/apt.conf.d/proxy"

	local command="Vars"
	[[ "$1" =~ ^(apt|wpad|vars)$ ]] && { command="$(ProperCase "$1")"; shift; }

	local subCommand
	case "$1" in
		-d|--disable) subCommand="Disable"; shift;;
		-e|--enable) subCommand="Enable"; shift;;
		-s|--status) subCommand="Status"; shift;;
	esac

	[[ $# != 0 ]] && UnknownOption "$1"

	Proxy${command}${subCommand}Command "$@"
}

ProxyVarsEnableCommand()
{
	! IsAvailable "$proxyServer" && { ProxyVarsDisableCommand; return; }
	echo "export {$proxyVars}=\"http://$proxy/\"; eval export {$noProxyVars}=\"$noProxy\""
}

ProxyVarsDisableCommand() {	echo "unset {$allVars}; unset {$allVars}"; }
ProxyVarsStatusCommand() { (( $(export | grep -i 'proxy=\"http' | wc -l) > 1 )) && echo "enabled" || echo "disabled"; }

ProxyAptEnableCommand()
{
	[[ -f "$aptFile" ]] && return
	echo "Acquire::http::Proxy \"http://$proxy\";
Acquire::https::Proxy \"http://$proxy\";" | sudo tee "$aptFile"
}

ProxyAptDisableCommand() { [[ -f "$aptFile" ]] && sudo rm "$aptFile"; }
ProxyAptStatusCommand() { [[ -f "$aptFile" ]] && echo "enabled" || echo "disabled"; }

ProxyWpadEnableCommand() { scp "$CLOUD/network/proxy/wpad.dat.enable" "$wpadServer:$wpadFile"; }
ProxyWpadDisableCommand() { scp "$CLOUD/network/proxy/wpad.dat.disable" "$wpadServer:$wpadFile"; }
ProxyWpadStatusCommand() { ssh $wpadServer cat "$wpadFile" | grep "PROXY" > /dev/null && echo "enabled" || echo "disabled"; }

run "$@"

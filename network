#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
usage: network adapter|current|cache|center|dns|internet|name|profile|proxy|run|vpn|workgroup"
	exit $1
}

init() 
{
	defaultCommand="center"

	noProxy="localhost,127.0.0.1,.$(ConfigGet "domain"),.releases.ubuntu.com"
	wpadServer="$(ConfigGet "web")" wpadFile="/share/Web/autoproxy/wpad.dat"

	adapterKey='HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Networkâ€‹'
	profileKey='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles/'
}


#
# commands
#

runCommand() { ssh "$1" 'source /etc/profile; '"${@:2}"''; }
centerCommand() {	start control /name Microsoft.NetworkAndSharingCenter; }
cacheCommand() { IsAvailable "$1" || return; net use '\\'$1'\ipc$' >& /dev/null; }
nameCommand() { registry edit 'HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/NetworkList/Profiles'; }

#
# Adapter Commands
#

adapterUsage() { echot "Usage: $(ScriptName) adapter edit|list|name
Network adapter commands."; }

adapterCommand() { usage; }

adapterEditCommand() { registry edit "$adapterKey"; }

adapterListCommand()
{
	! IsElevated && { RunScript --elevate network adapter list "$@"; return; }
	powershell.exe Get-NetAdapter | RemoveCarriageReturn | RemoveEmptyLines | tail -n +3
}

adapterNameArgs()
{
	ScriptArgGet "old" -- "$@"; shift
	ScriptArgGet "new" -- "$@"; shift
}

adapterNameCommand()
{ 
	! IsElevated && { RunScript --elevate -- network adapter name "$old" "$new"; return; }
	powershell.exe Rename-NetAdapter -Name \"$old\" -NewName \"$new\"
}

#
# Current Commands
#

currentUsage()
{
	echot "Usage: $(ScriptName) current name|update
Current network commands.

	name			name of the current network
	update		update network settings for the current network"
}

currentCommand() { currentNameCommand; }

currentNameCommand()
{
	network="external"

	local -A networks; eval networks=( $(ConfigGet "proxyNetworks") )

	for i in "${!networks[@]}"
	do
		local name="$i" ip="${networks[$i]}"

		# check if the IP is available, if it is see if the DNS server can resolve names 
		[[ ! $quiet ]] && printf "Checking $name ($ip)..."
		if IsAvailable "$ip" && dig @$ip bogus +time=1 +tries=1 >& /dev/null; then
			[[ ! $quiet ]] && echo "found"
			network="$name"
			break
		fi

	done
	[[ "$network" == "external" && ! $quiet ]] && echo "done"

	[[ $quiet ]] && echo "$network" || echo "The current network is $network"
}

currentUpdateCommand()
{
	local network existing="$(UpdateGet "network")"

	hilight "Determining network..."
	echo "Existing network is ${existing:-unknown}"
	! currentNameCommand && return

	hilight "Setting the network to $network..."

	UpdateSet "network" "$network" || return

	local file="$DATA/setup/resolv.conf.$network"
	[[ ! -f "$file" ]] && { EchoErr "network: could not find a network configuration file for $network"; return 1; }
	sudoc cp "$file" "/etc/resolv.conf"

	local status="disable"; [[ "$network" != "external" ]] && status="enable"
	UpdateSet "proxy" "$status" || return
	ScriptEval network proxy vars --$status || return
	network proxy apt --$status || return
	network proxy || return
}

#
# DNS Commands
#

dnsUsage() { echot "Usage: $(ScriptName) adapter edit|list|name
Network adapter commands."; }

dnsCommand() { dnsFlushCommand; }

dnsFlushCommand() 
{ 
	case "$PLATFORM" in
		win) ipconfig /flushdns;;
		mac) sudo killall -HUP mDNSResponder;;
	esac
}

#
# Internet Commands
#

internetUsage() { echot "Usage: $(ScriptName) internet address|provider [GATEWAY]
Internet commands.

	address						get the public internet address with the default or specified gateway
	provider [short]	get the internet provider name"
}

internetArgs()
{
	[[ $1 ]] && ScriptArgGet "gateway" -- "$@"
	return 0
}

internetCommand() { internetProviderCommand; }

internetAddressCommand() 
{
	if [[ ! $gateway ]]; then 
		nslookup myip.opendns.com resolver1.opendns.com | grep Address | grep -v 53 | cut -d: -f2 | RemoveSpace
		return
	fi

	# find the internet address for ther specified gateway
	# assumes the default gateway is a UniFi gateway named "router" 
	gateway="$(GetIpAddress "$gateway")"
	local dns; dns="$(GetIpAddress "resolver1.opendns.com")" || return

	! IsAvailablePort router 22 && { ScriptErr "the router is not available"; return 1; }
	
	credential get unifi admin | sshpass ssh router "$(cat <<-EOF
			sudo ip route add "$dns" via "$gateway"
			nslookup myip.opendns.com resolver1.opendns.com
			sudo ip route delete "$dns"
		EOF
	)" |& grep Address | grep -v 53 | cut -d: -f2 | RemoveSpace

}

internetProviderCommand()
{
	local address; address="$(internetAddressCommand)" || return
	whois "$address" | grep "OrgTechName" | head -1 | cut -d: -f2 | RemoveSpaceFront
}

internetProviderShortCommand() { internetProviderCommand | GetWord - 1 | LowerCase; }

#
# Profile Commands
#

profileUsage() { echot "Usage: $(ScriptName) profile edit|list|set
Network profile commands."; }

profileArgStart() { IsPlatform win && return; EchoErr "network: profile is only implemented for Windows"; return 1; }
profileCommand() { profileListCommand; }

profileEditCommand() { registry edit "$profileKey"; }

profileListCommand()
{
	! IsElevated && { RunScript --elevate network profile list "$@"; return; }

	local IFS=$'\n' name type category

	for key in $(registry get "$profileKey"); do
		name="$(registry get "$key/ProfileName" | RemoveCarriageReturn)"
		type="$(registry get "$key/NameType" | RemoveCarriageReturn)"
		category="$(registry get "$key/Category" | RemoveCarriageReturn)"

		case "$type" in
			0x6) type="Wired";;
			0x17) type="VPN";;
			0x47) type="Wireless";;
			0xF3) type="Mobile Broadband";;
		esac

		case "$category" in
			0x0) category="public";;
			0x1) category="private";;
			0x2) category="work";;
		esac

		echo "$name: $category $type"
	done
}

profileSetArgs() { ScriptArgGet "name" -- "$@"; shift; }

# profile set - if there is only one network profile, set it's name and make it a private network
profileSetCommand()
{
	! IsElevated && { RunScript --elevate network profile set "$name"; pause; return; }

	local numProfiles="$(registry get "$profileKey" | RemoveEmptyLines | wc -l)"

	(( $numProfiles > 1 )) && { EchoErr "Cannot set the profile if more than one exists"; return 1; }

	local key="$(registry get "$profileKey" | RemoveEmptyLines | head -1)"
	registry set "$key/ProfileName" REG_SZ "$name" || return
	registry set "$key/Category" REG_DWORD "1" || return # private
}

#
# VPN Commands
#

vpnUsage() { echot "Usage: $(ScriptName) workgroup on|off|status
VPN commands."; }

vpnArgStart() { IsPlatform win && return; EchoErr "network: VPN is only implemented for Windows"; return 1; }
vpnCommand() { vpnStatusCommand; }
vpnStatusCommand() { rasdial.exe; }

vpnOnCommand()
{
	rasdial.exe "vpn-$(ConfigGet "network")" "$USER" "$(credential get secure default)" || return
	currentUpdateCommand || return
}

vpnOffCommand()
{
	rasdial.exe "vpn-$(ConfigGet "network")" /disconnect || return
	currentUpdateCommand || return
}

#
# Workgroup Commands
#

workgroupUsage() { echot "Usage: $(ScriptName) workgroup name|set
SAMBA workgroup commands."; }

workgroupCommand() { workgroupNameCommand; }

workgroupNameCommand()
{ 
	if IsPlatform win; then
		net.exe config workstation | grep "Workstation domain" | RemoveCarriageReturn | awk '{ print $3; }'
	elif [[ -f "/etc/samba/smb.conf" ]]; then
		cat "/etc/samba/smb.conf" | grep -i "^[ 	]*workgroup[ 	]*=[ 	s]*" | cut -d "=" -f 2 | sed 's/ //g'
 	else
		echo "unknown"
	fi 
}

workgroupSetArgs() { [[ $1 ]] && ScriptArgGet "new" -- "$@"; return 0; }

workgroupSetCommand()
{
	local current="$(network workgroup name)"
	[[ ! $new ]] && { read -p "Enter new workgroup: " new; echo; }

	[[ ! $force && "$current" == "$new" ]] && return

	echo "The current workgroup is $current, setting the workgroup to $new..."

	if [[ -f "/etc/samba/smb.conf" ]]; then
		sudoc sed -i "s/^[        ]*workgroup[    ]*=.*$/workgroup = ${new}/" "/etc/samba/smb.conf" || return
	fi

	if IsPlatform win; then
		elevate RunScript --pause-error powershell Add-computer -WorkgroupName "$new" || return
	fi
	
	return 0
}

#
# proxy commands
#

proxyUsage()
{ 
	echot "Usage: $(ScriptName) proxy [apt|wpad|vars]
Network proxy server commands.

	-e, --enable
	-d, --disable
	-s, --status"
}

proxyArgStart()
{
	action="status"
	proxy="$(ConfigGet "proxy")"
	proxyVars="http_proxy,https_proxy,ftp_proxy,HTTP_PROXY,HTTPS_PROXY,FTP_PROXY"
	noProxyVars="no_proxy,NO_PROXY"	
	allVars="$proxyVars,$noProxyVars"
	aptFile="/etc/apt/apt.conf.d/proxy"	
}

proxyOpt() 
{
	case "$1" in
		-d|--disable) action="disable";;
		-e|--enable) action="enable";;
		-s|--status) action="status";;
		*) return 1
	esac
}

proxyArgs()
{
	[[ "$action" == "status" ]] && what="all" || what="vars"
	[[ "$1" =~ ^(apt|wpad|vars)$ ]] && { what="$1"; ((++shift)); }
	return 0
}

proxyCommand() { proxy${what^}${action^}; }

proxyAllStatus()
{
	echo "proxy=$(proxyVarsStatus)"
	[[ -d "/etc/apt" ]] && echo "apt proxy=$(proxyAptStatus)"
	return 0
}

proxyVarsEnable() { echo "export {$proxyVars}=\"$proxy/\"; eval export {$noProxyVars}=\"$noProxy\""; }
proxyVarsDisable() {	echo "unset {$allVars}; unset {$allVars}"; }
proxyVarsStatus() { (( $(export | grep -i 'proxy=\"http' | wc -l) > 1 )) && echo "enabled" || echo "disabled"; }

proxyAptEnable()
{
	[[ ! -d "/etc/apt" || -f "$aptFile" ]] && return
	echo "Acquire::http::Proxy \"$proxy\";
Acquire::https::Proxy \"$proxy\";" | sudo tee "$aptFile"
}

proxyAptDisable() { [[ ! -f "$aptFile" ]] && return; sudo rm "$aptFile"; }
proxyAptStatus() { [[ -f "$aptFile" ]] && echo "enabled" || echo "disabled"; }

proxyWpadEnable() { scp "$CLOUD/network/system/proxy/wpad.dat.enable" "$wpadServer:$wpadFile"; }
proxyWpadDisable() { scp "$CLOUD/network/system/proxy/wpad.dat.disable" "$wpadServer:$wpadFile"; }
proxyWpadStatus() { ssh $wpadServer cat "$wpadFile" | grep "PROXY" > /dev/null && echo "enabled" || echo "disabled"; }

ScriptRun "$@"

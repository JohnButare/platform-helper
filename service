#!/usr/bin/env bash
. function.sh || exit
. color.sh || return

usage()
{
	echot "\
usage: service [COMMAND](start) SERVICE [HOST]
	Control Windows services
	detail|exists|list|ListFile|log|StartType|show|state|status|running
	continue|pause|restart|start|stop				control service
	auto|delete|demand|disable|manual		 		configure service
	-f, 		--force 							force the service operation even if we the service shows to be in the correct state
	-h, 		--host 								host to check
	-nhc,		--no-host-check 			do not check for host availability
	-nsc,		--no-service-check		do not check for service existence
	-w, 		--wait								wait for the service to change state"
	exit $1
}

args()
{
	unset command force service host noHostCheck noServiceCheck wait 

	[[ $# == 0 ]] && { command="show"; return; }
	
	while (( $# != 0 )); do
		case "$1" in
			--force|-f) force="true";;
			--host|-h) host="$2"; shift;;
			--no-host-check|-nhc) noHostCheck="--no-host-check";;
			--no-service-check|-nsc) noServiceCheck="--no-service-check";;
			--wait|-w) wait="--wait";;
			--help) help="--help";;
			ListFile) command="listFile";; StartType) command="startType";;
			*)
				! IsOption "$1" && [[ ! $command ]] && { CheckCommand "$1"; command="${1,,}"; shift; continue; }
				! IsOption "$1" && [[ "$command" != @(list|ListFile) && ! $service ]] && { service="$1"; shift; continue; }
				! IsOption "$1" && [[ ! $host ]] && { host="$1"; shift; continue; }
				UnknownOption "$1"
		esac
		shift
	done

	[[ $help ]] && { IsFunction "${command}Usage" && ${command}Usage || usage 0; }
	
	args=("$@")
}

init()
{ 
	unset hostUnc hostDescription sudo type useSystemd

	# Windows Service (sc.exe) - fix SC data area error - http://www.dostips.com/forum/viewtopic.php?f=3&t=3408
	scBufferSize=5000 sc="sc.exe" # service command

	# service argument
	[[ ! $service && "$command" != @(list|ListFile|show) ]] && MissingOperand "service"

	# check remote host
	if [[ ! $noHostCheck && $host && "$host" != @(localhost|$HOSTNAME) ]]; then
		! IsAvailable "$host" && { EchoErr "service: $host is not available"; return 1; }
		hostUnc='\\'"$host"
		hostDescription=" on $host"
	fi
		
	# initialize service variables
	[[ "$command" != @(exists|list|ListFile|show) ]] && { initService || return; }

	# run with additional permissions if needed
	if [[ "$command" == @(auto|demand|disable|pause|stop) ]]; then

		# Windows elevation
		if IsPlatform win && ! isLinuxService "$service" && ! IsElevated; then
			elevate RunScript --pause-error service $command $wait $noServiceCheck $noHostCheck "$service" "$host"
			exit $?
		fi

	fi

	return 0
}

initService()
{
	[[ $noServiceCheck ]] && return 0

	type="${PLATFORM^}"

	case $PLATFORM in
		mac)
			config="$(macGetServices | grep "\/${service}\.plist$")" || { unknownService; return; }
			sudo=""; find "${macDaemons[@]}" -type f | grep "\/${service}\.plist$" >& /dev/null && sudo="sudoc"
			label="$(cat "$config" | grep '<string>' | head -1 | cut -d'>' -f 2 | cut -d '<' -f 1)"
			;;

		linux) 
			isLinuxService "$service" || { unknownService; return; }

			# use systemd if in the init process is is  PID 1
			ps -aux | head -2 | tail -1 | grep "init$" >& /dev/null && { useSystemd="true"; return; }

			[[ -f "/etc/init.d/$service" ]] && return
			
			EchoErr "service: unable to control $service"; return 1
			;;

		win)
			isLinuxService "$service" && { type="Linux"; return; }	

			local result="$(sc.exe $hostUnc query "$service" | RemoveCarriageReturn |& grep FAILED)"
			resultCode="${result#*FAILED }"; resultCode="${resultCode%%:}"

			case $resultCode in
				"") return 0;;
		  	5) echo "service: access to the service control manager denied on $host"; return 1;;
				1060) unknownService; return;;
				*) EchoErr "service: unknown error $resultCode accessing $service"; return 1;;
			esac
			;;

	esac

}

unknownService() 
{
	EchoErr "service: $service does not exist as an installed service$hostDescription"
	return 1
}

run() {	args "$@"; init || return; ${command}Command "${args[@]}"; }

#
# Helper Functions
#

macDaemons=( "/System/Library/LaunchDaemons" "/Library/LaunchDaemons" )
macAgents=( "/System/Library/LaunchAgents" "/Library/LaunchAgents" "$HOME/Library/LaunchAgents" )
macServices=( "${macDaemons[@]}" "${macAgents[@]}" )

macGetServices() { find "${macServices[@]}" -type f; }

checkElevated()
{
	! IsPlatform win && return
	
	if ! IsElevated && [[ "$host" == @(|localhost|$HOSTNAME) ]]; then
		elevate="true";
		return 0
	else
		elevate=""
		return 1
	fi
}

checkWaiting()
{
	unset waiting
	[[ ! $wait ]] && waiting="\n"
}

isLinuxService() { [[ -f "/etc/init.d/$1" || -f "/etc/systemd/system/$1.service" ]]; }

linuxService() # Linux Service Command - COMMAND SERVICE
{
	if IsPlatform wsl; then sudoc "/usr/sbin/service" "$2" "$1"
	elif [[ $useSystemd ]]; then sudoc systemctl "$1" "$2"
	else sudoc "/etc/init.d/$2" "$1"
	fi
}

waitForState()
{
	local seconds=30 state="$1"

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		[[ "$(stateCommand)" == "$state" ]] && { echo "$3 in $i seconds"; return 0; }
		printf "."
	done

	echo "did not $2 in $seconds seconds"; return 1
}

#
# Commands
#

existsCommand() { initService >& /dev/null; }
runningCommand() { [[ "$(stateCommand)" == "RUNNING" ]]; }
showCommand() { ! IsPlatform win && return; start services.msc; }

demandCommand() 
{	
	[[ "$type" != "win" ]] && { disableCommand; return; }

	[[ ! $force && "$(startTypeCommand)" == "DEMAND_START" ]] && return 
	$sc config $hostUnc "$service" start= demand; 
}

continueCommand()
{
	[[ "$type" != "win" ]] && { startCommand; return; }
	
	[[ ! $force && "$(stateCommand)" != "PAUSED" ]] && return 
	
	checkWaiting; printf "Continuing $service service$hostDescription..."$waiting
	result="$($sc $hostUnc continue "$service")" || { EchoErr "$result"; return 1; }
	[[ ! $wait ]] && return
	waitForState "RUNNING" "continue" "continued"
}

listFileCommand() 
{ 
	local file="$TMP/services.txt";
	printf "" > "$file" || return
	listCommand >> "$file" || return
	TextEdit "$file"
}

manualCommand()
{
	echo "Stopping $service service and setting it to demand start$hostDescription..."
	demandCommand || return
	stopCommand || return
	return 0
}

pauseCommand()
{
	[[ "$type" != "win" ]] && { stopCommand; return; }
	
	[[ ! $force && "$(stateCommand)" != "RUNNING" ]] && return 

	checkWaiting; printf "Pausing $service service$hostDescription..."$waiting
	result="$($sc $hostUnc pause "$service")" || { EchoErr "$result"; return 1; }
	[[ ! $wait ]] && return
	waitForState "PAUSED" "pause" "paused"
}

restartCommand() 
{ 
	local oldWait="$wait" wait="--wait"; noServiceCheck="--no-service-check"
	stopCommand || return
	wait="$oldWait"
	startCommand || return
	return 0
}

statusCommand()
{
	state="$(stateCommand)" || return
	startType="$(startTypeCommand)" || return
	echo "$service is $RED$state$RESET$hostDescription ($startType)"
}

#
# Auto Command
#

autoCommand() { [[ "$(startTypeCommand)" == "AUTO_START" ]] && return; auto$type; }
autoLinux() { linuxService enable "$service"; }
autoMac() { :; }
autoWin() {	$sc config $hostUnc "$service" start= auto; }

#
# Detail Command
#

detailCommand() { statusCommand && detail$type; }
detailLinux() { linuxService status "$service"; }

detailMac()
{
	echo "Service label is $RED$label$RESET"
	echo "$BLUE$config:$RESET"; sudoc cat "$config" || return
	[[ "$(stateCommand)" == "RUNNING" ]] && { echo "${BLUE}status:${RESET}"; $sudo launchctl list "$label" || return; }
}	

detailWin()
{
	$sc $hostUnc GetDisplayName "$service"
	$sc $hostUnc qdescription  "$service" $scBufferSize
	$sc $hostUnc queryex "$service" $scBufferSize
	$sc $hostUnc qc "$service" $SscBufferSize
	$sc $hostUnc qfailure "$service"
}

#
# Disable Command
#

disableCommand() { [[ "$(startTypeCommand)" == "DISABLED" ]] && return; disable$type; }
disableMac() { $sudo launchctl disable "$service"; }
disableWin() { $sc config $hostUnc "$service" start= disabled; }
disableLinux() { linuxService disable "$service"; }

#
# List Command
#

listCommand() { list${PLATFORM^}; }
listMac() { macGetServices | awk -F/ '{ print $(NF) }' | sed 's/.plist//' | sort; }
listWin() { $sc $hostUnc queryex bufsize= $scBufferSize type= all state= all; /usr/sbin/service --status-all; ls -1 "/etc/init.d/"; }

listLinux()
{
	{ ls -1 "/etc/init.d/"; [[ -d "/etc/systemd/system/" ]] && ls -1 "/etc/systemd/system/" | grep ".service$" | cut -d. -f 1; } | sort | uniq
}

#
# Log Command
#

logCommand() { log$type; }
logLinux() { sudoc journalctl -f -u "$service" -b; }
logMac() { :; }
logWin() { EventViewer; }

#
# Start Command
#

startCommand()
{
	[[ ! $force && "$(stateCommand)" != @(FAILED|STOPPED) ]] && return 

	checkWaiting; printf "Starting $service service$hostDescription...$waiting"
	start$type || return
	[[ ! $wait ]] && return
	waitForState RUNNING start started || return
}

startLinux() { linuxService start "$service"; }
startMac() { $sudo launchctl load -w "$config"; }
startWin() { local result; result="$($sc $hostUnc start "$service")" || { EchoErr "$result"; return 1; }; }

#
# State Command
#

stateCommand() { state$type; }

stateLinux()
{
	[[ ! $useSystemd ]] && { linuxService status "$service" | grep "is running" > /dev/null && echo "RUNNING" || echo "STOPPED"; return; }

	local status="$(linuxService status "$service" | head -3 | grep "^[ ]*Active:" | sed 's/^[ ]*//' | cut -d" " -f2-3)"

	[[ "$status" = "active (running)" ]] && { echo "RUNNING"; return; }
	[[ "$status" =~ ^failed.* ]] && { echo "FAILED"; return; }
	echo "STOPPED"; return; # Active: inactive	
}

stateMac() { { sudoc launchctl list; launchctl list; } | cut -f3 | grep "^${label}$" >& /dev/null && echo "RUNNING" || echo "STOPPED"; }

stateWin() { GetWord "$($sc $hostUnc query "$service" |& grep STATE)" 4; }

#
# Start Type Command
#

startTypeCommand() { startType$type; }

startTypeLinux()
{
	[[ ! $useSystemd ]] && { echo "unknown"; return; }
	linuxService status "$service" | grep -E "^[ ]*Loaded:" | grep "enabled;" >& /dev/null && echo "AUTO_START" || echo "DISABLED"
}

startTypeMac()
{
	if sudoc launchctl print-disabled system | grep "\"$service\" => true" >& /dev/null; then echo "DISABLED"
	elif sudoc launchctl print-disabled system | grep "\"$service\" => false"  >& /dev/null; then echo "AUTO_START"
	else echo "DEMAND"
	fi
}

startTypeWin() { GetWord "$($sc $hostUnc qc "$service" $ScBufferSize |& RemoveCarriageReturn | grep START_TYPE)" 4; }

#
# Stop Command
#

stopCommand()
{
	[[ ! $force && "$(stateCommand)" != "RUNNING" ]] && return 

	checkWaiting; printf "Stopping $service service$hostDescription..."$waiting
	stop$type || return
	[[ ! $wait ]] && return
	waitForState "STOPPED" "stop" "stopped"
}

stopLinux() { linuxService stop "$service"; }
stopMac() { $sudo launchctl unload "$config"; }
stopWin() { result="$($sc $hostUnc stop "$service")" || { EchoErr "$result"; return 1; }; }

run "$@"

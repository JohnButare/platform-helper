#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: service [OPTION]... [COMMAND](start) 
Control system services.

	continue|manage|pause|reload|restart|start|stop SERVICE			control service
	auto|delete|demand|disable|manual SERVICE		 								configure service
	detail|exists|log|StartType|state|status|running SERVICE	service information
	dir|list|refresh|ui

	-f, --force 						force the service operation even if the service seems to be in the correct state
	-H, --host=HOST					host to check
			--no-host-check 		do not check for host availability
			--no-service-check	do not check for service existence
	-q, --quiet							minimize output
	-w, --wait							wait for the service to change state"
	exit $1
}

init()
{ 
	sc="sc.exe" scBufferSize=5000 # fix sc data area error - http://www.dostips.com/forum/viewtopic.php?f=3&t=3408
}

argStart() { unset host hostArg ignoreHost noHostCheck noServiceCheck wait; unset service; }

opt()
{
	case "$1" in
		--host|-H|--host=*|-H=*) ScriptOptGet "host" "$@"; hostArg="--host=\"$host\"";;
		--ignore-host) ignoreHost="true";;
		--no-host-check|--nhc) noHostCheck="--no-host-check";;
		--no-service-check|--nsc) noServiceCheck="--no-service-check";;
		--wait|-w) wait="--wait";;
		*) return 1;;
	esac
}

args()
{
	[[ "$command" != @(dir|list|logClear|refresh|ui) ]] && { ScriptArgGet "service" -- "$@"; shift; }
	return 0
}

argEnd() { serviceInit; }

serviceInit()
{
	unset hostUnc hostDescription sudo type useSystemd

	# check remote host
	if IsLocalHost "$host"; then
		unset host
	else
		[[ ! $noHostCheck ]] && { HostAvailable "$host" || return; }
		hostUnc='\\'"$host"
		hostDescription=" on $host"
		ssh="SshHelper $host --interactive --pseudo-terminal ${globalArgs} --"
	fi

	# run on host - assumes service command exists on remote host
	[[ $host && ! $ignoreHost ]] && { RunLog $ssh service --ignore-host "${originalArgs[@]}"; exit $?; }

	# initialize service variables
	[[ $service ]] && { serviceCheck || return; }

	# run with additional permissions if needed
	if IsPlatform win && [[ "$command" == @(auto|delete|demand|disable|pause|stop) ]] && ! isLinuxService "$service" && ! IsElevated; then
		RunLog elevate RunScript --pause-error -- service "${originalArgs[@]}"; exit $?
	fi

	return 0
}

serviceCheck()
{
	# initialize - set _platform for subsequent commands
	_platform="$PLATFORM"

	# check
	case $PLATFORM in
		mac)
			config="$(macGetServices | grep "\/${service}\.plist$")" || { unknownService; return; }
			sudo=""; isMacSystemService "$service" && sudo="sudoc"
			label="$(cat "$config" | grep '<string>' | head -1 | cut -d'>' -f 2 | cut -d '<' -f 1)"
			;;

		linux) 
			checkSystemd || return
			! isLinuxService "$service" && { unknownService; return; }
			;;

		win)
			checkSystemd || return

			if isLinuxService "$service"; then
				log1 "service '$service' is a linux service"
				_platform="linux"
				return
			fi

			local result="$(sc.exe $hostUnc query "$service" | RemoveCarriageReturn |& grep FAILED)"
			resultCode="${result#*FAILED }"; resultCode="${resultCode%%:}"

			case $resultCode in
				"") return 0;;
		  	5) echo "service: access to the service control manager denied on $host"; return 1;;
				1060) unknownService; return;;
				*) EchoErr "service: unknown error $resultCode accessing $service"; return 1;;
			esac
			;;

	esac

	return 0
}

checkSystemd() { IsSystemd && useSystemd="true"; return 0; }
isMacSystemService() { find "${macDaemons[@]}" "${macSystemAgents[@]}" -type f | ${G}grep --quiet "\/${1}\.plist$"; }
getMacServicePrefix() { isMacSystemService "$1" && echo "system/";  return 0; }

unknownService() 
{
	[[ $noServiceCheck ]] && { exit 0; }
	[[ ! $quiet ]] && EchoErr "service: $service does not exist as an installed service$hostDescription"
	return 1
}

#
# Helper Functions
#

macDaemons=( "/System/Library/LaunchDaemons" "/Library/LaunchDaemons" )
macSystemAgents=( "/System/Library/LaunchAgents" "/Library/LaunchAgents" "$HOME/Library/LaunchAgents" )
macAgents=(  "${macSystemAgents[@]}" "$HOME/Library/LaunchAgents" )
macServices=( "${macDaemons[@]}" "${macAgents[@]}" )

macGetServices() { find "${macServices[@]}" -type f; }

checkElevated()
{
	! IsPlatform win && return
	
	if ! IsElevated && [[ "$host" == @(|localhost|$HOSTNAME) ]]; then
		elevate="true";
		return 0
	else
		elevate=""
		return 1
	fi
}

checkWaiting()
{
	unset waiting
	[[ ! $wait ]] && waiting="\n"
}

isLinuxService() { isInitdService "$1" || isSystemdService "$1"; }
isInitdService() { [[ -f "/etc/init.d/$1" ]] ; }

# isSystemdService NAME - NAME format is SERVICE_NAME[@SERVICE_INSTANCE]
isSystemdService()
{
	[[ $useSystemd ]] || return
	local name="$1" 
	[[ "$name" =~ @ && "$(RemoveBefore "$name" "@")" == "" ]] && return 1 # empty instance name not allowed
	[[ "$name" =~ @ ]] && name="$(RemoveAfter "$name" "@")@" # remove instance suffix
	[[ -f "/etc/systemd/system/$name.service" || -f "/lib/systemd/system/$name.service" ]]
}

linuxService() # Linux Service Command - COMMAND SERVICE
{
	sudov || return
	
	if IsPlatform wsl; then 
		[[ $1 == "auto" ]] && return
		RunLog sudo "/usr/sbin/service" "$2" "$1" > "$quietOutput"
	elif [[ $useSystemd ]]; then sudo systemctl "$1" "$2"
	else RunLog sudo "/etc/init.d/$2" "$1"
	fi
}

waitForState()
{
	local seconds=30 state="$1"

	[[ ! $wait ]] && return

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		[[ "$(stateCommand)" == "$state" ]] && { echo "$3 in $i seconds"; return 0; }
		printf "."
	done

	echo "did not $2 in $seconds seconds"; return 1
}

waitForStop()
{
	local seconds=30 state="$1"

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		[[ "$(stateCommand)" == "STOPPED" ]] && { echo "stopped in $i seconds"; return 0; }
 		[[ "$(stateCommand)" == "FAILED" ]] && { echo "failed in $i seconds"; return 0; }
		printf "."
	done

	echo "did not stop in $seconds seconds"; return 1
}

#
# Commands
#

existsCommand() { serviceCheck >& /dev/null; }
runningCommand() { [[ "$(stateCommand)" == "RUNNING" ]]; }
uiCommand() { ! IsPlatform win && return; start services.msc; }

dirCommand() { RunPlatform "dir" --host;  }
dirMac() { ArrayShow macServices; }

dirLinux()
{
	if IsSystemd; then
		[[ -d "/etc/systemd/system/" ]] && echo "/etc/systemd/system/"
		[[ -d "/lib/systemd/system/" ]] && echo "/lib/systemd/system/"
	fi

	[[ -d "/etc/init.d/" ]] && echo "/etc/init.d/"
}

demandCommand() 
{	
	! IsPlatform win && { disableCommand; return; }

	[[ ! $force && "$(startType)" == "DEMAND_START" ]] && return 
	$sc config $hostUnc "$service" start= demand; 
}

continueCommand()
{
	! IsPlatform win && { startCommand; return; }
	
	[[ ! $force && "$(stateCommand)" != "PAUSED" ]] && return 
	
	checkWaiting; [[ ! $quiet ]] && printf "Continuing $service service$hostDescription..."$waiting
	result="$($sc $hostUnc continue "$service")" || { EchoErr "$result"; return 1; }
	waitForState "RUNNING" "continue" "continued"
}

manualCommand()
{
	[[ ! $quiet ]] && echo "Stopping $service service and setting it to demand start$hostDescription..."
	demandCommand || return
	stopCommand || return
	return 0
}

pauseCommand()
{
	! IsPlatform win && { stopCommand; return; }
	
	[[ ! $force && "$(stateCommand)" != "RUNNING" ]] && return 

	checkWaiting; [[ ! $quiet ]] && printf "Pausing $service service$hostDescription..."$waiting
	result="$($sc $hostUnc pause "$service")" || { EchoErr "$result"; return 1; }
	waitForState "PAUSED" "pause" "paused"
}

refreshUsage()
{
	EchoWrap "Usage: $(ScriptName) refresh SERVICE
Load new services and reset failed services."
}

refreshCommand()
{
	! IsSystemd && return
	sudo systemctl daemon-reload && sudo systemctl reset-failed
}

reloadCommand()
{
	if [[ $useSystemd ]]; then
		sudo systemctl reload "$service" || return
	else
		restartCommand || return
	fi
}

restartCommand() 
{ 
	local oldWait="$wait" wait="--wait"
	stopCommand || return
	wait="$oldWait"
	startCommand || return
	return 0
}

statusCommand()
{
	state="$(stateCommand)" || return
	startType="$(startType)" || return
	echo "$service is $RED$state$RESET$hostDescription ($startType)"
}

#
# Auto Command
#

autoCommand() { [[ ! $force && "$(startType)" == "AUTO_START" ]] && return; RunPlatform "auto" --host; }
autoLinux() { linuxService enable "$service"; }
autoMac() { $sudo launchctl enable "$(getMacServicePrefix "$service")$service"; }
autoWin() {	$sc config $hostUnc "$service" start= auto; }

#
# Delete Command
#

deleteCommand() { stopCommand || return; disableCommand || return; RunPlatform "delete" --host; }
deleteWin() {	$sc delete $hostUnc "$service"; }

deleteLinux()
{
	[[ -f "/etc/systemd/system/$service.service" ]] && { sudo rm -f "/etc/systemd/system/$service.service" || return; }
	[[ -f "/lib/systemd/system/$service.service" ]] && { sudo rm -f "/lib/systemd/system/$service.service" || return; }
	sudo systemctl daemon-reload || return
	sudo systemctl reset-failed || return
}

#
# Detail Command
#

detailCommand() { statusCommand && RunPlatform "detail" --host; }

detailLinux()
{
	if [[ $useSystemd ]]; then
		if [[ -f "/lib/systemd/system/$service.service" ]]; then echo "systemd service: /lib/systemd/system/$service.service"
		elif [[ -f "/etc/systemd/system/$service.service" ]]; then echo "systemd service: /etc/systemd/system/$service.service"
		fi
	else
		[[ -f "/etc/init.d/$service" ]] && echo "init.d service: /etc/init.d/$service"
	fi

	linuxService status "$service"; 
}

detailMac()
{
	echo "Service label is $RED$label$RESET"
	echo "$BLUE$config:$RESET"; sudoc cat "$config" || return
	[[ "$(stateCommand)" == "RUNNING" ]] && { echo "${BLUE}status:${RESET}"; $sudo launchctl list "$label" || return; }
}	

detailWin()
{
	$sc $hostUnc GetDisplayName "$service"
	$sc $hostUnc qdescription  "$service" $scBufferSize
	$sc $hostUnc queryex "$service" $scBufferSize
	$sc $hostUnc qc "$service" $SscBufferSize
	$sc $hostUnc qfailure "$service"
}

#
# Disable Command
#

disableCommand() { [[ ! $force && "$(startType)" == "DISABLED" ]] && return; RunPlatform "disable" --host; }
disableMac() { $sudo launchctl disable "$(getMacServicePrefix "$service")$service"; }
disableWin() { $sc config $hostUnc "$service" start= disabled; }
disableLinux() { linuxService disable "$service"; }

#
# List Command
#

listUsage()
{
	EchoWrap "Usage: service list - list services

	-F, --file			show the services in a file"
}

listArgStart() { unset file; }

listOpt()
{
	case "$1" in
		-F|--file) file="true";;
		*) return 1
	esac
}

listCommand()
{
	[[ ! $file ]] && { RunPlatform "list"; return; }

	local file="$TMP/services.txt";
	printf "" > "$file" || return
	RunPlatform "list" >> "$file" || return
	TextEdit "$file"
}

listMac() { macGetServices | awk -F/ '{ print $(NF) }' | sed 's/.plist//' | sort; }
listWin() { $sc $hostUnc queryex bufsize= $scBufferSize type= all state= all; /usr/sbin/service --status-all; ls -1 "/etc/init.d/"; }

listLinux()
{
	local isSystemd; IsSystemd && isSystemd="true"
	{
		[[ -d "/etc/init.d" ]] && grep "force-reload" "/etc/init.d/"* --files-with-matches | cut -d'/' -f4;
		[[ $isSystemd && -d "/etc/systemd/system" ]] && ls -1 "/etc/systemd/system/" | grep ".service$" | cut -d. -f 1; 
		[[ $isSystemd && -d "/lib/systemd/system" ]] && ls -1 "/lib/systemd/system/" | grep ".service$" | cut -d. -f 1;
		[[ $isSystemd ]] && systemctl list-units --type=service --no-legend --full | tr -s " " | cut -d" " -f2 | cut -d. -f1;
	} | sort | uniq; 
}

#systemctl list-units --type=service --no-legend --full | tr -s " " | cut -d" " -f2 | cut -d. -f1;
		# [[ $isSystemd && -d "/etc/systemd/system" ]] && ls -1 "/etc/systemd/system/" | grep ".service$" | cut -d. -f 1; 
		# [[ $isSystemd && -d "/lib/systemd/system" ]] && ls -1 "/lib/systemd/system/" | grep ".service$" | cut -d. -f 1;

#
# Log Command
#

logUsage()
{
	EchoWrap "Usage: $(ScriptName) log [clear]
Log commands.

	-a, --all			show logs from start"
}

logArgStart() { unset all; }

logOpt() 
{
	case "$1" in
		-a|--all) all="--all";;
		*) return 1
	esac
}

logCommand() { RunPlatform "log" --host; }
logWin() { start eventvwr.msc; }

logLinux()
{
	local args=( )

	[[ ! $all ]] && args+=( "--follow" )
	RunLog $ssh sudoc journalctl -u "$service" "${args[@]}"; 
}

logClearCommand() { RunPlatform "logClear"; }
logClearLinux() { sudo journalctl --rotate && sudoc journalctl --vacuum-time=1s; }

#
# Start Command
#

manageUsage()
{
	EchoWrap "Usage: $(ScriptName) manage SERVICE
Start the service and display periodic output while the service is running.  Stop the service when SIGTERM is received.  This is useful to control service from orchestration engines such as Nomad."
}

manageCommand()
{
	local i=0 signal

	# start service
	echo "Service '$service' manager pid is $$"
	service start --wait "$service" || return
	TimerOn || return

	# traps
	trap "manageSignal SIGINT" SIGINT
	trap "manageSignal SIGTERM" SIGTERM
	trap "manageExit" EXIT

	# wait
	while true; do
		(( i % 60 == 0 )) && printf "\nThe '$service' service has been running for $(TimerOff)..." || printf "."; (( ++i ))
		[[ "$(service state "$service")" != "RUNNING" ]] && { printf "\nThe '$service' service stopped running...\n"; break; }		
		[[ ! $signal ]] && sleep 5 &
		wait; [[ $signal ]] && break
	done
}

manageExit()
{
	service stop "$service"
	echo "The '$service' service ran for $(TimerOff)"
}

manageSignal()
{
	signal="$1"
	printf "\nReceived $1...\n"
}

#
# Start Command
#

startCommand()
{
	[[ ! $force && "$(stateCommand)" != @(FAILED|STOPPED) ]] && return 

	checkWaiting; [[ ! $quiet ]] && printf "Starting $service service$hostDescription...$waiting"
	RunPlatform "start" --host || return
	waitForState RUNNING start started || return
}

startLinux() { linuxService start "$service"; }
startMac() { $sudo launchctl load -w "$config"; }
startWin() { local result; result="$($sc $hostUnc start "$service")" || { EchoErr "$result"; return 1; }; }

#
# State Command
#

stateCommand() { RunPlatform "state" --host; }

stateLinux()
{
	[[ ! $useSystemd ]] && { linuxService status "$service" | grep --quiet "is running" && echo "RUNNING" || echo "STOPPED"; return; }

	local status="$(linuxService status "$service" | head -3 | grep "^[ ]*Active:" | sed 's/^[ ]*//' | cut -d" " -f2-3)"
	[[ "$status" = "active (running)" ]] && { echo "RUNNING"; return; }
	[[ "$status" =~ ^failed.* ]] && { echo "FAILED"; return; }
	echo "STOPPED"; return; # Active: inactive	
}

stateMac()
{ 
	{ sudoc launchctl list; launchctl list; } | cut -f3 | ${G}grep --quiet "^${label}$" && echo "RUNNING" || echo "STOPPED"
}

stateWin()
{
	GetWord "$($sc $hostUnc query "$service" |& grep STATE)" 4
}

#
# Start Type Command
#

starttypeCommand() { startType; }
startType() { RunPlatform "startType" --host; }

startTypeLinux()
{
	[[ ! $useSystemd ]] && { echo "unknown"; return; }
	[[ "$(linuxService is-enabled "$service")" == "enabled" ]] && echo "AUTO_START" || echo "DISABLED"
}

startTypeMac()
{
	if sudoc launchctl print-disabled system | ${G}grep --quiet "\"$service\" => true"; then echo "DISABLED"
	elif sudoc launchctl print-disabled system | ${G}grep --quiet "\"$service\" => false"; then echo "AUTO_START"
	else echo "DEMAND"
	fi
}

startTypeWin()
{
	GetWord "$($sc $hostUnc qc "$service" $ScBufferSize |& RemoveCarriageReturn | grep START_TYPE)" 4
}

#
# Stop Command
#

stopCommand()
{
	[[ ! $force && "$(stateCommand)" != "RUNNING" ]] && return 

	checkWaiting; [[ ! $quiet ]] && printf "Stopping $service service$hostDescription..."$waiting
	RunPlatform "stop" --host || return
	[[ ! $wait ]] && return
	waitForStop
}

stopLinux() { linuxService stop "$service"; }
stopMac() { $sudo launchctl unload "$config"; }
stopWin() { result="$($sc $hostUnc stop "$service")" || { EchoErr "$result"; return 1; }; }

ScriptRun "$@"

#!/usr/bin/env bash
. script.sh || exit
. color.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: service [OPTION]... [COMMAND](start) 
Control system services.

	continue|manage|pause|reload|restart|start|stop SERVICE				control service
	auto|delete|demand|disable|manual SERVICE		 									configure service
	detail|exists|log|show|StartType|state|status|running SERVICE	service information
	dir|list|refresh|ui

	-f, --force 						force the service operation even if the service seems to be in the correct state
	-H, --host=HOST					host to check
			--no-host-check 		do not check for host availability
			--no-service-check	do not check for service existence
	-q, --quiet							minimize output
	-w, --wait							wait for the service to change state"
	exit $1
}

init()
{ 
	sc="sc.exe" scBufferSize=5000 # fix sc data area error - http://www.dostips.com/forum/viewtopic.php?f=3&t=3408
}

argStart() { unset -v host hostArg ignoreHost noHostCheck noServiceCheck wait; unset -v service; }

opt()
{
	case "$1" in
		--host|-H|--host=*|-H=*) ScriptOptGet "host" "$@"; hostArg="--host=\"$host\"";;
		--ignore-host) ignoreHost="--ignore-host";;
		--no-host-check|--nhc) noHostCheck="--no-host-check";;
		--no-service-check|--nsc) noServiceCheck="--no-service-check";;
		--wait|-w) wait="--wait";;
		*) return 1;;
	esac
}

args()
{
	[[ "$command" != @(dir|list|logClear|refresh|ui) ]] && { ScriptArgGet "service" -- "$@"; shift; }
	return 0
}

argEnd() { serviceInit; }

serviceInit()
{
	unset -v hostUnc hostDescription sudo type useSystemd

	# check remote host
	if IsLocalHost "$host"; then
		unset -v host
	else
		[[ ! $noHostCheck ]] && { HostAvailable "$host" || return; }
		hostUnc='\\'"$host"
		hostDescription=" on $host"
		ssh="SshHelper $host --interactive ${globalArgs} --"
	fi

	# run on host - assumes service command exists on remote host
	[[ $host && ! $ignoreHost ]] && { RunLog $ssh service --ignore-host "${originalArgs[@]}"; exit $?; }

	# initialize service variables
	[[ $service ]] && { serviceCheck || return; }

	return 0
}

serviceCheck()
{
	# initialize - set _platformOs for subsequent commands
	_platformOs="$PLATFORM_OS"

	# check
	case "$_platformOs" in
		mac)
			config="$(macGetServices | grep "\/${service}\.plist$")" || { unknownService; return; }
			sudo=""; isMacSystemService "$service" && sudo="sudoc"
			label="$(cat "$config" | grep '<string>' | head -1 | cut -d'>' -f 2 | cut -d '<' -f 1)"
			;;

		linux) 
			checkSystemd || return
			! isLinuxService "$service" && { unknownService; return; }
			;;

		win)
			checkSystemd || return

			if isLinuxService "$service"; then
				log1 "service '$service' is a linux service"
				_platformOs="linux"
				return
			fi

			local result="$(sc.exe $hostUnc query "$service" | RemoveCarriageReturn |& grep FAILED)"
			resultCode="${result#*FAILED }"; resultCode="${resultCode%%:}"

			case $resultCode in
				"") return 0;;
		  	5) echo "service: access to the service control manager denied on $host"; return 1;;
				1060) unknownService; return;;
				*) EchoErr "service: unknown error $resultCode accessing $service"; return 1;;
			esac
			;;

	esac

	return 0
}

checkSystemd() { IsSystemd && useSystemd="true"; return 0; }
isMacSystemService() { find "${macDaemons[@]}" "${macSystemAgents[@]}" -type f | ${G}grep --quiet "/$1.plist$"; }
getMacServicePrefix() { isMacSystemService "$1" && echo "system/";  return 0; }

unknownService() 
{
	[[ $noServiceCheck ]] && { exit 0; }
	[[ ! $quiet ]] && EchoErr "service: $service does not exist as an installed service$hostDescription"
	return 1
}

#
# commands
#

existsCommand() { serviceCheck >& /dev/null; }
runningCommand() { [[ "$(stateCommand)" == "RUNNING" ]]; }
uiCommand() { ! IsPlatform win && return; start services.msc; }

dirCommand() { RunPlatform "dir" --host;  }
dirMac() { ArrayShow macServices; }

dirLinux()
{
	if IsSystemd; then
		[[ -d "/etc/systemd/system/" ]] && echo "/etc/systemd/system/"
		[[ -d "/lib/systemd/system/" ]] && echo "/lib/systemd/system/"
	fi

	[[ -d "/etc/init.d/" ]] && echo "/etc/init.d/"
}

demandCommand() 
{	
	if IsPlatform win; then
		doCommand "demand"
	else
		disableCommand
	fi
}

demandWin() { local result; result="$($sc config $hostUnc "$service" start= demand)" && return; EchoErr "$result"; return 1; }

manualCommand()
{
	[[ ! $quiet ]] && echo "Stopping $service service and setting it to demand start$hostDescription..."
	demandCommand || return
	stopCommand || return
	return 0
}

refreshUsage()
{
	EchoWrap "Usage: $(ScriptName) refresh SERVICE
Load new services and reset failed services."
}

refreshCommand()
{
	! IsSystemd && return
	sudo systemctl daemon-reload && sudo systemctl reset-failed
}

reloadCommand()
{
	if [[ $useSystemd ]]; then
		sudoc systemctl reload "$service" || return
	else
		restartCommand || return
	fi
}

restartCommand() 
{ 
	local oldWait="$wait" wait="--wait"
	stopCommand || return
	wait="$oldWait"
	startCommand || return
	return 0
}

statusCommand()
{
	state="$(stateCommand)" || return
	startType="$(startType)" || return
	echo "$service is $RED$state$RESET$hostDescription ($startType)"
}

#
# auto command
#

autoCommand() { doCommand "auto"; }
autoLinux() { linuxService enable "$service"; }
autoMac() { $sudo launchctl enable "$(getMacServicePrefix "$service")$service"; }
autoWin() { local result; result="$($sc config $hostUnc "$service" start= auto)" && return; EchoErr "$result"; return 1; }

#
# continue command
#

continueCommand()
{
	if IsPlatform win; then
		doCommand "continue"
	else
		startCommand
	fi	
}

continueWin() { local result; result="$($sc $hostUnc continue "$service")" && return; EchoErr "$result"; return 1; }

#
# delete command
#

deleteCommand() { stopCommand && disableCommand && RunPlatform "delete" --host; }
deleteWin() {	$sc delete $hostUnc "$service"; }

deleteLinux()
{
	[[ -f "/etc/systemd/system/$service.service" ]] && { sudo rm -f "/etc/systemd/system/$service.service" || return; }
	[[ -f "/lib/systemd/system/$service.service" ]] && { sudo rm -f "/lib/systemd/system/$service.service" || return; }
	sudo systemctl daemon-reload || return
	sudo systemctl reset-failed || return
}

#
# detail command
#

detailCommand() { statusCommand && RunPlatform "detail" --host; }

detailLinux()
{
	if [[ $useSystemd ]]; then
		if [[ -f "/lib/systemd/system/$service.service" ]]; then echo "systemd service: /lib/systemd/system/$service.service"
		elif [[ -f "/etc/systemd/system/$service.service" ]]; then echo "systemd service: /etc/systemd/system/$service.service"
		fi
	else
		[[ -f "/etc/init.d/$service" ]] && echo "init.d service: /etc/init.d/$service"
	fi

	linuxService status "$service"; 
}

detailMac()
{
	echo "Service label is $RED$label$RESET"
	echo "$BLUE$config:$RESET"; sudoc cat "$config" || return
	[[ "$(stateCommand)" == "RUNNING" ]] && { echo "${BLUE}status:${RESET}"; $sudo launchctl list "$label" || return; }
}	

detailWin()
{
	$sc $hostUnc GetDisplayName "$service"
	$sc $hostUnc qdescription  "$service" $scBufferSize
	$sc $hostUnc queryex "$service" $scBufferSize
	$sc $hostUnc qc "$service" $SscBufferSize
	$sc $hostUnc qfailure "$service"
}

#
# disable command
#

disableCommand() { doCommand "disable"; }
disableMac() { $sudo launchctl disable "$(getMacServicePrefix "$service")$service"; }
disableWin() { $sc config $hostUnc "$service" start= disabled; }
disableLinux() { linuxService disable "$service"; }

#
# list command
#

listUsage()
{
	EchoWrap "Usage: service list - list services

	-F, --file			show the services in a file"
}

listArgStart() { unset -v file; }

listOpt()
{
	case "$1" in
		-F|--file) file="true";;
		*) return 1
	esac
}

listCommand()
{
	[[ ! $file ]] && { RunPlatform "list"; return; }

	local file="$TMP/services.txt";
	printf "" > "$file" || return
	RunPlatform "list" >> "$file" || return
	TextEdit "$file"
}

listMac() { macGetServices | awk -F/ '{ print $(NF) }' | sed 's/.plist//' | sort; }
listWin() { $sc $hostUnc queryex bufsize= $scBufferSize type= all state= all; /usr/sbin/service --status-all; ls -1 "/etc/init.d/"; }

listLinux()
{
	local isSystemd; IsSystemd && isSystemd="true"
	{
		[[ -d "/etc/init.d" ]] && grep "force-reload" "/etc/init.d/"* --files-with-matches | cut -d'/' -f4;
		[[ $isSystemd && -d "/etc/systemd/system" ]] && ls -1 "/etc/systemd/system/" | grep ".service$" |  sed 's/.service$//'; 
		[[ $isSystemd && -d "/lib/systemd/system" ]] && ls -1 "/lib/systemd/system/" | grep ".service$" |  sed 's/.service$//';
		[[ $isSystemd ]] && systemctl list-units --type=service --no-legend --full | tr -s " " | cut -d" " -f1 |  sed 's/.service$//';
		[[ $isSystemd ]] && systemctl list-units --type=target --no-legend --full | tr -s " " | cut -d" " -f1;
	} | sort | uniq; 
}

#
# log command
#

logUsage()
{
	EchoWrap "Usage: $(ScriptName) log [clear]
Log commands.

	-a, --all					show logs from start
	-np, --no-pager		do not use a pager"
}

logArgStart() { unset -v all noPager; }

logOpt() 
{
	case "$1" in
		-a|--all) all="--all";;
		-np|--no-pager) noPager="--no-pager";;
		*) return 1
	esac
}

logCommand() { RunPlatform "log" --host; }
logWin() { start eventvwr.msc; }

logLinux()
{
	local args=( )

	[[ ! $all && ! $noPager ]] && args+=( "--follow" )
	[[ $noPager ]] && args+=( "--no-pager" )
	RunLog $ssh sudoc journalctl -u "$service" "${args[@]}"; 
}

logClearCommand() { RunPlatform "logClear"; }
logClearLinux() { sudo journalctl --rotate && sudoc journalctl --vacuum-time=1s; }

#
# manage command
#

manageUsage()
{
	EchoWrap "Usage: $(ScriptName) manage SERVICE
Start the service and display periodic output while the service is running.  Stop the service when SIGTERM is received.  This is useful to control service from orchestration engines such as Nomad."
}

manageArgStart() { unset -v noStopService noWaitService; }

manageOpt() 
{
	case "$1" in
		--no-stop-service) noStopService="--no-stop-service";;
		--no-wait-service) noWaitService="--no-wait-service";;
		*) return 1
	esac
}

manageCommand()
{
	local i=0 stopSignal

	# start service
	local args=(); [[ ! $noWaitService ]] && args+=(--wait)
	echo "Service '$service' manager pid is $$"
	service start "${args[@]}" "$service" || return
	TimerOn || return

	# traps
	trap "manageSignal SIGINT" SIGINT
	trap "manageSignal SIGTERM" SIGTERM
	trap "manageExit" EXIT

	# wait
	while true; do
		(( i % 60 == 0 )) && printf "\nThe '$service' service has been running for $(TimerOff)..." || printf "."; (( ++i ))
		[[ ! $noWaitService && "$(service state "$service")" != "RUNNING" ]] && { printf "\nThe '$service' service stopped running...\n"; break; }		
		[[ ! $stopSignal ]] && sleep 5 &
		wait; [[ $stopSignal ]] && break
	done
}

manageExit()
{
	[[ ! $noStopService ]] && service stop "$service"
	echo "The '$service' service ran for $(TimerOff)"
}

manageSignal()
{
	stopSignal="$1"
	printf "\nReceived $stopSignal...\n"
}

#
# pause command
#

pauseCommand()
{
	if IsPlatform win; then
		doCommandWait "pause"
	else
		stopCommand
	fi
}

pauseWin() { local result; result="$($sc $hostUnc pause "$service")" && return; EchoErr "$result"; return 1; }

#
# start command
#

startCommand() { doCommandWait "start"; }
startLinux() { linuxService start "$service"; }
startMac() { $sudo launchctl load -w "$config"; }
startWin() { local result; result="$($sc $hostUnc start "$service")" && return; EchoErr "$result"; return 1; }

#
# State Command
#

stateUsage()
{
	EchoWrap "Usage: $(ScriptName) state
Show service state, one of RUNNING, STOPPED, FAILED, or PAUSED."
}

stateCommand() { RunPlatform "state" --host; }

stateLinux()
{
	[[ ! $useSystemd ]] && { linuxService status "$service" | grep --quiet "is running" && echo "RUNNING" || echo "STOPPED"; return; }

	local status="$(linuxService status "$service" | head -3 | grep "^[ ]*Active:" | sed 's/^[ ]*//' | cut -d" " -f2-3)"
	[[ "$status" = "active (running)" ]] && { echo "RUNNING"; return; }
	[[ "$status" =~ ^failed.* ]] && { echo "FAILED"; return; }
	echo "STOPPED"; return; # Active: inactive	
}

stateMac()
{ 
	{ sudoc launchctl list; launchctl list; } | cut -f3 | ${G}grep --quiet "^${label}$" && echo "RUNNING" || echo "STOPPED"
}

stateWin()
{
	GetWord "$($sc $hostUnc query "$service" |& grep STATE)" 4
}

#
# show command
#

showUsage() { EchoWrap "Usage: $(ScriptName) show active|start\nShow service information."; }
showCommand() { RunPlatform show; }
showLinux() { [[ ! $useSystemd ]] && return; systemctl show "$service"; }

showActiveUsage() { EchoWrap "Usage: $(ScriptName) show active\nShow time service became active."; }
showActiveCommand() { RunPlatform showActive; }
showActiveLinux() { getProp "ActiveEnterTimestamp"; }

showStartUsage() { EchoWrap "Usage: $(ScriptName) show start\nShow service start time."; }
showStartCommand() { RunPlatform showStart; }
showStartLinux() { local result="$(getProp "ExecMainStartTimestamp")"; [[ $result ]] && { echo $result; return; }; showActiveLinux; }

getProp() { showCommand | grep "^$1=" | cut -d= -f2; }

#
# Start Type Command
#

starttypeUsage()
{
	EchoWrap "Usage: $(ScriptName) StartType
Show service start type, one of AUTO_START, DISABLED, or DEMAND_START."
}

starttypeCommand() { startType; }
startType() { RunPlatform "startType" --host; }

startTypeLinux()
{
	[[ ! $useSystemd ]] && { echo "unknown"; return; }
	[[ "$(linuxService is-enabled "$service")" == "enabled" ]] && echo "AUTO_START" || echo "DISABLED"
}

startTypeMac()
{
	if sudoc launchctl print-disabled system | ${G}grep --quiet "\"$service\" => true"; then echo "DISABLED"
	elif sudoc launchctl print-disabled system | ${G}grep --quiet "\"$service\" => false"; then echo "AUTO_START"
	else echo "DEMAND_START"
	fi
}

startTypeWin()
{
	GetWord "$($sc $hostUnc qc "$service" $ScBufferSize |& RemoveCarriageReturn | grep START_TYPE)" 4
}

#
# Stop Command
#

stopCommand() { doCommandWait "stop"; }
stopLinux() { linuxService stop "$service"; }
stopMac() { $sudo launchctl unload "$config"; }
stopWin() { local result="$($sc $hostUnc stop "$service")" && return; EchoErr "$result"; return 1; }

#
# helper
#

doCommand() { local command="$1"; checkState "$command" && return; doCommandRun "$command"; }
doCommandWait() { local command="$1"; checkState "$command" && return; waitStart "$command" && doCommandRun "$command" --host && waitEnd "$command"; }

doCommandRun()
{
	local command="$1"

	# run command with additional permissions if needed
	if IsPlatform win && ! isLinuxService "$service" && ! IsElevated; then
		! CanElevate && { ScriptErrQuiet "unable to elevate"; return 1; }
		RunLog elevate RunScript --pause-error -- service $command $service $noHostCheck $noServiceCheck "${globalArgs[@]}"
		return
	fi

	# run command
	RunPlatform "$command" --host
}

macDaemons=( "/System/Library/LaunchDaemons" "/Library/LaunchDaemons" )
macSystemAgents=( "/System/Library/LaunchAgents" "/Library/LaunchAgents" "$HOME/Library/LaunchAgents" )
macAgents=(  "${macSystemAgents[@]}" "$HOME/Library/LaunchAgents" )
macServices=( "${macDaemons[@]}" "${macAgents[@]}" )

macGetServices() { find "${macServices[@]}" -type f; }

checkElevated()
{
	! IsPlatform win && return
	
	if ! IsElevated && [[ "$host" == @(|localhost|$HOSTNAME) ]]; then
		elevate="true";
		return 0
	else
		elevate=""
		return 1
	fi
}

isLinuxService() { isInitdService "$1" || isSystemdService "$1"; }
isInitdService() { [[ -f "/etc/init.d/$1" ]] ; }

# isSystemdService NAME - NAME format is SERVICE_NAME[@SERVICE_INSTANCE]
isSystemdService()
{
	local name="$1"; [[ $useSystemd ]] || return

	# service or service@instance exists explicitly
	[[ -f "/etc/systemd/system/$name.service" || -f "/lib/systemd/system/$name.service" ]] && return

	# service with an instance name
	[[ "$name" =~ @ && "$(RemoveBefore "$name" "@")" == "" ]] && return 1 # empty instance name not allowed
	[[ "$name" =~ @ ]] && name="$(RemoveAfter "$name" "@")@" # remove instance suffix
	[[ -f "/etc/systemd/system/$name.service" || -f "/lib/systemd/system/$name.service" ]] && return

	# static units
	systemctl is-enabled "$service" >& /dev/null
}

# linuxService - COMMAND SERVICE
linuxService() 
{
	local command="$1" service="$2"

	sudov || return
	
	# WSL
	if IsPlatform wsl; then 
		[[ "$command" == "enable" ]] && return
		local quiet="/dev/null"; [[ "$command" == "status" ]] && quiet="/dev/stdout"
		RunLog sudo "/usr/sbin/service" "$service" "$command" > "$quiet"

	# systemd
	elif [[ $useSystemd ]]; then
		sudo systemctl "$command" "$service"

	# init.d
	else 
		RunLog sudo "/etc/init.d/$service" "$command"

	fi
}

#
# helper - checkState
#

# checkState - return true if the command is in the desired state
checkState() { local command="$1"; [[ ! $force ]] && RunFunction "checkState" "$command"; }

checkStateAuto() { [[ "$(startType)" == "AUTO_START" ]]; }
checkStateDemand() { ! IsPlatform win && { checkStateDisabled; return; }; [[ "$(startType)" == "DEMAND_START" ]]; }
checkStateDisable() { [[ "$(startType)" == "DISABLED" ]]; }

checkStateContinue() { ! IsPlatform win && { checkStateStart; return; }; [[ "$(stateCommand)" != "RUNNING" ]]; }
checkStatePause() { ! IsPlatform win && { checkStateStop; return; }; [[ "$(stateCommand)" != "PAUSED" ]]; }
checkStateStart() { [[ "$(stateCommand)" != @(FAILED|STOPPED) ]]; }
checkStateStop() { [[ "$(stateCommand)" != "RUNNING" ]]; }

#
# helper - wait
#

waitNeeded() { IsFunction "waitForState${command^}"; }

waitStart() 
{	
	! waitNeeded && return
	local desc="${command^}ing"; [[ "$command" == "stop" ]] && desc="Stopping"
	[[ ! $quiet ]] && printf "$desc $service service$hostDescription..."
	return 0
}

# waitEnd
waitEnd()
{
	! waitNeeded && return
	[[ ! $wait ]] && { [[ ! $quiet ]] && echo done; return 0; }
	RunFunction waitForState "$command"
}

waitForStateContinue() { waitForState "RUNNING" "continue" "continued"; }
waitForStatePause() { waitForState "PAUSED" "pause";}
waitForStateStart() { waitForState "RUNNING" "start" "started"; }
waitForStateStop() { waitForState  "STOPPED|FAILED" "stop"; }

# waitForState STATE PRESENT [PAST](finalState)
waitForState()
{
	local seconds=30 state="$1" present="$2" past="$3"

	[[ ! $wait ]] && return

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		local currentState="$(stateCommand)"
 		[[ "$currentState" =~ ^($state)$ ]] && { [[ ! $quiet ]] && echo "${past:-${currentState,,}} in $i seconds"; return 0; }
		printf "."
	done

	[[ ! $quiet ]] && echo "did not $present in $seconds seconds";
	return 1
}

ScriptRun "$@"

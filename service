#!/usr/bin/env bash
. script.sh || exit
. color.sh || return

run() {	init && args "$@" && serviceInit && "${command}Command" "${args[@]}"; }

init()
{ 
	scBufferSize=5000 sc="sc.exe" # sc - data area error - http://www.dostips.com/forum/viewtopic.php?f=3&t=3408
}

usage()
{
	ScriptUsage "$1" "\
Usage: service [OPTION]... [COMMAND](start) 
Control system services.

	continue|pause|reload|restart|start|stop SERVICE					control service
	auto|delete|demand|disable|manual SERVICE		 							configure service
	detail|exists|log|StartType|state|status|running SERVICE	service information
	list|ui

	-f, 		--force 						force the service operation even if the 
																service seems to be in the correct state
	-H, 		--host=HOST					host to check
					--no-host-check 		do not check for host availability
					--no-service-check	do not check for service existence
	-q, 		--quiet							minimize output
	-w, 		--wait							wait for the service to change state"
	exit $1
}

args()
{
	unset force host hostArg noHostCheck noServiceCheck quiet wait
	unset command service

	# commands
	ScriptCommand "$@" || return

	# options
	set -- "${args[@]}"; args=()
	while (( $# != 0 )); do		
		case "$1" in "") : ;;
			-f|--force|-f) force="--force";;
			-h|--help) usage 0;;
			-H|--host|-H*|--host=*) ScriptArg "host" "$@"; hostArg="--host=\"$host\"";;
			--nhc|--no-host-check) noHostCheck="--no-host-check";;
			--nsc|--no-service-check) noServiceCheck="--no-service-check";;
			-q|--quiet) quiet="--quiet";;
			-w|--wait) wait="--wait";;
			-h|--help) help="--help";;
			*) ScriptOption "$@";;
		esac
		shift "$shift"; shift=1
	done
	set -- "${args[@]}"

	# arguments
	ScriptArgs "$@" || return; shift "$shift"
	[[ "$command" != @(list|ui) ]] && { ScriptGetArg "service" "$1"; shift; }
	[[ $@ ]] && usage

	return 0
}

serviceInit()
{
	unset hostUnc hostDescription sudo type useSystemd
		
	# check remote host
	if [[ ! $noHostCheck ]] && ! IsLocalHost "$host"; then
		! IsAvailable "$host" && { ScriptErr "$host is not available"; return 1; }
		hostUnc='\\'"$host"
		hostDescription=" on $host"
	fi

	# initialize service variables
	[[ "$command" != @(exists|list|ui) ]] && { serviceCheck || return; }

	# run with additional permissions if needed
	if IsPlatform win && [[ "$command" == @(auto|delete|demand|disable|pause|stop) ]]; then

		# Windows elevation
		if ! isLinuxService "$service" && ! IsElevated; then			
			elevate RunScript --pause-error -- service $command "$service" $force $hostArg $noHostCheck $noServiceCheck $quiet $wait
			exit $?
		fi

	fi

	return 0
}

serviceCheck()
{
	[[ $noServiceCheck ]] && return 0

	case $PLATFORM in
		mac)
			config="$(macGetServices | grep "\/${service}\.plist$")" || { unknownService; return; }
			sudo=""; find "${macDaemons[@]}" -type f | grep "\/${service}\.plist$" >& /dev/null && sudo="sudoc"
			label="$(cat "$config" | grep '<string>' | head -1 | cut -d'>' -f 2 | cut -d '<' -f 1)"
			;;

		linux) 
			checkSystemd || return
			! isLinuxService "$service" && { unknownService; return; }
			;;

		win)
			checkSystemd || return
			isLinuxService "$service" && { ALT_PLATFORM="linux"; return; }

			local result="$(sc.exe $hostUnc query "$service" | RemoveCarriageReturn |& grep FAILED)"
			resultCode="${result#*FAILED }"; resultCode="${resultCode%%:}"

			case $resultCode in
				"") return 0;;
		  	5) echo "service: access to the service control manager denied on $host"; return 1;;
				1060) unknownService; return;;
				*) EchoErr "service: unknown error $resultCode accessing $service"; return 1;;
			esac
			;;

	esac

	return 0
}

checkSystemd() { IsSystemd && useSystemd="true"; return 0; }

unknownService() 
{
	[[ ! $quiet ]] && EchoErr "service: $service does not exist as an installed service$hostDescription"
	return 1
}

#
# Helper Functions
#

macDaemons=( "/System/Library/LaunchDaemons" "/Library/LaunchDaemons" )
macAgents=( "/System/Library/LaunchAgents" "/Library/LaunchAgents" "$HOME/Library/LaunchAgents" )
macServices=( "${macDaemons[@]}" "${macAgents[@]}" )

macGetServices() { find "${macServices[@]}" -type f; }

checkElevated()
{
	! IsPlatform win && return
	
	if ! IsElevated && [[ "$host" == @(|localhost|$HOSTNAME) ]]; then
		elevate="true";
		return 0
	else
		elevate=""
		return 1
	fi
}

checkWaiting()
{
	unset waiting
	[[ ! $wait ]] && waiting="\n"
}

isLinuxService() { isInitdService "$1" || isSystemdService "$1"; }
isInitdService() { [[ -f "/etc/init.d/$1" ]] ; }
isSystemdService() { [[ -f "/etc/systemd/system/$1.service" ]]; }

linuxService() # Linux Service Command - COMMAND SERVICE
{
	local sudo="sudoc"; [[ "$1" == @(status) ]] && sudo=""

	if IsPlatform wsl; then $sudo "/usr/sbin/service" "$2" "$1"
	elif [[ $useSystemd ]]; then $sudo systemctl "$1" "$2"
	else $sudo "/etc/init.d/$2" "$1"
	fi
}

waitForState()
{
	local seconds=30 state="$1"

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		[[ "$(stateCommand)" == "$state" ]] && { echo "$3 in $i seconds"; return 0; }
		printf "."
	done

	echo "did not $2 in $seconds seconds"; return 1
}

waitForStop()
{
	local seconds=30 state="$1"

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		[[ "$(stateCommand)" == "STOPPED" ]] && { echo "stopped in $i seconds"; return 0; }
 		[[ "$(stateCommand)" == "FAILED" ]] && { echo "failed in $i seconds"; return 0; }
		printf "."
	done

	echo "did not stop in $seconds seconds"; return 1
}

#
# Commands
#

existsCommand() { serviceCheck >& /dev/null; }
runningCommand() { [[ "$(stateCommand)" == "RUNNING" ]]; }
uiCommand() { ! IsPlatform win && return; start services.msc; }

demandCommand() 
{	
	! IsPlatform win && { disableCommand; return; }

	[[ ! $force && "$(startTypeCommand)" == "DEMAND_START" ]] && return 
	$sc config $hostUnc "$service" start= demand; 
}

continueCommand()
{
	! IsPlatform win && { startCommand; return; }
	
	[[ ! $force && "$(stateCommand)" != "PAUSED" ]] && return 
	
	checkWaiting; printf "Continuing $service service$hostDescription..."$waiting
	result="$($sc $hostUnc continue "$service")" || { EchoErr "$result"; return 1; }
	[[ ! $wait ]] && return
	waitForState "RUNNING" "continue" "continued"
}

manualCommand()
{
	echo "Stopping $service service and setting it to demand start$hostDescription..."
	demandCommand || return
	stopCommand || return
	return 0
}

pauseCommand()
{
	! IsPlatform win && { stopCommand; return; }
	
	[[ ! $force && "$(stateCommand)" != "RUNNING" ]] && return 

	checkWaiting; printf "Pausing $service service$hostDescription..."$waiting
	result="$($sc $hostUnc pause "$service")" || { EchoErr "$result"; return 1; }
	[[ ! $wait ]] && return
	waitForState "PAUSED" "pause" "paused"
}

reloadCommand()
{
	if [[ $useSystemd ]]; then
		sudo systemctl daemon-reload || return
		sudo systemctl reset-failed || return
		sudo systemctl reload "$service" || return
	else
		restartCommand || return
	fi
}

restartCommand() 
{ 
	local oldWait="$wait" wait="--wait"; noServiceCheck="--no-service-check"
	stopCommand || return
	wait="$oldWait"
	startCommand || return
	return 0
}

statusCommand()
{
	state="$(stateCommand)" || return
	startType="$(startTypeCommand)" || return
	echo "$service is $RED$state$RESET$hostDescription ($startType)"
}

#
# Auto Command
#

autoCommand() { [[ ! $force && "$(startTypeCommand)" == "AUTO_START" ]] && return; RunPlatform "auto"; }
autoLinux() { linuxService enable "$service"; }
autoWin() {	$sc config $hostUnc "$service" start= auto; }

#
# Delete Command
#

deleteCommand() { stopCommand || return; disableCommand || return; RunPlatform "delete"; }
deleteWin() {	$sc delete $hostUnc "$service"; }

deleteLinux()
{
	sudo rm -f "/etc/systemd/system/$service.service" || return
	sudo systemctl daemon-reload || return
	sudo systemctl reset-failed || return
}

#
# Detail Command
#

detailCommand() { statusCommand && RunPlatform "detail"; }
detailLinux() { linuxService status "$service"; }

detailMac()
{
	echo "Service label is $RED$label$RESET"
	echo "$BLUE$config:$RESET"; sudoc cat "$config" || return
	[[ "$(stateCommand)" == "RUNNING" ]] && { echo "${BLUE}status:${RESET}"; $sudo launchctl list "$label" || return; }
}	

detailWin()
{
	$sc $hostUnc GetDisplayName "$service"
	$sc $hostUnc qdescription  "$service" $scBufferSize
	$sc $hostUnc queryex "$service" $scBufferSize
	$sc $hostUnc qc "$service" $SscBufferSize
	$sc $hostUnc qfailure "$service"
}

#
# Disable Command
#

disableCommand() { [[ ! $force && "$(startTypeCommand)" == "DISABLED" ]] && return; RunPlatform "disable"; }
disableMac() { $sudo launchctl disable "$service"; }
disableWin() { $sc config $hostUnc "$service" start= disabled; }
disableLinux() { linuxService disable "$service"; }

#
# List Command
#

listVars() { unset file; }

listUsage()
{
	echo "\
Usage: service list - list services
	-F, --file			show the services in a file"
}

listOption()
{
	case "$1" in
		-F|--file) file="true";;
		*) return 1
	esac
}

listCommand()
{
	[[ ! $file ]] && { RunPlatform "list"; return; }

	local file="$TMP/services.txt";
	printf "" > "$file" || return
	RunPlatform "list" >> "$file" || return
	TextEdit "$file"
}

listLinux() {	{ ls -1 "/etc/init.d/"; [[ -d "/etc/systemd/system/" ]] && ls -1 "/etc/systemd/system/" | grep ".service$" | cut -d. -f 1; } | sort | uniq; }
listMac() { macGetServices | awk -F/ '{ print $(NF) }' | sed 's/.plist//' | sort; }
listWin() { $sc $hostUnc queryex bufsize= $scBufferSize type= all state= all; /usr/sbin/service --status-all; ls -1 "/etc/init.d/"; }

#
# Log Command
#

logCommand() { RunPlatform "log"; }
logLinux() { sudoc journalctl -f -u "$service" -b; }
logWin() { start eventvwr.msc; }

#
# Start Command
#

startCommand()
{
	[[ ! $force && "$(stateCommand)" != @(FAILED|STOPPED) ]] && return 

	checkWaiting; printf "Starting $service service$hostDescription...$waiting"
	RunPlatform "start" || return
	[[ ! $wait ]] && return
	waitForState RUNNING start started || return
}

startLinux() { linuxService start "$service"; }
startMac() { $sudo launchctl load -w "$config"; }
startWin() { local result; result="$($sc $hostUnc start "$service")" || { EchoErr "$result"; return 1; }; }

#
# State Command
#

stateCommand() { RunPlatform "state"; }

stateLinux()
{
	[[ ! $useSystemd ]] && { linuxService status "$service" | grep "is running" > /dev/null && echo "RUNNING" || echo "STOPPED"; return; }

	local status="$(linuxService status "$service" | head -3 | grep "^[ ]*Active:" | sed 's/^[ ]*//' | cut -d" " -f2-3)"

	[[ "$status" = "active (running)" ]] && { echo "RUNNING"; return; }
	[[ "$status" =~ ^failed.* ]] && { echo "FAILED"; return; }
	echo "STOPPED"; return; # Active: inactive	
}

stateMac()
{ 
	{ sudoc launchctl list; launchctl list; } | cut -f3 | grep "^${label}$" >& /dev/null && echo "RUNNING" || echo "STOPPED"
}

stateWin()
{
	GetWord "$($sc $hostUnc query "$service" |& grep STATE)" 4
}

#
# Start Type Command
#

startTypeCommand() { RunPlatform "startType"; }

startTypeLinux()
{
	[[ ! $useSystemd ]] && { echo "unknown"; return; }
	linuxService status "$service" | grep -E "^[ ]*Loaded:" | grep "enabled;" >& /dev/null && echo "AUTO_START" || echo "DISABLED"
}

startTypeMac()
{
	if sudoc launchctl print-disabled system | grep "\"$service\" => true" >& /dev/null; then echo "DISABLED"
	elif sudoc launchctl print-disabled system | grep "\"$service\" => false"  >& /dev/null; then echo "AUTO_START"
	else echo "DEMAND"
	fi
}

startTypeWin()
{
	GetWord "$($sc $hostUnc qc "$service" $ScBufferSize |& RemoveCarriageReturn | grep START_TYPE)" 4
}

#
# Stop Command
#

stopCommand()
{
	[[ ! $force && "$(stateCommand)" != "RUNNING" ]] && return 

	checkWaiting; printf "Stopping $service service$hostDescription..."$waiting
	RunPlatform "stop" || return
	[[ ! $wait ]] && return
	waitForStop
}

stopLinux() { linuxService stop "$service"; }
stopMac() { $sudo launchctl unload "$config"; }
stopWin() { result="$($sc $hostUnc stop "$service")" || { EchoErr "$result"; return 1; }; }

run "$@"

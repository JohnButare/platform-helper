#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script color || exit

usage()
{
	ScriptUsage "$1" "\
Usage: service [OPTION]... [COMMAND](start) 
Control system services.

	continue|manage|pause|restart|start|stop SERVICE										control service
	IsLoaded|load|reload|unload SERVICE																	control service
	auto|boot|delete|demand|disable|manual SERVICE		 									configure service
	detail|exists|info|log|show|StartType|state|status|running SERVICE	service information
	dir|install|list|refresh|ui																					other commands

	auto|demand|disable start|stop	configure and control service, i.e. service auto start SERVICE

	-f, --force 						force the service operation even if the service seems to be in the correct state
	-H, --host=HOST					host to check
			--no-host-check 		do not check for host availability
			--no-service-check	do not check for service existence
	-q, --quiet							minimize output
	-w, --wait							wait for the service to change state"
	exit $1
}

init()
{ 
	sc="sc.exe" scBufferSize=5000 # fix sc data area error - http://www.dostips.com/forum/viewtopic.php?f=3&t=3408
}

argStart() { unset -v host hostArg ignoreHost noHostCheck noServiceCheck wait; unset -v service; }

opt()
{
	case "$1" in
		--host|-H|--host=*|-H=*) ScriptOptGet "host" "$@"; hostArg="--host=\"$host\"";;
		--ignore-host) ignoreHost="--ignore-host";;
		--no-host-check|--nhc) noHostCheck="--no-host-check";;
		--no-service-check|--nsc) noServiceCheck="--no-service-check";;
		--wait|-w) wait="--wait";;
		*) return 1;;
	esac
}

args()
{
	local logClear=""; IsPlatform linux && logClear="logClear"
	[[ "$command" == @(dir|infoAll|infoDump|install|list*|$logClear|refresh|ui) ]] && return
	ScriptArgGet "service" -- "$@";
}

argEnd() { unset macServiceFiles; serviceInit; }

serviceInit()
{
	unset -v hostUnc hostDescription sudo type useSystemd

	# check remote host
	if IsLocalHost "$host"; then
		unset -v host
	else
		[[ ! $noHostCheck ]] && { HostAvailable "$host" || return; }
		hostUnc='\\'"$host"
		hostDescription=" on $host"
		ssh="SshHelper $host --interactive ${globalArgs} --"
	fi

	# run on host - assumes service command exists on remote host
	[[ $host && ! $ignoreHost ]] && { RunLog $ssh service --ignore-host "${originalArgs[@]}"; exit $?; }

	# initialize service variables
	[[ $service ]] && { serviceCheck "$service" || return; }

	return 0
}

# serviceCheck SERVICE - initialize the service
serviceCheck()
{
	# initialize
	service="$1" serviceOriginal="$1"
	_platformOs="$PLATFORM_OS" # set _platformOs for subsequent commands
	
	# check
	case "$_platformOs" in

		mac)
			local serviceNameOk
			unset macService macServiceFile macServiceFileContent macServiceFileValidated

			# service is file (i.e. a property list file)
			if [[ -f "$service" ]]; then
				macServiceFile="$service"
				service="$(macServiceFileGetServiceName)" || return
			fi

			# check loaded services then services on disk
			if ! getMacServiceInfo && [[ ! $macServiceFile ]]; then # sets macServiceDomain, macServiceInfo, and macServiceLoaded
				quiet="--quiet" getMacServiceFile || { unknownService; return; }
				service="$(macServiceFileGetServiceName)" || return
				getMacServiceInfo # try and get the loaded service information with the new service name
			fi 

			# get the service domain if possible
			if [[ ! $macServiceDomain ]]; then				
				if [[ "$(infoTypeMac)" == "LaunchDaemon" ]]; then macServiceDomain="system/" # launch daemons must be in the system/ doamin
				elif [[ "$macServiceFile" =~ ^/Users/ ]]; then macServiceDomain="user/$UID/"
				else macServiceDomain="unknown"						
				fi
			fi

			# finalize
			[[ $macServiceDomain ]] && macService="$macServiceDomain$service"
			sudo=""; [[ "$macServiceDomain" == "system/" ]] && sudo="sudoc"
			log1 "service=$service macService=$macService domain=$macServiceDomain loaded=$macServiceLoaded sudo=$sudo"
			;;

		linux) 
			checkSystemd || return
			isLinuxService "$service" || { unknownService; return; }
			;;

		win)
			checkSystemd || return

			if isLinuxService "$service"; then
				log1 "service '$service' is a linux service"
				_platformOs="linux"
				return
			fi

			local result="$(sc.exe $hostUnc query "$service" | RemoveCarriageReturn |& grep FAILED)"
			resultCode="${result#*FAILED }"; resultCode="${resultCode%%:}"

			case $resultCode in
				"") return 0;;
		  	5) echo "service: access to the service control manager denied on $host"; return 1;;
				1060) unknownService; return;;
				*) EchoErr "service: unknown error $resultCode accessing $service"; return 1;;
			esac
			;;

	esac

	# logging
	[[ "$serviceOriginal" != "$service" ]] && log1 "using actual service name '$service'"

	return 0
}

unknownService() 
{
	[[ $noServiceCheck ]] && { exit 0; }
	[[ ! $quiet ]] && EchoErr "service: $service does not exist as an installed service$hostDescription"
	return 1
}

#
# commands
#

existsCommand() { serviceCheck "$service" >& /dev/null; }
runningCommand() { [[ "$(stateCommand)" == "RUNNING" ]]; }
uiCommand() { ! IsPlatform win && return; start services.msc; }

autoStartCommand() { autoCommand && startCommand; }
demandStopCommand() { demandCommand && stopCommand; }
disableStopCommand() { disableCommand && stopCommand; }

dirCommand() { RunPlatformOs "dir" --host;  }
dirMac() { ArrayShow macServices; }
dirWin() { dirLinux; }

dirLinux()
{	
	if IsSystemd; then
		[[ -d "/etc/systemd/system/" ]] && echo "/etc/systemd/system/"
		[[ -d "/lib/systemd/system/" ]] && echo "/lib/systemd/system/"
	elif [[ -d "/etc/init.d/" ]]; then
		echo "/etc/init.d/"
	fi
}

bootCommand() {	! isWinService "$service" && return; doCommand "boot"; }
bootWin() { local result; result="$($sc config $hostUnc "$service" start= boot)" && return; EchoErr "$result"; return 1; }

demandCommand() {	doCommand "demand"; }
demandLinux() { disableLinux; }
demandMac() {	macServiceFileWrite "Disabled" "false" && macServiceFileWrite "RunAtLoad" "false"; }
demandWin() { local result; result="$($sc config $hostUnc "$service" start= demand)" && return; EchoErr "$result"; return 1; }

manualCommand()
{
	[[ ! $quiet ]] && echo "Stopping $service service and setting it to demand start$hostDescription..."
	demandCommand || return
	stopCommand || return
	return 0
}

refreshUsage()
{
	EchoWrap "Usage: $(ScriptName) refresh SERVICE
Load new services and reset failed services."
}

refreshCommand() { RunPlatformOs refresh; }

refreshLinux()
{
	! IsSystemd && return
	sudo systemctl daemon-reload && sudo systemctl reset-failed
}

restartCommand() 
{ 
	local oldWait="$wait" wait="--wait"
	stopCommand || return
	wait="$oldWait"
	startCommand || return
	return 0
}

statusCommand()
{
	local loaded state startType
	loaded="$(isLoadedCommand)" || return; [[ $loaded ]] && loaded+=" "
	state="$(stateCommand)" || return
	startType="$(startType)" || return
	echo "$service is $RED$state$RESET$hostDescription ($loaded$startType)"
}

#
# auto command
#

autoCommand() { doCommand "auto"; }
autoLinux() { linuxService enable "$service"; }
autoMac() {	macServiceFileWrite "Disabled" "false" && macServiceFileWrite "RunAtLoad" "true"; }
autoWin() { local result; result="$($sc config $hostUnc "$service" start= auto)" && return; EchoErr "$result"; return 1; }

#
# continue command
#

continueCommand()
{
	if isWinService "$service"; then
		doCommand "continue"
	else
		startCommand
	fi	
}

continueWin() { local result; result="$($sc $hostUnc continue "$service")" && return; EchoErr "$result"; return 1; }

#
# delete command
#

deleteCommand() { stopCommand && disableCommand && RunPlatformOs "delete" --host; }
deleteWin() {	$sc delete $hostUnc "$service"; }

deleteLinux()
{
	[[ -f "/etc/systemd/system/$service.service" ]] && { sudo rm -f "/etc/systemd/system/$service.service" || return; }
	[[ -f "/lib/systemd/system/$service.service" ]] && { sudo rm -f "/lib/systemd/system/$service.service" || return; }
	sudo systemctl daemon-reload || return
	sudo systemctl reset-failed || return
}

#
# detail command
#

detailUsage() { EchoWrap "Usage: $(ScriptName) detail [brief]\nShow service detail, optionally in a concise format."; }
detailCommand() { statusCommand && RunPlatformOs "detail" --host; }
detailBriefCommand() { brief="brief" RunPlatformOs "detail" --host; }

detailLinux()
{	
	echo "$(infoTypeLinux) service: $(infoFileLinux)"
	linuxService status "$service" || return
}

detailMac()
{
	# detailed information
	local sep=$'\n'; [[ $brief ]] && sep=" "
	getMacServiceFile
	echo -e "macService=$macService${sep}file=$macServiceFile${sep}domain=$macServiceDomain${sep}loaded=$macServiceLoaded${sep}sudo=$sudo"
	
	# service definition
	[[ ! $brief ]] && { hilight "Service Definition"; infoFileContentsCommand || return; }

	# service info
	[[ ! $brief && $macServiceLoaded ]] && { hilight "Service Information"; echo "$macServiceInfo"; }

	return 0
}

detailWin()
{
	$sc $hostUnc GetDisplayName "$service"
	$sc $hostUnc qdescription  "$service" $scBufferSize
	$sc $hostUnc queryex "$service" $scBufferSize
	$sc $hostUnc qc "$service" $SscBufferSize
	$sc $hostUnc qfailure "$service"
}

#
# disable command
#

disableCommand() { RunPlatformOs "disable"; }
disableLinux() { linuxService disable "$service"; }
disableMac() { macServiceFileWrite "Disabled" "true"; }
disableWin() { $sc config $hostUnc "$service" start= disabled; }

#
# install command
#

installUsage() {	ScriptUsageEcho "Usage: service install FILE\nInstall a service from a file."; }
installArgs() { ScriptArgGet "file" -- "$@" && ScriptCheckFile "$file"; }
installCommand() { RunPlatformOs "install"; }

installMac()
{
	local dest="/Library/LaunchDaemons" exists
	local fileName="$(GetFileName "$file")"
	local destFile="$dest/$fileName"

	# validate service file
	macServiceFileValidateDo "$file" || return

	# remove existing service file
	if [[ -f "$destFile" ]]; then
		[[ ! $force ]] && { ScriptErrQuiet "the service file '$destFile' exists, use --force to overwrite it"; return 1; }
		sudoc rm "$destFile" || return
		exists="true"
	fi

	# copy
	sudoc cp "$file" "$dest" || return
	$sudo chmod +r "$destFile" || return

	# reload
	[[ $exists ]] && { service reload "$destFile" || return; }

	return 0
}

#
# list command
#

listUsage()
{
	ScriptUsageEcho "\
Usage: service list [files|running|unloaded]
List services.

	-d, --detail		show more detail about the services
	-F, --file			show the services in a file"
}

listArgStart() { unset -v detail file; }

listOpt()
{
	case "$1" in
		-d|--detail) detail="true";;
		-F|--file) file="true";;
		*) return 1
	esac
}

listCommand()
{
	[[ ! $file ]] && { RunPlatformOs "list"; return; }

	local file="$TMP/services.txt";
	printf "" > "$file" || return
	RunPlatformOs "list" >> "$file" || return
	TextEdit "$file"
}

listLinux()
{
	if IsSystemd; then
		{
			[[ -d "/etc/systemd/system" ]] && command ls -1 "/etc/systemd/system/" | grep ".service$"; 
			[[ -d "/lib/systemd/system" ]] && command ls -1 "/lib/systemd/system/" | grep ".service$";
			systemctl list-units --type=service,target --no-legend --full --plain | cut -d" " -f1;
		} | grep -v "@.service$" | sed 's/.service$//' | sort | uniq; # @.service are templates
	elif [[ -d "/etc/init.d" ]]; then
		grep "force-reload" "/etc/init.d/"* --files-with-matches | cut -d'/' -f4
	fi
}

listMac()
{ 
	{ 
		{ launchctl list; sudoc launchctl list; } | cut -d"	" -f3 | ${G}grep -v "^Label$"		# loaded services
		listFilesMac | rev | ${G}cut -d$'/' -f1 | cut -d"." -f2- | rev 											# unloaded services
	} | sort | uniq; 
}

listWin()
{
	[[ $detail ]] && { listWinDetail; return; }
	{ listLinux; sc.exe queryex | grep "^SERVICE_NAME: " | cut -d" " -f2; } | sort | uniq
}

listWinDetail()
{
	header "Windows"; $sc $hostUnc queryex bufsize= $scBufferSize type= all state= all
	if IsSystemd; then header "Systemd"; listLinux
	elif [[ -d "/etc/init.d" ]]; then header "Init"; /usr/sbin/service --status-all
	fi 
}

listFilesUsage() { ScriptUsageEcho "Usage: $(ScriptName) list files\nList files associated with all services."; }
listFilesCommand() { RunPlatformOs listFiles; }
listFilesMac() { find "${macServices[@]}" -type f | sort | uniq; }

listRunningUsage() { ScriptUsageEcho "Usage: $(ScriptName) list running [user|system]\nList running services."; }
listRunningCommand() { RunPlatformOs listRunning; }
listRunningMac() { { launchctl list; sudoc launchctl list; } | grep -v "^-" | cut -d"	" -f3 | sort | uniq; }
listRunningUserCommand() { RunPlatformOs listRunningUser; }
listRunningUserMac() { launchctl list | grep -v "^-" | cut -d"	" -f3 | sort; }
listRunningSystemCommand() { RunPlatformOs listRunningSystem; }
listRunningSystemMac() { sudoc launchctl list | grep -v "^-" | cut -d"	" -f3 | sort ; }

listUnloadedUsage() { ScriptUsageEcho "Usage: $(ScriptName) list unloaded [files]\nList unloaded services."; }
listUnloadedArgStart() { unset files; }
listUnloadedCommand() { RunPlatformOs listUnloaded; }
listUnloadedFilesCommand() { files="files" RunPlatformOs listUnloaded; }

listUnloadedMac()
{
	# loaded services 
	local loaded="$({ launchctl list; sudoc launchctl list; } | cut -d"	" -f3 | ${G}grep -v "^Label$" | sort | uniq)"

	# service files - format FILE:SERVICE
	local both="$(eval "$(service list files | awk '{ print "printf " $0" ; printf : ; defaults read " $0 " Label" }')" 2>/dev/null)"
	local services="$(echo "$both" | cut -d':' -f2 | sort | uniq)"

	# services that are not loaded
	services="$(comm -23 <(echo "$services") <(echo "$loaded"))"

	# return services
	[[ ! $files ]] && { echo "$services"; return; }

	# return service files
	echo "$both" | ${G}grep -f <(echo "$services") | sort
}

#
# load commands
#

loadUsage() { EchoWrap "Usage: $(ScriptName) load SERVICE\nLoad the service."; }
loadCommand() { runStatus "load" "loading"; }
loadNotNeededMac() { [[ $macServiceLoaded || ! $macServiceDomain ]] || ! getMacServiceFile; }
loadMac() {	$sudo launchctl bootstrap "$macServiceDomain" "$macServiceFile"; }

# loadValidateMac - validate and load the service, return error if cannot load
loadValidateMac() 
{ 
	[[ $macServiceLoaded ]] && return
	[[ ! $macServiceDomain ]] && { ScriptErr "unable to load service '$service', domain is unknown"; return 1; }
	! getMacServiceFile && { ScriptErr "unable to load service '$service', unable to get the service configuration file"; return 1; }
	printf "loading..."; loadMac
}

isLoadedUsage() { EchoWrap "Usage: $(ScriptName) IsLoaded SERVICE\nReturn LOADED or UNLOADED."; }
isLoadedCommand() { RunPlatformOs isLoaded && printf "LOADED" || printf "UNLOADED"; }
isLoadedMac() {	[[ $macServiceLoaded ]]; }

reloadUsage() { EchoWrap "Usage: $(ScriptName) reload SERVICE\nReload the service to pickup any configuration changes."; }
reloadCommand() { runStatus reload "reloading"; }
reloadNotNeededLinux() { [[ ! $useSystemd ]]; }
reloadNotNeededMac() { [[ ! $macServiceDomain ]] || ! getMacServiceFile; } 
reloadLinux() { sudoc systemctl reload "$service"; }
reloadMac() {	! unloadNotNeededMac && { printf "unloading..."; unloadMac &> /dev/null; }; printf "loading..."; loadMac &> /dev/null; }

unloadUsage() { EchoWrap "Usage: $(ScriptName) unload SERVICE\nUnload the service."; }
unloadCommand() { runStatus "unload" "unloading"; }
unloadNotNeededMac() { [[ ! $macServiceLoaded || ! $macServiceDomain ]] || ! getMacServiceFile; }
unloadMac() { $sudo launchctl bootout "$macServiceDomain" "$macServiceFile"; }

#
# log command
#

logUsage()
{
	EchoWrap "Usage: $(ScriptName) log [clear]
Log commands.

	-a, --all					show logs from start
	-e, --error				show error log
	-np, --no-pager		do not use a pager"
}

logArgStart() { unset -v all error noPager; }

logOpt() 
{
	case "$1" in
		-a|--all) all="--all";;
		-e|--error) error="--error";;
		-np|--no-pager) noPager="--no-pager";;
		*) return 1
	esac
}

logCommand() { RunPlatformOs "log" --host; }

logLinux()
{
	local args=( )

	[[ ! $all && ! $noPager ]] && args+=( "--follow" )
	[[ $noPager ]] && args+=( "--no-pager" )
	RunLog $ssh sudoc journalctl -u "$service" "${args[@]}"; 
}

logMac()
{
	local stderr stdout; logMacFind
	local command="LogShow"; [[ $noPager ]] && command="cat"
	local file="$stdout"; [[ $error ]] && file="$stderr"
	logValidate "$file" && "$command" "$file"
}

logWin() { start eventvwr.msc; }

logClearCommand() { RunPlatformWin "logClear"; }

logClearLinux() { sudo journalctl --rotate && sudoc journalctl --vacuum-time=1s; }

logClearMac()
{
	local stderr stdout; logMacFind
	[[ -f "$stdout" ]] && sudoc truncate -s 0 "$stdout"
	[[ -f "$stderr" ]] && sudoc truncate -s 0 "$stderr"
	return 0
}

# helper

logMacFind()
{
	local content="$(getMacServiceFileContent)"
	if getMacServiceFile; then
		stdout="$(quiet="--quiet" macServiceFileRead "StandardOutPath")"
		stderr="$(quiet="--quiet" macServiceFileRead "StandardErrorPath")"
	elif [[ "$content" != "unknown" ]]; then
		stdout="$(echo "$content" | grep "stdout path" | cut -d"=" -f2 | RemoveSpaceTrim)"
		stderr="$(echo "$content" | grep "stderr path" | cut -d"=" -f2 | RemoveSpaceTrim)"
	fi
}

# logValidate FILE - validate log file
logValidate()
{
	[[ -f "$file" ]] && return
	ScriptErr "unable to find the log file for the '$service' service"
}

#
# manage command
#

manageUsage()
{
	EchoWrap "Usage: $(ScriptName) manage SERVICE
Start the service and display periodic output while the service is running.  Stop the service when SIGTERM is received.  Restart the service if it stops.  This is useful to control service from orchestration engines such as Nomad.

	-no-stop-service			do not stop the service if we stop
	-retries N						number of times to try and start the service"

}

manageArgStart() { unset -v noStopService nowaitService; retriesArg="5"; }

manageOpt() 
{
	case "$1" in
		--no-stop-service) noStopService="--no-stop-service";;
		--no-wait-service) nowaitService="--no-wait-service";;
		--retries) ScriptArgGet "retriesArg" --integer -- "$@";;
		*) return 1
	esac
}

manageCommand()
{
	local stopSignal

	# start service
	echo "Service '$service' manager pid is $$"

	# traps
	trap "manageSignal SIGINT" SIGINT
	trap "manageSignal SIGTERM" SIGTERM
	trap "manageExit" EXIT

	# wait
	local seconds=0 sleepSeconds=5 statusSeconds=120 try tryLimit=5; TimerOn
	while true; do

		# get service state
		local state; state="$(service state "$service" "${globalArgsLessVerbose[@]}")" || return

		# status every two minutes
		if (( seconds % statusSeconds == 0 )); then
			printf "\nThe '$service' service has been $state for $(TimerOff)..."
		elif [[ ! $verbose ]]; then
			printf "."	
		else
			log1 "state=$state seconds=$seconds for=$(TimerStatus) try=$try tryLimit=$tryLimit sleepSeconds=$sleepSeconds statusSeconds=$statusSeconds"
		fi

		# service is now running
		if [[ "$state" == "RUNNING" && $try ]]; then
			unset -v try; seconds=0; TimerOn

		# service is now not running
		elif [[ "$state" != "RUNNING" && ! $try ]]; then
			 try=1; seconds=0; TimerOn; echo
			 service start "$service" "${globalArgsLessVerbose[@]}"

		# service is still not running, at try limit
		elif [[ "$state" != "RUNNING" ]] && (( try >= tryLimit )); then
			printf "\nThe '$service' could not be started after $tryLimit tries, exiting"
			return 1
	
		# service is still not running, try and start it every minute
		elif [[ "$state" != "RUNNING" ]] && (( seconds % 60 == 0 )); then
			  (( ++try )); echo
			  service start "$service" "${globalArgsLessVerbose[@]}"

		fi

		# sleep if we have not been signaled, break if we are signaled
		[[ ! $stopSignal ]] && sleep $sleepSeconds &
		wait; [[ $stopSignal ]] && return		
		(( seconds+=$sleepSeconds ))

	done
}

manageExit()
{
	[[ ! $noStopService ]] && service stop "$service" "${globalArgs[@]}"
	echo "The '$service' service ran for $(TimerOff)"
}

manageSignal()
{
	stopSignal="$1"
	printf "\nReceived $stopSignal...\n"
}

#
# pause command
#

pauseCommand()
{
	if isWinService "$service"; then
		doCommandWait "pause"
	else
		stopCommand
	fi
}

pauseWin() { local result; result="$($sc $hostUnc pause "$service")" && return; EchoErr "$result"; return 1; }

#
# start command
#

startCommand() { doCommandWait "start"; }
startLinux() { linuxService start "$service"; }
startWin() { local result; result="$($sc $hostUnc start "$service")" && return; EchoErr "$result"; return 1; }
startMac() { loadValidateMac && RunLog $sudo launchctl start "$service"; }

#
# State Command
#

stateUsage()
{
	EchoWrap "Usage: $(ScriptName) state
Show service state, one of RUNNING, STOPPED, FAILED, or PAUSED."
}

stateCommand() { RunPlatformWin "state" --host; }

stateLinux()
{
	[[ ! $useSystemd ]] && { linuxService status "$service" | grep --quiet "is running" && echo "RUNNING" || echo "STOPPED"; return; }

	local status="$(linuxService status "$service" | head -3 | grep "^[ ]*Active:" | sed 's/^[ ]*//' | cut -d" " -f2-3)"
	[[ "$status" = "active (running)" ]] && { echo "RUNNING"; return; }
	[[ "$status" =~ ^failed.* ]] && { echo "FAILED"; return; }
	echo "STOPPED"; return; # Active: inactive	
}

stateMac()
{
	[[ ! $macServiceLoaded ]] && { echo "STOPPED"; return; }

	# macServiceInfo state - exited, not running, running, or uninitialized
	local state; state="$(echo "$macServiceInfo" | ${G}grep "^	state = " | ${G}cut -d"=" -f2 | RemoveSpaceTrim)" || return

	# running
	[[ "$state" == "running" ]] && { echo "RUNNING"; return; }

	# failed - lastExitCode != 0
	local lastExitCode; lastExitCode="$(echo "$macServiceInfo" | ${G}grep "^	last exit code = " | ${G}cut -d"=" -f2)"
	IsInteger "$lastExitCode" && [[ "$lastExitCode" != "0" ]] && { echo "FAILED"; return; }

	# stopped
	echo "STOPPED"
}

stateWin()
{
	GetWord "$($sc $hostUnc query "$service" |& grep STATE)" 4
}

#
# show command
#

showUsage() { EchoWrap "Usage: $(ScriptName) show active|start\nShow service information."; }
showCommand() { RunPlatformWin show; }
showLinux() { [[ ! $useSystemd ]] && return; systemctl show "$service"; }

showActiveUsage() { EchoWrap "Usage: $(ScriptName) show active\nShow time service became active."; }
showActiveCommand() { RunPlatformWin showActive; }
showActiveLinux() { getProp "ActiveEnterTimestamp"; }

showStartUsage() { EchoWrap "Usage: $(ScriptName) show start\nShow service start time."; }
showStartCommand() { RunPlatformWin showStart; }
showStartLinux() { local result="$(getProp "ExecMainStartTimestamp")"; [[ $result ]] && { echo $result; return; }; showActiveLinux; }

getProp() { showCommand | grep "^$1=" | cut -d= -f2; }

#
# Start Type Command
#

starttypeUsage()
{
	EchoWrap "Usage: $(ScriptName) StartType
Show service start type, one of AUTO_START, DISABLED, or DEMAND_START."
}

starttypeCommand() { startType; }
startType() { RunPlatformWin "startType" --host; }

startTypeLinux()
{
	[[ ! $useSystemd ]] && { echo "unknown"; return; }
	[[ "$(linuxService is-enabled "$service")" == "enabled" ]] && echo "AUTO_START" || echo "DISABLED"
}

startTypeMac()
{
	# no service file
	if ! getMacServiceFile; then
		if [[ "$macServiceDomain" != "unknown" ]] && launchctl print-disabled "$macServiceDomain" | ${G}grep --quiet "\"$service\" => disabled"; then	
			echo "DISABLED"
		else
			echo "DEMAND_START"
		fi
		return
	fi

	# service file - keys may not exist so use defaults
	local runAtLoad; quiet="--quiet" runAtLoad="$(macServiceFileRead "RunAtLoad")"
	local disabled; quiet="--quiet" disabled="$(macServiceFileRead "Disabled")"
	log1 "runAtLoad=$runAtLoad disabled=$disabled"
	! IsInteger "$runAtLoad" && runAtLoad="0"
	! IsInteger "$disabled" && disabled="0"
	
	if (( disabled == 0 && runAtLoad == 1 )); then
		echo "AUTO_START"
	elif (( disabled == 0 && runAtLoad == 0 )); then
		echo "DEMAND_START"
	elif (( disabled == 1 )); then
		echo "DISABLED"
	else
		echo "UNKNOWN" # got a bogus value
	fi
}

startTypeWin()
{
	GetWord "$($sc $hostUnc qc "$service" $ScBufferSize |& RemoveCarriageReturn | grep START_TYPE)" 4
}

#
# stop command
#

stopCommand() { doCommandWait "stop"; }
stopLinux() { linuxService stop "$service"; }
stopWin() { local result="$($sc $hostUnc stop "$service")" && return; EchoErr "$result"; return 1; }

stopMac()
{
	getMacServiceFile && [[ $macServiceDomain ]] && { RunLog $sudo launchctl bootout $macServiceDomain "$macServiceFile" && return; }
	[[ $macService ]] && { RunLog $sudo launchctl stop "$service" && return; }
	ScriptErr "unable to stop service '$service' in domain '$macServiceDomain'"
}

#
# helper
#

isWinService() { IsPlatform win && ! isLinuxService "$1"; }

doCommand() { local command="$1"; checkState "$command" && return; doCommandRun "$command"; }
doCommandWait() { local command="$1"; checkState "$command" && return; waitStart "$command" && doCommandRun "$command" --host && waitEnd "$command"; }

doCommandRun()
{
	local command="$1"

	# run command with additional permissions if needed
	if isWinService "$service" && ! IsElevated; then
		! CanElevate && { ScriptErrQuiet "unable to elevate"; return 1; }
		RunLog elevate RunScript --pause-error -- service $command $service $noHostCheck $noServiceCheck "${globalArgs[@]}"
		return
	fi

	# run command
	RunPlatformOs "$command" --host
}

macDaemons=( "/System/Library/LaunchDaemons" "/Library/LaunchDaemons" )
macSystemAgents=( "/System/Library/LaunchAgents" "/Library/LaunchAgents" "$HOME/Library/LaunchAgents" )
macAgents=(  "${macSystemAgents[@]}" "$HOME/Library/LaunchAgents" )
macServices=( "${macDaemons[@]}" "${macAgents[@]}" )

isLinuxService() { isInitService "$1" || isSystemdService "$1"; }
isInitService() { [[ -f "/etc/init.d/$1" ]] ; }

# isSystemdService NAME - NAME format is SERVICE_NAME[@SERVICE_INSTANCE]
isSystemdService()
{
	local name="$1"; [[ $useSystemd ]] || return

	# service or service@instance exists explicitly
	[[ -f "/etc/systemd/system/$name.service" || -f "/lib/systemd/system/$name.service" ]] && return

	# service with an instance name
	[[ "$name" =~ @ && "$(RemoveBefore "$name" "@")" == "" ]] && return 1 # empty instance name not allowed
	[[ "$name" =~ @ ]] && name="$(RemoveAfter "$name" "@")@" # remove instance suffix
	[[ -f "/etc/systemd/system/$name.service" || -f "/lib/systemd/system/$name.service" ]] && return

	# static units
	systemctl is-enabled "$service" >& /dev/null
}

# linuxService - COMMAND SERVICE
linuxService() 
{
	local command="$1" service="$2"
	local sudo; [[ "$command" != @(running|status) ]] && sudo="sudo"

	[[ $sudo ]] && { sudov || return; }

	# systemd
	if [[ $useSystemd ]]; then
		RunLog $sudo systemctl "$command" "$service"

	# WSL
	elif IsPlatform wsl; then 
		[[ "$command" == "enable" ]] && return
		local quiet="/dev/null"; [[ "$command" == "status" ]] && quiet="/dev/stdout"
		RunLog $sudo "/usr/sbin/service" "$service" "$command" > "$quiet"

	# init.d
	else 
		RunLog $sudo "/etc/init.d/$service" "$command"

	fi
}

#
# info commands
#

infoUsage() { EchoWrap "Usage: $(ScriptName) info all|file|dump|platform|type\nShow service information."; }
infoCommand() { usage; }

infoAllUsage() { EchoWrap "Usage: $(ScriptName) info all\nService information for all services."; }

infoAllCommand()
{
	local service services; IFS=$'\n' ArrayMake services "$(RunPlatformOs "list")" || return

	{
		echo "service#domain#type#start type#state"

		PrintErr "Checkin $(ArraySize services) services..."
		{
			for service in "${services[@]}"; do
				PrintErr "."
				serviceCheck "$service" || return
				echo "$service#$macServiceDomain#$(infoTypeMac)#$(startType)#$(stateCommand)"
			done	
		} | sort | uniq
		EchoErrEnd "done"

	} | ${G}column -c $(tput cols -T "$term") -t -s#
}

infoDumpUsage() { EchoWrap "Usage: $(ScriptName) info dump\nDump all service information if possible."; }
infoDumpCommand() { RunPlatformOs "infoDump"; }
infoDumpMac() { launchctl dumpstate; }

infoFileUsage() { EchoWrap "Usage: $(ScriptName) info file [contents]\nShow the file associated with the service, if applicable."; }
infoFileCommand() { RunPlatformOs "infoFile"; }

infoFileLinux()
{
	if [[ $useSystemd ]]; then
		if [[ -f "/lib/systemd/system/$service.service" ]]; then echo "/lib/systemd/system/$service.service"
		elif [[ -f "/etc/systemd/system/$service.service" ]]; then echo "/etc/systemd/system/$service.service"
		fi
	elif [[ -f "/etc/init.d/$service" ]]; then
		echo "/etc/init.d/$service"
	fi
}

infoFileMac() { getMacServiceFile && echo "$macServiceFile"; }

infoFileContentsCommand()
{
	local file; file="$(RunPlatformOs "infoFile")"; [[ ! $file ]] && return; 
	ScriptFileCheck "$file" || return
	IsPlatform mac && { plutil -p "$file"; return; }
	cat "$file"
}

infoPlatformUsage() { EchoWrap "Usage: $(ScriptName) info platform\nShow platform specific service information."; }
infoPlatformCommand() { RunPlatformOs "infoPlatform"; }

infoPlatformMac()
{
	[[ $macServiceLoaded ]] && { echo "$macServiceInfo"; return; }
	getMacServiceFileContent && echo "$macServiceFileContent"
	return 0
}

infoTypeUsage() { EchoWrap "Usage: $(ScriptName) info type\nShow the platform specific type of the service."; RunPlatformOs infoTypeUsage; }
infoTypeUsageMac() { echo "Valid service types: Extension LaunchAgent LaunchDaemon pid Submitted XPCService"; }
infoTypeCommand() { RunPlatformOs "infoType"; }

infoTypeMac()
{
	# get type from loaded service
	[[ $macServiceLoaded ]] && { echo "$macServiceInfo" | grep "^	type = " | ${G}cut -d"=" -f2 | RemoveSpaceTrim; return; }
	
	# get type from the service file
	if getMacServiceFile; then
		[[ "$macServiceFile" =~ '/LaunchAgents/' ]] && { echo "LaunchAgent"; return; }
		[[ "$macServiceFile" =~ '/LaunchDaemons/' ]] && { echo "LaunchDaemon"; return; }
	fi

	echo "unknown"
}

infoTypeLinux() { [[ $useSystemd ]] && echo "systemd" || echo "init.d"; }

#
# helper - checkState
#

# checkState - return true if the command is in the desired state
checkState() { local command="$1"; [[ ! $force ]] && RunFunction "checkState" "$command"; }

checkStateAuto() { [[ "$(startType)" == "AUTO_START" ]]; }
checkStateDemand() { isLinuxService "$service" && { checkStateDisable; return; }; [[ "$(startType)" == "DEMAND_START" ]]; }
checkStateDisable() { [[ "$(startType)" == "DISABLED" ]]; }

checkStateContinue() { isLinuxService "$service" && { checkStateStart; return; }; [[ "$(stateCommand)" != "RUNNING" ]]; }
checkStatePause() { ! isWinService "$service" && { checkStateStop; return; }; [[ "$(stateCommand)" != "PAUSED" ]]; }
checkStateStart() { [[ "$(stateCommand)" != @(FAILED|STOPPED) ]]; }
checkStateStop() { [[ "$(stateCommand)" != "RUNNING" ]]; }

#
# helper - wait
#

# runStatus COMMAND DESCRIPTION - run a command and show status
runStatus()
{
	local command="$1" description="$2"
	RunPlatformOs ${command}NotNeeded && return
	[[ ! $quiet ]] && printf "$description..."
	RunPlatformOs "$command" || { echo "failed"; return 1; }
	[[ ! $quiet ]] && echo "done"
	return 0
}

waitNeeded() { IsFunction "waitForState${command^}"; }

waitStart() 
{	
	! waitNeeded && return
	local desc="${command^}ing"; [[ "$command" == "stop" ]] && desc="Stopping"
	[[ ! $quiet ]] && printf "$desc $service service$hostDescription..."
	return 0
}

# waitEnd
waitEnd()
{
	! waitNeeded && return
	[[ ! $wait ]] && { [[ ! $quiet ]] && echo "done"; return 0; }
	RunFunction waitForState "$command"
}

waitForStateContinue() { waitForState "RUNNING" "continue" "continued"; }
waitForStatePause() { waitForState "PAUSED" "pause";}
waitForStateStart() { waitForState "RUNNING" "start" "started"; }
waitForStateStop() { waitForState  "STOPPED|FAILED" "stop"; }

# waitForState STATE PRESENT [PAST](finalState)
waitForState()
{
	local seconds=30 state="$1" present="$2" past="$3"

	[[ ! $wait ]] && return

	for (( i=1; i<=seconds; ++i )); do
 		read -n 1 -t 1 -s && { echo "cancelled after $i seconds"; return 1; }
 		local currentState="$(stateCommand)"
 		[[ "$currentState" =~ ^($state)$ ]] && { [[ ! $quiet ]] && echo "${past:-${currentState,,}} in $i seconds"; return 0; }
		printf "."
	done

	[[ ! $quiet ]] && echo "did not $present in $seconds seconds";
	return 1
}

#
# helper
#

checkSystemd() { IsSystemd && useSystemd="true"; return 0; }

getMacServiceFileContent() 
{
	[[ $macServiceFileContent ]] && return
	getMacServiceFile && macServiceFileContent="$(defaults read "$macServiceFile")" || macServiceFileContent="unknown"
}

# getMacServiceFile - set macServiceFile (i.e. the property list file) for the current service
getMacServiceFile()
{
	[[ $macServiceFile ]] && return

	# look in the cached macServiceInfo
 	if [[ $macServiceInfo ]]; then
 		macServiceFile="$(echo "$macServiceInfo" | ${G}grep "path =.*\.plist$" | cut -d"=" -f2 | RemoveSpaceTrim)"
 		[[ ! -f "$macServiceFile" ]] && { log2 "getMacServiceFile: service '$service' file '$macServiceFile' from the cached service information does not exist"; unset macServiceFile; }
 	fi

 	# look for service files on disk
 	if [[ ! $macServiceFile ]]; then 	
 		getMacServiceFiles || return
		macServiceFile="$(echo "$macServiceFiles" | ${G}grep "/$service.plist$" | head -1)"
		[[ ! $macServiceFile ]] && { log2 "getMacServiceFile: service '$service' does not have a service file on disk"; unset macServiceFile; }
	fi

	# validation, logging, and return
	local result=0
	[[ ! $macServiceFile ]] && { result=1 macServiceFile="unknown"; }
	log2 "getMacServiceFile: macServiceFile='$macServiceFile'"
	return $result
}

# getMacServiceFiles - set macServiceFiles to all of the known service files (i.e. property list files)
getMacServiceFiles() 
{
	[[ $macServiceFiles ]] && return
	macServiceFiles="$(listFilesMac)"
}

# macServiceFileGetServiceName - get the service name (the propert list Label) from the service file
macServiceFileGetServiceName()
{
	quiet="--quiet" macServiceFileRead "Label" && return
	GetFileNameWithoutExtension "$macServiceFile"
}

# macServiceFileRead KEY - read the key from the service file
macServiceFileRead()
{
	# validate the file
	local key="$1"; macServiceFileValidate || return

	# validate and return the key

	local value; value="$(defaults read "$macServiceFile" "$key" 2>&1)" && { echo "$value"; return; }
	ScriptErrQuiet "service file '$(FileToDesc "$macServiceFile")' does not have key '$macServiceFile'"
	(( verboseLevel > 1 )) && defaults read "$macServiceFile" "$key"
	return 1
}

# macServiceFileWrite KEY VALUE- write the value to the key in the service file
macServiceFileWrite()
{
	# validate the file
	local key="$1" value="$2"; macServiceFileValidate || return

	# validate and return the key
	local value; value="$($sudo defaults write "$macServiceFile" "$key" -boolean "$value" 2>&1)" && { $sudo chmod +r "$macServiceFile"; return; }
	ScriptErrQuiet "unable to write '$value' to key $key' in the service file '$(FileToDesc "$macServiceFile")'"
	(( verboseLevel > 1 )) && defaults write "$macServiceFile" "$key" "$value"
	return 1
}

# macServiceFileValidate - validate the contents of the service file
macServiceFileValidate()
{
	[[ $macServiceFileValidated ]] && return

	# validate the file
	{ getMacServiceFile && ScriptFileCheck "$macServiceFile"; } || return

	# validate and get the contents of the properly list file
	macServiceFileValidateDo "$macServiceFile" && { macServiceFileValidated="true"; return; }
}

macServiceFileValidateDo()
{
	local file="$1"
	$sudo plutil -lint "$file" >& /dev/null && return
	ScriptErrQuiet "service file '$(FileToDesc "$file")' is not a valid service property list file"
	(( verboseLevel > 1 )) && plutil -lint "$file"
	return 1
}

# getMacServiceInfo - gets information on a loaded server, sets macServiceDomain, macServiceInfo, and macServiceLoaded
getMacServiceInfo()
{
	macServiceLoaded="true"
	if macServiceInfo="$(launchctl print "system/$service" 2>&1)"; then macServiceDomain="system/"
	elif macServiceInfo="$(launchctl print "gui/$UID/$service" 2>&1)"; then macServiceDomain="gui/$UID/"
	elif macServiceInfo="$(launchctl print "user/$UID/$service" 2>&1)"; then macServiceDomain="user/$UID/"
	else unset macServiceDomain macServiceInfo macServiceLoaded; return 1
	fi
}

ScriptRun "$@"

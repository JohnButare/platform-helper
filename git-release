#!/usr/bin/env bash

run()
{
	[[ $# > 1 ]] && { echo "usage: git release [NUM_COMMITS](1)"; exit 1; }

	local numCommits=${1-1}

	local releaseBranch="Release-v$(git show-ref | grep 'refs/remotes/origin' | cut -f 2 -d' ' | cut -f 3-5 -d'/' | egrep '^[ ]*origin/Release-v' | sed 's/origin\/Release-v//g' | sort -n | tail -1)"
	[[ ! $releaseBranch ]] && { echo "No release branch found"; exit 1; }

	local currentBranch="$(git symbolic-ref -q HEAD | cut -d"/" -f 3)"
	[[ ! $currentBranch ]] && { echo "Not on a branch"; exit 1; }

	local b="$currentBranch"
	if [[ "$b" == "Production" || "$b" == "Pre-Production" || "$b" == "Test" || "$b" =~ Release.* || "$b" =~ origin\/.* ]]; then
		echo "Cannot freeze $currentBranch"
		exit 1
	fi

	if [[ "$(git status --porcelain)" ]]; then
		echo "Current branch $currentBranch has changes that must be committed before release"
		exit 1
	fi

	if ask "Rebase $numCommits commits from $currentBranch onto $releaseBranch"; then
		git rebase --interactive HEAD~$numCommits --onto $releaseBranch || exit 1
		git push --force || exit 1
	fi

	if ask "Merge $currentBranch into $releaseBranch"; then
		git checkout $releaseBranch || exit 1
		git merge $currentBranch || exit 1
		git push || exit 1
	fi

	if [[ "$currentBranch" != "develop" ]] && ask "Delete $currentBranch"; then
		git branch -D $currentBranch  || exit 1
		git push origin :$currentBranch || exit 1
	fi
}

ask()
{
	local message="$1"
	local valid='yn'
	local default='y'

	while true; do
		printf "$message ($default)? "
		read response
		[[ ! $response ]] && response="$default"
		[[ $response && "$valid" == *$response* ]] && break
	done

	(( index=$(${G}expr index "${valid,,}" "${response,,}") - 1 ))
	return $index
}

pause() { local response; read -n 1 -s -p "${*-Press any key when ready...}"; echo; }

run "$@"
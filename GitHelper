#!/usr/bin/env bash
. function.sh || exit

usage()
{
	echot "\
usage: GitHelper ge|gb|gui|hub|tgui|changes|save|down|commit|commitg|browse|diff|status|size|ToHttp|ToSsh
	Addition Git functionality
	bin				Setup bin folders for git
	ge 				run Git Extensions/msysgit git
	gb 				run msysgit bash
	gui				run GitExtensions GUI
	hide 			hide Git files in repository
	ToGitHub REPO 			add a repository to GitHub
	CloneExisting	REPO	re-create repository that exists in the current directory
	profile save|restore|dir|SaveDir [<profile name>|default](latest) [--global]
	-w, --wait		wait for the operation to complete"
	exit $1
}

guiUsage() { "$gui" --help; exit $1; }

args()
{
	unset command help dest exclude file show arg1 arg2
	versions=( 2013 2012 )
	while (( $# != 0 )); do
		case "$1" in
			--help) help="--help";;
			--wait|-w) wait="--direct";;
			IsInstalled) command="IsInstalled";; ToGitHub) command="ToGitHub";; ToHttp) command="ToHttp";; ToSsh) command="ToSsh";; CloneExisting) command="CloneExisting";;
			*)
				! IsOption "$1" && IsInArray "$1" versions && { version="$1"; shift; continue; }
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(profile|ge|gui|tgui|up|down|browse|CloneExisting|commit|commitg|diff|status|ToGitHub|hide|changes) ]] && break # defer argument processing
				UnknownOption "$1"
		esac
		shift
	done
	[[ $help ]] && { IsFunction "${command}Usage" 0 && ${command}Usage || usage 0; }
	[[ ! $command ]] && { MissingOperand "command"; }
	args=("$@")
}

init()
{ 
	gb="$P32/Git/bin/sh.exe"
	ge="$P32/Git/bin/git.exe"
	gui="gitx"; [[ "$PLATFORM" == "win" ]] && gui="$P32/GitExtensions/GitExtensions.exe"
	tgui="$P/TortoiseGit/bin/TortoiseGitProc.exe" # http://tortoisesvn.net/docs/nightly/TortoiseSVN_en/tsvn-automation.html
}

run() {	init || return; args "$@" || return; ${command}Command "${args[@]}"; }
IsInstalledCommand() { [[ -f "$ge" ]]; }
profileCommand() {	profile --app "GitExtensions" --method "$APPDATA/GitExtensions/GitExtensions" --files "GitExtensions.settings" "$@"; }

gbCommand()
{
	[[ ! -f "$gb" ]] && { EchoErr "Could not find Git Bash command: is Git Extensions installed?"; return 1; }
	start --direct "$gb" --login -i "$@"
}

geCommand()
{
	[[ ! -f "$ge" ]] && { EchoErr "Could not find git command: is Git Extensions installed?"; return 1; }
	start --direct "$ge" "$@"
}

guiCommand()
{
	[[ ! -f "$gui" ]] && ! FindInPath "$gui" > /dev/null && { EchoErr "Could not find gui command"; return 1; }
	gui$PLATFORM "$@"
}

guiwin()
{
	(( $# == 1 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; }
	start $wait "$gui" "$@"
}

optionsCommand()
{
	[[ "$PLATFORM" != "win" ]] && { guiCommand; return; }

	# When setting options in GitExtensions .gitconfig cannot be a link
	[[ ! -f ~/.gitconfig.hold ]] && { mv ~/.gitconfig ~/.gitconfig.hold || return; }
	cp ~/.gitconfig.hold ~/.gitconfig || return
	GitHelper gui --wait || return
	mv ~/.gitconfig.hold ~/.gitconfig || rreturn
}

guimac()
{
	(( $# == 1 )) && [[ -d "$1" ]] && { start "$gui" --git-dir="$1"; return; }
	start $wait "$gui" "$@"
}

tguiCommand()
{
	[[ ! -f "$tgui" ]] && { EchoErr "Could not find TortoiseGitProc command: is TortoiseGit installed?"; return 1; }

	# convert /path:"$dir" paths
	#local args; for arg in "$@"; do
	#	[[ "$arg" == @(/path:*) ]] && args+=( "/path:$(utw "${arg#/path:}")" ) || args+=( "$arg" )
	#done

	start --direct "$tgui" "$@"
}

changesCommand()
{
	(( $# != 0 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	[[ "$(git status --porcelain)" != "" ]]
}

hideCommand()
{
	(( $# == 1 )) && { pushd "$1" > /dev/null || return; shift; }
	[[ "$PLATFORM" == "win" ]] || return 0
	[[ -d ".git" ]] && attrib +h ".git"
	[[ -f ".gitignore" ]] && attrib +h ".gitignore"
	attrib +h /s .gitkeep >& /dev/null
	return 0	
}

saveCommand()
{
	(( $# == 2 )) && { pushd "$1" > /dev/null || return; echo "Uploading $1..."; shift; }
	changesCommand || return 0
	git status
	git add --all || return
	git commit -m "$1" || return
	git push || return
}

downCommand()
{
	(( $# == 1 )) && { pushd "$1" > /dev/null || return; echo "Downloading $1..."; shift; };
	git pull
}

statusCommand()
{
	(( $# == 1 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	git status --short --branch
}

diffCommand()
{
	(( $# == 1 )) && { pushd "$1" > /dev/null || return; shift; };
	git diff
}

commitCommand() 
{ 
	(( $# != 0 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	guiCommand commit "$@"
}

commitgCommand() 
{
	(( $# != 0 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	changesCommand && guiCommand browse "$@"
}

browseCommand() { guiCommand browse "$@"; }

CloneExistingCommand()
{
	[[ -d .git ]] && return
	git clone "$@" hold || return
	[[ -f hold/.gitignore ]] && { mv hold/.gitignore . || return; }
	hideCommand || return
	rm -fr hold || return
}

binCommand()
{
	local nas="butare.net"; intel IsIntelHost && nas=192.168.1.3
	local binRepo ubinRepo

	[[ -d "$BIN/.git" && -d "$UBIN/.git" ]] && return 0

	if HostUtil available $nas; then
		binRepo="git@$nas:/volume1/git/public-bin"
		ubinRepo="git@$nas:/volume1/git/jjbutare-bin"
	elif HostUtil available github.intel.com; then
		binRepo="https://github.intel.com/jjbutare/bin"
		ubinRepo="https://github.intel.com/jjbutare/ubin"
		#binRepo="git@github.intel.com:jjbutare/bin"
		#ubinRepo="git@github.intel.com:jjbutare/ubin"
	else
		return 0
	fi

	cd "$BIN" || return
	GitHelper CloneExisting "$binRepo" || return
	git config --local --unset core.filemode || return

	cd "$BIN" || return
	GitHelper CloneExisting "$ubinRepo" || return
	git config --local --unset core.filemode || return
}

sizeCommand()
{
	# @see http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/
	# @author Antony Stubbs

	# set the internal field spereator to line break, so that we can iterate easily over the verify-pack output
	IFS=$'\n';

	# list all objects including their size, sort by size, take top 10
	echo "Calculating object sizes..."
	objects=`git verify-pack -v .git/objects/pack/pack-*.idx | grep -v chain | sort -k3nr | head -n 50`

	echo "All sizes are in kB's. Pack is the size of the object, compressed, inside the pack file."

	output="size,pack,SHA,location"
	for y in $objects
	do
		# extract the size in bytes
		size=$((`echo $y | cut -f 5 -d ' '`/1024))
		# extract the compressed size in bytes
		compressedSize=$((`echo $y | cut -f 6 -d ' '`/1024))
		# extract the SHA
		sha=`echo $y | cut -f 1 -d ' '`
		# find the objects location in the repository tree
		other=`git rev-list --all --objects | grep $sha`
		#lineBreak=`echo -e "\n"`
		output="${output}\n${size},${compressedSize},${other}"
	done

	echo -e $output | column -t -s ', '
}

ToHttpCommand()
{
	git remote set-url origin "https://$(getBaseUrl)"
	git remote --verbose
}

ToSshCommand()
{
	local url="git@$(getBaseUrl)"
	url="$(echo "$url" | sed 's/\//:/')"
	git remote set-url origin "$url"
	git remote --verbose
}

getBaseUrl()
{
	local url="$(git remote --verbose | grep origin | cut -f2 | cut -d" " -f1 | head -1)"
	url="$(echo "$url" | sed 's/https:\/\///')"
	url="$(echo "$url" | sed s/git@// | sed 's/:/\//' | sed 's/\/\//\//')"
	echo "$url"
}


#
# ToGitHub
#

ToGitHubCommand()
{
	local org="CSIS"
	local dir="/cygdrive/d/Archive"

	[[ $# != 1 ]] && { EchoErr "usage: togithub REPO"; return 1; }
	repo="$1"
	[[ ! -d "$dir/$repo" ]] && { EchoErr "$repo is not a valid repository"; return 1; }
	cd "$dir/$repo"

	echo '**********' "$repo" '**********'

	[[ ! -f .gitignore ]] && { AddDefaultGitIgnore || return 1; }
	[[ ! -f README.md ]] && { AddDefaultReadMe || return 1; }
	git remote | grep origin > /dev/null || { CreateGitHubRepository || return 1; } 
	[[ -d .git/svn ]] && { echo "Getting changes from the SVN repository..."; "$P32/Git/bin/git" svn fetch || return 1; }
	#git merge trunk
	#ge svn dcommit
	#git push --force
	echo "Pushing repository to GitHub..."; git push || return 1
	} 

CreateGitHubRepository()
{ 
	echo "Creating GitHub repository...."
	hub create $org/$repo -p -d "$repo project (converted from CSIS SVN repository)" || return 1
}

AddDefaultGitIgnore()
{
	echo "Adding default C# .gitignore...."
	cp ../.gitignore . || return 1
	git add .gitignore || return 1
	git commit -m "Add default C# .gitignore" || return 1
}

AddDefaultReadMe()
{
	echo "Adding default README.md...."
	echo "$repo" > README.md
	eval printf '=%.0s' {1..${#n}} >> README.md
	echo "" >> README.md
	echo "$repo project (converted from a CSIS SVN repository)." >> README.md
	echo "" >> README.md
	echo "External Dependencies" >> README.md
	echo "---------------------" >> README.md
	echo "Install external dependencies listed here from \\\\\\\\CsisBuild.intel.com\d$\install" >> README.md
	git add README.md || return 1
	git commit -m "Add default README.md" || return 1
}

run "$@"

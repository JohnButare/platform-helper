#!/usr/bin/env bash
. function.sh || exit

usage()
{
	echot "\
usage: GitHelper ge|gb|gui|hub|tgui|changes|save|down|commit|commitg|browse|diff|status|size|ToHttp|ToSsh
	Additional Git functionality
	bin				Setup bin folders for git
	ge 				run msysgit git
	gfw				run Git for Windows git
	gb 				run msysgit bash
	gui				run GitExtensions GUI
	hide 			hide Git files in repository
	options 	Git Extensions options
	ToGitHub REPO 			add a repository to GitHub
	CloneExisting	REPO	re-create repository that exists in the current directory
	profile save|restore|dir|SaveDir [<profile name>|default](latest) [--global]
	-w, --wait		wait for the operation to complete"
	exit $1
}

guiUsage() { "$gui" --help; exit $1; }

args()
{
	unset command help dest exclude file show arg1 arg2
	versions=( 2013 2012 )
	while (( $# != 0 )); do
		case "$1" in
			--help) help="--help";;
			--wait|-w) wait="--direct";;
			IsInstalled) command="IsInstalled";; GitInstalled) command="GitInstalled";;  ToGitHub) command="ToGitHub";; ToHttp) command="ToHttp";; ToSsh) command="ToSsh";; CloneExisting) command="CloneExisting";;
			*)
				! IsOption "$1" && IsInArray "$1" versions && { version="$1"; shift; continue; }
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(profile|ge|gfw|gui|tgui|up|down|browse|CloneExisting|commit|commitg|diff|status|ToGitHub|hide|changes) ]] && break # defer argument processing
				UnknownOption "$1"
		esac
		shift
	done
	[[ $help ]] && { IsFunction "${command}Usage" 0 && ${command}Usage || usage 0; }
	[[ ! $command ]] && { MissingOperand "command"; }
	args=("$@")
}

init()
{ 
	GitInstalledCommand || return
	gb="$P32/Git/bin/sh.exe"
	ge="$P32/Git/bin/git.exe"
	gfw="$P/Git/cmd/git.exe"
	gui="gitx"; [[ "$PLATFORM" == "win" ]] && gui="$P32/GitExtensions/GitExtensions.exe"
	tgui="$P/TortoiseGit/bin/TortoiseGitProc.exe" # http://tortoisesvn.net/docs/nightly/TortoiseSVN_en/tsvn-automation.html
}

run() {	init || return; args "$@" || return; ${command}Command "${args[@]}"; }
GitInstalledCommand() { which git >& /dev/null; }
IsInstalledCommand() { [[ -f "$ge" ]]; }
profileCommand() {	profile --app "GitExtensions" --method "$APPDATA/GitExtensions/GitExtensions" --files "GitExtensions.settings" "$@"; }

gbCommand()
{
	[[ ! -f "$gb" ]] && { EchoErr "Could not find Git Bash command: is Git Extensions installed?"; return 1; }
	start --direct "$gb" --login -i "$@"
}

geCommand()
{
	[[ ! -f "$ge" ]] && { EchoErr "Could not find msysgit git command"; return 1; }
	start --direct "$ge" "$@"
}

gfwCommand()
{
	[[ ! -f "$gfw" ]] && { EchoErr "Could not find Git for Windows git comman"; return 1; }
	start --direct "$gfw" "$@"
}

guiwin() { start $wait "$gui" "$@"; }

optionsCommand()
{
	[[ "$PLATFORM" != "win" ]] && { guiCommand; return; }

	# When setting options in GitExtensions .gitconfig cannot be a link
	[[ ! -f ~/.gitconfig.hold ]] && { mv ~/.gitconfig ~/.gitconfig.hold || return; }
	cp ~/.gitconfig.hold ~/.gitconfig || return
	GitHelper gui --wait || return
	mv ~/.gitconfig.hold ~/.gitconfig || rreturn
}

guimac()
{
	(( $# == 1 )) && [[ -d "$1" ]] && { start "$gui" --git-dir="$1"; return; }
	start $wait "$gui" "$@"
}

tguiCommand()
{
	[[ ! -f "$tgui" ]] && { EchoErr "Could not find TortoiseGitProc command: is TortoiseGit installed?"; return 1; }

	# convert /path:"$dir" paths
	#local args; for arg in "$@"; do
	#	[[ "$arg" == @(/path:*) ]] && args+=( "/path:$(utw "${arg#/path:}")" ) || args+=( "$arg" )
	#done

	start --direct "$tgui" "$@"
}

changesCommand()
{
	(( $# != 0 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	[[ "$(git status --porcelain)" != "" ]]
}

hideCommand()
{
	IsPlatform win || return 0

	(( $# == 1 )) && { pushd "$1" > /dev/null || return; shift; }
	
	[[ -d ".git" ]] && { attrib +h ".git" || return; }
	[[ -f ".gitignore" ]] && { attrib +h ".gitignore" || return; }
	attrib +h /s .gitkeep >& /dev/null || return
	git config --local --unset core.filemode || return

	return 1
}

saveCommand()
{
	(( $# == 2 )) && { pushd "$1" > /dev/null || return; echo "Uploading $1..."; shift; }
	changesCommand || return 0
	git status
	git add --all || return
	git commit -m "$1" || return
	git push || return
}

downCommand()
{
	(( $# == 1 )) && { pushd "$1" > /dev/null || return; echo "Downloading $1..."; shift; };
	git pull
}

statusCommand()
{
	(( $# == 1 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	git status --short --branch
}

diffCommand()
{
	(( $# == 1 )) && { pushd "$1" > /dev/null || return; shift; };
	git diff
}

commitCommand() 
{ 
	#(( $# != 0 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	guiCommand commit "$@"
}

commitgCommand() 
{
	changesCommand "$@" && guiCommand browse "$@"
}

guiCommand()
{
	[[ ! -f "$gui" ]] && ! FindInPath "$gui" > /dev/null && { EchoErr "Could not find gui command"; return 1; }
	[[ "$@" == "" ]] && gui$PLATFORM browse . || gui$PLATFORM "$@"
}

browseCommand() { guiCommand browse "$@"; }

CloneExistingCommand()
{
	local repo="$1"
	
	echo "Cloning $1..."
	[[ ! -d .git && ! -d hold/.git ]] && { git clone "$repo" hold || return; }
	[[ -f hold/.gitignore ]] && { mv hold/.gitignore . || return; }
	[[ -d hold/.git ]] && { mv hold/.git . || return; }
	hideCommand || return
	[[ -d hold ]] && { rm -fr hold || return; }
	
	echo "Updating remote to $repo..."
	git remote set-url origin "$repo" || return
	
	return 0
}

binCommand()
{
	local binRepo ubinRepo

	if [[ -d "/volume1/Git" ]]; then
		binRepo="/volume1/Git/public-bin"
		ubinRepo="/volume1/Git/jjbutare-bin"
	elif HostUtil available nas1; then
		binRepo="ssh://admin@nas1:608/git/public-bin"
		ubinRepo="ssh://admin@nas1:608/git/jjbutare-bin"
	elif HostUtil available github.intel.com; then
		binRepo="https://github.intel.com/jjbutare/bin"
		ubinRepo="https://github.intel.com/jjbutare/ubin"
	else
		return 0
	fi

	cd "$BIN" || return
	GitHelper CloneExisting "$binRepo" || return
	
	cd "$UBIN" || return
	GitHelper CloneExisting "$ubinRepo" || return
	
	if [[ -d "$BIN/.git" && -d "$UBIN/.git" ]]; then
		echo "Git is setup for the the bin directories"
		return 0
	fi

}

sizeCommand()
{
	# @see http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/
	# @author Antony Stubbs

	# set the internal field spereator to line break, so that we can iterate easily over the verify-pack output
	IFS=$'\n';

	# list all objects including their size, sort by size, take top 10
	echo "Calculating object sizes..."
	objects=`git verify-pack -v .git/objects/pack/pack-*.idx | grep -v chain | sort -k3nr | head -n 50`

	echo "All sizes are in kB's. Pack is the size of the object, compressed, inside the pack file."

	output="size,pack,SHA,location"
	for y in $objects
	do
		# extract the size in bytes
		size=$((`echo $y | cut -f 5 -d ' '`/1024))
		# extract the compressed size in bytes
		compressedSize=$((`echo $y | cut -f 6 -d ' '`/1024))
		# extract the SHA
		sha=`echo $y | cut -f 1 -d ' '`
		# find the objects location in the repository tree
		other=`git rev-list --all --objects | grep $sha`
		#lineBreak=`echo -e "\n"`
		output="${output}\n${size},${compressedSize},${other}"
	done

	echo -e $output | column -t -s ', '
}

ToHttpCommand()
{
	git remote set-url origin "https://$(getBaseUrl)/"
	git remote --verbose
}

ToSshCommand()
{
	local url="$(getBaseUrl)" port
	local server="${url%%/*}"
	local suffix="${url#*( )*/}"

	case "$server" in
		gitlab.devtools.intel.com) port=":29418";;
	esac

	git remote set-url origin "ssh://git@${server}${port}/${suffix}"
	git remote --verbose
}

getBaseUrl()
{
	# ssh://git@gitlab.devtools.intel.com:29418/csis/ics/ScadaPortal.git
	# https://gitlab.devtools.intel.com/csis/ics/ScadaPortal.git/

	local url="$(git remote --verbose | grep origin | cut -f2 | cut -d" " -f1 | head -1 | sed 's/\r//g')"
	url="$(echo "$url" | sed 's/https:\/\///')" # remove https://
	url="$(echo "$url" | sed 's/ssh:\/\///' | sed 's/git@//' | sed 's/:[0-9]*\//\//')" # remove ssh://, git@, and :NNN
	url="${url%%/}" # remove trailing /
	echo "${url}"
}


#
# ToGitHub
#

ToGitHubCommand()
{
	local org="CSIS"
	local dir="/cygdrive/d/Archive"

	[[ $# != 1 ]] && { EchoErr "usage: togithub REPO"; return 1; }
	repo="$1"
	[[ ! -d "$dir/$repo" ]] && { EchoErr "$repo is not a valid repository"; return 1; }
	cd "$dir/$repo"

	echo '**********' "$repo" '**********'

	[[ ! -f .gitignore ]] && { AddDefaultGitIgnore || return 1; }
	[[ ! -f README.md ]] && { AddDefaultReadMe || return 1; }
	git remote | grep origin > /dev/null || { CreateGitHubRepository || return 1; } 
	[[ -d .git/svn ]] && { echo "Getting changes from the SVN repository..."; "$P32/Git/bin/git" svn fetch || return 1; }
	#git merge trunk
	#ge svn dcommit
	#git push --force
	echo "Pushing repository to GitHub..."; git push || return 1
	} 

CreateGitHubRepository()
{ 
	echo "Creating GitHub repository...."
	hub create $org/$repo -p -d "$repo project (converted from CSIS SVN repository)" || return 1
}

AddDefaultGitIgnore()
{
	echo "Adding default C# .gitignore...."
	cp ../.gitignore . || return 1
	git add .gitignore || return 1
	git commit -m "Add default C# .gitignore" || return 1
}

AddDefaultReadMe()
{
	echo "Adding default README.md...."
	echo "$repo" > README.md
	eval printf '=%.0s' {1..${#n}} >> README.md
	echo "" >> README.md
	echo "$repo project (converted from a CSIS SVN repository)." >> README.md
	echo "" >> README.md
	echo "External Dependencies" >> README.md
	echo "---------------------" >> README.md
	echo "Install external dependencies listed here from \\\\\\\\CsisBuild.intel.com\d$\install" >> README.md
	git add README.md || return 1
	git commit -m "Add default README.md" || return 1
}

run "$@"

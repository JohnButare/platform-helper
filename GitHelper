#!/usr/bin/env bash
. "${BASH_SOURCE[0]%/*}/function.sh" script PlatformVars || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) changes|clone|edit|files|github|gui|hide|hub|IsInstalled|profile|pull|push|remote|server|size|time|upstream|version [OPTION]...
Additional Git functionality.

Common options:
	-w,	 --win		use Windows git
	-t, --timeout		$(ScriptOptTimeoutUsage)"
	exit $1
}

init()
{ 
	code="$CODE"

	fork="/usr/local/bin/fork"
	forkWin="$UADATA/Fork/Fork.exe"; IsPlatform win && fork="$forkWin"
	forkGit="$UADATA/Fork/gitInstance/2.24.1/bin/git.exe"
	forkTitle="Fork*"

	gitExtensions="$P/GitExtensions/GitExtensions.exe"
	gitExtensionsGit="$P/Git/cmd/git.exe"

	gitKraken="/usr/bin/gitkraken"; IsPlatform mac && gitKraken="$P/GitKraken.app/Contents/MacOS/GitKraken"
	gitKrakenNoPath="$gitKraken"; IsPlatform mac && gitKrakenNoPath="GitKraken"
	gitKrakenWin="$UADATA/gitkraken/gitkraken.exe"

	gitx="$P/GitX.app/Contents/Resources/gitx"

	# find a Windows git executable
	! IsPlatform win && return
	gitWin="$(FindInPath "git.exe")" && return
	[[ -f "$gitExtensionsGit" ]] && { gitWin="$gitExtensionsGit"; return; }
	[[ -f "$forkGit" ]] && { gitWin="$forkGit"; return; }
	gitWin="git"
}

argStart() { ScriptOptTimeoutArgStart; }
argEnd() { setGit; }

opt()
{
	case "$1" in
		--win|-w) win="--win" code="$WIN_CODE";;
		--timeout|--timeout=*|-t|-t=*) ScriptOptTimeout "$@";;
		*) return 1;;
	esac
}

#
# commands
#

isInstalledCommand() { InPath git; }
profileUsage() { ScriptUsageEcho "Usage: $(ScriptName) profile dir|SaveDir|save|restore [<profile name>|default](latest)\n$(ScriptName) configuration."; }
profileArgs() { profileArgs=( "$@" ); (( shift+=$# )); return 0; }
profileCommand() { profile --app "GitExtensions" --method "$UADATA/../Roaming/GitExtensions/GitExtensions" --files "GitExtensions.settings" "${profileArgs[@]}"; }
versionCommand() { :; }

changesCommand()
{
	GitValidate "GitHelper" || return

	# quiet - return 0 if no changes, 1 if changes
	[[ $quiet ]] && { [[ "$(git status --porcelain)" != "" ]]; return; }

	# change summary
	local newline changeSummary; changeSummary="$("$git" --no-pager diff --compact-summary)" || return
	if [[ $changeSummary ]]; then
		echo "$changeSummary"
		newline='\n'
	fi

	# regular git status output
	(( verboseLevel > 1 )) && { printf "$newline"; "$git" status || return; }

	# new files
	local newFiles; newFiles="$("$git" status --porcelain | ${G}grep -E "^(\?\?|A)" | cut -c 4-)"
	if [[ $newFiles ]] && (( verboseLevel <= 1 )); then
		printf "${newline}New files:\n"
		"$git" status --porcelain | ${G}grep -E "^(\?\?|A)" | cut -c 4- | AddTab
		newline='\n'
	fi

	# file mode changes
	local fileModeChanges; fileModeChanges="$("$git" --no-pager diff --summary)" || return
	if [[ $fileModeChanges ]]; then
		(( verboseLevel <= 1 )) && printf "$newline"
		echo "File mode changes:"
		echo "$fileModeChanges" | AddTab
		[[ $verbose ]] && { "$git" diff --summary | ${G}grep 'mode change ' | awk '{print "'$(GitRoot)'/"$6}' | ${G}xargs --no-run-if-empty ${G}stat -c '%A %a %n' | AddTab || return; }
	fi

	return 0
}

editUsage() { echot "Usage: $(ScriptName) edit\nEdit ~/.gitconfig.  In Windows, copy it to \$WIN_HOME/.gitconfig removing everything after the '# not windows' comment."; }

editCommand()
{
	# initialize
	local file="$UDATA/.gitconfig"	winFile="$WIN_HOME/.gitconfig"
	local platform="$PLATFORM_OS"; IsPlatform win && platform="linux"

	# merge .gitconfig-base with Windows ~.gitconfig
	if IsPlatform win && ask "Do you want to merge '.gitconfig' with the Windows '.gitconfig'"; then
		while (( "$(merge --wait "$UBIN/.gitconfig" "$winFile"; echo "$?")" > 12 )); do
			echo ""
		done
	fi

	# edit .gitconfig-* files
	local otherFiles=( "$UBIN/.gitconfig"* ) args=(); IsPlatform win && args+=(--wait)
	echo "Update .gitconfig files..."
	sublime "${args[@]}" "${otherFiles[@]}" || return			

	# copy .gitconfig to the Windows home directory
	IsPlatform win && { cp "$UBIN/.gitconfig" "$winFile" || return; }

	return 0	
}

filesUsage()
{
	EchoWrap "\
Usage: $(ScriptName) files
Return all files in the repository.\

	-t, --today		if specified, only return files modified today"
}

filesArgStart() { unset -v today; }

filesOpt()
{
	case "$1" in
		-t|--today) today="--today";;
		*) return 1
	esac
}

filesCommand() { local files; GitValidate "GitHelper" && getFiles && ArrayShow files; }

hideCommand()
{
	{ ! IsPlatform win || ! drive IsWin .; } && return
	repoCheck || return
	
	FileHide ".git" || return
	FileTouchAndHide ".gitignore" || return

	[[ -f ".gitkeep" ]] && { attrib .gitkeep +h /s || return; }

	return 0
}

pullUsage() { ScriptUsageEcho "Usage: $(ScriptName) pull [REMOTE...]\nPull from the specified remotes if they exist."; }
pullArgStart() { unset -v remotes; }
pullArgs() { remotes=( $@ ); shift="$#"; }

pullCommand()
{
	local remote branch="$(GitBranch)"
	for remote in "${remotes[@]}"; do
		! git remote | ${G}grep -q "^${remote}$" && continue
		hilight "Pulling $branch from $remote..."
		RunLog git pull "$remote" "$branch" "${otherArgs[@]}" || return
	done
}

pushUsage() { ScriptUsageEcho "Usage: $(ScriptName) push [REMOTE...]\nPush to the specified remotes if they exist."; }
pushArgStart() { unset -v remotes; }
pushArgs() { remotes=( $@ ); shift="$#"; }

pushCommand()
{
	local remote
	for remote in "${remotes[@]}"; do

		# check if remote exists in this repository
		! remoteExists "$remote" && continue

		# check if the remote server is available
		local url; url="$(remoteUrl "$remote")" || return
		local server; server="$(GetUncServer "$url")" || return
		log2 "push: remote=$remote url=$url server=$server timeout=$timeout"

		# check if the server is available
		# - TODO: parse url for port to check
		# - Sandia Zscaler does not support IsAvailable
		if IsInDomain sandia; then 
			server="$(RemovePort "$server")"
			IsAvailablePort "$server" 22 $timeout
		else
			IsAvailable "$server" $timeout
		fi
		(( $? != 0 ))  && { ScriptErrQuiet "remote '$remote' server '$server' is not available"; continue; }

		# push
		hilight "Pushing to $remote ($server)..."
		git push "$remote" "${otherArgs[@]}" $force || return
	done
}

serverUsage() { ScriptUsageEcho "Usage: $(ScriptName) server\nManage a Git server for a Nomad job."; }

serverCommand()
{
	local i=0 stopSignal

	serverCheck || return

	# start service
	echo "Git server manager pid is $$"
	TimerOn || return

	# traps
	trap "serverSignal SIGINT" SIGINT
	trap "serverSignal SIGTERM" SIGTERM
	trap "serverExit" EXIT

	# wait
	while true; do
		(( i % 60 == 0 )) && printf "\nThe Git server has been running for $(TimerOff)..." || printf "."; (( ++i ))
		serverCheck || { printf "\nThe 'Get server stopped running...\n"; break; }		
		[[ ! $stopSignal ]] && sleep 5 &
		wait; [[ $stopSignal ]] && break
	done
}

serverExit()
{
	echo "The Git server manager ran for $(TimerOff)"
}

serverSignal()
{
	stopSignal="$1"
	printf "\nReceived $stopSignal...\n"
}

serverCheck()
{
	[[ ! -d "/git" ]] && { ScriptErr "Git repositories are not present in '/git"; return 1; }
	! InPath "git" &&  { ScriptErr "Git is not installed"; return 1; }
	return 0
}

# sizeCommand - from # http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/
sizeCommand()
{
	repoCheck || return

	# set the internal field spereator to line break, so that we can iterate easily over the verify-pack output
	local IFS=$'\n';

	# list all objects including their size, sort by size, take top 10
	echo "Calculating object sizes..."
	objects=`"$git" verify-pack -v .git/objects/pack/pack-*.idx | ${G}grep -v chain | sort -k3nr | head -n 50`

	echo "All sizes are in kB's. Pack is the size of the object, compressed, inside the pack file."

	output="size,pack,SHA,location"
	for y in $objects
	do
		# extract the size in bytes
		size=$((`echo $y | cut -f 5 -d ' '`/1024))
		# extract the compressed size in bytes
		compressedSize=$((`echo $y | cut -f 6 -d ' '`/1024))
		# extract the SHA
		sha=`echo $y | cut -f 1 -d ' '`
		# find the objects location in the repository tree
		other=`"$git" rev-list --all --objects | ${G}grep $sha`
		#lineBreak=`echo -e "\n"`
		output="${output}\n${size},${compressedSize},${other}"
	done

	echo -e $output | column -t -s ', '
}

upstreamUsage()
{
	echot "Usage: $(ScriptName) upstream
Return the upstream status: up-to-date, behind, ahead, or diverged."
}

upstreamCommand()
{
	local upstream='@{u}'
	local local="$("$git" rev-parse @)"
	local remote="$("$git" rev-parse "$upstream")"
	local base=$("$git" merge-base @ "$upstream")

	if [[ "$local" == "$remote" ]]; then echo "up-to-date"
	elif [[ "$local" == "$base" ]]; then echo "behind"
	elif [[ "$remote" == "$base" ]]; then echo "ahead"
	else echo "diverged"
	fi
}

#
# Clone Commands
#

cloneUsage()
{
	echot "Usage: $(ScriptName) clone bin|existing|URL
Clone a repository.  URL is either a Git URL, or a NAME[/PREFIX] [REPO].   The name can be a servername or alias.

	-d, --dest DIR		repository destination directory, defaults to \$code
	-w, --windows			clone to the Windows code directory (\$WCODE)"
}

cloneArgStart() { unset -v dest url; }

cloneOpt()
{
	case "$1" in
		--dest|--dest=*|-d|-d=*) ScriptOptGet "dest" "$@"; dest="$(RemoveTrailingSlash "$dest")";;
		*) return 1;;
	esac
}

cloneArgs() { [[ "$command" != @(clone|cloneExisting) ]] && return; argUrl "$@"; }

cloneCommand()
{
	# set the repo
	local repo; repo="$(echo "$url" | RemoveTrailingSlash | GetFileName | RemoveEnd ".git")"

	# set the destination
	[[ ! $dest ]] && { dest="$code/$repo"; [[ $win ]] && dest="$WIN_CODE/$repo"; }

	[[ ! $force && -d "$dest" ]] && return
	setGit "$dest" || return

	# clone
	echo "Cloning $repo ($url) to '$(FileToDesc "$dest")'..."
	log1 "repo=$repo dest=$dest git=$git url=$url"
	RunLog "$git" clone "$url" "$dest" || return
	[[ $test ]] && return

	# change to the new repo directory
	cd "$dest" || return

	# Windows file system does not support file permissions
	drive IsWin "$dest" && { RunLog "$git" config --local --add core.filemode false || return; }

	return 0
}

cloneBinCommand()
{
	local url;

	# platform bin	
	if url="$(configGetUrl "RepoBinPublic")"; then
		cd "$BIN" || return		
		cloneExisting "$url" || return
		url="$(configGetUrl "RepoBinPublicGh")" && { remoteAdd "gh" "$url" || return; }
	fi

	# user bin
	if url="$(configGetUrl "RepoBinUser")"; then
		cd "$UBIN" || return
		cloneExisting "$url" || return
		url="$(configGetUrl "RepoBinUserGh")" && { remoteAdd "gh" "$url" || return; }
	fi
	
	# permissions
	SyncLocalFiles permission || return
}

cloneExistingUsage() { EchoWrap "Usage: $(ScriptName) clone existing URL\nClone into the current directory.  This is useful if the content from the cloned repositry already exists."; }
cloneExistingCommand() { cloneExisting "$url"; }

cloneExisting()
{
	local url="$1"

	echo "Cloning '$url' to the current directory..."
	[[ ! -d .git && ! -d hold/.git ]] && { git clone "$url" hold || return; }	
	[[ -f hold/.gitignore ]] && { mv hold/.gitignore . || return; }
	[[ -d hold/.git ]] && { mv hold/.git . || return; }
	hideCommand || return

	[[ -d hold ]] && { rm -fr hold || return; }

	echo "Updating remote to '$url'..."
	"$git" remote set-url origin "$url" || return # in case the repository existed
}
#
# GUI Command
#

guiUsage()
{
	echot "Usage: $(ScriptName) gui [PATH]
Open the repository in the current or specified directory in a Git GUI program.

	-w, --wait		wait for the operation to complete"
}

guiArgStart() { unset -v path wait; }
guiArgs() { (( ! $# )) && return; ScriptArgGet --required "path" -- "$@" && shift && ScriptCheckDir "$path" && path="$(GetFullPath "$path")" && isGitRepo "$path"; }

guiOpt()
{
	case "$1" in
		-w|--wait) wait="true";;
		*) return 1
	esac
}

guiCommand()
{	
	drive IsWin "$path" && { guiWin && return; }

	if [[ -f "$gitKraken" ]]; then guiGitKraken
	elif [[ -f "$fork" ]]; then guiFork
	elif SublimeMerge IsInstalled; then SublimeMerge start $wait "${otherArgs[@]}"
	elif [[ -f "$gitx" ]]; then guiGitx
	elif InPath "gitg"; then guiGitg
	else guiWin || guiNone
	fi
}

guiWin()
{
	if [[ -f "$gitKrakenWin" ]]; then guiGitKrakenWin
	elif [[ -f "$forkWin" ]]; then guiForkWin
	elif [[ -f "$gitExtensions" ]]; then guiGitExtensions
	else return 1
	fi
}

guiNone() { ScriptErr "could not find a Git GUI application"; return 1; }

guiGitg()
{
	[[ $path ]] && { command cd "$path" || return; }
	start $wait gitg "${otherArgs[@]}"
}

guiGitExtensions()
{
	local args=( "${otherArgs[@]}" ); [[ $path ]] && args+=( browse "$path" )
	start $wait "$gitExtensions" "${args[@]}" || return
}

guiFork()
{
	local args=(); [[ $path ]] && args+=( "$path" )
	start "$fork" "${args[@]}"
}

guiForkWin()
{
	local args=(); [[ $path ]] && args+=( "$path" )
	start "$forkWin" "${args[@]}"
}

guiGitKraken()
{
	if [[ $path ]]; then
		local args=(); [[ $path ]] && args+=( --path "$path" )
		RunLog start $wait "$gitKraken" "${args[@]}" || return
	else
		RunLog start $wait "$gitKrakenNoPath" || return
	fi
	! IsPlatform win && return
	WinSetState "GitKraken" --activate >& /dev/null
}

guiGitKrakenWin()
{
	local args=(); [[ $path ]] && args+=( --path "$(utw "$path")" )
	GitKrakenHelper cli -- "${args[@]}" &
}

guiGitx()
{
	local args=( "${otherArgs[@]}" ); [[ $path ]] && args+=( -git-dir="$path" )
	start $wait "$gitx" "${args[@]}"
}

#
# GitHub Commands
#

githubUsage() { ScriptUsageEcho "Usage: $(ScriptName) GitHub dir|clone|create"; }
githubCommand(){ usage; }
githubDirArgs() { ScriptArgGet "repo" -- "$@"; }
githubDirCommand() { repoDir "$repo"; }

#
# GitHub clone command
#

githubCloneArgs() { ScriptArgGet "repo" -- "$@"; }

githubCloneCommand()
{
	local dir; dir="$(repoDir "$repo")" || return
	[[ -d "$dir" ]]  && { echo "$dir"; return; }
	setGit "$(GetParentDir "$dir")" || return
	cd "$code" && "$git" clone "$repo" 1>&2 && echo "$dir"
}

#
# GitHub create command
#

githubCreateUsage()
{
	echot "Usage: $(ScriptName) GitHub create [REPO]
Create a GitHub repository from an existing repository."
}

githubCreateArgs() { ScriptArgGet "repo" -- "$@"; }

githubCreateCommand()
{
	local org="$USER"
	local dir="$code"

	[[ ! -d "$dir/$repo" ]] && { EchoErr "$repo is not a valid repository"; return 1; }
	cd "$dir/$repo"
	setGit "$dir/$repo" || return

	header "$repo"

	[[ ! -f .gitignore ]] && { addDefaultGitIgnore || return 1; }
	[[ ! -f README.md ]] && { addDefaultReadMe || return 1; }
	"$git" remote | ${G}grep origin > /dev/null || { createGitHubRepository || return 1; } 
	echo "Pushing repository to GitHub..."; "$git" push || return 1
	} 

createGitHubRepository()
{ 
	echo "Creating GitHub repository...."
	hub create $org/$repo -p -d "$repo project (converted from CSIS SVN repository)" || return 1
}

addDefaultGitIgnore()
{
	echo "Adding default C# .gitignore...."
	cp ../.gitignore . || return 1
	"$git" add .gitignore || return 1
	"$git" commit -m "Add default C# .gitignore" || return 1
}

addDefaultReadMe()
{
	echo "Adding default README.md...."
	cat <<-EOF > "README.md"
		$repo
		$(eval printf '=%.0s' {1..${#n}})
		
		$repo project (converted from a CSIS SVN repository).
		
		External Dependencies
		---------------------
	EOF
	
	"$git" add README.md || return 1
	"$git" commit -m "Add default README.md" || return 1
}

#
# Remote Commands
#

remoteUsage() { ScriptUsageEcho "Usage: $(ScriptName) remote [add|dir|init|ls|swap|to](ls)\nManipulate remote repositories."; }
remoteCommand() { remoteLsCommand; }

remoteAddUsage() { ScriptUsageEcho "Usage: $(ScriptName) git remote add URL\nAdd the URL as a remote."; }
remoteAddArgs() { argUrl "$@"; }
remoteAddCommand() { "$git" remote add "$(GetUriServer "$url" | RemoveDnsSuffix)" "$url" && "$git" fetch "$server" && "$git" remote -v; }

remoteDirUsage() { ScriptUsageEcho "Usage: $(ScriptName) remote dir URL\nReturn the server Git directory ."; }
remoteDirArgs() { argUrl "$@"; }
remoteDirCommand() { echo "$(configGitUnc)/$(nameToUrl "$url" | GetUrisDirs)"; }

remoteLsUsage() { ScriptUsageEcho "Usage: $(ScriptName) remote ls SERVER\nList git repositories on the specified server."; }
remoteLsArgs() { ScriptArgGet "server" -- "$@"; }
remoteLsCommand() { hilight "$server repostiories: "; ssh "$server" ls "/$(configGitShareDir)" | ${G}grep -Ev "eaDir"; }	

remoteToUsage() { ScriptUsageEcho "Usage: $(ScriptName) git remote to http|https:ssh\nConvert the current repository to HTTP or SSH."; }
remoteToCommand() { usage; }
remoteToHttpCommand() { "$git" remote set-url origin "http://$(getBaseUrl "origin")/" && "$git" remote --verbose; }
remoteToHttpsCommand() { "$git" remote set-url origin "https://$(getBaseUrl "origin")/" && "$git" remote --verbose; }
remoteToSshCommand() { "$git" remote set-url origin "ssh://$(getBaseUrl "origin")" && "$git" remote --verbose; }

remoteInitUsage() { ScriptUsageEcho "Usage: $(ScriptName) git remote init SERVER REPO\nInitialize an empty repository on the specified server."; }
remoteInitArgs() { ScriptArgGet "server" -- "$@" && ScriptArgGet "repo" -- "$@"; }

remoteInitCommand()
{
	# change to server Git directory
	local dir; dir="$(unc mount "//$server/$(configGitShare)")" || return
	cd "$dir" || return
	[[ -e "$repo" ]] && { ScriptErr "repository $repo already exists on $server"; return 1; }

	# create respository
	${G}mkdir --parents "$repo" && setGit "$repo" && cd "$repo" && "$git" init --bare 
}

remoteSwapUsage() { ScriptUsageEcho "Usage: $(ScriptName) git remote swap [remote1] [remote2](origin)\nSwap remote names."; }
remoteSwapArgStart() { unset -v remote1; remote2="origin"; }

remoteSwapArgs()
{
	ScriptArgGet "remote1" -- "$@" || return; shift
	(( ! $# )) && return; ScriptArgGet "remote2" -- "$@"
}

remoteSwapCommand()
{
	# validate
	[[ "$remote1" == "$remote2" ]] && { ScriptErr "remote1 and remote2 must be different"; return 1; }

	local remote1Url; remote1Url="$(remoteUrl "$remote1")" || return
	local remote2Url; remote2Url="$(remoteUrl "$remote2")" || return
	local remote1NewName="$remote2" remote2NewName="$remote1"
	[[ "$remote1" == "origin" ]] && { remote1NewName="$(GetUriServer "$remote1Url")"; }
	[[ "$remote2" == "origin" ]] && { remote2NewName="$(GetUriServer "$remote2Url")"; }

	# original configuration
	header "Original Configuration"
	"$git" remote -v || return
	echo

	# swap
	header "Swapping $remote1 and $remote2"
	log1 "$remote1 ($remote1Url)->$remote1NewName"
	log1 "$remote2 ($remote2Url)->$remote2NewName"
	RunLog "$git" remote rename "$remote1" "$remote1.hold" || return
	RunLog "$git" remote rename "$remote2" "$remote2NewName" || return
	RunLog "$git" remote rename "$remote1.hold" "$remote1NewName" || return
	[[ "$remote1" == "origin" || "$remote2" == "origin" ]] && { RunLog "$git" branch master --set-upstream-to origin/master || return; }
	echo

	# new configuration
	header "New Configuration"
	"$git" remote -v || return
}

#
# Time Command
#

timeUsage()
{
	EchoWrap "\
Usage: $(ScriptName) time [-a|--all]
Set modification time of files to the modification time in the repository.\
This is useful to correct file modification time of newly checked out files.

	-t, --today		if specified, only adjust files modified today"
}

timeArgStart() { unset -v today; }

timeOpt()
{
	case "$1" in
		-t|--today) today="--today";;
		*) return 1
	esac
}

timeCommand()
{
	# validate
	IsDomainRestricted && return # can only sync one remo time
	GitValidate "GitHelper" || return

	# get files
	local file files; getFiles || return

	# get changed files
	local changes; changes="$(git status --porcelain)" || return
	
	# status
	[[ ! $quiet ]] && printf "file times..."

	# update times
	for file in "${files[@]}"; do

		# skip modified files
		echo "$changes" | qgrep "${file}$" && { log1 "$file: skipping $(echo "$changes" | grep "${file}$")"; continue; }

		# get file author time
	  local gitTime; gitTime="$("$git" log -1 --format="%at" -- "$file")"
	  local fileTime; fileTime="$(GetFileModSeconds "$file")"	  
	  [[ "$gitTime" == "$fileTime" ]] && { printf "."; continue; }

	  # set the file modified time to the author time
	  printf "$file..."; log1 "$file: gitTime='$(GetDate @$gitTime)' fileTime='$(GetDate @$fileTime)' diff=$(( fileTime - gitTime ))"
	  RunLog ${G}touch "$file" --time=mtime --date "@$gitTime" || return
	done

	# status
	[[ ! $quiet ]] && echo "done"

	return 0
}

#
# helper
#

argUrl() { ScriptArgGet "url" -- "$@" && url="$(nameToUrl "$url")"; }

configGetUrl() { local var="$1" name; name="$(ConfigGetCurrent "$var")" && nameToUrl "$name"; } # configGetUrl VAR - get a repo URL from configuration
configGitShare() { ConfigGetCurrent "GitShare"; }																								# configGitShare - get the Git server UNC share suffix (SHARE/DIRS) from configuration, i.e. root/git
configGitShareDir() { RemoveBeforeFirst "$(configGitShare)" "/"; }															# configGitShareDir - get the Git server directory from configuration (SHARE/DIRS -> DIRS)
configGitUnc() { local server="$1"; echo "//$server/$(configGitShare)"; }												# configGitUnc SERVER - get the Git UNC for SERVER, i.e. //SERVER/SHARE/DIRS

# getFiles - set the files variable to the files in the Git repository.  If the today variable is set, return only files modified today.
getFiles()
{
	IFS=$'\n' ArrayMakeC files git ls-tree -r --name-only HEAD || return
	[[ $today ]] && { IFS=$'\n' ArrayMake files "$(command ${G}ls -al --time-style=+%D "${files[@]}" | ${G}grep "$(date +%D)" | rev | cut -d" " -f1 | rev)" || return; }
	return 0
}

# getBaseUrl REMOTE - get repository base URL for a remote, i.e. https://server/path/ ssh://user@server:port/path/ -> server/path
getBaseUrl() 
{
	local url; url="$(remoteUrl "$1")" || return
	url="$(echo "$url" | ${G}sed 's/https*:\/\///')" # remove http[s]://
	url="$(echo "$url" | ${G}sed 's/ssh:\/\///' | sed 's/git@//' | sed 's/:[0-9]*\//\//')" # remove ssh://, user@, and :port
	url="${url%%/}" # remove trailing /
	echo "${url}"
}

# isGitRepo DIR - return 0 if the directory is in a Git repository
isGitRepo()
{
	( cd "$path" && setGit "$path" && "$git" rev-parse --git-dir >& /dev/null; ) && return
	ScriptErrQuiet "fatal: not a git repository (or any of the parent directories)"
}

# nameToUrl URL|NAME[/PREFIX] -> protocol://user@server:port/prefix/dir/repo
# - name - can be a URL, server, or aliases (i.e. sandiap, Sandia Personal repo)
# - repo - optional name of the repository, can be included in the name
nameToUrl()
{
	# initialize
	local name="$1"; IsUrl "$name" && return

	# prefix
	prefix="$(RemoveBeforeFirst "$name" "/")"; [[ $prefix ]] && prefix="$prefix/"
	name="$(GetUriServer "$name")"
	log2 "nameToUrl: prefix=$prefix name=$name"

	# resolve alias
	local url="$(nameResolveAlias "$name")"

	# add protocol if needed
	[[ ! $(GetUriProtocol "$url") ]] && url="ssh://"

	# return URL
	echo "$url/$prefix"; 
}

nameResolveAlias()
{
	local name="$name"
	case "${name,,}" in
		gh) echo "https://github.com";;
		ghp) echo "https://github.com/$(ConfigGetCurrent "GithubUser")";;
		git) echo "ssh://git.butare.net";;												# butare
		sandia) echo "https://cee-gitlab.sandia.gov";;						# sandia
		sandiam) echo "https://cee-gitlab.sandia.gov/mfg";;				# sandia manufacturing
		sandiap) echo "https://cee-gitlab.sandia.gov/${USER,,}";;	# sandia personal
		*) echo "$1";;
	esac
}

repoCheck() { [[ -d ".git" ]] && return; ScriptErr "not a git repository"; return; }

repoDir()
{ 
	local repo="$1"; 
	IsUrl "$repo" && { echo "$code/$(GetUriDirs "$1" | RemoveTrailingSlash | GetFileName)"; return; }
	[[ -d "$code/$repo" ]] && { echo "$code/$repo"; return; }
	ScriptErr "'$repo' is not a valid repository"; return 1
}

remoteAdd() { remoteExists "$1" && return; git remote add "$1" "$2"; }
remoteExists() { remoteUrl "$1" >& /dev/null; }
remoteUrl() { "$git" remote get-url "$1"; }

setGit()
{
	local dir="${1:-.}"
	git="git"
	IsPlatform win && { [[ $win ]] || drive IsWin "$dir"; } && git="$gitWin"
	log1 "git set to '$git'"
}

ScriptRun "$@"

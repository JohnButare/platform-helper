#!/usr/bin/env bash
. script.sh || exit

usage()
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) changes|clone|github|gui|hide|hub|IsInstalled|profile|remote|size|upstream [OPTION]...
Additional Git functionality."
	exit $1
}

init()
{ 
	GitExtensions="$P32/GitExtensions/GitExtensions.exe"
	gitExtensionsGit="$P/Git/cmd/git.exe"

	fork="$UADATA/Fork/Fork.exe"; IsPlatform mac && fork="/usr/local/bin/fork"
	forkGit="$UADATA/Fork/gitInstance/2.24.1/bin/git.exe"
	forkTitle="Fork*"

	gitx="$P/GitX.app/Contents/Resources/gitx"
}

#
# commands
#

isInstalledCommand() { InPath git; }
profileUsage() { echot "Usage: $(ScriptName) profile dir|SaveDir|save|restore [<profile name>|default](latest)\n$(ScriptName) configuration."; }
profileCommand() { profile --app "GitExtensions" --method "$UADATA/../Roaming/GitExtensions/GitExtensions" --files "GitExtensions.settings" "$@"; }

changesCommand()
{
	local newline

	# change summary
	local changeSummary; changeSummary="$(git --no-pager diff --compact-summary)" || return
	if [[ $changeSummary ]]; then
		echo "$changeSummary"
		newline='\n'
	fi

	# regular git status output
	(( verboseLevel > 1 )) && { printf "$newline"; git status || return; }

	# new files
	local newFiles; newFiles="$(git status --porcelain | grep -E "^(\?\?|A)" | cut -c 4-)" || return
	if [[ $newFiles ]] && (( verboseLevel <= 1 )); then
		printf "${newline}New files:\n"
		git status --porcelain | grep -E "^(\?\?|A)" | cut -c 4- | AddTab
		newline='\n'
	fi

	# file mode changes
	local fileModeChanges; fileModeChanges="$(git --no-pager diff --summary)" || return
	if [[ $fileModeChanges ]]; then
		(( verboseLevel <= 1 )) && printf "$newline"
		echo "File mode changes:"
		echo "$fileModeChanges" | AddTab
		[[ $verbose ]] && { git diff --summary | tgrep 'mode change ' | awk '{print "'$(GitRoot)'/"$6}' | ${G}xargs --no-run-if-empty ${G}stat -c '%A %a %n' | AddTab || return; }
	fi
	return 0
}

hideCommand()
{
	! IsPlatform win && return
	checkRepo || return
	
	FileHide ".git" || return
	FileTouchAndHide ".gitignore" || return

	[[ -f ".gitkeep" ]] && { attrib .gitkeep +h /s || return; }

	return 0
}

# sizeCommand - from # http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/
sizeCommand()
{
	checkRepo || return

	# set the internal field spereator to line break, so that we can iterate easily over the verify-pack output
	local IFS=$'\n';

	# list all objects including their size, sort by size, take top 10
	echo "Calculating object sizes..."
	objects=`git verify-pack -v .git/objects/pack/pack-*.idx | grep -v chain | sort -k3nr | head -n 50`

	echo "All sizes are in kB's. Pack is the size of the object, compressed, inside the pack file."

	output="size,pack,SHA,location"
	for y in $objects
	do
		# extract the size in bytes
		size=$((`echo $y | cut -f 5 -d ' '`/1024))
		# extract the compressed size in bytes
		compressedSize=$((`echo $y | cut -f 6 -d ' '`/1024))
		# extract the SHA
		sha=`echo $y | cut -f 1 -d ' '`
		# find the objects location in the repository tree
		other=`git rev-list --all --objects | grep $sha`
		#lineBreak=`echo -e "\n"`
		output="${output}\n${size},${compressedSize},${other}"
	done

	echo -e $output | column -t -s ', '
}

upstreamUsage()
{
	echot "Usage: $(ScriptName) upstream
Return the upstream status: up-to-date, behind, ahead, or diverged."
}

upstreamCommand()
{
	local upstream='@{u}'
	local local="$(git rev-parse @)"
	local remote="$(git rev-parse "$upstream")"
	local base=$(git merge-base @ "$upstream")

	if [[ "$local" == "$remote" ]]; then echo "up-to-date"
	elif [[ "$local" == "$base" ]]; then echo "behind"
	elif [[ "$remote" == "$base" ]]; then echo "ahead"
	else echo "diverged"
	fi
}

#
# Clone Commands
#

cloneUsage()
{
	echot "Usage: $(ScriptName) clone [bin|existing] URL
Clone a repository.  URL is either a standard Git URL or a SERVER and REPO.

	-d, --dest DIR		repository destination directory, defaults to \$CODE
	-w, --win					clone to the Windows code directory (\$WCODE)"
}

cloneArgStart() { unset -v dest repo server url win; }

cloneArgs()
{
	[[ "$command" != @(clone|cloneExisting) ]] && return

	if IsUrl "$1"; then
		ScriptArgGet "url" -- "$@"; shift	
	else
		ScriptArgGet "server" -- "$@"; shift
		ScriptArgGet "repo" -- "$@"; shift
	fi
}

cloneOpt()
{
	case "$1" in
		-d|--dest) ScriptOptGet "dest" "$@"; dest="$(RemoveTrailingSlash "$dest")";;
		-w|--win) win="true";;
		*) return 1;;
	esac
}

cloneCommand()
{
	# set the url
	[[ ! $url ]] && url="$(serverToRepo "$server" "$repo")"

	# set the repo
	[[ ! $repo ]] && repo="$(GetFileName "$url" | RemoveEnd ".git")"

	# set the destination
	[[ ! $dest ]] && { dest="$CODE/$repo"; [[ $win ]] && dest="$WIN_CODE/$repo"; }
	[[ ! $force && -d "$dest" ]] && return

	# clone	
	echo "Cloning $repo ($url) to $dest..."
	RunLog git clone "$url" "$dest" || return
	[[ $test ]] && return

	# change to the new repo directory
	cd "$dest" || return

	# Windows file system does not support file permissions
	drive IsWin "$dest" && { RunLog git config --local --add core.filemode false || return; }

	return 0
}

cloneBinCommand()
{
	local server; server="$(findServer)" || { ScriptErr "unable to find a Git server"; return 1; }

	cd "$BIN" && { repo="public-bin" cloneExistingCommand || return; }
	cd "$UBIN" && { repo="$USER-bin" cloneExistingCommand || return; }
	
	# Windows plink requires accepting the key manually
	local port="$(serverToPort "$server")"
	if IsPlatform win && IsAvailablePort "$server" "$port"; then
		echo "Testing SSH connection to $server..."
		start plink.exe -v -P "$port" "$(serverToUser "$server")$server" git --version
	fi

	if [[ -d "$BIN/.git" && -d "$UBIN/.git" ]]; then
		echo "Git is setup for the the bin directories"
		return 0
	fi

	return 0
}

cloneExistingUsage()
{
	EchoWrap "Usage: $(ScriptName) clone existing SERVER
Clone into the current directory.  This is useful if the content from the cloned repositry already exists."
}

cloneExistingCommand()
{
	repo="$(serverToRepo "$server" "$repo")"

	echo "Cloning $repo..."
	[[ ! -d .git && ! -d hold/.git ]] && { git clone "$repo" hold || return; }	
	[[ -f hold/.gitignore ]] && { mv hold/.gitignore . || return; }
	[[ -d hold/.git ]] && { mv hold/.git . || return; }
	hideCommand || return

	[[ -d hold ]] && { rm -fr hold || return; }

	echo "Updating remote to $repo..."
	git remote set-url origin "$repo" || return # in case the repository existed
	
	return 0
}

#
# GUI Command
#

guiUsage()
{
	echot "Usage: $(ScriptName) gui [PATH]
Open the repository in the current or specified directory in a Git GUI program.

	-w, --wait		wait for the operation to complete"
}

guiArgStart() { unset -v path wait; }
guiArgs() { [[ ! $1 ]] && return; ScriptArgGet "path" -- "$@"; ScriptCheckDir "$dir"; }

guiOpt()
{
	case "$1" in
		-w|--wait) wait="true";;
		*) return 1
	esac
}

guiCommand()
{
	path="${path:-$PWD}"; ! git rev-parse --git-dir >& /dev/null && unset path

	if InPath "gitkraken" && ! drive IsWin "$path"; then unset path; guiGitKraken
	elif InPath "gitkraken"; then guiGitKraken
	elif [[ -d "/Applications/GitKraken.app" ]]; then guiGitKraken
	elif [[ -f "$fork" ]]; then guiFork
	elif [[ -f "$GitExtensions" ]]; then guiGitExtensions
	elif [[ -f "$gitx" ]]; then guiGitx
	elif InPath "gitg"; then guiGitg
	else ScriptErr "could not find a Git GUI application"; return 1
	fi
}

guiFork()
{
	local args=(); [[ $path ]] && args+=( "$path" )
	local start; IsPlatform win && start="start"
	$start "$fork" "${args[@]}"
}

guiGitExtensions()
{
	local args=( "${otherArgs[@]}" ); [[ $path ]] && args+=( browse "$path" )
	start $wait "$GitExtensions" "${args[@]}" || return
}

guiGitg()
{
	[[ $path ]] && { command cd "$path" || return; }
	start $wait gitg "${otherArgs[@]}"
}

guiGitKraken()
{
	IsPlatform mac && { start "GitKraken.app"; return; }
	local args=( --new-window "${otherArgs[@]}" ); [[ $path ]] && args+=( -p "$path" )
	start $wait gitkraken "${args[@]}"
	WinSetState "GitKraken" --activate >& /dev/null
}

guiGitx()
{
	local args=( "${otherArgs[@]}" ); [[ $path ]] && args+=( -git-dir="$path" )
	start $wait "$gitx" "${args[@]}"
}

#
# GitHub Commands
#

githubUsage() { echot "Usage: $(ScriptName) GitHub dir|clone|create"; }
githubCommand(){ usage; }
githubDirArgs() { ScriptArgGet "repo" -- "$@"; }
githubDirCommand() { githubDir "$repo"; }
githubDir() { echo "$CODE/$(GetUriDirs "$1" | RemoveTrailingSlash | GetFileName)"; }

#
# GitHub clone command
#

githubCloneArgs() { ScriptArgGet "repo" -- "$@"; }

githubCloneCommand()
{
	local dir; dir="$(githubDir "$repo")" || return
	[[ -d "$dir" ]]  && return
	cd "$CODE" && git clone "$repo"
}

#
# GitHub create command
#

githubCreateUsage()
{
	echot "Usage: $(ScriptName) GitHut create [REPO]
Create a GitHub repository from an existing repository."
}

githubCreateArgs() { ScriptArgGet "repo" -- "$@"; shift; }

githubCreateCommand()
{
	local org="$USER"
	local dir="$CODE"

	[[ ! -d "$dir/$repo" ]] && { EchoErr "$repo is not a valid repository"; return 1; }
	cd "$dir/$repo"

	header "$repo"

	[[ ! -f .gitignore ]] && { addDefaultGitIgnore || return 1; }
	[[ ! -f README.md ]] && { addDefaultReadMe || return 1; }
	git remote | grep origin > /dev/null || { createGitHubRepository || return 1; } 
	echo "Pushing repository to GitHub..."; git push || return 1
	} 

createGitHubRepository()
{ 
	echo "Creating GitHub repository...."
	hub create $org/$repo -p -d "$repo project (converted from CSIS SVN repository)" || return 1
}

addDefaultGitIgnore()
{
	echo "Adding default C# .gitignore...."
	cp ../.gitignore . || return 1
	git add .gitignore || return 1
	git commit -m "Add default C# .gitignore" || return 1
}

addDefaultReadMe()
{
	echo "Adding default README.md...."
	cat <<-EOF > "README.md"
		$repo
		$(eval printf '=%.0s' {1..${#n}})
		
		$repo project (converted from a CSIS SVN repository).
		
		External Dependencies
		---------------------
	EOF
	
	git add README.md || return 1
	git commit -m "Add default README.md" || return 1
}

#
# Remote Commands
#

remoteUsage() { echot "Usage: $(ScriptName) remote [add|dir|init|list|swap|to](list)\nManipulate remote repositories."; }
remoteCommand() { remoteLsCommand; }
remoteArgStart() { unset -v repo server; }

remoteArgs()
{
	[[ "$command" == @(remoteAdd|remoteDir|remoteInit|remoteLs) ]] && { ScriptArgGet "server" -- "$@"; shift; }
	
	if [[ "$command" == @(remoteAdd|remoteDir|remoteInit) ]]; then
		if (( $# > 0 )); then
			ScriptArgGet "repo" -- "$@"; shift;
		elif [[ "$command" != @(remoteDir) ]]; then
			local url; url="$(git remote get-url origin)" || return
			repo="$(echo "$url" | GetLastDir)"
		fi
	fi

	return 0
}

remoteAddUsage() { echot "Usage: $(ScriptName) git remote add SERVER REPO\nAdd the repository as a remote."; }
remoteAddCommand() { git remote add "$server" "$(serverToRepo "$server" "$repo")" && git fetch "$server" && git remote -v; }

remoteDirUsage() { echot "Usage: $(ScriptName) remote dir SERVER\nReturn the git directory for the specified server."; }
remoteDirCommand() { echo "$(serverToShare "$server")/$repo"; }

remoteLsUsage() { echot "Usage: $(ScriptName) remote ls SERVER\nList git repositories on the specified server."; }
remoteLsCommand() { hilight "$server repostiories: "; ssh "$server" ls "/$(serverToDir "$server")" | grep -Ev "eaDir"; }	

remoteToUsage() { echot "Usage: $(ScriptName) git remote to http|ssh\nConvert the current repository to HTTP or SSH."; }
remoteToCommand() { usage; }

remoteInitUsage() { echot "Usage: $(ScriptName) git remote init SERVER REPO\nInitialize an empty repository on the specified server."; }

remoteInitCommand()
{
	# change to server Git directory
	local dir; dir="$(unc mount "$(serverToShare "$server")")" || return
	cd "$dir" || return
	[[ -e "$repo" ]] && { ScriptErr "repository $repo already exists on $server"; return 1; }

	# create respository
	${G}mkdir --parents "$repo" || return
	cd "$repo" || return
	git init --bare || return
}

remoteSwapUsage() { echot "Usage: $(ScriptName) git remote swap [remote1] [remote2](origin)\nSwap remote names."; }
remoteSwapArgStart() { unset -v remote1; remote2="origin"; }

remoteSwapArgs()
{
	ScriptArgGet "remote1" -- "$@"; shift;
	(( $# > 0 )) && { ScriptArgGet "remote2" -- "$@"; shift; }
	return 0
}

remoteSwapCommand()
{
	# validate
	[[ "$remote1" == "$remote2" ]] && { ScriptErr "remote1 and remote2 must be different"; return 1; }

	local remote1Url; remote1Url="$(git remote get-url "$remote1")" || return
	local remote2Url; remote2Url="$(git remote get-url "$remote2")" || return
	local remote1NewName="$remote2" remote2NewName="$remote1"
	[[ "$remote1" == "origin" ]] && { remote1NewName="$(GetUriServer "$remote1Url")"; }
	[[ "$remote2" == "origin" ]] && { remote2NewName="$(GetUriServer "$remote2Url")"; }

	# original configuration
	header "Original Configuration"
	git remote -v || return
	echo

	# swap
	header "Swapping $remote1 and $remote2"
	log1 "$remote1 ($remote1Url)->$remote1NewName"
	log1 "$remote2 ($remote2Url)->$remote2NewName"
	RunLog git remote rename "$remote1" "$remote1.hold" || return
	RunLog git remote rename "$remote2" "$remote2NewName" || return
	RunLog git remote rename "$remote1.hold" "$remote1NewName" || return
	[[ "$remote1" == "origin" || "$remote2" == "origin" ]] && { RunLog git branch master --set-upstream-to origin/master || return; }
	echo

	# new configuration
	header "New Configuration"
	git remote -v || return
}

remoteToHttpCommand()
{
	git remote set-url origin "https://$(getBaseUrl "origin")/"
	git remote --verbose
}

remoteToSshCommand()
{
	local url="$(getBaseUrl "origin")"
	local server="${url%%/*}"
	local suffix="${url#*( )*/}"

	git remote set-url origin "$(serverToRepo "$server" "${suffix}")" || return
	git remote --verbose
}

#
# helper
#

checkRepo() { [[ -d ".git" ]] && return; ScriptErr "not a git repository"; return; }

# findServer - find a Git server
findServer()
{
	# local repositories
	local dir dirs=("/usr/local/data/appdata2/git" "/usr/local/data/appdata2/git")
	for dir in "${dirs[@]}"; do
		[[ -d "$dir" ]] && { echo "$dir"; return; }
	done

	# remote servers
	local server servers=(git.butare.net pi1.butare.net pi2.butare.net nas1.butare.net nas3.butare.net)
	for server in "${servers[@]}"; do
		local port="$(serverToPort "$server")"
		IsAvailablePort "$server" "${port:-22}" && { echo "$server"; return; }
	done

	return 1
}

# getBaseUrl REMOTE - get repository base URL, i.e. https://server/path/ ssh://user@server:port/path/ -> server/path
getBaseUrl() 
{
	local url; url="$(git remote get-url "$1")" || return
	url="$(echo "$url" | sed 's/https:\/\///')" # remove https://
	url="$(echo "$url" | sed 's/ssh:\/\///' | sed 's/git@//' | sed 's/:[0-9]*\//\//')" # remove ssh://, user@, and :port
	url="${url%%/}" # remove trailing /
	echo "${url}"
}

# serverToRepo server name -> ssh://user@server:port/dir/name
serverToRepo() 
{
	local server="$1" name="$2"
	[[ -d "$server" ]] && { echo "$server/$name"; return; }
	local port="$(serverToPort "$server")"; [[ $port ]] && port=":$port"
	echo "ssh://$(serverToUser "$1")$server$port/$(serverToDir "$1")/$name"; 
}

serverToDir()
{
	case "$1" in
		gitlab|gitlab.butare.net) echo "$USER";;
		nas3|nas3.butare.net|nas3.hagerman.butare.net) echo "usr/local/data/appdata2/git";;
		*) echo "git";;
	esac
}

serverToPort()
{
	case "$1" in
		gitlab|gitlab.butare.net) echo "10022";;
		nas1|nas1.butare.net|nas1.hagerman.butare.net) echo "608";;
		nas3|nas3.butare.net|nas3.hagerman.butare.net) echo "608";;
	esac
}

serverToShare()
{
	case "$1" in
		nas1|nas1.butare.net|nas1.hagerman.butare.net) echo "//$server/git";;
		*) echo "//$server/root/$(serverToDir "$server")"
	esac
}

serverToUser()
{
	case "$1" in
		gitlab|gitlab.butare.net) echo "git@";;
		*) echo "$USER@";;
	esac
}

ScriptRun "$@"

#!/usr/bin/env bash
. function.sh || exit

run() {	init || return; args "$@" || return; ${command}Command "${args[@]}"; }

init()
{ 
	GitExtensions="$P32/GitExtensions/GitExtensions.exe"
	gitExtensionsGit="$P/Git/cmd/git.exe"

	fork="$ADATA/Fork/Fork.exe"; IsPlatform mac && fork="/usr/local/bin/fork"
	forkGit="$ADATA/Fork/gitInstance/2.24.1/bin/git.exe"
	forkTitle="Fork*"

	gitx="$P/GitX.app/Contents/Resources/gitx"
}

usage()
{
	echot "\
usage: GitHelper ge|gb|gui|hub|tgui|changes|save|down|commit|commitg|browse|diff|status|size|ToHttp|ToSsh
	Additional Git functionality
	bin				Setup bin folders for git
	clone 		clone a repository
	gui				run GUI git program
	hide 			hide Git files in repository
	options 	Git Extensions options
	ToGitHub REPO 			add a repository to GitHub
	CloneExisting	REPO	re-create repository that exists in the current directory
	profile save|restore|dir|SaveDir [<profile name>|default](latest) [--global]
	-w, --wait		wait for the operation to complete"
	exit $1
}

args()
{
	unset command help dest exclude file show arg1 arg2
	versions=( 2013 2012 )
	while (( $# != 0 )); do
		case "$1" in
			--help) help="--help";;
			--wait|-w) wait="--wait";;
			IsInstalled) command="IsInstalled";; ToGitHub) command="ToGitHub";; ToHttp) command="ToHttp";; ToSsh) command="ToSsh";; CloneExisting) command="CloneExisting";;
			*)
				! IsOption "$1" && IsInArray "$1" versions && { version="$1"; shift; continue; }
				[[ ! $command ]] && { CheckCommand "$1"; shift; continue; }
				[[ "$command" == @(clone|profile|ge|gfw|gui|tgui|up|down|browse|CloneExisting|commit|commitg|diff|status|ToGitHub|hide|changes) ]] && break # defer argument processing
				UnknownOption "$1"
		esac
		shift
	done
	[[ $help ]] && { IsFunction "${command}Usage" 0 && ${command}Usage || usage 0; }
	[[ ! $command ]] && { MissingOperand "command"; }
	args=("$@")
}

guiUsage() { "$gui" --help; exit $1; }
IsInstalledCommand() { InPath git; }
profileCommand() {	profile --app "GitExtensions" --method "$ADATA/../Roaming/GitExtensions/GitExtensions" --files "GitExtensions.settings" "$@"; }

optionsCommand()
{
	[[ "$PLATFORM" != "win" ]] && { guiCommand; return; }

	# When setting options in GitExtensions .gitconfig cannot be a link
	[[ ! -f ~/.gitconfig.hold ]] && { mv ~/.gitconfig ~/.gitconfig.hold || return; }
	cp ~/.gitconfig.hold ~/.gitconfig || return
	GitHelper gui --wait || return
	mv ~/.gitconfig.hold ~/.gitconfig || rreturn
}

changesCommand()
{
	(( $# != 0 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	[[ "$(git status --porcelain)" != "" ]]
}

hideCommand()
{
	IsPlatform win || return 0

	(( $# == 1 )) && { pushd "$1" > /dev/null || return; shift; }

	FileHide ".git" || return
	FileTouchAndHide ".gitignore" || return
	attrib .gitkeep +h /s >& /dev/null || return

	if git config --local core.filemode >& /dev/null; then
		git config --local --unset core.filemode || return
	fi

	return 0
}

saveCommand()
{
	(( $# == 2 )) && { pushd "$1" > /dev/null || return; echo "Uploading $1..."; shift; }
	changesCommand || return 0
	git status
	git add --all || return
	git commit -m "$1" || return
	git push || return
}

downCommand()
{
	(( $# == 1 )) && { pushd "$1" > /dev/null || return; echo "Downloading $1..."; shift; };
	git pull
}

statusCommand()
{
	(( $# == 1 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	git status --short --branch
}

diffCommand()
{
	(( $# == 1 )) && { pushd "$1" > /dev/null || return; shift; };
	git diff
}

commitCommand() 
{ 
	#(( $# != 0 )) && [[ -d "$1" ]] && { pushd "$1" > /dev/null || return; shift; };
	guiCommand commit "$@"
}

commitgCommand() 
{
	changesCommand "$@" && guiCommand browse "$@"
}

guiCommand()
{
	local result pop guiTitle

	WinSetState "$forkTitle" --activate >& /dev/null && return

	[[ -d "$1" ]] && { pushd "$1" >& /dev/null; shift; pop="$true"; }

	if InPath gitkraken; then coproc gitkraken -p "$PWD"
	elif [[ -f "$fork" ]]; then IsPlatform win && start "$fork" "$PWD" || "$fork" "$@"; guiTitle="$forkTitle"
	elif [[ -f "$GitExtensions" ]]; then [[ "$@" == "" ]] && start $wait "$GitExtensions" browse . || start $wait "$gitE" "$@";
	elif [[ -f "$gitx" ]]; then [[ "$@" == "" ]] && start $wait "$gitx" --git-dir=. || start $wait "$gitx" "$@";
	elif InPath "gitg"; then start $wait gitg "$@"	
	else EchoErr "Could not find a git gui application"; return 1; fi
	result="$?"

	[[ $pop ]] && popd

	return $result
}

browseCommand() { guiCommand browse "$@"; }

CloneExistingCommand()
{
	local repo="$1"

	echo "Cloning $1..."
	[[ ! -d .git && ! -d hold/.git ]] && { git clone "$repo" hold || return; }	
	[[ -f hold/.gitignore ]] && { mv hold/.gitignore . || return; }
	[[ -d hold/.git ]] && { mv hold/.git . || return; }
	hideCommand || return

	[[ -d hold ]] && { rm -fr hold || return; }

	echo "Updating remote to $repo..."
	git remote set-url origin "$repo" || return
	
	return 0
}

binCommand()
{
	local binRepo ubinRepo

	if [[ -d "/volume1/Git" ]]; then
		binRepo="/volume1/Git/public-bin"
		ubinRepo="/volume1/Git/jjbutare-bin"
	elif IsAvailable nas1; then
		binRepo="ssh://admin@nas1.hagerman.butare.net:608/git/public-bin"
		ubinRepo="ssh://admin@nas1.hagerman.butare.net:608/git/jjbutare-bin"
	else
		return 0
	fi

	cd "$BIN" || return
	GitHelper CloneExisting "$binRepo" || return
	
	cd "$UBIN" || return
	GitHelper CloneExisting "$ubinRepo" || return
	
	# Windows plink requires accepting the key manually
	if IsPlatform win && IsAvailable nas1; then
		echo "Testing ssh connection to nas1..."
		start plink.exe -v -P 608 root@nas1.hagerman.butare.net git --version
	fi

	if [[ -d "$BIN/.git" && -d "$UBIN/.git" ]]; then
		echo "Git is setup for the the bin directories"
		return 0
	fi

}

sizeCommand()
{
	# @see http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/
	# @author Antony Stubbs

	# set the internal field spereator to line break, so that we can iterate easily over the verify-pack output
	IFS=$'\n';

	# list all objects including their size, sort by size, take top 10
	echo "Calculating object sizes..."
	objects=`git verify-pack -v .git/objects/pack/pack-*.idx | grep -v chain | sort -k3nr | head -n 50`

	echo "All sizes are in kB's. Pack is the size of the object, compressed, inside the pack file."

	output="size,pack,SHA,location"
	for y in $objects
	do
		# extract the size in bytes
		size=$((`echo $y | cut -f 5 -d ' '`/1024))
		# extract the compressed size in bytes
		compressedSize=$((`echo $y | cut -f 6 -d ' '`/1024))
		# extract the SHA
		sha=`echo $y | cut -f 1 -d ' '`
		# find the objects location in the repository tree
		other=`git rev-list --all --objects | grep $sha`
		#lineBreak=`echo -e "\n"`
		output="${output}\n${size},${compressedSize},${other}"
	done

	echo -e $output | column -t -s ', '
}

ToHttpCommand()
{
	git remote set-url origin "https://$(getBaseUrl)/"
	git remote --verbose
}

ToSshCommand()
{
	local url="$(getBaseUrl)" port
	local server="${url%%/*}"
	local suffix="${url#*( )*/}"

	case "$server" in
		gitlab.devtools.intel.com) port=":29418";;
	esac

	git remote set-url origin "ssh://git@${server}${port}/${suffix}"
	git remote --verbose
}

getBaseUrl()
{
	# ssh://git@gitlab.devtools.intel.com:29418/csis/ics/ScadaPortal.git
	# https://gitlab.devtools.intel.com/csis/ics/ScadaPortal.git/

	local url="$(git remote --verbose | grep origin | cut -f2 | cut -d" " -f1 | head -1 | sed 's/\r//g')"
	url="$(echo "$url" | sed 's/https:\/\///')" # remove https://
	url="$(echo "$url" | sed 's/ssh:\/\///' | sed 's/git@//' | sed 's/:[0-9]*\//\//')" # remove ssh://, git@, and :NNN
	url="${url%%/}" # remove trailing /
	echo "${url}"
}


#
# ToGitHub
#

ToGitHubCommand()
{
	local org="CSIS"
	local dir="/cygdrive/d/Archive"

	[[ $# != 1 ]] && { EchoErr "usage: togithub REPO"; return 1; }
	repo="$1"
	[[ ! -d "$dir/$repo" ]] && { EchoErr "$repo is not a valid repository"; return 1; }
	cd "$dir/$repo"

	echo '**********' "$repo" '**********'

	[[ ! -f .gitignore ]] && { AddDefaultGitIgnore || return 1; }
	[[ ! -f README.md ]] && { AddDefaultReadMe || return 1; }
	git remote | grep origin > /dev/null || { CreateGitHubRepository || return 1; } 
	[[ -d .git/svn ]] && { echo "Getting changes from the SVN repository..."; "$P32/Git/bin/git" svn fetch || return 1; }
	#git merge trunk
	#ge svn dcommit
	#git push --force
	echo "Pushing repository to GitHub..."; git push || return 1
	} 

CreateGitHubRepository()
{ 
	echo "Creating GitHub repository...."
	hub create $org/$repo -p -d "$repo project (converted from CSIS SVN repository)" || return 1
}

AddDefaultGitIgnore()
{
	echo "Adding default C# .gitignore...."
	cp ../.gitignore . || return 1
	git add .gitignore || return 1
	git commit -m "Add default C# .gitignore" || return 1
}

AddDefaultReadMe()
{
	echo "Adding default README.md...."
	echo "$repo" > README.md
	eval printf '=%.0s' {1..${#n}} >> README.md
	echo "" >> README.md
	echo "$repo project (converted from a CSIS SVN repository)." >> README.md
	echo "" >> README.md
	echo "External Dependencies" >> README.md
	echo "---------------------" >> README.md
	echo "Install external dependencies listed here from \\\\\\\\CsisBuild.intel.com\d$\install" >> README.md
	git add README.md || return 1
	git commit -m "Add default README.md" || return 1
}

cloneCommand()
{
	local repo="$1"

	if [[ "$repo" == "nas1" ]]; then
		[[ ! $2 ]] && { echo "nas1 repostiories: "; ssh nas1 ls /git | grep -Ev "eaDir|-bin"; return 0; }
		repo="ssh://admin@nas1.hagerman.butare.net:608/git/$2"
	fi

	echo "Cloning $repo..."
	pushd "$CODE"	>& /dev/null || return
	git clone "$repo" || return
	popd || return
}

run "$@"

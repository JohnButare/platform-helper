#!/usr/bin/env bash
. app.sh
. office.sh || exit 1

init()
{
	command='start'
	title="${OfficeTitle}Word";
	program="$OfficeDir/WinWord.exe";
	FastStart="$PUB/documents/data/setup/Word Fast Start.docx"
	SignatureDir="$APPDATA/Microsoft/Signatures"
}

usage() {	echot "usage: word [start|startup|close|restart](start)
	info|cd|RestoreNormal|SaveNormal|show
	hide|restore: hide or restore the FastStart document
	-b, --brief		brief status messages"; exit $1; }

run() {	init; args "$@"; ${command}Command "${args[@]}"; }

args()
{
	unset -v brief
	while [[ "$1" != "" ]]; do
		case "$1" in
			--brief|-b) brief="--brief";;
			--help) usage 0;;
			IsRunning) command="IsRunning";; IsInstalled) command="IsInstalled";;
			SaveNormal) command="SaveNormal";; RestoreNormal) command="RestoreNormal";;
			*) 
				IsFunction "${1,,}Command" && { command="${1,,}"; shift; continue; }
				[[ "$command" == @(start|profile) ]] && break;
				UnknownOption "$1"
		esac
		shift
	done
	args=( "$@" )
}

startCommand()
{
	! IsInstalledCommand && return 1; IsRunningCommand && return 0
	task start $brief --duplicate --title "$title" "$program" "$@"
}

startupCommand()
{
	! IsInstalledCommand && return 1; IsRunningCommand && return 0

	# - Specify a window title to ensure that the hidden Word window is not reused by the next opened word document.
	# - Command line option reference - http://support.microsoft.com/kb/q210565/
	# - Important note: If Word is minimized when hidden, subsequent opens using the Open File Dialog and other actions will restore
	#   the hidden window so that it is visible.
	task start $brief --fast --wait --title "$WordFastStartTitle" "$program" /w /q "$FastStart"
}

IsInstalledCommand() { [[ -f "$program" ]]; }
IsRunningCommand() { IsTaskRunning "$program"; }
closeCommand() { ! IsRunningCommand && return 0; ProcessClose "$program"; } 
restartCommand() { closeCommand && startCommand; }
profileCommand() {	tc profile.btm "$@" || usage; }
cdCommand() { echo "$DOC/data/templates"; }

restoreCommand() { WinSetState "$WordFastStartTitle" restore; }
hideCommand() { WinSetState "$WordFastStartTitle" hide; }

SaveNormalCommand()
{
	dir="$DOC\data"
	templates="$dir/templates"
	replicate="$dir/replicate"

	cp "$templates/Normal.dotm" "$replicate/Normal Original.dotm" || return $?
	cp "$templates/NormalEmail.dotm" "$replicate/NormalEmail Original.dotm" || return $?
	return 0
}

RestoreNormalCommand()
{
	! IsInstalledCommand && return 1

	local IsRunning=0

	if [[ -f "$DOC/data/templates/toc.docx" ]] && 
		! diff "$DOC/data/templates/toc.docx" "$USERPROFILE/templates/toc.docx" >& /dev/null; then
		printf "Update table of contents..."
		cp "$DOC/data/templates/toc.docx" "$USERPROFILE/templates" || return
		echo "done"
	fi

	for ext in dot dotm; do RestoreNormalExtension "Normal" "$ext" || return; done
	for ext in dot dotm; do RestoreNormalExtension "NormalEmail" "$ext" || return; done

	[[ $IsRunning == 1 ]] && startupCommand

	return 0
}

RestoreNormalExtension()
{
	local template="$1"
	local ext="$2"
	local dir="$DOC/data"
	local normal="$dir/templates/$template.$ext"
	local original="$dir/replicate/$template Original.$ext"

	[[ ! -f "$original" ]] && return 0

	[[ ! -f "$normal" ]] && { cp "$original" "$normal"; return; }
	
 	diff "$normal" "$original" >& /dev/null && return

  printf "Restoring the $template template..."
   
	# Close word	 
	if word IsRunning; then
		IsRunning=1
		word close
		sleep 2
	fi
	
  while true; do
    
    printf "copying..."
    cp "$original" "$normal" && echo "done"
    
    diff "$original" "$normal" && break

    handle "$template"
    echo ""
    pause "Manually close the above tasks then press any key to continue..."
  
  done
}

run "$@"

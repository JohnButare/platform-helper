#!/usr/bin/env bash
. script.sh || exit

usage() { ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... check|fix|get|show|start|status
$(ScriptName) commands."; }

init()
{
  formatDisplay="%H:%M:%S.%N" formatSerial="%s.%N"; format="$formatDisplay"
  toleranceSeconds="1" toleranceWindowsSeconds="2"
}

#
# check command
#

checkUsage()
{
  ScriptUsageEcho "\
Usage: $(ScriptName) check
Return 1 if the clock is more than $toleranceSeconds second off of reference time."
}

checkCommand() { RunPlatform check; }

checkLinux()
{
  log1 "checking time..."  
  local skew; skew="$(getSkewNtp || getSkewChrony)" || return  
  checkSkew "$skew"
} 

checkWin()
{
  # check WSL clock
  checkLinux || return

  # check Windows clock
  log1 "checking Windows time..."
  local format="$formatSerial" toleranceSeconds="$toleranceWindowsSeconds"
  local timeWin; timeWin="$(getTimeWin)" || return
  local timeNtp; timeNtp="$(getTimeNtp)" || return
  local skew; skew="$(echo "$timeWin-$timeNtp" | bc -l | RemoveFront "-")" || return
  checkSkew "$skew" "Windows "
}

checkSkew()
{
  local skew="$1" desc="$2"
  log1 "${desc}skew=$skew seconds tolerance=$toleranceSeconds"
  (( $(echo "$skew <= $toleranceSeconds" | bc -l) ))
}

#
# fix command
#

fixUsage() { EchoWrap "$1" "Usage: $(ScriptName) fix [HOST](time.apple.com)\nFix system clocks, using the specified host if possible."; }
fixArgStart() { host="$(getTimeServer)"; }
fixArgs() { (( $# == 0 )) && return; ScriptArgGet "host" -- "$@"; }

fixCommand()
{
  # check if we need to fix a clock
  [[ ! $force ]] && checkCommand >& /dev/null && return

  # fix the clocks
  [[ ! $quiet ]] && echo -n "fixing..."
  RunPlatform fix || return
  EchoQuiet "done"

  # log if manual fix is required in Windows
  if [[ ! $quiet ]] && IsPlatform win && checkLinux && ! checkWin; then
    [[ $brief ]] && echo
    echo "The Windows clock must be manually corrected"
    IsInDomain && echo "Connect to the corporate network and run 'w32tm.exe /resync' or 'net.exe time sync /set'"
    return
  fi

  # status
  [[ ! $quiet ]] && statusCommand

  return 0
}

fixMac() { RunQuiet sudoc sntp -sS "$host"; }
fixWin() { fixWinTime && fixLinux; }

fixLinux()
{
  isInstalledChrony && fixChrony && return # use Chrony if installed
  fixNtp # if Chrony is not installed or fails use NTP
}

fixNtp()
{
  isInstalledNtp || return 0
  [[ ! $quiet ]] && echo -n "ntp..."; [[ $verbose ]] && echo
  RunSilent sudoc ntpdate "$host"
}

fixChrony()
{
  isInstalledChrony || return 0
  [[ ! $quiet ]] && echo -n "chrony..."; [[ $verbose ]] && echo
  RunSilent sudoc chronyc makestep
}

fixWinTime()
{
  isInstalledWinTime || return 0
  [[ ! $quiet ]] && echo -n "win..."; [[ $verbose ]] && echo
  RunSilent RunScript --elevate w32tm.exe /resync
}

#
# get command
#

getUsage() { EchoWrap "Usage: $(ScriptName) sync [local|wsl|HOST](local)\nGet time from the specified host.  If host is a UNC, get time using the SMB protocol."; }
getArgStart() { host="local"; }
getArgs() { (( $# == 0 )) && return; ScriptArgGet "host" -- "$@"; host="${host,,}"; }

getCommand()
{
  # get local time
  if [[ "$host" == @(local|wsl) ]]; then
    if IsPlatform win && [[ "$host" == "local" ]]; then
      getTimeWin; return
    else
      getTimeLocal; return
    fi
  fi

  # get host time
  if IsUncPath "$host"; then getTimeSmb "$host"
  else getTimeNtp "$host"
  fi
}

getTimeLocal() { ${G}date +"$format"; }

getTimeWin()
{
  local time; time="$({ cmd.exe /c time < /dev/null; } |& cut -d: -f2- | grep -vE "CMD|UNC|command|wsl|Enter" | RemoveEmptyLines)";
  ${G}date +"$format" -d "$time"
}

# getNtpTime [HOST](timeServer) - get time from host using the NTP protocol
getTimeNtp()
{
  local host="${host:-$(getTimeServer)}"

  ! InPath ntpdate && { ScriptErrQuiet "cannot get time from '$host' using NTP"; return 1; }
  HostAvailable "$host" || return

  local result; result="$(ntpdate -q "$host" | tail -1)" || return
  local time="$(echo "$result" | RemoveAfter "ntpdate" | awk '{ print $NF; }')" # ... HH:MM:SS ntpdate...
  local offset="$(echo "$result" | awk '{print $(NF - 1)}')"
  log1 "getTimeNtp: $host offset from clock is $offset"
  ${G}date +"$format" -d "$time + $offset second"
}

# getTimeSmb HOST - get time from host using the SMB protocol
getTimeSmb()
{
  local host="$(GetUncServer "$1")"

  if InPath net.exe; then
    local time; time="$(net.exe time '\\'"$host" | head -1 | RemoveCarriageReturn | cut -d" " -f6-)" || return
  else
    ScriptErrQuiet "cannot get time from '$host' using SMB"; return 1
  fi

  ${G}date +"$format" -d "$time"
}

#
# show command
#

showUsage()
{
  ScriptUsageEcho "\
Usage: $(ScriptName) show [gui|terminal](gui)
Show a clock."
}

showCommand() { showGuiCommand; }

showGuiCommand()
{
  if [[ $DISPLAY ]] && InPath xclock; then coproc xclock -title $HOSTNAME -digital -update 1
  else showTerminalCommand
  fi
}

showTerminalCommand()
{
  if InPath tty-clock; then tty-clock -s -c; 
  else ${G}date;
  fi
}

#
# status command
#

statusUsage()
{
  ScriptUsageEcho "\
Usage: $(ScriptName) status [client|server|win](client)
Show clock status using the Chrony service (if running) and the configured time server."
}

statusCommand() { statusClientCommand; }

statusClientCommand()
{
  InitColor || return;

  # show chrony server time
  if InPath chronyc; then
    local tracking; tracking="$(chronyc tracking)" || return
    local chronyServer="$(echo "$tracking" | grep "^Reference ID" | cut -d"(" -f2 | cut -d")" -f1)"
    local chronyReferenceTime="$(echo "$tracking" | grep "^Ref time" | cut -d: -f2- | RemoveSpaceTrim)"
    local chronyDifference="$(echo "$tracking" | grep "^System time" | cut -d: -f2 | cut -d" " -f2)"
    echo "   ${GREEN}chrony:${RESET} $(${G}date +"$formatDisplay" -d "$chronyReferenceTime UTC") ($chronyServer, $chronyDifference seconds from system)"
    [[ $verbose ]] && { chronyc tracking || return; }
  fi

  ! InPath ntpdate && return

  local timeServer="$(getTimeServer)"
  local format="$formatSerial"
  local winSerial; IsPlatform win && winSerial="$(getTimeWin)"
  local localSerial="$(getTimeLocal)"
  local serverSerial="$(getTimeNtp "$timeServer")"

  # show reference server time
  echo "${GREEN}reference:${RESET} $(${G}date +"$formatDisplay" -d @$serverSerial) ($timeServer)"

  # show local time
  if IsPlatform wsl2; then # WSL time and Windows time are the same in WSL1
    echo "    ${GREEN}local:${RESET} $(timeDiff "$winSerial" "$serverSerial")"
  elif IsPlatform wsl2; then # WSL time and Windows time are separate in WSL2
    echo "      ${GREEN}WSL:${RESET} $(timeDiff "$localSerial" "$serverSerial")"
    echo "  ${GREEN}windows:${RESET} $(timeDiff "$winSerial" "$serverSerial")"
  else
    echo "    ${GREEN}local:${RESET} $(timeDiff "$localSerial" "$serverSerial")"
  fi

  # show tolerance  
  if IsPlatform wsl1; then
    echo "${GREEN}tolerance:${RESET} $toleranceWindowsSeconds second(s)"
  elif IsPlatform wsl2; then
    echo "${GREEN}tolerance:${RESET} $toleranceSeconds second(s), windows $toleranceWindowsSeconds second(s)"
  else
    printf "${GREEN}tolerance:${RESET} $toleranceSeconds second(s)"
  fi
}

statusServerCommand() 
{ 
  ! isChronyServerRunning || return
  
  header "Chrony Sources"
  chronyc sources || return
  echo

  header "Chrony Server Statistics"
  sudoc chronyc serverstats
}

isChronyServerRunning()
{
  local service="chrony"; IsPlatform mac && service="org.tuxfamily.chronyc"
  [[ -f "/etc/chrony/chrony.conf" ]] && grep "^allow" "/etc/chrony/chrony.conf" >& /dev/null && service running "$chrony"
}

statusWinCommand()
{
  ! IsPlatform win && return
  w32tm.exe /query /status /verbose || return
}

#
# helper
#

getSkewChrony() { InPath chronyc && chronyc tracking | grep "^System time" | cut -d" " -f8; }
getSkewNtp() { InPath ntpdate && ntpdate -q "${host:-$(getTimeServer)}" | tail -1 | awk '{ print $(NF-1); }' | RemoveFront "-" | RemoveFront "+"; }

isInstalledChrony() { InPath chronyc && [[ -f "/etc/chrony/chrony.conf" ]] && service exists chrony && service start chrony --wait --quiet; }
isInstalledNtp() { ! IsPlatform wsl1 && InPath ntpdate; }
isInstalledWinTime() { ! IsParallelsVm && CanElevate && service start W32Time --wait --quiet; } # W32Time not needed under Parallels and requires ability to elevate

getTimeServer()
{
  local server="$(ConfigGet "timeServer")"
  echo "${server:-time.apple.com}"
}

# timeDiff TIME_SERIAL REFERENCE_TIME_SERIAL - show time with reference difference as "TIME (DIFFERENCE)"
timeDiff()
{
  local time="$1" reference="$2"
  echo "$(${G}date +"$formatDisplay" -d @$time) ($(echo "$time-$reference" | bc -l) seconds from reference)"
}

ScriptRun "$@"

#!/usr/bin/env bash
. app.sh || exit

usage() 
{
	ScriptUsage "$1" "\
Usage: $(ScriptName) [OPTION]... [close|environment|IsInstalled|IsRunning|IsUnlocked|program|restart|start|startup|status|unlock](start)
$(ScriptName) commands."
}

init()
{
	configDir="$HOME/.config/op"
	sessionRefreshFile="$configDir/session_refreshed"
	credentialPath="1Password"

	case "$PLATFORM" in
		mac) program="TBD";;
		win) program="$UADATA/1Password/app/8/1Password.exe";;
		*) unset program;;
	esac

	return 0
}

closeCommand() { ! isRunningCommand && return 0; ProcessClose "$program"; } 
environmentCommand() { initSession && ScriptReturn --export OP_SESSION_my; }
isInstalledCommand() { [[ -e "$program" ]]; }
isRunningCommand() { IsTaskRunning "$(GetFileName "$program")"; }
isUnlockedCommand() {	[[ $OP_SESSION_my && -f "$sessionRefreshFile" && -f "$(find "$sessionRefreshFile" -mmin -29)" ]]; }
programCommand() { echo "$program"; }
restartCommand() { closeCommand && startCommand; }
statusCommand() { isUnlockedCommand && echo "signed in" || echo "not signed in"; }
startArgs() { startArgs=( "$@" ); shift="$#"; }
startCommand() { isInstalledCommand && start $wait "$program" "${startArgs[@]}"; }
startupCommand() { startCommand; }

#
# unlock command
#

unlockArgStart() { unset -v password; }
unlockUsage() { echot "Usage: $(ScriptName) unlock [PASSWORD]\nUnlock 1Password."; }
unlockArgs() { [[ ! $1 ]] && return; ScriptArgGet "password" -- "$@"; }

unlockCommand()
{	
	[[ ! $force ]] && isUnlockedCommand && return

	# arguments
	local args=(--cache); [[ $session ]] && args+=(--session "$OP_SESSION_my")

	# get login information if there is no account configured yet
	if [[ ! -f "$configDir/config" ]]; then
		local url; url="$(credGet url)" || return
		local email; email="$(credGet email)" || return
		local key; key="$(credGet SecretKey)" || return
		local session="$(getSession)"
		args+=("$url" "$email" "$key")
	fi

	# password
	if [[ ! $password ]] && credExists "password"; then
		password="$(credGet "password")" || return
	fi

	if [[ ! $password && ! $noPrompt ]] && IsStdIn; then
		password="$(ask password "Enter your 1Password account password")" || return
	elif [[ ! $password ]]; then
		[[ ! $quiet ]] && ScriptErr "a terminal is required to read the password."
		return 1
	fi

	# signin
	unset OP_SESSION_my

	local script="$(cat <<-EOF
		spawn op signin ${args[@]}
		expect "Enter the password for"
		send "$password\n";
		expect "output the session token.\n"
		EOF
	)"

	# with a carriage return, macOS completely butchers the value when saved then restore in the macOS credential store
	eval "$(expect -c "$script" |& grep "^export" | RemoveCarriageReturn)" || return

	# login failed if the session variable was not set
	if [[ $OP_SESSION_my ]]; then
		[[ ! $quiet ]] && EchoErr "successfully unlocked your 1Password account"
	else
		(( verbose > 2 )) && expect -c "$script"
		[[ ! $quiet ]] && ScriptErr "unable to unlock your 1Password account"
		return 1
	fi

	# save and return
	log1 "OP_SESSION_my=$OP_SESSION_my"
	credSet "session" "$OP_SESSION_my" && touch "$sessionRefreshFile" && ScriptReturn --export OP_SESSION_my
}

#
# helper
#

credExists() { credential "$credentialPath" exists "$1" --fallback --exclude-managers=op "${globalArgs[@]}"; }
credGet() { credential get "$credentialPath" "$1" --if-exists --fallback --exclude-managers=op "${globalArgs[@]}"; }
credSet() { credential set "$credentialPath" "$1" "$2" --fallback --exclude-managers=op "${globalArgs[@]}" > /dev/null; }

getSession()
{
	[[ $OP_SESSION_my && ! $force ]] && { echo "$OP_SESSION_my"; return; }
	credExists "session" && { credGet "session"; return; }
	return 0
}

initSession()
{
	local session; session="$(getSession)" || { [[ ! $quiet ]] && ScriptErr "not signed in"; return 1; }
	export OP_SESSION_my="$session"
}
									 
ScriptRun "$@"

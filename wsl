#!/usr/bin/env bash
. script.sh

usage()
{
	ScriptUsage "$1" "\
usage: wsl disk|dist|fix|get|help|install|list|update
Windows Subsystem for Linux (WSL) commands."
}

init()
{ 
	wslDir="$DATA/appdataw/wsl"; [[ ! -d "$wslDir/image" ]] && { mkdir --parents "$wslDir/image" || return; }
	shortcutDir="$PROGRAMDATA/Microsoft/Windows/Start Menu/Programs/Operating System/Other/WSL/"
}

#
# commands
#

listCommand() { w --list --verbose | Utf16toAnsi | RemoveCarriageReturn; }
updateCommand() { ! supports "update" && return; w --update; }

#
# Disk Command
#

diskUsage() { echot "Usage: $(ScriptName) disk mount|unmount
Disk commands."; }

diskArgStart() { unset -v disk; }

diskArgs() { (( $# == 0 )) && return; ScriptArgGet "disk" -- "$@"; }

diskCommand() { usage; }

diskMountUsage() { echot "Usage: $(ScriptName) disk mount [NUMBER](first offline)
Mount the specified Windows disk number in WSL."; }

diskMountCommand()
{
	supportsMount || return

	# get the disk to mount
	[[ ! $disk ]] && disk="$(drive win GetOffline | head -1)"
	
	if [[ ! $disk ]]; then
		EchoErr "wsl: there are no offline disks to mount.  Use \`drive win offline NUM\` to offline a disk for use in WSL"
		drive win list
		return 1
	fi

	# run elevated
	! IsElevated && { RunScript $verbose --elevate -- wsl mount "$disk"; return; }

	# get the existing block devices
	local devices; IFS=$'/n' devices=( $(lsblk -no NAME) )

	# mount the disk
	w --mount '\\.\PHYSICALDRIVE'$disk'' --bare || return

	# start LVM service and scan for volumes - systemd run the udev service which creates LVM devices automatically
	if InPath vgscan && ! IsSystemd ; then
		service start lvm2 || return
		sudo vgscan --mknodes || return
	fi

	# wait for the block device to be mounted and return it
	sleep 2
	lsblk -no NAME | grep -v "$(ArrayDelimit devices $'\n')"
}

diskUnmountUsage() { echot "Usage: $(ScriptName) disk unmount [NUMBER]
Unmount the specified Windows disk number."; }

diskUnmountCommand()
{
	supportsMount || return

	if IsElevated; then
		wsl.exe --unmount '\\.\PHYSICALDRIVE'$disk'' || return
	else
		RunScript $verbose --elevate -- wsl disk unmount "$disk" || return
	fi
}

#
# Distribution Commands
#

distUsage() { echot "Usage: $(ScriptName) dist backup|bootstrap|copy|delete|kill|restore|run|shortcut|summary|user [NAME](current)"; }
distArgs() { distArgGetDefault "$@" || return; }
distCommand() { usage; }
distKillCommand() { w --terminate "$dist"; }
distRunCommand() { w --distribution "$dist"; }
distSummaryCommand() { lxr summary -n "$dist" | Utf16toAnsi | RemoveCarriageReturn; }

# backup

distBackupCommand()
{
	local file="$(utw "$wslDir/image/$dist-$(GetTimeStamp).tar.gz")"

	distIsRunning && { ScriptErr "the '$dist' distribution must be stopped to be backed up"; return 1; }
	w --export "$dist" "$file" || return
	src="$(wtu "$file")" # for restore

	echo "'$dist' backed up to '$src'"
}

# bootstrap
distBootstrapCommand()
{
	cmd.exe /c 'copy '$(utw $BIN/bootstrap-init)' \\$(wslShare)\'$dist'\tmp' || return
	cmd.exe /c 'copy '$(utw $BIN/bootstrap-config.sh)' \\$(wslShare)\'$dist'\tmp' || return
	lxr run -n "$dist" -w -c "bash -c \". /tmp/bootstrap-init\"" || return
}

# copy

distCopyUsage() { echot "Usage: $(ScriptName) copy SRC DEST
Copy a distribution."; }

distCopyArgs() { ScriptArgGet "dest" -- "$@"; }

distCopyCommand()
{ 
	local user; user="$(userGetCommandCommand "$src")" || return
	backupCommand || return

	dist="$dest"
	distExists && { echo "The distribution '$dist' already exists"; deleteCommand || return; }
	restoreCommand || return
	userSetCommand  || return
}

# delete

distDeleteCommand()
{
	# checks
	[[ "$dist" == "$(distName)" ]] && { ScriptErr "cannot delete the current distribution"; return 1; }

	# distribution directory
	local dir="$(distDir)"
	[[ ! -d "$dir" ]] && { ScriptErr "the '$dist' distribution directory was not found"; return 1; }

	# ask to delete
	[[ ! $noPrompt ]] && ! ask -dr n "Delete the '$dist' distribution" && return 1

	# delete
	[[ $test ]] && return
	exit; distKillCommand && w --unregister "$dist" && rm -fr "$dir"
}

# restore

distRestoreUsage() { echot "Usage: $(ScriptName) dist restore DIST [SRC](ubuntu-focal)
Restore restore a WSL image commands.  SRC is a file or the name of a distribution image."; }

distRestoreArgs() { (( $# == 0 )) && src="ubuntu-focal" || ScriptArgGet "src" -- "$@"; }

distRestoreCommand()
{
	local cachedFile dist src version i="$(i dir)"
	local image="$i/platform/LINUX/wsl/image"

	# checks
	[[ "$dist" == "$(distName)" ]] && { ScriptErr "cannot restore to the current distribution"; return 1; }

	# src argument
	file="$src"

	# check if src is a cached file
	[[ ! -f "$file" ]] && file="$wslDir/image/$src.tar.gz" 

	# check for src in each distribution in the image directory
	if [[ ! -f "$file" ]]; then
		for dir in "$image/"*; do
			file="$dir/$src.tar.gz"
			[[ -f "$file" ]] && break
		done
	fi

	# find src from install directory - assume src is in the format distribution-version, i.e. ubuntu-focal
	if [[ ! -f "$file" ]]; then
		local i d v; IFS='-' read d v <<<"$src"
		file="$(ls "$image/$d/$d-$v-"* |& head -1)"
	fi

	# find src from LxRunOffline download site - https://github.com/DDoSolitary/LxRunOffline/wiki
	if [[ ! -f "$file" ]]; then
		file="$wslDir/image/$src.tar.gz"
		curl -L "http://lxrunoffline.apphb.com/download/$d/$v" -o "$file"
		! tar -tzf "$file" >& /dev/null && rm -f "$file" >& /dev/null
	fi

	if [[ ! -f "$file" ]]; then
		ScriptErr "could not find the installation for '$src'"
		return 1
	fi

	echo "Importing $(GetFileName "$file") as $dist..."
 	wsl.exe --import "$dist" "$(utw "$wslDir/$dist")" "$(utw "$file")" --version 2 || return
	shortcutCommand "$dist" || return
}

# shortcut

distShortcutCommand()
{ 
	[[ ! -d "$shortcutDir" ]] && { mkdir --parents "$shortcutDir" || return; }
	MakeShortcut "wsl.exe" "$shortcutDir/$dist" "-d $dist" "$(utw $(FindInPath wsl.exe))" || return
}

# user
 
distUserUsage()
{ 
	echot "Usage: $(ScriptName) user get|set [DIST](current)
Get or set the default user for the specified distribution.

	-u,	--user=[UID|NAME]($USER)		the name or uid to set as the default user"; 
}

distUserArgStart() { user="$USER"; }

distUserOpt() 
{
	case "$1" in
		-u|--user) ScriptOptGet user "$@" || return;;
		*) return 1
	esac
}

distUserCommand() { distUserGetCommand; }

distUserGetCommand() { distUserGetCommand; }

distUserSetCommand()
{
	local dir; dir="$(unc mount --no-host-check "//$(wslShare)/$dist")" || return
	local uid="$user"

	! IsInteger "$uid" && uid="$(grep -i "^$user:" "$dir/etc/passwd" | head -1 | cut -d: -f3)"
	[[ ! $uid ]] && { ScriptErr "could not find uid for user '$user' in distribution '$dist'"; return 1; }

	local currentUid="$(getDefaultUser)" || return
	[[ "$uid" == "$currentUid" ]] && { echo "Distribution '$dist' default user is already $uid"; return; }

	echo "Chaning the default used from UID $currentUid to UID $uid..."
	lxr set-uid -n "$dist" -v "$uid"
}

#
# Get Command
#

getUsage() { echot "Usage: $(ScriptName) get share
Get WSL configuration"; }

getCommand() { usage; }
getShareCommand() { wslShare; }

#
# Fix Commands
#

fixUsage() { echot "Usage: $(ScriptName) fix dns
Fix WSL behavior."; }

fixCommand() { usage; }

fixDnsUsage() { echot "Usage: $(ScriptName) fix dns
Manually specify DNS configuration for WSL."; }

fixDnsCommand()
{
	! IsPlatform wsl2 && { ScriptErr "name resolution only needs to be fixed in WSL 2"; return 1; }

	if ! grep -q "generateResolvConf = false" "/etc/wsl.conf"; then
		printf "[network]\ngenerateResolvConf = false\n" | sudo tee -a "/etc/wsl.conf"
		clipw "wsl.exe -d $(distName) -e bash -l wsl FixDnsNameLookup"
		pause "When WSL is terminated execute the contents of the clipboard..."
		killCommand "$(distName)" || return
		exit
	fi

	# fix /etc/resolv.conf which is a link to a missing file after the restart
	local dns1="$(ConfigGet "dns1")" dns2="$(ConfigGet "dns2")" domain="$(ConfigGet "domain")"
	if ! grep -q "nameserver $dns1" "/etc/resolv.conf"; then
		sudo rm -f "/etc/resolv.conf" || return
		sudo touch "/etc/resolv.conf" || return
		printf "nameserver $dns1\nameserver $dns2\nsearch $domain\n" | sudo tee "/etc/resolv.conf" || return
	fi

	return 0
}

#
# Help Commands
#

helpUsage() { echot "Usage: $(ScriptName) help lxr|wsl"; }
helpCommand() { helpLxrCommand; helpWslCommand; }
helpLxrCommand() { lxr |& Utf16to8; }
helpWslCommand() { w --help | Utf16to8; }

#
# Install Commands
#

installUsage() { echot "Usage: $(ScriptName) install systemd"; }
installCommand() { usage; }

installSystemdCommand()
{
	ghq get https://github.com/DamionGans/ubuntu-wsl2-systemd-script.git || return
	"$HOME/ghq/github.com/DamionGans/ubuntu-wsl2-systemd-script/ubuntu-wsl2-systemd-script.sh" || return
}

#
# helper
#

distDir() { wtu "$(wsl dist summary "$dist" | grep "Installation directory" | cut -d: -f 2- | cut -d" " -f 2)"; }
distExists() { [[ $1 && "$(list "$1" | cut -d" " -f1 | grep "^${1}$")" ]]; }
distFirst() { list "$1" | head -1 | awk '{ print $1; }'; }
distIsRunning() { [[ "$(list | grep "^$dist" | awk '{ print $2; }')" == "Running" ]]; }
distValidate() { distExists && return; [[ ! $quiet ]] && EchoErr "Distribution '$dist' does not exist"; return 1; }
distVersion() { list | grep "^$dist" | awk '{ print $3; }'; }

distArgGetDefault()
{ 
	(( $# == 0 )) && { dist="$(distName)"; return; }
	dist="$1"; ((++shift)); distValidate
}

distName()
{ 
	[[ $WSL_DISTRO_NAME ]] && { echo "$WSL_DISTRO_NAME"; return; }

	# WSL_DISTRO_NAME is not passed by default when using su/sudo/login
	local name="$(utw / | cut -d'\' -f4)"
	[[ $name ]] && { ScriptErr "unable to find the default WSL distribution"; return 1; }

	return 0
}

getDefaultUser() { lxr get-uid -n "$dist" | Utf16toAnsi | RemoveCarriageReturn; }
list() { listCommand | cut -b 3- | tail +2 ; } # remove header and default distribution * }
lxr() { ( cd /; LxRunOffline.exe "$@"; ); }
wslShare() { supportsMount && printf "wsl" || printf "wsl$"; }
supports() { wsl.exe --help | Utf16to8 | grep '\-\-'"$1" >& /dev/null; }
supportsMount() { supports "mount" && return; ScriptErr "mounting drives is not implemented in this version of WSL"; return 1; }
w() { ( cd /; wsl.exe "$@"; ); } # cd to local directory to fix invalid argument error running programs from SMB mounted shares

ScriptRun "$@"
